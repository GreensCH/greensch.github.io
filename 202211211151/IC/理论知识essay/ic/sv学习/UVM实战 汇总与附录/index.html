

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="时间：2022-11-21 第一章 主要介绍uvm发展史，验证内容 第二章  验证平台组成 最简单的验证平台：my_driver与top_tb组成  第一章1.2 学了UVM之后能做什么 使用sequence机制、factory机制、callback机制、寄存器模型（register model）等 验证基本常识 如何实现代码可重复性  机制索引 phase机制（5.1） objection机制（">
<meta property="og:type" content="article">
<meta property="og:title" content="UVM实战 汇总与附录">
<meta property="og:url" content="http://yoursite.com/202211211151/IC/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%AE%9E%E6%88%98%20%E6%B1%87%E6%80%BB%E4%B8%8E%E9%99%84%E5%BD%95/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="时间：2022-11-21 第一章 主要介绍uvm发展史，验证内容 第二章  验证平台组成 最简单的验证平台：my_driver与top_tb组成  第一章1.2 学了UVM之后能做什么 使用sequence机制、factory机制、callback机制、寄存器模型（register model）等 验证基本常识 如何实现代码可重复性  机制索引 phase机制（5.1） objection机制（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221020170035636.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021221512291-16663617135971.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021232129013.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021234757273.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221022000741471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221119221905011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221121200506347.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221121200630176.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122191951186.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122194654543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122194711463.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122195318124.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122195318124-167920883830623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221124215734579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123223740902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123202541061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123223740902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221124215734579-167920883830624.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126200628230.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126213948859.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126230440906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126230451710.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221128220610915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129170140433.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129213614571.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129213843287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129221442784.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129221331582.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130000841385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130142739555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130152626953.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130165225736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130205806862.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/165940jab2g1y11hkftt9a-166989718169113.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/165847yqpta82scoqsot2t-166989716460610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/170049kzs3ssxc0zzt09xt.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201203549829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201230236248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201232244548.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221202145232206.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221202151230913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221221220313662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230117171156899-16739467200511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230117171156899-16739467200511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230201023224980.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230119164542281.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230120170703668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/1039625-20191116113321329-1067463265.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230125235342862.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230121014833931.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126002422689.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126020234630.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126020356516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128014745459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128024721210.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128024732855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128125318552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230130224454181.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230131164418383.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230201231549666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230202024457390.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160656552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160723445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160802325.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160959965.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203175708374.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181838425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181315705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181642832.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181933558.png">
<meta property="article:published_time" content="2022-11-21T03:51:10.000Z">
<meta property="article:modified_time" content="2023-03-19T07:43:51.303Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="UVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221020170035636.png">
  
  <title>UVM实战 汇总与附录 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start -->
<link defer rel="stylesheet" href="/css/article_para.css" />
<div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner_img/anime/100723659_p0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="UVM实战 汇总与附录">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-11-21 11:51" pubdate>
        2022年11月21日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      267k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      834 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">UVM实战 汇总与附录</h1>
            
            <div class="markdown-body">
              <p>时间：2022-11-21</p>
<p>第一章</p>
<p>主要介绍uvm发展史，验证内容</p>
<p>第二章</p>
<ul>
<li>验证平台组成</li>
<li>最简单的验证平台：my_driver与top_tb组成</li>
</ul>
<h2><span id="第一章">第一章</span></h2><h3><span id="12-学了uvm之后能做什么">1.2 学了UVM之后能做什么</span></h3><ul>
<li>使用sequence机制、factory机制、callback机制、寄存器模型（register model）等</li>
<li>验证基本常识</li>
<li>如何实现代码可重复性</li>
</ul>
<h3><span id="机制索引">机制索引</span></h3><ul>
<li>phase机制（5.1）</li>
<li>objection机制（5.2）</li>
<li>sequence机制（2.4, 6）</li>
<li>facory机制（8）</li>
<li>file automation机制</li>
<li>config_db机制</li>
<li>callback机制（9）</li>
</ul>
<h3><span id="特性检索">特性检索</span></h3><ul>
<li>TLM</li>
<li>drain_time，撤销objection的延时（5.2.4）</li>
<li>domain（5.3）</li>
<li>register model</li>
</ul>
<h2><span id="第二章">第二章</span></h2><h3><span id="21-验证平台组成">2.1 验证平台组成</span></h3><p>验证用于找出DUT中的bug，这个过程通常是把DUT放入一个验证平台中来实现的</p>
<p>一个验证平台要实现如下基本功能：</p>
<ul>
<li>激励的功能：driver<ul>
<li>各种激励：正常激励、异常激励</li>
</ul>
</li>
<li>判断是否符合预期：scoreboard/checker</li>
<li>收集DUT输出并传递给sb：monitor</li>
<li>reference model</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221020170035636.png" srcset="/img/loading.gif" lazyload alt="image-20221020170035636"></p>
<h3><span id="22-只有driver的验证平台">2.2 只有driver的验证平台</span></h3><h4><span id="221-最简单的验证平台">2.2.1 最简单的验证平台</span></h4><p><strong>1. driver是验证平台最基本的组件</strong></p>
<blockquote>
<p><strong>如何搭建driver?</strong></p>
<ul>
<li>UVM是一个库，在这个库中，几乎所有的东西都是使用类（class）来实现的，如：driver、 monitor、reference model、scoreboard等组成部分都是类</li>
<li><strong>类有函数（function）和任务（task）</strong>，通过这些函数和任务可以完成driver的输出激励功能</li>
<li>使用UVM的第一条原则是：<strong>验证平台中所有的组件应该派生自UVM中的类</strong></li>
</ul>
</blockquote>
<p><strong>2. 定义一个my_driver类</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_DRIVER__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_DRIVER__SV</span><br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   top_tb<span class="hljs-variable">.rxd</span> &lt;= <span class="hljs-number">8&#x27;b0</span>; <br>   top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!top_tb<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>      top_tb<span class="hljs-variable">.rxd</span> &lt;= $urandom_range(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>);<br>      top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW)</span><br>   <span class="hljs-keyword">end</span><br>   @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>   top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">endtask</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>new参数</p>
<ul>
<li>uvm_driver的类的new函数有两个参数（这两个参数是由uvm_component要求的），一个是string类型的name，一个是uvm_component类型的parent</li>
<li>每一个派生自uvm_component或其派生类的类在其new函数中要指明两个参数：name和parent</li>
</ul>
<p>phase</p>
<ul>
<li>driver所做的事情几乎都在main_phase中完成</li>
<li><p>UVM由phase来管理验证平台的运行，这些phase统一以xxxx_phase来命名，且都有一个类型为uvm_phase、名字为phase的参数</p>
</li>
<li><p><strong>可以简单地认为， 实现一个driver等于实现其main_phase</strong></p>
</li>
</ul>
<p><code>`uvm_info</code>宏：与Verilog中display语句的功能类似，比display语句更加强大</p>
<ul>
<li>三个参数，第一个参数是字符串，用于把打印的信息归类；第二个参数也是字符串，是具体需要打印的信息；第三个参数则是冗余级别</li>
<li>非常关键可设置为UVM_LOW，可有可无可设置为UVM_HIGH，介于两者之间是UVM_MEDIUM。UVM默认只显示UVM_MEDIUM或者UVM_LOW的信息，本书3.4.1节会讲</li>
</ul>
<blockquote>
<p><strong>uvm_info打印内容</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">UVM_INFO</span> my_driver.sv(<span class="hljs-number">20</span>)@<span class="hljs-number">48500000</span>：drv[my_driver]data is drived<br></code></pre></div></td></tr></table></figure>
<ul>
<li>my_driver.sv(20)：指明此条打印信息的来源，其中括号里的数字表示原始的uvm_info打印语句在my_driver.sv中的行号</li>
<li>48500000：表明此条信息的打印时间</li>
<li>drv：这是driver在UVM树中的路径索引<ul>
<li>UVM采用树形结构，对于树中任何一个结点，都有一个与其相应的字符串类型的 路径索引。路径索引可以通过<code>get_full_name</code>函数来获取，把下列代码加入任何UVM树的结点中就可以得知当前结点的路径索引：<code>$display(&quot;the full name of current component is: %s&quot;, get_full_name());</code><ul>
<li>[my_driver]：方括号中显示的信息即调用uvm_info宏时传递的第一个参数</li>
<li>data is drived：表明宏最终打印的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>3. 实例化一对象</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">timescale</span> 1ns/1ps</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;uvm_macros.svh&quot;</span><br><br><span class="hljs-keyword">import</span> uvm_pkg::*;<br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;my_driver.sv&quot;</span><br><br><span class="hljs-keyword">module</span> top_tb;<br><br><span class="hljs-keyword">reg</span> clk;<br><span class="hljs-keyword">reg</span> rst_n;<br><span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rxd;<br><span class="hljs-keyword">reg</span> rx_dv;<br><span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] txd;<br><span class="hljs-keyword">wire</span> tx_en;<br><br>dut my_dut(<span class="hljs-variable">.clk</span>(clk),<br>           <span class="hljs-variable">.rst_n</span>(rst_n),<br>           <span class="hljs-variable">.rxd</span>(rxd),<br>           <span class="hljs-variable">.rx_dv</span>(rx_dv),<br>           <span class="hljs-variable">.txd</span>(txd),<br>           <span class="hljs-variable">.tx_en</span>(tx_en));<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   my_driver drv;<br>    drv = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//new的时候第二个参数一般不为null,这里省略所以为null</span><br>   drv<span class="hljs-variable">.main_phase</span>(<span class="hljs-literal">null</span>);<br>   <span class="hljs-built_in">$finish</span>();<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   clk = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">100</span> clk = ~clk;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   rst_n = <span class="hljs-number">1&#x27;b0</span>;<br>   #<span class="hljs-number">1000</span>;<br>   rst_n = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>`include uvm_macros.svh</code> 包含了众多的宏定义，只需要包含一 次</li>
<li><code>import uvm_pkg::*;</code>导入uvm_pkg库</li>
<li>new的时候第二个参数一般不为null</li>
<li>显示调用<code>main_phase</code></li>
<li><code>$finish();</code>结束仿真</li>
</ul>
<h4><span id="222-加入factory机制">2.2.2 加入factory机制</span></h4><p>上节的实例化及main_phase的显式调用，只使用简单的SystemVerilog也可完成</p>
<p>本节介绍：自动创建一个类的实例并调用其中的函数（function）和任务（task）</p>
<hr>
<p><strong>1. 使用factory机制重写my_driver</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_DRIVER__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_DRIVER__SV</span><br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-meta">`uvm_component_utils(my_driver)</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;new is called&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">endfunction</span><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;main_phase is called&quot;, UVM_LOW);</span><br>   top_tb<span class="hljs-variable">.rxd</span> &lt;= <span class="hljs-number">8&#x27;b0</span>; <br>   top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!top_tb<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>      top_tb<span class="hljs-variable">.rxd</span> &lt;= $urandom_range(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>);<br>      top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">end</span><br>   @(<span class="hljs-keyword">posedge</span> top_tb<span class="hljs-variable">.clk</span>);<br>   top_tb<span class="hljs-variable">.rx_dv</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">endtask</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>factory机制之宏<code>`uvm_component_utils</code></p>
<p>这个宏所做的事情非常多，其中之一就是将my_driver登记在 UVM内部的一张表中</p>
<p><mark>所有派生自uvm_component及其派生类的类都应该使用uvm_component_utils宏注册</mark></p>
<blockquote>
<p>这张表是factory功能实现的基础。只要在定义一个新的类时使用这个宏，就相当于把这个类注册到了这张表中。有关内容深入解释在后面</p>
</blockquote>
</blockquote>
<p><strong>2. 使用factory机制重写top_tb</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">...<br><br><span class="hljs-keyword">module</span> top_tb;<br><br>...<br>    <br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   run_test(<span class="hljs-string">&quot;my_driver&quot;</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>运行top_tb后输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br>main_phased <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br></code></pre></div></td></tr></table></figure>
<p>并没有输出：”data is drived”，关于这个问题，牵涉UVM的objection机制</p>
<blockquote>
<p><strong><code>run_test(&quot;注册的类名&quot;)</code></strong></p>
<p>使用<code>run_test(&quot;注册的类名&quot;)</code>代替my_driver实例化与显式调用</p>
<ul>
<li>run_test创建一个my_driver的实例，并且会自动调用my_driver的main_phase</li>
</ul>
</blockquote>
<h4><span id="223-加入objection机制">2.2.3 加入objection机制</span></h4><p>上一节只输出了“main_phase is called”，但是“data is drived”并没有输出，因为main_phase被杀死了</p>
<hr>
<p><strong>1. objection机制</strong></p>
<blockquote>
<p>UVM中通过objection机制来控制验证平台的关闭，在每个phase中，UVM会检查是否有objection被提起 (<code>raise_objection</code>)。如果有，则等待这个objection被撤销(<code>drop_objection</code>)后停止仿真；如果没有，则马上结束当前phase</p>
<ul>
<li><code>raise_objection</code>和<code>drop_objection</code>总是成对出</li>
<li><code>raise_objection</code>语句必须在main_phase中第一个消耗仿真时间 [1]的语句之前</li>
</ul>
<blockquote>
<p>所谓仿真时间，是指$time函数打印出的时间。与之相对的还有实际仿真中所消耗的CPU时间，通常说一个测试用例的运行时间 即指CPU 时间，为了与仿真时间相区分，本书统一把这种时间称为运行时间。</p>
<p>如<code>$display</code>语句是不消耗仿真时间的，这些语句可 以放在<code>raise_objection</code>之前，但是类似<code>@(posedge top.clk)</code>等语句是要消耗仿真时间的。按照如下的方式使用<code>raise_objection</code>是无法<br>起到作用的</p>
</blockquote>
</blockquote>
<ol>
<li>使用objection机制的my_driver</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_DRIVER__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_DRIVER__SV</span><br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>	...<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   	phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   <br>    ...<br>   <br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h4><span id="224-加入virtual-interrface">2.2.4 加入virtual interrface</span></h4><p><strong>1. 绝对路径遇到的问题：</strong></p>
<p>driver中等待时钟事件（@posedge top.clk）、给DUT中输入端口赋值（top.rx_dv&lt;=1‘b1）都是使用绝对路径，绝对路径的使用大大减弱了验证平台的可移植性。一个最简单的例子就是假如clk信号的层次从top.clk变成了top.clk_inst.clk，那么就需要对driver中的相关代码做大量修改。因此，从根本上来说，应该尽量杜绝在验证平台中使用绝对路径</p>
<p><strong>2. 解决方案①使用宏</strong></p>
<p>使用<code>`TOP</code>代替上文中的top，但是如果clk_inst变了照样解决不了，还要改</p>
<p><strong>3. 解决方法②使用接口</strong></p>
<p>定义接口</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_IF__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_IF__SV</span><br><br><span class="hljs-keyword">interface</span> my_if(<span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> rst_n);<br><br>   <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br>   <span class="hljs-keyword">logic</span> valid;<br><span class="hljs-keyword">endinterface</span><br><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></div></td></tr></table></figure>
<p>在top_tb中实例化DUT时，就可以直接使用接口</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br><br>...<br><br>my_if input_if(clk, rst_n);<br>my_if output_if(clk, rst_n);<br><br>dut my_dut(<span class="hljs-variable">.clk</span>(clk),<br>           <span class="hljs-variable">.rst_n</span>(rst_n),<br>           <span class="hljs-variable">.rxd</span>(input_if<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.rx_dv</span>(input_if<span class="hljs-variable">.valid</span>),<br>           <span class="hljs-variable">.txd</span>(output_if<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.tx_en</span>(output_if<span class="hljs-variable">.valid</span>));<br><br>...<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p><strong>4. 如何在driver（类）中使用接口</strong></p>
<p>不能直接，这种方式只能在module模块中才能实现</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br>    my_if drv_if;<br>    ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在类中应该使用虚接口virtual interface：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br>   ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>替代后的全部my_driver代码如下，可见绝对路径已消除</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br><br>   <span class="hljs-meta">`uvm_component_utils(my_driver)</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;new is called&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;build_phase is called&quot;, UVM_LOW);</span><br>      <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br>         <span class="hljs-meta">`uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;main_phase is called&quot;, UVM_LOW);</span><br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>; <br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>      vif<span class="hljs-variable">.data</span> &lt;= $urandom_range(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>);<br>      vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">end</span><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>5. 如何链接top_tb的input_if与my_driver中的vif(<mark>config_db机制</mark>)</strong></p>
<p>使用<code>run_test</code>进行实例化，从而无法直接引用my_driver实例</p>
<p><strong>使用<code>config_db</code>机制</strong></p>
<blockquote>
<p><mark><strong>config_db机制：</strong></mark></p>
<p>config_db用来在端口间传递数据（端口级），分为set和get两步操作</p>
<ul>
<li><code>uvm_config_db#(?)::set</code>操作，可以简单地理解成是“寄信”</li>
<li><code>uvm_config_db#(?)::get</code>则相当于是“收信”</li>
</ul>
</blockquote>
<p>在top_tb中执行set操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br><br>...<br><br>my_if input_if(clk, rst_n);<br>my_if output_if(clk, rst_n);<br><br>dut my_dut(<span class="hljs-variable">.clk</span>(clk),<br>           <span class="hljs-variable">.rst_n</span>(rst_n),<br>           <span class="hljs-variable">.rxd</span>(input_if<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.rx_dv</span>(input_if<span class="hljs-variable">.valid</span>),<br>           <span class="hljs-variable">.txd</span>(output_if<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.tx_en</span>(output_if<span class="hljs-variable">.valid</span>));<br><br>...<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if)</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>在my_driver中，执行get操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br><br>   ...<br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;build_phase is called&quot;, UVM_LOW);</span><br>      <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br>         <span class="hljs-meta">`uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br>   <span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>build_phase</code></p>
<ul>
<li>定义：与main_phase一样，build_phase也是UVM中内建的一个phase</li>
<li>执行顺序：当UVM启动后，会自动执行 build_phase，运行在new之后，main_phase之前</li>
<li>主要作用：主要通过config_db的set和get操作来传递一些数据， 以及实例化成员变量等</li>
<li>使用注意事项：需要在build_phase中调用<code>super.build_phase(phase)</code>，因为父类的build_phase中执行了一些必要的操作，这里必须显式调用并执行</li>
<li>与main_phase不同：main_phase是任务，build_phase是函数不消耗仿真时间</li>
</ul>
<p><strong><code>`uvm_fatal</code>宏</strong></p>
<ul>
<li>参数：两个与<code>`uvm_info</code>前两个参数意义一样</li>
<li>主要作用：表示验证平台出现了重大问题而无法继续下去，必须停止仿真并做相应的检查</li>
<li>与<code>`uvm_info</code>不同：会调用<code>$finish()</code>结束仿真</li>
</ul>
<p><code>config_db</code>的参数</p>
<ul>
<li>config_db的set和get函数都有四个参数，且第三个参数必须完全一致</li>
</ul>
<p><code>uvm_config_db::set</code></p>
<ul>
<li>第二个参数表示的是路径索引(2.2.1节提到<code>`uvm_info</code>中的路径索引)<ul>
<li>run_test创建的实例名为<code>uvm_test_top</code>，无论传给run_test参数是什么创建的实例名都是uvm_test_top</li>
</ul>
</li>
<li>第四个参数表示要将哪个interface 通过config_db传递给my_driver</li>
</ul>
<p><code>uvm_config_db::get</code></p>
<ul>
<li>第四个参数表示把得到的interface传递给哪个my_driver的成员变量</li>
</ul>
<p>参数化：</p>
<ul>
<li><code>uvm_config_db#(virtual my_if)</code>是一个参数化的类，其参数就是要寄信的类型</li>
<li>如果要传递一个int类型：<code>uvm_config_db#(int)::set</code></li>
</ul>
</blockquote>
<h3><span id="23-为验证平台加入各个组件">2.3 为验证平台加入各个组件</span></h3><p>2.2节的操作基于信号级，本节引入scoreboard、reference model、monitor这些组件是基于transaciton</p>
<h4><span id="231-加入transaction">2.3.1 加入<mark>transaction</mark></span></h4><p>transaction的概念：transaction就是用于模拟物理协议/以太网协议/…，一 笔transaction就是一个包</p>
<p><strong>1. 一个简单的transaction定义</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_TRANSACTION__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_TRANSACTION__SV</span><br><br><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] smac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ether_type;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">byte</span>      pload[];<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<br><br>   <span class="hljs-keyword">constraint</span> pload_cons&#123;<br>      pload<span class="hljs-variable">.size</span> &gt;= <span class="hljs-number">46</span>;<br>      pload<span class="hljs-variable">.size</span> &lt;= <span class="hljs-number">1500</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] calc_crc();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">32&#x27;h0</span>;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> post_randomize();<br>      crc = calc_crc;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils(my_transaction)</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_transaction&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>();<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>uvm_sequence_item</code></p>
<p>my_transaction的基类是uvm_sequence_item，uvm_sequence_item的祖先是<code>uvm_object</code></p>
<p><code>uvm_object_utils</code></p>
<ul>
<li>不使用<code>uvm_component_utils</code>而使用<code>` uvm_object_utils</code>  的原因：<ul>
<li>transaction不同于driver等组件，具有生命周期，这种类一般派生自uvm_object或uvm_object的派生类</li>
</ul>
</li>
</ul>
<p><strong><code>post_randomize</code></strong></p>
<ul>
<li><p>post_randomize是SystemVerilog中提供的一个函数，</p>
</li>
<li><p>当某个类的实例的randomize函数被调用后，post_randomize会紧随其后无条件地被调用</p>
</li>
</ul>
</blockquote>
<p><strong>2. driver驱动transaction</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_DRIVER__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_DRIVER__SV</span><br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br><br>   <span class="hljs-meta">`uvm_component_utils(my_driver)</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br>         <span class="hljs-meta">`uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> drive_one_pkt(my_transaction tr);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) <span class="hljs-keyword">begin</span> <br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;pload<span class="hljs-variable">.size</span> == <span class="hljs-number">200</span>;&#125;);<br>      drive_one_pkt(tr);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> my_driver::drive_one_pkt(my_transaction tr);<br>   <span class="hljs-keyword">bit</span> [<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] tmp_data;<br>   <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data_q[$]; <br>  <br>   <span class="hljs-comment">//push dmac to data_q</span><br>   tmp_data = tr<span class="hljs-variable">.dmac</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(tmp_data[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]);<br>      tmp_data = (tmp_data &gt;&gt; <span class="hljs-number">8</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//push smac to data_q</span><br>   tmp_data = tr<span class="hljs-variable">.smac</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(tmp_data[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]);<br>      tmp_data = (tmp_data &gt;&gt; <span class="hljs-number">8</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//push ether_type to data_q</span><br>   tmp_data = tr<span class="hljs-variable">.ether_type</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(tmp_data[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]);<br>      tmp_data = (tmp_data &gt;&gt; <span class="hljs-number">8</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//push payload to data_q</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>; i++) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(tr<span class="hljs-variable">.pload</span>[i]);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//push crc to data_q</span><br>   tmp_data = tr<span class="hljs-variable">.crc</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(tmp_data[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]);<br>      tmp_data = (tmp_data &gt;&gt; <span class="hljs-number">8</span>);<br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;begin to drive one pkt&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br><br>   <span class="hljs-keyword">while</span>(data_q<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>      vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      vif<span class="hljs-variable">.data</span> &lt;= data_q<span class="hljs-variable">.pop_front</span>(); <br>   <span class="hljs-keyword">end</span><br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>流程：</p>
<p>① 随机化：main_phase中执行transactin的randomize()</p>
<p>② 数据入列：main_phase执行数据入列函数，把transaction压入data_q</p>
<blockquote>
<p>SystemVerlog提供的流操作符实现</p>
<p>IEEE Standard for SystemVerilog—Unified Hardware Design，Specification，and Verification Language 的11.4.14章</p>
</blockquote>
</blockquote>
<h4><span id="232-加入env">2.3.2 加入env</span></h4><p>我们在哪对各种组件例化？</p>
<ul>
<li>（不可行）top_tb中使用run_test不行，因为run_test只能实例化一个实例</li>
<li>（不可行）top_tb中直接new不行，这样run_test没意义了</li>
<li>（正确的）引入一个容器类，在这个类里面例化各种组件，此时run_test的参数不再是my_driver而是容器类。uvm中使用继承自<mark><code>uvm_env</code></mark>的子类，来表示这个容器类</li>
</ul>
<p><strong>1. 定义my_env</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   my_driver drv;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>); <br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>类名::type_id::create</code></p>
<ul>
<li>factory机制带来的独特的实例化方式，只有factory注册过的类可以这种方式例化（代替new）</li>
<li>好处：后面可以用到factory中强大的重载功能</li>
</ul>
</blockquote>
<p><strong>2. 树形结构——回顾my_driver参数2</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>name：实例名称</li>
<li>parent：由于是在uvm_env例化，则my_driver的drv实例是my_env<ul>
<li><mark><strong>建立了树形结构</strong></mark></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021221512291-16663617135971.png" srcset="/img/loading.gif" lazyload alt="image-20221021221512291"></p>
<p><strong>3. build_phase顺序</strong></p>
<p><mark>build_phase的执行遵照从树根到树叶的顺序</mark>，当把整棵树的build_phase都执行完毕后，再执行后面的phase</p>
<p>因此，先执行my_env的build_phase，再执行my_driver的build_phase</p>
<p><strong>4. 修改config_db</strong></p>
<p><mark>树根始终是run_test创建的uvm_test_top</mark>，这里uvm_test_top对象代表了一个my_env类</p>
<p>我们为啥要修改config_db？</p>
<p>答：我们加了一个env，你忘了吗</p>
<hr>
<p>假如在my_env中实例化一个my_driver为my_drv：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env<br>    ...<br>    drv = my_driver::type_id::create(<span class="hljs-string">&quot;my_drv&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>则在top_tb.sv中修改为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br>    ...<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.my_drv&quot;, &quot;vif&quot;, input_if)</span>;<br>    <span class="hljs-comment">//原来是</span><br>    <span class="hljs-comment">//uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if);</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="233-加入monitor">2.3.3 加入monitor</span></h4><p>monitor作用：收集DUT行为</p>
<p>monitor内容：收集DUT端口数据，转换为transaction后交给后续组件（与driver相反）</p>
<p>driver内容：把transaction数据变为DUT端口级别，并驱动到DUT</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_MONITOR__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_MONITOR__SV</span><br><span class="hljs-keyword">class</span> my_monitor <span class="hljs-keyword">extends</span> uvm_monitor;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br><br>   <span class="hljs-meta">`uvm_component_utils(my_monitor)//my_monitor</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_monitor&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br>         <span class="hljs-meta">`uvm_fatal(&quot;my_monitor&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> collect_one_pkt(my_transaction tr);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">task</span> my_monitor::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      collect_one_pkt(tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> my_monitor::collect_one_pkt(my_transaction tr);<br>   <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data_q[$]; <br>   <span class="hljs-keyword">int</span> psize;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>      <span class="hljs-keyword">if</span>(vif<span class="hljs-variable">.valid</span>) <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-meta">`uvm_info(&quot;my_monitor&quot;, &quot;begin to collect one pkt&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">while</span>(vif<span class="hljs-variable">.valid</span>) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(vif<span class="hljs-variable">.data</span>);<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//pop dmac</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.dmac</span> = &#123;tr<span class="hljs-variable">.dmac</span>[<span class="hljs-number">39</span>:<span class="hljs-number">0</span>], data_q<span class="hljs-variable">.pop_front</span>()&#125;;<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//pop smac</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.smac</span> = &#123;tr<span class="hljs-variable">.smac</span>[<span class="hljs-number">39</span>:<span class="hljs-number">0</span>], data_q<span class="hljs-variable">.pop_front</span>()&#125;;<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//pop ether_type</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.ether_type</span> = &#123;tr<span class="hljs-variable">.ether_type</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], data_q<span class="hljs-variable">.pop_front</span>()&#125;;<br>   <span class="hljs-keyword">end</span><br><br>   psize = data_q<span class="hljs-variable">.size</span>() - <span class="hljs-number">4</span>;<br>   tr<span class="hljs-variable">.pload</span> = <span class="hljs-keyword">new</span>[psize];<br>   <span class="hljs-comment">//pop payload</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; psize; i++) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.pload</span>[i] = data_q<span class="hljs-variable">.pop_front</span>();<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-comment">//pop crc</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.crc</span> = &#123;tr<span class="hljs-variable">.crc</span>[<span class="hljs-number">23</span>:<span class="hljs-number">0</span>], data_q<span class="hljs-variable">.pop_front</span>()&#125;;<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-meta">`uvm_info(&quot;my_monitor&quot;, &quot;end collect one pkt, print it:&quot;, UVM_LOW);</span><br>    tr<span class="hljs-variable">.my_print</span>();<br><span class="hljs-keyword">endtask</span><br><br><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>流程：</p>
<p>数据入列：main_phase执行数据入列函数，把transaction压入data_q</p>
<p><mark>永不停歇</mark></p>
<p>由于monitor需要时刻收集数据，永不停歇，所以在main_phase中使用<code>while(1)</code>来实现</p>
<p>对比monitor中的collect_one_pkt与driver中的drv_one_pkt：</p>
<ul>
<li>两者代码非常相似</li>
<li>当收集完一个transaction后， 通过my_print函数将其打印出来<ul>
<li>my_printf在my_transaction中定义</li>
</ul>
</li>
</ul>
</blockquote>
<p>transaction中定义的my_printf：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_print();<br>   <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;dmac = %0h&quot;</span>, dmac);<br>   <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;smac = %0h&quot;</span>, smac);<br>   <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;ether_type = %0h&quot;</span>, ether_type);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pload<span class="hljs-variable">.size</span>; i++) <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;pload[%0d] = %0h&quot;</span>, i, pload[i]);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;crc = %0h&quot;</span>, crc);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>env中对组件的例化：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   my_driver drv;<br>   my_monitor i_mon;<br>   <br>   my_monitor o_mon;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>); <br>      i_mon = my_monitor::type_id::create(<span class="hljs-string">&quot;i_mon&quot;</span>, <span class="hljs-keyword">this</span>);<br>      o_mon = my_monitor::type_id::create(<span class="hljs-string">&quot;o_mon&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endfunction</span><br><br>    <span class="hljs-meta">`uvm_component_utils(my_env)//注册my_env</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>实例化两个monitor</strong></p>
<ul>
<li>一个用于检测DUT输入</li>
<li>一个用于检测DUT输出</li>
</ul>
<p>为什么输入也monitor？</p>
<p>这个答案仁者见仁，智者见智。这里还是推荐使用monitor，原因是：</p>
<ul>
<li>第一，在一个大型的项目中，driver根据某一协议发送数据，而 monitor根据这种协议收集数据，如果driver和monitor由不同人员实现，那么可以大大减少其中任何一方对协议理解的错误</li>
<li>第二，在后文将会看到，在实现<strong>代码重用</strong>时，使用monitor是非常有必要的</li>
</ul>
</blockquote>
<p><strong>2. 现在的树结构</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021232129013.png" srcset="/img/loading.gif" lazyload alt="image-20221021232129013"></p>
<p><strong>3. top_tb中config_db修改</strong></p>
<p>使用config_db将input_if和output_if传递给两个monitor，从而完成端口连接</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.drv&quot;, &quot;vif&quot;, input_if)</span>;<br>uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.i_mon&quot;, &quot;vif&quot;, input_if)</span>;<br>uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.o_mon&quot;, &quot;vif&quot;, output_if)</span>;<br></code></pre></div></td></tr></table></figure>
<h4><span id="234-封装成agent">2.3.4 封装成agent</span></h4><p>driver与monitor代码相似（本质处理同一种协议）</p>
<p>因此UVM常把二者封装在一起，成为<mark>agent</mark></p>
<p><mark>不同的agent就代表了不同的协议</mark></p>
<hr>
<p><strong>1. my_agent定义</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_AGENT__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_AGENT__SV</span><br><br><span class="hljs-keyword">class</span> my_agent <span class="hljs-keyword">extends</span> uvm_agent ;<br>   my_driver     drv;<br>   my_monitor    mon;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br><br>   <span class="hljs-meta">`uvm_component_utils(my_agent)</span><br><span class="hljs-keyword">endclass</span> <br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   <span class="hljs-keyword">if</span>(is_active == UVM_ACTIVE) <span class="hljs-keyword">begin</span><br>       drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">end</span><br>   mon = my_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>uvm_agent</code></p>
<ul>
<li>所有agent派生自此类</li>
</ul>
<p><code>is_active</code></p>
<ul>
<li><code>is_active</code>是<code>uvm_agent</code>的一个成员变量，类型为<code>uvm_active_passive_enum</code>是一个枚举类型</li>
<li>默认为<code>UVM_PASSIVE</code></li>
</ul>
<p><code>uvm_active_passive_enum</code>：</p>
<ul>
<li><code>typedef enum bit &#123; UVM_PASSIVE=0, UVM_ACTIVE=1 &#125; uvm_active_passive_enum;</code></li>
<li><code>UVM_PASSIVE</code>：意味着输入端口，无需驱动任何信号，只做检查信号(即只要monitor不要driver）</li>
<li><code>UVM_ACTIVE</code>：意味着输出端口，需驱动任何信号</li>
</ul>
</blockquote>
<p><strong>2. 修改env中对driver和monitor的实例化（同时配置is_active）</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   my_agent  i_agt;<br>   my_agent  o_agt;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      i_agt = my_agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      o_agt = my_agent::type_id::create(<span class="hljs-string">&quot;o_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      i_agt<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;<br>      o_agt<span class="hljs-variable">.is_active</span> = UVM_PASSIVE;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3. 目前树结构</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221021234757273.png" srcset="/img/loading.gif" lazyload alt="image-20221021234757273"></p>
<p><strong>4. config_db修改端口连接</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br>	...<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.i_agt.drv&quot;, &quot;vif&quot;, input_if)</span>;<br>       <span class="hljs-comment">//原来是uvm_test_top.drv</span><br>       uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.i_agt.mon&quot;, &quot;vif&quot;, input_if)</span>;<br>        <span class="hljs-comment">//原来是uvm_test_top.i_mon</span><br>       uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.o_agt.mon&quot;, &quot;vif&quot;, output_if)</span>;<br>        <span class="hljs-comment">//原来是uvm_test_top.*_mon</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（补充）5.用config_db也可以传is_active</strong></p>
<p>背景：使用new实例化时，无法传递is_active。此时使用config_db机制可以传递is_active</p>
<p>注意！：UVM中约定俗成的还是在build_phase中完成实例化工作。<mark>因此，强烈建议仅在build_phase中完成实例化</mark></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br>   my_agent  i_agt;<br>   my_agent  o_agt;<br>   ...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)::set(this, &quot;i_agt&quot;, &quot;is_active&quot;, UVM_ACTIVE)</span>;<br>      uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)::set(this, &quot;o_agt&quot;, &quot;is_active&quot;, UVM_PASSIVE)</span>;<br>      i_agt = my_agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      o_agt = my_agent::type_id::create(<span class="hljs-string">&quot;o_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> my_agent <span class="hljs-keyword">extends</span> uvm_agent ;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>      uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)::get(this, &quot;&quot;, &quot;is_active&quot;, is_active)</span>;<br>      <span class="hljs-keyword">if</span> (is_active == UVM_ACTIVE) <span class="hljs-keyword">begin</span><br>          drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">end</span><br>      mon = my_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endfunction</span> <br><span class="hljs-keyword">endclass</span> <br><br></code></pre></div></td></tr></table></figure>
<h4><span id="235-加入reference-model">2.3.5 加入reference model</span></h4><p>作用：完成与DUT相同功能</p>
<p>输出：被scoreboard接收</p>
<hr>
<p><strong>1. 定义my_model</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_MODEL__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_MODEL__SV</span><br><br><span class="hljs-keyword">class</span> my_model <span class="hljs-keyword">extends</span> uvm_component;<br>   <br>   uvm_blocking_get_port <span class="hljs-variable">#(my_transaction)</span>  port;<br>   uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span>  ap;<br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><br>   <span class="hljs-meta">`uvm_component_utils(my_model)</span><br><span class="hljs-keyword">endclass</span> <br><br><span class="hljs-keyword">function</span> my_model::<span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_model::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-keyword">this</span>);<br>   ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.my_copy</span>(tr);<br>      <span class="hljs-meta">`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>      new_tr<span class="hljs-variable">.my_print</span>();<br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>此reference model就是单纯使用transaction中的my_copy函数，复制一份从i_agt得到的transaction，再传递到后级的scoreboard</p>
<p>reference和其他组件一样，再env中被实例化</p>
<p><strong>2. 目前的树结构</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221022000741471.png" srcset="/img/loading.gif" lazyload alt="image-20221022000741471"></p>
<p><strong>3. transaction的传输</strong></p>
<blockquote>
<p>目前传输：</p>
<p>i_agt -&gt; ref -&gt; scoreboard</p>
<p>i_agt -&gt; dut（目前还没提到DUT模块在哪）</p>
<p><mark>TLM(Transaction Level Modeling)</mark></p>
<p>UVM一般使用<mark>TLM(Transaction Level Modeling)</mark>实现component之间的transaction通信</p>
<p>TLM有多种实现方式：</p>
<ul>
<li>发送的其中一种方法使用<code>uvm_analysis_port</code></li>
<li>接收的其中一种方法使用<code>uvm_blocking_get_port</code></li>
<li>连接：在此基础上还需要再env上定义一个<code>uvm_tlm_analysis_fifo</code>（一个fifo）将二者连在一起</li>
</ul>
<p><code>uvm_analysis_port</code>是TLM发送的实现方式的一种</p>
<ul>
<li>定义：<code>uvm_analysis_port #(my_transaction) ap;</code></li>
<li>参数化的类，参数为需要传递数据的类型（本节中为my_transaction）</li>
<li>通过调用内建函数<code>write</code>完成发送</li>
<li><mark>非阻塞的</mark></li>
</ul>
<p><code>uvm_blocking_get_port</code>是TLM接收的实现方式的一种</p>
<ul>
<li>定义：<code>uvm_blocking_get_port #(my_transaction)  port;</code></li>
<li>参数化的类，参数为需要传递数据的类型（本节中为my_transaction）</li>
<li>通过调用内建函数<code>get</code>完成接收</li>
</ul>
<p><code>uvm_tlm_analysis_fifo</code>是TLM连接的实现方式的一种</p>
<ul>
<li>定义：<code>uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;</code></li>
<li><p>参数化的类，参数为需要传递数据的类型（本节中为my_transaction）</p>
</li>
<li><p>具体连接方法：</p>
<ul>
<li>通过在<mark><strong>connect_phase</strong></mark>中，分别层次化调用monitor中的<code>uvm_analysis_port</code>与model中的<code>uvm_blocking_get_port</code>两种port的内建函数<code>connect</code>完成发送与接收的连接</li>
<li>连接时，需要调用<code>uvm_tlm_analysis_fifo</code>中用于指示端口类型的成员变量：<code>analysis_export</code>与<code>blocking_get_export</code></li>
</ul>
</li>
</ul>
<p>为什么需要一个fifo？为啥不直接把monitor中的analysis_port和model中的blocking_get_port连接？</p>
<ul>
<li>analysis_port是非阻塞性质的，ap.write函数调用完成后马上返回，不会等待数据被接收。假如当write函数调用时， blocking_get_port正在忙于其他事情，而没有准备好接收新的数据时，此时被write函数写入的my_transaction就需要一个暂存的位置，这就是fifo</li>
</ul>
<p><mark><strong>connect_phase</strong></mark></p>
<ul>
<li>在build_phase之后马上执行</li>
<li><mark>与build_phase的同级执行顺序不同，connect_phase从树叶到叶根</mark>（从小到大）<ul>
<li>即：先执行driver和monitor的connect_phase，再执行agent的connect_phase，最后执行env的connect_phase</li>
<li><mark>这样做有利于在实例化组件之后，进行层次化连接</mark>（见本节总结）</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>4. 使用<code>uvm_analysis_port</code>发送</strong></p>
<p>my_monitor中：</p>
<ul>
<li>定义一个<code>uvm_analysis_port</code>类型的port</li>
<li>在build_phase中实例化</li>
<li>当准备好一个transaction后，在main_phase中写入该port<ul>
<li>写入port通过调用它的内建函数<code>write</code>实现</li>
</ul>
</li>
</ul>
<p>如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> MY_MONITOR__SV</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MY_MONITOR__SV</span><br><span class="hljs-keyword">class</span> my_monitor <span class="hljs-keyword">extends</span> uvm_monitor;<br>   ...<br>   uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span>  ap;<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br>         <span class="hljs-meta">`uvm_fatal(&quot;my_monitor&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br>      ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> collect_one_pkt(my_transaction tr);<br>       <br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_monitor::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      collect_one_pkt(tr);<br>      ap<span class="hljs-variable">.write</span>(tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>5. 使用<code>uvm_blocking_get_port</code>接收</strong></p>
<p>在model中：</p>
<ul>
<li>定义一个<code>uvm_blocking_get_port</code>类型的port</li>
<li>在build_phase中实例化</li>
<li>不断读取i_agt从此port发送来的transaction<ul>
<li>从port读取通过调用它的内建函数<code>get</code>实现</li>
</ul>
</li>
</ul>
<p>如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_model <span class="hljs-keyword">extends</span> uvm_component;<br>   <br>   uvm_blocking_get_port <span class="hljs-variable">#(my_transaction)</span>  port;<br>   uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span>  ap;<br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><br>   <span class="hljs-meta">`uvm_component_utils(my_model)</span><br><span class="hljs-keyword">endclass</span> <br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> my_model::<span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_model::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-keyword">this</span>);<br>   ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.my_copy</span>(tr);<br>      <span class="hljs-meta">`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>      new_tr<span class="hljs-variable">.my_print</span>();<br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>6. 使用<code>uvm_tlm_analysis_fifo</code>连接</strong></p>
<p>在env中：</p>
<ul>
<li>定义一个<code>uvm_tlm_analysis_fifo</code>类型的fifo，一个</li>
<li>在build_phase中实例化<code>uvm_tlm_analysis_fifo</code><ul>
<li><mark>注意：无需对env中的ap和port例化</mark>，他俩在monitor和model中已经被例化过了，这里只是做调用</li>
</ul>
</li>
<li>在connect_phase中进行连接<ul>
<li>发送这么连接到fifo：<code>i_agt.ap.connect(agt_mdl_fifo.analysis_export);</code></li>
<li>接收这么连接到fifo：<code>model.port.connect(agt_mdl_fifo.blocking_get_export);</code><ul>
<li><code>agt_mdl_fifo</code>：一个<code>uvm_tlm_analysis_fifo</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   my_agent  i_agt;<br>   my_agent  o_agt;<br>   my_model  mdl;<br>   <br>   uvm_tlm_analysis_fifo <span class="hljs-variable">#(my_transaction)</span> agt_mdl_fifo;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      i_agt = my_agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      o_agt = my_agent::type_id::create(<span class="hljs-string">&quot;o_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      i_agt<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;<br>      o_agt<span class="hljs-variable">.is_active</span> = UVM_PASSIVE;<br>      mdl = my_model::type_id::create(<span class="hljs-string">&quot;mdl&quot;</span>, <span class="hljs-keyword">this</span>);<br>      agt_mdl_fifo = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;agt_mdl_fifo&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   i_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.analysis_export</span>);<br>   mdl<span class="hljs-variable">.port</span><span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.blocking_get_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>6. 总结一下</strong></p>
<ul>
<li>主要目的：model需要得到从i_agt来的transaction</li>
<li><p>方式：</p>
<ul>
<li>i_agt发送</li>
<li>model接收</li>
<li>env建立fifo并连接</li>
</ul>
</li>
<li><p>实例化位置：</p>
<ul>
<li>i_monitor发送，因此<code>uvm_analysis_port</code>在i_monitor中实例化</li>
<li>i_agt实例化i_monitor，为了方便引用，因此在这里定义了一个指向i_monitor.ap的指针</li>
<li>model中接收，因此<code>uvm_blocking_get_port</code>在model中实例化</li>
<li>env中实例化一个<code>uvm_tlm_analysis_fifo</code>，并实例化各种组件，通过层次化引用到ap和port</li>
</ul>
</li>
<li>重要执行顺序：<ul>
<li>env在build_phase中实例化agent</li>
<li>agent在build_phase中实例化i_monitor</li>
<li>agent在connect_phase中引用i_monitor.ap</li>
<li>env在conncet_phase中引用i_monitor.ap和model.port，并进行连接</li>
</ul>
</li>
</ul>
<blockquote>
<p><mark>为什么是i_monitor发送？</mark></p>
<ul>
<li>因为driver是给到dut的，基于信号级；model是基于transaction，因此需要i_monitor转换后的</li>
</ul>
</blockquote>
<h4><span id="236-加入scoreboard">2.3.6 加入scoreboard</span></h4><p>用于比较dut与ref的输出</p>
<hr>
<p><strong>1.scoreboard定义</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;<br>   my_transaction  expect_queue[$];<br>   uvm_blocking_get_port <span class="hljs-variable">#(my_transaction)</span>  exp_port;<br>   uvm_blocking_get_port <span class="hljs-variable">#(my_transaction)</span>  act_port;<br>   <span class="hljs-meta">`uvm_component_utils(my_scoreboard)</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent = <span class="hljs-literal">null</span>);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span> <br><br><span class="hljs-keyword">function</span> my_scoreboard::<span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent = <span class="hljs-literal">null</span>);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_scoreboard::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   exp_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;exp_port&quot;</span>, <span class="hljs-keyword">this</span>);<br>   act_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;act_port&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);<br>   my_transaction  get_expect,  get_actual, tmp_tran;<br>   <span class="hljs-keyword">bit</span> result;<br> <br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">fork</span> <br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         exp_port<span class="hljs-variable">.get</span>(get_expect);<br>         expect_queue<span class="hljs-variable">.push_back</span>(get_expect);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         act_port<span class="hljs-variable">.get</span>(get_actual);<br>         <span class="hljs-keyword">if</span>(expect_queue<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>            tmp_tran = expect_queue<span class="hljs-variable">.pop_front</span>();<br>            result = get_actual<span class="hljs-variable">.my_compare</span>(tmp_tran);<br>            <span class="hljs-keyword">if</span>(result) <span class="hljs-keyword">begin</span> <br>               <span class="hljs-meta">`uvm_info(&quot;my_scoreboard&quot;, &quot;Compare SUCCESSFULLY&quot;, UVM_LOW);</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>               <span class="hljs-meta">`uvm_error(&quot;my_scoreboard&quot;, &quot;Compare FAILED&quot;);</span><br>               <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the expect pkt is&quot;</span>);<br>               tmp_tran<span class="hljs-variable">.my_print</span>();<br>               <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the actual pkt is&quot;</span>);<br>               get_actual<span class="hljs-variable">.my_print</span>();<br>            <span class="hljs-keyword">end</span><br>         <span class="hljs-keyword">end</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_error(&quot;my_scoreboard&quot;, &quot;Received from DUT, while Expect Queue is empty&quot;);</span><br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the unexpected pkt is&quot;</span>);<br>            get_actual<span class="hljs-variable">.my_print</span>();<br>         <span class="hljs-keyword">end</span> <br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>流程：</p>
<ul>
<li>建立两个进程</li>
<li>进程1：接收<code>exp_port</code>(ref)一个trans到队列expect_queue中</li>
<li>进程2：<ul>
<li>从<code>act_port</code>(dut)接收一个trans为get_actual</li>
<li>expect_queue弹出一个trans到tmp_tran</li>
<li>调用get_actual.compare函数</li>
</ul>
</li>
</ul>
<p>数据：</p>
<p>scoreboard比较的数据：</p>
<ul>
<li>来自reference model的port，通过端口exp_port获取</li>
<li>来自monitor的o_agt，通过端口act_port获取<ul>
<li>你可能好奇为什么DUT是通过monitor的o_agt获取到scoreboard的？你个笨蛋！DUT是直接和o_agt连接的，把数据打包为事务级（driver相反，把事务级转为端口级）</li>
</ul>
</li>
</ul>
<p>端口与对应组件(2.3.5)</p>
<ul>
<li>scoreboard：act_port, exp_port</li>
<li>monitor：o_agt</li>
<li>reference model：port</li>
</ul>
</blockquote>
<p><strong>2.实例化scoreboard</strong></p>
<p>在my_env中实例化scoreboard</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221119221905011.png" srcset="/img/loading.gif" lazyload alt="image-20221119221905011"></p>
<h4><span id="237-加入field_automation机制">2.3.7 加入<mark>field_automation</mark>机制</span></h4><p>用于在transaction中定义变量，从而可以用到uvm的transaction函数</p>
<hr>
<p><strong>1.my_transaction定义修改</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] smac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ether_type;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">byte</span>      pload[];<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<br><br>   <span class="hljs-keyword">constraint</span> pload_cons&#123;<br>      pload<span class="hljs-variable">.size</span> &gt;= <span class="hljs-number">46</span>;<br>      pload<span class="hljs-variable">.size</span> &lt;= <span class="hljs-number">1500</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] calc_crc();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">32&#x27;h0</span>;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> post_randomize();<br>      crc = calc_crc;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils_begin(my_transaction)</span><br>      <span class="hljs-meta">`uvm_field_int(dmac, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(smac, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(ether_type, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_array_int(pload, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(crc, UVM_ALL_ON)</span><br>   <span class="hljs-meta">`uvm_object_utils_end</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_transaction&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>();<br>   <span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><mark>file_automation机制</mark>&gt;</p>
<p>流程：</p>
<ul>
<li><code>uvm_object_utils_begin</code> 与 <code>`uvm_object_utils_end</code>划定file_automation定义的范围</li>
<li>针对不同数据类型调用不同宏进行变量定义<ul>
<li><code>uvm_field_int</code></li>
<li><code>uvm_field_array_int</code></li>
</ul>
</li>
</ul>
<p>经过以上步骤，可以直接调用定义了这些变量的类的方法：</p>
<ul>
<li><code>copy</code></li>
<li><code>compare</code></li>
<li><code>print</code></li>
<li><code>pack_bytes</code></li>
<li><code>unpack_bytes</code></li>
</ul>
</blockquote>
<p><strong>2.my_model与scoreboard中直接调用file_automation带来的方法</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.copy</span>(tr);<span class="hljs-comment">//直接调用</span><br>      <span class="hljs-meta">`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>       new_tr<span class="hljs-variable">.print</span>();<span class="hljs-comment">//直接调用</span><br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);<br>   my_transaction  get_expect,  get_actual, tmp_tran;<br>   <span class="hljs-keyword">bit</span> result;<br> <br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">fork</span> <br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         exp_port<span class="hljs-variable">.get</span>(get_expect);<br>         expect_queue<span class="hljs-variable">.push_back</span>(get_expect);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         act_port<span class="hljs-variable">.get</span>(get_actual);<br>         <span class="hljs-keyword">if</span>(expect_queue<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>            tmp_tran = expect_queue<span class="hljs-variable">.pop_front</span>();<br>            result = get_actual<span class="hljs-variable">.compare</span>(tmp_tran);<span class="hljs-comment">//直接调用</span><br>            <span class="hljs-keyword">if</span>(result) <span class="hljs-keyword">begin</span> <br>               <span class="hljs-meta">`uvm_info(&quot;my_scoreboard&quot;, &quot;Compare SUCCESSFULLY&quot;, UVM_LOW);</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>               <span class="hljs-meta">`uvm_error(&quot;my_scoreboard&quot;, &quot;Compare FAILED&quot;);</span><br>               <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the expect pkt is&quot;</span>);<br>               tmp_tran<span class="hljs-variable">.print</span>();<br>               <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the actual pkt is&quot;</span>);<br>               get_actual<span class="hljs-variable">.print</span>();<br>            <span class="hljs-keyword">end</span><br>         <span class="hljs-keyword">end</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_error(&quot;my_scoreboard&quot;, &quot;Received from DUT, while Expect Queue is empty&quot;);</span><br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;the unexpected pkt is&quot;</span>);<br>            get_actual<span class="hljs-variable">.print</span>();<br>         <span class="hljs-keyword">end</span> <br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.引入file_automation的好处/driver与monitor的定义简化</strong></p>
<p>好处：引入field_automation机制的另外一大好处是简化了driver和monitor。在2.3.1节及2.3.3节中，my_driver的drv_one_pkt任务和 my_monitor的collect_one_pkt任务代码很长，但是几乎都是一些重复性的代码</p>
<p>使用field_automation机制后，drv_one_pkt任务可以 简化为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::drive_one_pkt(my_transaction tr);<br>   <span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span>     data_q[];<br>   <span class="hljs-keyword">int</span>  data_size;<br>   <br>   data_size = tr<span class="hljs-variable">.pack_bytes</span>(data_q) / <span class="hljs-number">8</span>; <span class="hljs-comment">//直接调用pack_bytes方法，把tr中字段打包为字节流放入data_q中，简化了！</span><br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;begin to drive one pkt&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data_size; i++ ) <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>      vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      vif<span class="hljs-variable">.data</span> &lt;= data_q[i]; <br>   <span class="hljs-keyword">end</span><br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>pack流程：</p>
<ul>
<li>直接调用<code>pack_bytes</code></li>
</ul>
<p>对比：</p>
<ul>
<li>pack_bytes将tr中所有的字段变成byte流放入data_q中</li>
<li>在2.3.1节中是手工地将所有字段放入data_q中的。 pack_bytes极大地减少了代码量</li>
</ul>
</blockquote>
<p>my_monitor的collect_one_pkt可以简化成：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_monitor::collect_one_pkt(my_transaction tr);<br>   <span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span> data_q[$];<br>   <span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span> data_array[];<br>   <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br>   <span class="hljs-keyword">logic</span> valid = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> data_size;<br>   <br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>      <span class="hljs-keyword">if</span>(vif<span class="hljs-variable">.valid</span>) <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">end</span><br>   <br>   <span class="hljs-meta">`uvm_info(&quot;my_monitor&quot;, &quot;begin to collect one pkt&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">while</span>(vif<span class="hljs-variable">.valid</span>) <span class="hljs-keyword">begin</span><br>      data_q<span class="hljs-variable">.push_back</span>(vif<span class="hljs-variable">.data</span>);<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">end</span><br>   data_size  = data_q<span class="hljs-variable">.size</span>();   <br>   data_array = <span class="hljs-keyword">new</span>[data_size];<br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data_size; i++ ) <span class="hljs-keyword">begin</span><br>      data_array[i] = data_q[i]; <br>   <span class="hljs-keyword">end</span><br>    tr<span class="hljs-variable">.pload</span> = <span class="hljs-keyword">new</span>[data_size - <span class="hljs-number">18</span>]; <span class="hljs-comment">//da sa, e_type, crc</span><br>    data_size = tr<span class="hljs-variable">.unpack_bytes</span>(data_array) / <span class="hljs-number">8</span>; <span class="hljs-comment">//直接调用unpack_bytes方法，把data_q中的bytes流解包为tr各个字段，简化了！</span><br>   <span class="hljs-meta">`uvm_info(&quot;my_monitor&quot;, &quot;end collect one pkt&quot;, UVM_LOW);</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>unpack流程，括号内表示解释：</p>
<ul>
<li>定义一个接收data_q的动态数组，用作<code>unpack_bytes</code>函数参数（<code>unpack_bytes</code>函数的输入参数必须是一个动态数组，所以需要先把收集到的、放在data_q中的数据复制到一个动态数组中，这里使用到的是data_array）</li>
<li>由于tr在定义字段的时候使用到了一个动态数组字段，这里的需要指定大小后才能接收到tr的字段里，<em>讲道理我感觉可以在main_phase就指定了</em>（由于在tr中的pload是一个动态数组，所以需要在调用<code>unpack_bytes</code>之前指定其大小，这样unpack_bytes函数才能正常工作）</li>
<li>调用<code>unpack_bytes</code></li>
</ul>
<p><strong>打包成的数据流顺序：</strong></p>
<p>在把所有的字段变成byte流放入data_q中时，字段按照uvm_field系列宏书写的顺序排列</p>
<p>在上述代码中是先放入dmac，再依次放入smac、ether_type、pload、crc</p>
</blockquote>
<h3><span id="24-uvm的终极大作sequence机制">2.4 UVM的终极大作：<mark>sequence机制</mark></span></h3><h4><span id="241-在验证平台中加入sequencer">2.4.1 在验证平台中加入sequencer</span></h4><p>功能：<mark>sequence机制</mark>用于产生激励</p>
<p>区别：<strong>前面的例子中激励都是在driver中产生的，但是在一个规范化的UVM验证平台中，driver只负责驱动transaction，不负责生产transaction</strong></p>
<p>sequence机制两大组成部分：</p>
<ul>
<li>sequence</li>
<li>sequencer</li>
</ul>
<hr>
<p><strong>1.定义一个sequencer</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer <span class="hljs-variable">#(my_transaction)</span>;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_sequencer)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>流程：</p>
<ul>
<li><code>uvm_sequencer</code>是一个参数化的类，参数为自定义的transaction</li>
<li>派生自<code>uvm_sequencer</code></li>
<li>使用<code>`uvm_component_utils</code>进行注册</li>
</ul>
<p>与其他组件的关系：</p>
<ul>
<li>sequencer产生transaction</li>
<li>driver接收transaction</li>
</ul>
</blockquote>
<p><strong>2.有关派生自参数化的类</strong></p>
<blockquote>
<p>my_driver定义修正</p>
<p>之前定义的my_driver时都是直接从<code>uvm_driver</code>派生的，即<code>class my_driver extends uvm_driver;</code>，这是种<strong>不常见</strong>的写法</p>
<p>因为<code>uvm_driver</code>也是一个参数化的类，应该在定义时指明driver要驱动的transaction类型，这么写是<strong>正确</strong>的<code>class my_driver extends uvm_driver#(my_transaction);</code></p>
<p>使用参数的好处</p>
<p>可以直接使用<code>uvm_driver</code>中的某些预先定义好的成员变量</p>
<p>如<code>uvm_driver</code>中有成员变量req，它的类型就是传递给uvm_driver的参数，在这里就是my_transaction，可以直接使用req</p>
</blockquote>
<p>参数定义后的my_driver中，带来的好处（req直接使用），注：这里依然是在driver中产生激励，下一节从driver中移除</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) <span class="hljs-keyword">begin</span> <br>      req = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;req&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;pload<span class="hljs-variable">.size</span> == <span class="hljs-number">200</span>;&#125;);<br>       drive_one_pkt(req);<span class="hljs-comment">//直接使用</span><br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.把sequencer放入到agent中</strong></p>
<p>在完成sequencer的定义后，由于sequencer与driver的关系非常密切，因此要把其加入agent中</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_agent <span class="hljs-keyword">extends</span> uvm_agent ;<br>   my_sequencer  sqr;<br>   my_driver     drv;<br>   my_monitor    mon;<br>   <br>   uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span>  ap;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br><br>   <span class="hljs-meta">`uvm_component_utils(my_agent)</span><br><span class="hljs-keyword">endclass</span> <br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   <span class="hljs-keyword">if</span> (is_active == UVM_ACTIVE) <span class="hljs-keyword">begin</span><br>       sqr = my_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//创建sequencer</span><br>      drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">end</span><br>   mon = my_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   ap = mon<span class="hljs-variable">.ap</span>;<br><span class="hljs-keyword">endfunction</span><br><br></code></pre></div></td></tr></table></figure>
<p><strong>4.加入sequencer后的UVM树结构图</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221121200506347.png" srcset="/img/loading.gif" lazyload alt="image-20221121200506347"></p>
<h4><span id="242-sequence机制">2.4.2 sequence机制</span></h4><p><mark>sequence不属于验证平台的任何一部分</mark>，但是它与sequencer之间有密切的联系</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221121200630176.png" srcset="/img/loading.gif" lazyload alt="带sequnce的UVM验证平台"></p>
<blockquote>
<p>sequencer与sequence的关系</p>
<ul>
<li>只有在 sequencer的帮助下，sequence产生出的transaction才能最终送给driver</li>
<li>sequencer只有在sequence出现的情况下才能体现其价值</li>
</ul>
<p>一个奇怪的比喻</p>
<ul>
<li>sequence就像是一个弹夹，里面的子弹是transaction</li>
<li>而sequencer是一把枪</li>
<li>弹夹只有放入枪中才有意义，枪只有在放入弹夹后才能发挥威力</li>
</ul>
<p>sequencer与sequence的不同</p>
<ul>
<li>sequencer是一个<code>uvm_component</code></li>
<li>sequence是一个<code>uvm_object</code>，与transaction一样具有生命周期，比my_transaction生命周期要长一些，其内的transaction全部 发送完毕后，它的生命周期也就结束了</li>
<li>sequence使用<code>`uvm_object_utils</code>宏注册到factory中</li>
</ul>
</blockquote>
<p><strong>1.一个sequence的定义</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;my_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">1000</span>;<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(my_sequence)</span><br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>定义流程：</p>
<ul>
<li>派生自<code>uvm_sequence</code>，参数为transaction类型</li>
<li>定义<code>body</code>，每一个sequence都有一个<code>body</code>任务，当一个sequence启动之后，会自动执行body中的代码</li>
</ul>
<p><code>`uvm_do</code></p>
<p><strong>这是UVM中最常用的宏之一</strong>，作用：</p>
<ul>
<li>将一个my_transaction的变量m_trans实例化</li>
<li>将m_trans随机化</li>
<li>将m_trans<strong>送给</strong>sequencer</li>
</ul>
<p>如果不用<code>`uvm_do</code>宏，也可以直接使用<code>start_item</code>与<code>finish_item</code>的方式产生transaction</p>
<p>什么时候返回：等待driver的<code>item_done</code></p>
</blockquote>
<p><strong>2.sequence与sequencer的交互</strong></p>
<p>交互：</p>
<ul>
<li>一个sequence在向sequencer发送transaction前，要先向sequencer发送一个请求</li>
<li>sequencer把这个请求放在一个仲裁队列中</li>
</ul>
<p>sequencer的具体工作：</p>
<ol>
<li>检测仲裁队列里是否有某个sequence发送transaction的请求</li>
<li>检测driver是否申请transaction</li>
</ol>
<p>sequencer检测细节：</p>
<ol>
<li>如果仲裁队列里有发送请求，但是driver没有申请trans：一直等待driver</li>
<li>如果仲裁队列中没有发送请求，但是driver向sequencer申请新的trans：sqr进入等待seq状态</li>
<li>如果仲裁队列中有发送请求，同时driver也在向sequencer申请新的trans：直接同意并移交</li>
</ol>
<p><strong>3.driver如何向sequencer申请transaction</strong></p>
<ol>
<li>在agent的<code>connect</code>函数中，把drv中的变量seq_item_port与sqr中的seq_itemu_export连接，代码如下：</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   <span class="hljs-keyword">if</span> (is_active == UVM_ACTIVE) <span class="hljs-keyword">begin</span><br>      drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);<br>   <span class="hljs-keyword">end</span><br>   ap = mon<span class="hljs-variable">.ap</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li>连接好之后，就可以在driver中通过<code>get_next_item</code>或<code>try_next_item</code>任务向sequencer申请新的trans，代码如下：</li>
</ol>
<p>使用<code>get_next_item</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<span class="hljs-comment">//向sequencer申请新的transaction</span><br>      drive_one_pkt(req);<br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>使用<code>try_next_item</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.try_next_item</span>(req);<span class="hljs-comment">//向sequencer申请新的transaction</span><br>      <span class="hljs-keyword">if</span>(req == <span class="hljs-literal">null</span>)<br>       	@(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>)<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        drive_one_pkt(req);<br>        seq_item_port<span class="hljs-variable">.item_done</span>();<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>my_driver代码解析：</p>
<ul>
<li>使用while(1)，因为需要不断驱动</li>
<li>通过<code>get_next_item</code>任务得到一个trans，或者<code>try_next_item</code></li>
<li>通过<code>item_done</code>任务告知sequencer</li>
</ul>
<p>为什么会有一个<code>item_done</code>？</p>
<ul>
<li>一种握手机制</li>
<li>可以用来返回response（6.7.1）</li>
<li>sqr内部保存的同一trans会不断发送，直到调用了<code>item_done</code></li>
</ul>
<p>相比于<code>get_next_item</code>，<code>try_next_item</code>的行为更加接近真实driver的行为：当有数据时，就驱动数据，否则总线将一直处于空闲状 态</p>
</blockquote>
<p><strong>4.启动seq（在哪里实例化seq）</strong></p>
<p>启动可以在不同组件的<code>main_phase</code>中（sqr/env)，但在实际应用中， 使用最多的还是通过<code>default_sequence</code>的方式启动sequence见2.4.3节</p>
<p>在my_env中启动：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_env::main_phase(uvm_phase phase);<br>   my_sequence seq;<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   seq = my_sequence::type_id::create(<span class="hljs-string">&quot;seq&quot;</span>);<br>   seq<span class="hljs-variable">.start</span>(i_agt<span class="hljs-variable">.sqr</span>); <br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>在my_sqr中启动</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_sequencer::main_phase(uvm_phase phase);<br>   my_sequence seq;<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   seq = my_sequence::type_id::create(<span class="hljs-string">&quot;seq&quot;</span>);<br>   seq<span class="hljs-variable">.start</span>(<span class="hljs-keyword">this</span>); <br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>流程：</p>
<ul>
<li>声明一个seq变量</li>
<li>seq工厂机制实例化</li>
<li>调用seq的<code>start</code>方法，入参为sqr指针（如果不指明则不知道匹配的sqr是谁）</li>
</ul>
<p><mark>objection机制与结束仿真</mark></p>
<p>在UVM中，objection一般伴随着sequence，通常只在sequence出现的地方才提起和撤销 objection。如前面所说，sequence是弹夹，当弹夹里面的子弹用光之后，可以结束仿真了</p>
<p>sqr与env中启动的不同：唯一区别是seq.start的参数变为了this</p>
</blockquote>
<h4><span id="243-default_sequence的使用">2.4.3 default_sequence的使用</span></h4><p>sequence是在my_env的<code>main_phase</code>中手工启动的，作为示例使用这种方式足够了，<strong>但在实际应用中， 使用最多的是通过<code>default_sequence</code>的方式启动sequence</strong></p>
<hr>
<p><strong>1.如何在default_sequence中启动seq</strong></p>
<p>使用default_sequence的方式非常简单，只需要在某个component（如my_env）的<code>build_phase</code>中进行一行设置</p>
<p>在my_env中启动default_sequence的代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// my_env.sv</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>	  ...<br>      uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<br>                                              <span class="hljs-string">&quot;i_agt.sqr.main_phase&quot;</span>,<br>                                              <span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                              my_sequence::type_id::get());<span class="hljs-comment">//defualt_sequence!</span><br><br><span class="hljs-keyword">endfunction</span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>config_db</code>的使用：这是除了在top_tb中通过<code>config_db</code>设置virtual interface后再一次用到<code>config_db</code></p>
<p><strong>参数一：</strong></p>
<ul>
<li>与在top_tb中不同的是，这里set函数的第 一个参数由null变成了this，而第二个代表路径的参数则去除了<code>uvm_test_top</code></li>
<li>事实上，第二个参数是相对于第一个参数的相对路径，由于上述代码是在my_env中，而my_env本身已经是uvm_test_top了，且第一个参数被设置为了this，所以第二个参数中就不需要uvm_test_top</li>
<li>在top_tb中设置virtual interface时，由于top_tb不是一个类，无法使用this指针，所以设置set的第一个参数为null，第二个参数使用绝对路径uvm_test_top.xxx</li>
</ul>
<p><strong>参数二：</strong>在第二个路径参数中，出现了<code>main_phase</code>。这是UVM在设置default_sequence时的要求。由于除了<code>main_phase</code>外，还存在其他任务phase，如<code>configure_phase</code>、<code>reset_phase</code>等，<strong>所以必须指定是哪个phase</strong>，从而使sequencer知道在哪个phase启动这个sequence</p>
<p><strong>参数三、参数四、参数类型：</strong>至于set的第三个和第四个参数，以及<code>uvm_config_db#(uvm_object_wrapper)</code>中为什么是<code>uvm_object_wrapper</code>而不是 <code>uvm_sequence</code>或者其他，则纯粹是由于UVM的规定，用户在使用时照做即可</p>
<blockquote>
<p>为什么这里只用设置一次<code>config_db</code></p>
<p>config_db通常都是成对出现的，如：在top_tb中通过set设置virtual interface，而在driver或者monitor中通过get函数得到virtual interface</p>
<p>那么在这里是否需要在sequencer中手工写一些get相关的代码呢？答案是否定的。UVM已经做好了这些，读者无需再把时间花在这上面</p>
</blockquote>
</blockquote>
<p>也可以在top_tb中启动default_sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br>    ...<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        uvm_config_db# （uvm_object_wrapper)::set(<span class="hljs-literal">null</span>,<br>                                                <span class="hljs-string">&quot;uvm_test_top.i_agt.sqr.main_phase&quot;</span>,<br>                                                <span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                                 my_sequence::type_id::get());<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>形参设置：</p>
<p>第一个参数和第二个参数应该改变一下</p>
</blockquote>
<p>也可以在其他的组件内，如my_agent的<code>build_phase</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    ...<br>    uvm_config_db# (uvm_object_wrapper)::set(<span class="hljs-keyword">this</span>,<br>                                            <span class="hljs-string">&quot;sqr.main_phase&quot;</span>,<br>                                            <span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                             my_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>形参设置：</p>
<p>只需要正确地设置set的第二个参数即可（相对于my_env的）</p>
</blockquote>
<p><strong>3.default_sequence如何提起和撤销objection</strong></p>
<p>在上一节<u>手动启动sequence<strong>前后</strong>，分别提起和撤销objection</u>，此时使用default_sequence自动启动，又如何提起和撤销objection呢？</p>
<p><strong>方法：</strong>使用继承自uvm_sequence中的变量<code>starting_phase</code>，在sequence中使用<code>starting_phase</code>进行提起和撤销objection</p>
<p><strong>sequence定义代码如下：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;my_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">1000</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(my_sequence)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>sequencer在启动default_sequence时会自动做如下相关操作：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_sequencer::main_phase(uvm_phase phase);<br>…<br>  seq<span class="hljs-variable">.starting_phase</span> = phase;<br>  seq<span class="hljs-variable">.start</span>(<span class="hljs-keyword">this</span>);<br>…<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><mark>UVM1.2貌似优化了starting_phase功能，使用方式有所改变</mark></p>
<h3><span id="25-建造测试用例">2.5 建造测试用例</span></h3><h4><span id="251-加入base_test">2.5.1 加入<code>base_test</code></span></h4><p><strong>1.前情提要</strong></p>
<p>UVM使用的是一种树形结构，在本书的例子中：</p>
<ul>
<li>最初这棵树的树根是<code>my_driver</code></li>
<li>由于要放置其他component，树根变成 了<code>my_env</code></li>
<li>但是在一个实际应用的UVM验证平台中，my_env并不是树根，通常来说，树根是一个基于<code>uvm_test</code>派生的类</li>
</ul>
<p>本节先讲述<code>base_test</code>，真正的测试用例都是基于<code>base_test</code>派生的一个类</p>
<hr>
<p><strong>1.定义base_test</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;base_test&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_component_utils(base_test)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env  =  my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>); <br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>,<br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                            my_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::report_phase(uvm_phase phase);<br>   uvm_report_server server;<br>   <span class="hljs-keyword">int</span> err_num;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.report_phase</span>(phase);<br><br>   server = get_report_server();<br>   err_num = server<span class="hljs-variable">.get_severity_count</span>(UVM_ERROR);<br><br>   <span class="hljs-keyword">if</span> (err_num != <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST CASE FAILED&quot;</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST CASE PASSED&quot;</span>);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>定义流程：</p>
<ul>
<li>派生自<code>uvm_test</code>    </li>
<li>使用<code>`uvm_component_utils</code>宏注册到工厂中</li>
<li>在<code>build_phase</code>中实例化my_env</li>
<li>在<code>build_phase</code>中设置<code>default_sequence</code>，<strong>以后都在这里设置default_sequence</strong></li>
</ul>
<p>base_test一般做什么</p>
<ul>
<li>base_test中做的事情在根据不同的验证平台及不同的公司而不同，没有统一的答案</li>
<li>此例用到了<mark>report_phase</mark>，用于根据<code>UVM_ERROR</code>数量打印不同信息，除此之外一些工具可以根据打印信息判断DUT是否通过了某个测试用例的检查</li>
<li>设置整个验证平台的超时退出时间</li>
<li>通过config_db设置验 证平台中某些参数的值</li>
</ul>
<p><mark>report_phase</mark></p>
<p>report_phase也是UVM内建的一个phase，它在main_phase结束之后执行</p>
</blockquote>
<p><strong>2.加入base_test后的UVM树</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122191951186.png" srcset="/img/loading.gif" lazyload alt="image-20221122191951186"></p>
<p><strong>3.top_tb模块修改run_test的env为base_test</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_tb;<br><br>...<br>    <br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   run_test(<span class="hljs-string">&quot;base_test&quot;</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;vif&quot;, input_if)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.mon&quot;, &quot;vif&quot;, input_if)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.o_agt.mon&quot;, &quot;vif&quot;, output_if)</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="252-uvm中测试用例的启动">2.5.2 UVM中测试用例的启动</span></h4><p>测试用例=测试向量=<strong>pattern</strong></p>
<p><strong>1.如何启动两个（多个也行）不同的测试用例</strong></p>
<p>不同测试用例需要修改default_sequence，从而需要多个base_test</p>
<p><strong>方法1：修改run_test参数</strong></p>
<ul>
<li>启动my_case0，需要在top_tb中更改run_test的参数：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>    run_test(<span class="hljs-string">&quot;my_case0&quot;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>启动my_case1，需要在top_tb中更改run_test的参数：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>    run_test(<span class="hljs-string">&quot;my_case1&quot;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>需要不断编译！</p>
<p>当my_case0运行的时候需要修改代码，重新编译后才能运行；当my_case1运行时也需如此，这相当不方便</p>
</blockquote>
<p><strong>方法2：使用命令行</strong></p>
<p><strong>UVM提供对不加参数的run_test的支持</strong></p>
<ul>
<li>直接run_test</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>    run_test();<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在这种情况下，UVM会利用<code>UVM_TEST_NAME</code>从命令行中寻找测试用例的名字，创建它的实例并运行</p>
</blockquote>
<ul>
<li>命令行运行时需要添加参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...+UVM_TEST_NAME=my_case0<br>//或者<br>...+UVM_TEST_NAME=my_case1<br></code></pre></div></td></tr></table></figure>
<p><strong>2.测试用例流程启动与验证平台执行流程总结</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122194654543.png" srcset="/img/loading.gif" lazyload alt="image-20221122194654543"></p>
<p>启动后UVM树的结构如图</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122194711463.png" srcset="/img/loading.gif" lazyload alt="启动后UVM树的结构如图"></p>
<blockquote>
<p>UVM树与上一节的不同：</p>
<p>把base_test替换为my_casen（说明有好几个测试用例）</p>
</blockquote>
<p><strong>3.测试用例定义细节</strong></p>
<p>my_case0与case0_sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(case0_sequence)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">class</span> my_case0 <span class="hljs-keyword">extends</span> base_test;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_case0&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase); <br>   <span class="hljs-meta">`uvm_component_utils(my_case0)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<span class="hljs-comment">//default_sequencer</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>my_case1与case1_sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case1_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case1_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123; m_trans.pload.size() == 60;&#125;)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(case1_sequence)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> my_case1 <span class="hljs-keyword">extends</span> base_test;<br>  <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_case1&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase); <br>   <span class="hljs-meta">`uvm_component_utils(my_case1)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case1::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case1_sequence::type_id::get());<span class="hljs-comment">//default_sequencer</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>`uvm_do_with</code>宏</p>
<p>是<code>`uvm_do</code>系列宏中的一个，用于在随机化时提供对某些字段的<strong>约束</strong></p>
</blockquote>
<p>2022-11-22</p>
<h2><span id="第三章uvm基础">第三章UVM基础</span></h2><h3><span id="31-uvm_object与uvm_component">3.1 uvm_object与uvm_component</span></h3><h4><span id="311-uvm_component派生自uvm_object">3.1.1 uvm_component派生自uvm_object</span></h4><ul>
<li>要点一：<code>uvm_object</code>是UVM中最基本的类，几乎<strong>所有类</strong>都继承自<code>uvm_object</code></li>
<li>要点二：<code>uvm_component</code>派生自<code>uvm_object</code></li>
<li>要点三：<code>uvm_object</code>派生出两个分支</li>
<li>要点四：UVM树的所有结点都是<code>uvm_component</code>（下图左分支不可能出现在UVM树上）</li>
</ul>
<p><code>uvm_component</code>独立于<code>uvm_object</code>的两条特性：</p>
<ul>
<li>能在new的时候指定parent参数来形成一种树形的组织结构</li>
<li>能phase的自动执行</li>
</ul>
<p><strong>UVM中常用类的继承关系</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122195318124.png" srcset="/img/loading.gif" lazyload alt="image-20221122195318124"></p>
<h4><span id="312-常用的uvm_object派生类">3.1.2  常用的uvm_object派生类</span></h4><ul>
<li><code>uvm_sequence_item</code>：用于派生transaction，transaction就是封装了一定信息的一个类</li>
<li><code>uvm_transaction</code>：UVM中不能从<code>uvm_transaction</code>派生一个transaction，而要从<code>uvm_sequence_item</code>派生</li>
<li><code>uvm_sequence</code>：用于派生所有的sequence，sequence直接与sequencer打交道</li>
<li><p><code>config</code>：用于规范验证平台的行为方式，</p>
<ul>
<li>如规定driver在读取总线时 地址信号要持续几个时钟，片选信号从什么时候开始有效等</li>
<li>这里要注意<u>config与config_db的区别</u>。在上一章中已经见识了使用 config_db进行参数配置，这里的config其实指的是把所有的参数放在一个object中，如10.5节所示。然后通过config_db的方式设置给所有需要这些参数的component</li>
</ul>
</li>
<li><p><code>uvm_reg_item</code>、<code>uvm_reg_map</code>、<code>uvm_mem</code>、<code>uvm_reg_field</code>、<code>uvm_reg</code>、<code>uvm_reg_file</code>、<code>uvm_reg_block</code>等与寄存器相关的众多的类，用于register model</p>
</li>
<li><code>uvm_phase</code>：用为控制uvm_component的行为方式，使得uvm_component平滑地在各个不同的 phase之间依次运转</li>
<li>其他还有很多并不那么重要，这里不再一一列出</li>
</ul>
<h4><span id="313-常用的uvm_component派生类">3.1.3 常用的uvm_component派生类</span></h4><p><strong>合集：</strong></p>
<p>继承关系：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221122195318124-167920883830623.png" srcset="/img/loading.gif" lazyload alt="image-20221122195318124"></p>
<p>路径图：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221124215734579.png" srcset="/img/loading.gif" lazyload alt="image-20221124215734579"></p>
<p>3.4总结图</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123223740902.png" srcset="/img/loading.gif" lazyload alt="image-20221123223740902"></p>
<blockquote>
<p><code>uvm_driver</code>：派生driver</p>
<ul>
<li><code>driver</code>的功能主要就是向<code>sequencer</code>索要<code>sequence_item（</code>transaction），并将 <code>sequence_item</code>里的信息驱动到DUT的端口上</li>
<li>driver完成了从transaction级别到DUT能够接受的端口级别信息的转换</li>
<li>与<code>uvm_component</code>相比多的成员变量：<ul>
<li><code>uvm_seq_item_pull_port #(REQ, RSP) seq_item_port;</code></li>
<li><code>uvm_seq_item_pull_port #(REQ, RSP) seq_item_prod_if; // alias</code></li>
<li><code>uvm_analysis_port #(RSP) rsp_port;</code></li>
<li><code>REQ req;</code></li>
<li><code>RSP rsp;</code></li>
</ul>
</li>
<li>在函数/任务上，与<code>uvm_component</code>相比没有做过多的扩展</li>
</ul>
<p><code>uvm_monitor</code>：派生monitor</p>
<ul>
<li><p>monitor从DUT的pin上接收数据，并把接收到的数据转换成<code>transaction</code>级的<code>sequence_item</code>，再把转换后的数据发送给<code>scoreboard</code>，供其比较</p>
</li>
<li><p>与driver相反</p>
</li>
<li>与<code>uvm_component</code>相比，<code>uvm_monitor</code>几乎没有做任何扩充</li>
<li>几乎没有做任何扩展<ul>
<li>理论上来说所有的monitor要从<code>uvm_monitor</code>派生，但是实际上如果从<code>uvm_component</code>派生，也没有任何问题</li>
</ul>
</li>
</ul>
<p><code>uvm_sequencer</code>：派生sequencer</p>
<ul>
<li>sequencer的功能就是组织管理<code>sequence</code>，当<code>driver</code>要求数据时， 它就把<code>sequence</code>生成的<code>sequence_item</code>转发给<code>driver</code></li>
<li>与<code>uvm_component</code>相比，<code>uvm_sequencer</code>做了相当多的扩展，在第六章介绍</li>
</ul>
<p><code>uvm_scoreboard</code>：派生scoreboard</p>
<ul>
<li>scoreboard的功能就是比较<code>reference model</code>和<code>monitor</code>分别发送来的数据，根据比较结果判断DUT是否正确工作</li>
<li>与<code>uvm_component</code>相比，<code>uvm_scoreboard</code>几乎没有做任何扩充</li>
<li>几乎没有做任何扩展<ul>
<li>理论上来说所有的monitor要从<code>uvm_scoreboard</code>派生，但是实际上如果从<code>uvm_component</code>派生，也没有任何问题</li>
</ul>
</li>
</ul>
<p>reference model：</p>
<ul>
<li><p>UVM中并没有针对reference model定义一个类，reference model都是直接派生自<code>uvm_component</code></p>
</li>
<li><p>reference model的作用就是模仿DUT</p>
</li>
</ul>
<p><code>uvm_agent</code>：派生agent</p>
<ul>
<li>只是把driver和monitor封装在一起，根据参数值来决定是只实例化monitor还是要同时实例化driver和monitor</li>
<li>主要作用是<u>重构性</u></li>
<li>与<code>uvm_component</code>相比，<code>uvm_agent</code>的最大改动在引入了一个变量<code>is_active</code></li>
</ul>
<p><code>uvm_env</code>：派生env</p>
<ul>
<li>env将验证平台上用到的固定不变的component都封装在一 起</li>
<li><code>uvm_env</code>几乎没有做任何扩展</li>
<li>加入寄存器模型，包括reg model与adapt，并进行相应连接，在<code>uvm_test</code>中添加寄存器模型更常用</li>
</ul>
<p><code>uvm_test</code>：所有的测试用例要派生自<code>uvm_test</code>或其派生类，不同的测试用例之间差异很大，所以从<code>uvm_test</code>派生出来的类各不相同</p>
<ul>
<li>任何一个派生出的测试用例中，都要实例化<code>env</code>，只有这样，当测试用例在运行的时候，才能把数据正常地发给DUT，并正常接收DUT数据</li>
<li>uvm_test_top是一个<code>run_test(&quot;注册的类名&quot;)</code>生成的注册类名的实例，实例名固定为<code>uvm_test_top</code></li>
<li><code>uvm_test</code>几乎没有做任何扩展</li>
<li>用法<ul>
<li>例化env</li>
<li>控制打印信息</li>
<li>控制objection（5.1.7）</li>
<li>启动seq（2.5.2）</li>
<li>通过config_db设置seq（6.6）</li>
<li>加入寄存器模型，包括reg model与adapt，并进行相应连接（7.2.2）<ul>
<li>reg_predictor</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>base_test：</p>
<ul>
<li>print_topology(8.2.4 factory机制的调试)</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">uvm_root</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>uvm_top</code>是一个全局变量，它是<code>uvm_root</code>的一个实例（而且也是唯一的一个实例，设计模式中鼎鼎）</li>
<li>UVM中<mark>所有parent为null的component的父节点</mark></li>
<li><code>uvm_top</code>的名字是<code>__top__</code>，但是在显示路径的时候，并不会显示出这 个名字，而只显示从<code>uvm_test_top</code>开始的路径</li>
<li>UVM默认生成，你不用管</li>
<li>作用：为了确保整个验证平台中只有一棵树，所有节点都是uvm_top子节点</li>
</ul>
<p><code>testbench</code>模块</p>
<ul>
<li><code>import uvm_pkg::*;</code>和<code>`include &quot;uvm_macros.svh&quot;</code>和<code>`include “自定义的各种uvm组件.sv”</code></li>
<li>运行<code>run_test();</code>，有关<code>run_test();</code>的内容参考2.5.2</li>
<li>产生其他信号（clk，rstn）</li>
<li>用于例化DUT，virtual interface</li>
<li>将DUT与virtual interface直接连接</li>
<li>通过<code>config_db</code>将virtual interface与<code>uvm_test_top.env?</code>中各个组件进行连接</li>
</ul>
</blockquote>
<p><strong>其他扩展：</strong></p>
<blockquote>
<p>在哪控制objection？</p>
<ul>
<li>scoreboard或sequence中启动，详见5.2.3</li>
<li>存在virtual sequence在最顶层virtual sequence中启动，详见6.5.4</li>
</ul>
<p><strong>全局变量</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">factory</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>来源：8.2.2</li>
<li>作用：用于uvm_component外调用重载函数</li>
</ul>
</blockquote>
<h4><span id="314-uvm_object相关宏">3.1.4 uvm_object相关宏</span></h4><p><code>uvm_object</code>相关的<mark>factory宏</mark>有如下几个：</p>
<ul>
<li><code>`uvm_object_utils</code>：注册object到factory中</li>
<li><code>`uvm_object_param_utils</code>：注册参数化的object到factory中</li>
<li><code>`uvm_object_utils_begin</code>：对成员变量使用<mark>field_automation机制</mark></li>
<li><code>`uvm_object_param_utils_begin</code>：参数化的对成员变量使用<mark>field_automation机制</mark></li>
<li><code>`uvm_object_utils_end</code>：结束注册，与<code>uvm_object_*_begin</code>成对出现</li>
</ul>
<h4><span id="315-uvm_component相关宏">3.1.5 uvm_component相关宏</span></h4><p><code>uvm_component</code>相关的<mark>factory宏</mark>有如下几个：</p>
<ul>
<li><code>`uvm_component_utils</code>：注册component到factory中</li>
<li><code>`uvm_component_param_utils</code>：注册参数化的component到factory中</li>
<li><code>`uvm_component_utils_begin</code>：对成员变量使用<mark>field_automation机制</mark></li>
<li><code>`uvm_component_param_utils_begin</code>：参数化的对成员变量使用<mark>field_automation机制</mark></li>
<li><code>`uvm_object_utils_end</code>：结束注册，与<code>uvm_object_*_begin</code>成对出现</li>
</ul>
<blockquote>
<p>在类似于my_transaction这种类中使用field_automation机制可以让人理解，可是在component中使用field_automation机制有必要吗？</p>
<ul>
<li><code>uvm_component</code>派生自<code>uvm_object</code>，可以直接使用object的compare、print等方法</li>
<li>可以自动地使用<mark>config_db</mark>来得到某些变量的值。具体的可以参考3.5.3节的介绍</li>
</ul>
</blockquote>
<h4><span id="316-copy与clonecomp的一些限制">3.1.6 copy与clone，comp的一些限制</span></h4><p>由于<code>uvm_component</code>是作为UVM树的<strong>结点</strong>存在的，使它失去了<code>uvm_object</code>的某些特征</p>
<p><strong>1.无法使用clone方法</strong></p>
<p><code>uvm_object</code>的<code>clone</code>方法使用方式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_object;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>        A a1;<br>        A a2;<br>        a1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;a1&quot;</span>);<br>        a1<span class="hljs-variable">.data</span> = <span class="hljs-number">8&#x27;h9</span>;<br>        <span class="hljs-built_in">$cast</span>(a2, a1<span class="hljs-variable">.clone</span>());<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>上述<code>clone</code>函数无法用于<code>uvm_component</code>中，因为一旦使用后，新<code>clone</code>出来的类，其parent参数无法指定</p>
</blockquote>
<p><strong>2.可以使用copy方法</strong></p>
<p><code>clone=new+copy</code>：</p>
<ul>
<li>在使用copy前，目标实例必须已经使用new函数分配好了内存空间</li>
<li>使用clone函数时，目标实例可以只是一个空指针</li>
</ul>
<p><code>uvm_component</code>无法使用clone函数，但是可以使用copy函数。<strong>因为在调用copy之前，目标实例已经完成了实例化，其 parent参数已经指定了</strong></p>
<p><strong>3.禁止子节点同名</strong></p>
<p>位于同一个父结点下的不同的<code>component</code>，在实例化时不能使用相同的名字</p>
<p>如下的方式中都使用名字a1是会<strong>出错</strong>的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>        A a1;<br>        A a2;<br>        a1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-keyword">this</span>);<br>        a2 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="317-uvm_component与uvm_object的二元结构">3.1.7 uvm_component与uvm_object的二元结构</span></h4><p>这本书在讲尬的…</p>
<h3><span id="32-uvm的树形结构">3.2 UVM的树形结构</span></h3><h4><span id="321-uvm_component中的parent参数">3.2.1 uvm_component中的parent参数</span></h4><p><code>uvm_component</code>在new的时候，需要指定一个类型为<code>uvm_component</code>的变量parent</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br></code></pre></div></td></tr></table></figure>
<p>一般使用时，parent通常是this</p>
<blockquote>
<p>为什么要有parent这个参数？直接<code>new(string name)</code>不好吗</p>
<ul>
<li>书中写了一堆废话。。</li>
<li>最主要是要解决如何找到所有UVM节点的问题，加入了parent句柄，在new之后分别在对象与嵌套对象中维护一个m_children数组，从而能够知道一共几个</li>
<li>我的补充：讲道理，这应该是语言的基本特性。。。讲的这么复杂多少有点。。。</li>
</ul>
</blockquote>
<h4><span id="322-uvm树真正的根uvm_top">3.2.2 UVM树真正的根：<code>uvm_top</code></span></h4><p>UVM中真正的树根是一个称为<code>uvm_top</code>的东西，完整的UVM树如下：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123202541061.png" srcset="/img/loading.gif" lazyload alt="image-20221123202541061"></p>
<hr>
<p><code>uvm_top</code>哪来的？</p>
<ul>
<li><code>uvm_top</code>是一个全局变量，它是<code>uvm_root</code>的一个实例（而且也是唯一的一个实例，设计模式中鼎鼎）</li>
<li>UVM中<mark>所有parent为null的component的父节点</mark></li>
<li>UVM默认生成，你不用管</li>
<li>作用：为了确保整个验证平台中只有一棵树，所有节点都是uvm_top子节点</li>
</ul>
<p>总结一下：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221123223740902.png" srcset="/img/loading.gif" lazyload alt="image-20221123223740902"></p>
<blockquote>
<p>补充：</p>
<blockquote>
<p>UVM顶层：uvm_test_top是一个自动生成的<code>uvm_root</code>的实例，所有<code>parent</code>为null的组件的父节点（即上级），实例名为<code>uvm_top</code></p>
<p>测试用例：uvm_test_top是一个<code>run_test(&quot;注册的类名&quot;)</code>生成的注册类名的实例，实例名固定为<code>uvm_test_top</code></p>
<p>用法</p>
<ul>
<li>例化env</li>
<li>控制打印信息</li>
<li>控制objection（5.1.7）</li>
<li>启动seq（2.5.2）</li>
</ul>
</blockquote>
</blockquote>
<p>如何得到<code>uvm_top</code>句柄？</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_root top;<br>top=uvm_root::get();<br></code></pre></div></td></tr></table></figure>
<h4><span id="323-层次结构相关函数">3.2.3 层次结构相关函数</span></h4><ul>
<li><code>extern virtual function uvm_component get_parent();</code>函数，用于得到当前实例的parent</li>
<li><code>extern function uvm_component get_child(string name);</code>函数，用于得到child</li>
<li><code>extern function void get_children(ref uvm_component children[$]);</code>函数，用于得到所有child</li>
<li><code>extern function int get_first_child(ref string name);</code>：函数，得到第一个child的名字</li>
<li><code>extern function int get_next_child(ref string name);</code>：函数，得到下一个child的名字</li>
<li><code>extern function int get_num_children();</code>函数，返回当前component所拥有的child的数量</li>
</ul>
<p>遍历所有child的方法1（使用<code>get_children</code>）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_component array[$];<br>my_comp<span class="hljs-variable">.get_children</span>(array);<br><span class="hljs-keyword">foreach</span>(array[i])<br>    do_something(array[i]);<br></code></pre></div></td></tr></table></figure>
<p>遍历所有child的方法2（使用<code>get_child</code>、<code>get_first_child</code>、<code>get_next_child</code>）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">string</span> name;<br>uvm_component child;<br><span class="hljs-keyword">if</span> (comp<span class="hljs-variable">.get_first_child</span>(name))<br>    <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span><br>        child = comp<span class="hljs-variable">.get_child</span>(name);<br>        child<span class="hljs-variable">.print</span>();<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">while</span> (comp<span class="hljs-variable">.get_next_child</span>(name));<br></code></pre></div></td></tr></table></figure>
<h3><span id="33-field-automation机制">3.3 <mark>field automation机制</mark></span></h3><p>一般用于类的内部成员变量定义</p>
<h4><span id="331-field-automation机制相关宏">3.3.1 field automation机制相关宏</span></h4><p><code>uvm_field_*</code>系列宏：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//基本</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_int(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_real(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_enum(T,ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_object(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_event(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_string(ARG,FLAG)</span><br><span class="hljs-comment">//与动态数组有关</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_array_enum(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_array_int(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_array_object(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_array_string(ARG,FLAG)</span><br><span class="hljs-comment">//与静态数组有关</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_sarray_int(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_sarray_enum(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_sarray_object(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_sarray_string(ARG,FLAG)</span><br><span class="hljs-comment">//与队列有关</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_queue_enum(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_queue_int(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_queue_object(ARG,FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_queue_string(ARG,FLAG)</span><br><span class="hljs-comment">//与联合数组有关，共15种</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_string(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_string_string(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_object_string(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_int(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_int_unsigned(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_integer(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_integer_unsigned(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_byte(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_byte_unsigned(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_shortint(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_shortint_unsigned(ARG, FLAG) </span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_longint(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_int_longint_unsigned(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_string_int(ARG, FLAG)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_field_aa_object_int(ARG, FLAG)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>枚举类型示例（它有三个参数，所以单独拿出来说下）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;TB_TRUE, TB_FALSE&#125; tb_bool_e;<br>…<br>tb_bool_e tb_flag;<br>…<br><span class="hljs-meta">`uvm_field_enum(tb_bool_e, tb_flag, UVM_ALL_ON)</span><br></code></pre></div></td></tr></table></figure>
<p>基本和数组/队列的不同</p>
<ul>
<li>多了<code>*_real</code>和<code>*_event</code></li>
<li><code>*_enum</code>多了一个参数</li>
</ul>
<p>联合数组是SystemVerilog中定义的一种非常有用的数据类型，在验证平台中经常使用</p>
<p>在与联合数组有关的uvm_field系列宏中， 出现的第一个类型是存储数据类型，第二个类型是索引类型，如<code>uvm_field_aa_int_string</code>中的<code>_int_string</code>用于声明那些存储的数据是int，而其索引是string类型的联合数组</p>
</blockquote>
<h4><span id="332-field-automation机制常用功能">3.3.2 field automation机制常用功能</span></h4><p>field automation功能非常强大</p>
<ul>
<li><code>extern virtual function uvm_object clone();</code>完全复制实例，不用提前实例化，参考3.1.6</li>
<li><code>extern function void copy(uvm_object rhs);</code>复制实例，把A实例复制到B实例中，使用<code>B.copy(A)</code>。使用此函数前，B实例必须已经使用new函数分配了内存空间</li>
<li><code>extern function bit compare(uvm_object rhs, uvm_comparer comparer=null);</code>比较实例，比较A与B使用<code>A.compare(B)</code>，一致返回1，否则0</li>
<li><code>extern function int pack_bytes(ref byte unsigned bytestream[], input uvm_packer packer=null);</code>用于将所有字段打包为byte流，参考第二章</li>
<li><code>extern function int unpack_bytes(ref byte unsigned bytestream[], input uvm_packer packer=null);</code>用于把byte流恢复到某个类的实例中</li>
<li><code>extern function int pack(ref bit bitstream[], input uvm_packer packer=null);</code>与<code>pack_bytes</code>类似</li>
<li><code>extern function int unpack(ref bit bitstream[], input uvm_packer packer=null);</code>与unpack_bytes类似</li>
<li><code>extern function int pack_ints(ref int unsigned intstream[], input uvm_packer packer=null);</code>用于恢复一个int流</li>
<li><code>print</code>用于打印所有字段</li>
</ul>
<p>除此之外，field automation提供自动得到使用<code>config_db::set</code>设置的参数的功能，这点请参照3.5.3节</p>
<h4><span id="333-field-automation机制中的标志位flag">3.3.3 field automation机制中的标志位(flag)</span></h4><p>flag用于field automation定义变量的功能</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//A=ABSTRACT Y=PHYSICAL</span><br><span class="hljs-comment">//F=REFERENCE, S=SHALLOW, D=DEEP</span><br><span class="hljs-comment">//K=PACK, R=RECORD, P=PRINT, M=COMPARE, C=COPY</span><br><span class="hljs-comment">//--------------------------- AYFSD K R P M C</span><br><span class="hljs-keyword">parameter</span> UVM_ALL_ON = <span class="hljs-number">&#x27;b000000101010101</span>;<span class="hljs-comment">//17bit的数字</span><br><span class="hljs-keyword">parameter</span> UVM_COPY      = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br><span class="hljs-keyword">parameter</span> UVM_NOCOPY    = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">parameter</span> UVM_COMPARE   = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);<br><span class="hljs-keyword">parameter</span> UVM_NOCOMPARE = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br><span class="hljs-keyword">parameter</span> UVM_PRINT     = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br><span class="hljs-keyword">parameter</span> UVM_NOPRINT   = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br><span class="hljs-keyword">parameter</span> UVM_RECORD    = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br><span class="hljs-keyword">parameter</span> UVM_NORECORD  = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br><span class="hljs-keyword">parameter</span> UVM_PACK      = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>);<br><span class="hljs-keyword">parameter</span> UVM_NOPACK    = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">9</span>);<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>UVM_ALL_ON</code>的值是<code>&#39;b000000101010101</code>，表示打开该变量的<code>copy</code>、<code>compare</code>、<code>print</code>、<code>record</code>、<code>pack</code>功能</li>
<li><code>UVM_ALL_ON|UVM_NOPACK</code>的结果是<code>&#39;b000001101010101</code>，这样UVM在执行pack操作时，首先检查bit9，发现其为1，直接忽略bit8所代表的<code>UVM_PACK</code></li>
</ul>
<h4><span id="334-field-automation中宏与if的结合">3.3.4 field automation中宏与if的结合</span></h4><p>这本书中又讲了一个让人摸不着头脑的例子</p>
<p>简单来说，就是field_automation可以这么用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] smac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] vlan_info1;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]  vlan_info2;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       vlan_info3;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>] vlan_info4;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ether_type;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">byte</span>      pload[];<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       is_vlan;<span class="hljs-comment">//</span><br>  ...<br><br>   <span class="hljs-meta">`uvm_object_utils_begin(my_transaction)</span><br>      <span class="hljs-meta">`uvm_field_int(dmac, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(smac, UVM_ALL_ON)</span><br>      <span class="hljs-keyword">if</span>(is_vlan)<span class="hljs-keyword">begin</span><span class="hljs-comment">//使用is_vlan来决定是否定义</span><br>         <span class="hljs-meta">`uvm_field_int(vlan_info1, UVM_ALL_ON)</span><br>         <span class="hljs-meta">`uvm_field_int(vlan_info2, UVM_ALL_ON)</span><br>         <span class="hljs-meta">`uvm_field_int(vlan_info3, UVM_ALL_ON)</span><br>         <span class="hljs-meta">`uvm_field_int(vlan_info4, UVM_ALL_ON)</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-meta">`uvm_field_int(ether_type, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_array_int(pload, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(crc, UVM_ALL_ON | UVM_NOPACK)</span><br>      <span class="hljs-meta">`uvm_field_int(is_vlan, UVM_ALL_ON | UVM_NOPACK)</span><br>   <span class="hljs-meta">`uvm_object_utils_end</span><br>  ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>使用if来决定field_automation：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//随机化无VLAN的以太网帧：</span><br>my_transaction tr;<br>tr = <span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;is_vlan == <span class="hljs-number">0</span>;&#125;);<br><span class="hljs-comment">//随机化VLAN帧：</span><br>my_transaction tr;<br>tr = <span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;is_vlan == <span class="hljs-number">1</span>;&#125;);<br></code></pre></div></td></tr></table></figure>
<h3><span id="34-uvm中打印信息的控制">3.4 UVM中打印信息的控制</span></h3><p>一般在测试用例中设置，测试用例主要做打印信息的控制与仿真结束的控制（断点/rasie/error等待）以及<code>default_sequence</code>，env主要做组件例化和uvm_port连接</p>
<h4><span id="341-打印信息冗余度uvm_verbosity">3.4.1 打印信息冗余度(<code>uvm_verbosity</code>)</span></h4><p>UVM通过冗余度级别的设置提高了仿真日志的可读性</p>
<ul>
<li>在打印信息之前，UVM会比较要显示信息的冗余度级别与默认的冗余度阈值，<strong>如果小于等于阈值显示，否不显示</strong></li>
<li>默认的冗余度阈值是<code>UVM_MEDIUM</code>，所有低于等于 <code>UVM_MEDIUM</code>（如<code>UVM_LOW</code>）的信息都会被打印出来</li>
</ul>
<p>对不同的component设置不同的冗余度阈值非常有用。在芯片级别验证时，重用了不同模块（block）的env。由于个人习惯的不同，每个人对信息冗余度的容忍度也不同，有些人把所有信息设置为<code>UVM_MEDIUM</code>，也有另外一些人喜欢把所有的信息都设置为<code>UVM_HIGH</code>。通过设置不同env的冗余度级别，可以更好地控制整个芯片验证环境输出信息的质量。</p>
<p><strong>1.以组件为单位的函数</strong></p>
<blockquote>
<p><code>get_report_verbosity_level</code>得到某个component的冗余度阈值：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;env.i_agt.drv&#x27;s verbosity level is %0d&quot;</span>, env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.get_report_verbosity_level</span> ());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>返回值：<code>uvm_verbosity</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>  UVM_NONE   = <span class="hljs-number">0</span>,<br>  UVM_LOW    = <span class="hljs-number">100</span>,<br>  UVM_MEDIUM = <span class="hljs-number">200</span>,<br>  UVM_HIGH   = <span class="hljs-number">300</span>,<br>  UVM_FULL   = <span class="hljs-number">400</span>,<br>  UVM_DEBUG  = <span class="hljs-number">500</span><br>&#125; uvm_verbosity;<br></code></pre></div></td></tr></table></figure>
<p><code>set_report_verbosity_level</code>设置某个特定component的默认冗余度阈值，使用代码如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_verbosity_level</span>(UVM_HIGH);<br>    ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><code>set_report_verbosity_level</code>调用phase：</p>
<ul>
<li>需要牵扯到层次引用，所以需要在<code>connect_phase</code>及以后的phase才能调用这个函数</li>
<li>如果不牵扯到任何层次引用，可以在<code>connect_phase</code>之前调用</li>
</ul>
<p><code>set_report_verbosity_level</code>只对某个特定的component起作用</p>
<p> <code>set_report_verbosity_level_hier</code>递归设置某component及其子节点的默认冗余度阈值，使用代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_verbosity_level_hier</span>(UVM_HIGH);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>2.组件内以ID为单位的函数</strong></p>
<blockquote>
<p><code>set_report_id_verbosity</code>函数来区分不同的ID的冗余度阈值，使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//某组件中</span><br><span class="hljs-meta">`uvm_info(&quot;ID1&quot;, &quot;ID1 INFO&quot;, UVM_HIGH)</span><br><span class="hljs-meta">`uvm_info(&quot;ID2&quot;, &quot;ID2 INFO&quot;, UVM_HIGH)</span><br><span class="hljs-comment">//env中</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_verbosity</span>(<span class="hljs-string">&quot;ID1&quot;</span>, UVM_HIGH);<br><span class="hljs-comment">//经过上述设置后“ID1INFO”会显示，但是“ID2INFO”不会显示</span><br></code></pre></div></td></tr></table></figure>
<p><code>set_report_id_verbosity_hier</code>递归设置某component及其子节点的某ID的默认冗余度阈值，使用代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_verbosity_hier</span>(<span class="hljs-string">&quot;ID1&quot;</span>, UVM_HIGH);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>3.在命令行中设置</strong></p>
<blockquote>
<p>UVM支持在命令行中设置冗余度阈值：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt;&lt;sim <span class="hljs-built_in">command</span>&gt; +UVM_VERBOSITY=UVM_HIGH <br>&gt;或者：<br>&gt;&lt;sim <span class="hljs-built_in">command</span>&gt; +UVM_VERBOSITY=HIGH<br></code></pre></div></td></tr></table></figure>
<ul>
<li>这两个命令行参数是等价的，即可以把冗余度级别的前缀<code>UVM_</code>省略</li>
<li>上述的命令行参数会把整个验证平台的冗余度阈值设置为UVM_HIGH。相当于是在base_test中调用 <code>set_report_verbosity_level_hier</code>函数，把base_test及以下所有component的冗余度级别设置为<code>UVM_HIGH</code></li>
</ul>
</blockquote>
<h4><span id="342-重载打印信息的严重性">3.4.2 重载打印信息的严重性</span></h4><p>UVM默认有四种信息严重性：<code>UVM_INFO</code>、<code>UVM_WARNING</code>、<code>UVM_ERROR</code>、 <code>UVM_FATAL</code></p>
<p><strong>1.重载打印信息的严重性</strong></p>
<p><strong>重载</strong>是深入到UVM骨子里的一个特性</p>
<p>这四种严重性可以互相重载</p>
<blockquote>
<p><code>set_report_severity_override</code>重载严重性</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//如果要把driver中所有的`UVM_WARNING显示为`UVM_ERROR，可以使用如下的函数</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>  env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_override</span>(UVM_WARNING, UVM_ERROR); <span class="hljs-comment">//env.i_agt.drv.set_report_severity_id_override(UVM_WARNING, &quot;my_driver&quot;, UVM_ERROR);</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>不提供递归重载，与设置冗余度不同</p>
<p>严重性重载用的较少，一般的只会对某个component内使用，不会递归的使用</p>
<p>针对某个component的特定ID重载严重性：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_override</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, UVM_ERROR);<br></code></pre></div></td></tr></table></figure>
<p>命令行中实现重载严重性：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_severity=&lt;comp&gt;,&lt;id&gt;,&lt;current severity&gt;,&lt;new severity&gt;<br><span class="hljs-comment"># 如果要把driver中所有的`UVM_WARNING显示为`UVM_ERROR，可以使用如下的函数(替代set_report_severity_override中的示例)</span><br>&gt;&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_severity=<span class="hljs-string">&quot;uvm_test_top.env.i_agt.drv,my_driver,UVM_WARNING,UVM_ERROR&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>若要设置所有的ID，可以在id处使用<code>_ALL_</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_severity=<span class="hljs-string">&quot;uvm_test_top.env.i_agt.drv,_ALL_,UVM_WARNING,UVM_ERROR&quot;</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="343-严重性与结束仿真">3.4.3 严重性与结束仿真</span></h4><p><code>UVM_FATAL</code>出现时，表示出现了致命错误，仿真会马上停止</p>
<p>在<code>end_of_elaboration_phase</code>及其前的phase中，如果出现了一个或多个<code>UVM_ERROR</code>，那么UVM就认为出现了致命错误，会调用uvm_fatal结束仿真（5.1.6节提到），其他情况<code>UVM_ERROR</code>默认不会结束（最后一句不会结束我瞎猜的）</p>
<p><strong>1.设置<code>UVM_ERROR</code>退出阈值</strong></p>
<p><code>UVM_ERROR</code>达到一定数量时也可以结束仿真</p>
<ul>
<li>这个功能非常有用。对于某个测试用例，如果出现了大量的<code>UVM_ERROR</code>，根据这些错误已经可以确定bug所在了，再继续仿真下去意义已经不大，此时就可以结束仿真，而不必等到所有的objection被撤销</li>
</ul>
<blockquote>
<p><code>set_report_max_quit_count</code>设置<code>UVM_ERROR</code>退出阈值，使用函数示例</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  env = my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);<br>    set_report_max_quit_count(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><code>get_max_quit_count</code>查询当前的<code>UVM_ERROR</code>退出阈值，如果返回值为0则表示无论出现多少个<code>UVM_ERROR</code>都不会退出仿真</p>
<p>在命令行中设置退出阈值：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">+UVM_MAX_QUIT_COUNT=6,NO<br></code></pre></div></td></tr></table></figure>
<p>第一个参数6表示退出阈值，而第二个参数NO表示此值是不可以被后面的设置语句重载，其值还可以是YES</p>
</blockquote>
<p><strong>2.设置其他严重性退出</strong></p>
<blockquote>
<p><code>set_report_severity_action</code>把其他严重性加入计数目标，下面的代码把<code>UVM_WARNING</code>加入计数目标：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>    …<br>  set_report_max_quit_count(<span class="hljs-number">5</span>);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY|UVM_COUNT);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><code>set_report_severity_action</code>：递归设置</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_WARNING, UVM_DISPLAY| UVM_COUNT);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>3.针对ID计数退出</strong></p>
<p>除了针对严重性进行计数外，还可以对某个特定的ID进行计数</p>
<blockquote>
<p><code>set_report_id_action</code>：下面代码把ID为<code>my_drv</code>的所有信息加入计数退出</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_COUNT)<br></code></pre></div></td></tr></table></figure>
<p><code>set_report_id_action_hier</code>递归设置</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_COUNT);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>4.联合ID与严重性计数退出</strong></p>
<p>除了分别对严重性和ID进行设置外，UVM还支持把它们联合起来进行设置</p>
<blockquote>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">&gt;set_report_severity_id_action<br>env.i_agt.drv.set_report_severity_id_action(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY<span class="hljs-string">| UVM_COUNT);</span><br></code></pre></div></td></tr></table></figure>
<p><code>set_report_severity_id_action_hier</code>：递归形式</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_action_hier</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_COUNT);<br></code></pre></div></td></tr></table></figure>
<p>命令行中设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_action=&lt;comp&gt;,&lt;id&gt;,&lt;severity&gt;,&lt;action&gt;<br><span class="hljs-comment">#如</span><br>&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_action=<span class="hljs-string">&quot;uvm_test_top.env.i_agt.drv,my_driver,UVM_NG,UVM_DISPLAY|UVM_COUNT&quot;</span><br><span class="hljs-comment">#针对所有ID时，用_ALL_代替ID</span><br>&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_action=<span class="hljs-string">&quot;uvm_test_top.env.i_agt.drv,_ALL_,UVM_WARNING,UVM_DISPLAY|UVM_COUNT&quot;</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="345-uvm的断点功能">3.4.5 UVM的断点功能</span></h4><p>断点功能需要从仿真器的角度进行设置，不同仿真器的设置方式不同。<u>为了消除这些设置方式的不同</u>，UVM支持<strong>内建</strong>的断点功能，当执行到断点时，自动停止仿真，进入交互模式</p>
<p><strong>1.具体实现</strong></p>
<ul>
<li>把3.4.4节介绍的函数中<code>UVM_COUNT</code>替换为<code>UVM_STOP</code>就可以实现断点功能，函数目录：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY| UVM_COUNT); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_WARNING, UVM_DISPLAY| UVM_COUNT);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_COUNT); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_COUNT); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_action</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_COUNT);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_action_hier</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_COUNT);<br></code></pre></div></td></tr></table></figure>
<ul>
<li>命令行中也可以设置断点：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +uvm_set_action=<span class="hljs-string">&quot;uvm_test_top.env.i_agt.drv,my_driver,UVM_WARNING,UVM_DISPLAY|UVM_STOP&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.使用示例</strong></p>
<p>使用<code>set_report_severity_action</code>函数，当env.i_agt.drv中出现UVM_WARNING时，立即停止仿真，进入交互模式</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch3/section3.4/3.4.5/base_test.sv</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY| UVM_STOP);<br><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="346-将输出信息导入文件中">3.4.6 将输出信息导入文件中</span></h4><p>各个仿真器提供将显示在标准输出的信息同时输出到一个日志文件中的功能，但是这个日志文件混杂了所有的<code>UVM_INFO</code>、<code>UVM_WARNING</code>、<code>UVM_ERROR</code>及<code>UVM_FATAL</code></p>
<p>UVM提供将特定信息输出到特定日志文件的功能</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;base_test&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_component_utils(base_test)</span><br><br>   UVM_FILE info_log;<br>   UVM_FILE warning_log;<br>   UVM_FILE error_log;<br>   UVM_FILE fatal_log;<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>       info_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;info.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       warning_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;warning.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       error_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;error.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       fatal_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;fatal.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_INFO,    info_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_WARNING, warning_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_ERROR,   error_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_FATAL,   fatal_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_INFO, UVM_DISPLAY | UVM_LOG);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY | UVM_LOG);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_ERROR, UVM_DISPLAY | UVM_COUNT | UVM_LOG);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_FATAL, UVM_DISPLAY | UVM_EXIT | UVM_LOG);<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>代码总结</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//严重性</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_INFO,    info_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_WARNING, warning_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_ERROR,   error_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_FATAL,   fatal_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_INFO, UVM_DISPLAY | UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY | UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_ERROR, UVM_DISPLAY | UVM_COUNT | UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_FATAL, UVM_DISPLAY | UVM_EXIT | UVM_LOG);<br><span class="hljs-comment">//严重性递归</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_file_hier</span>(UVM_INFO, info_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_file_hier</span>(UVM_WARNING, warning_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_file_hier</span>(UVM_ERROR, error_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_file_hier</span>(UVM_FATAL, fatal_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_INFO, UVM_DISPLAY| UVM_LOG); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_WARNING, UVM_DISPLAY| UVM_LOG); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_ERROR, UVM_DISPLAY| UVM_COUNT |UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_action_hier</span>(UVM_FATAL, UVM_DISPLAY| UVM_EXIT | UVM_LOG);<br><span class="hljs-comment">//id</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_file_hier</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, driver_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_file_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, drv_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_LOG);<br><span class="hljs-comment">//id递归</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_file_hier</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, driver_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_file_hier</span>(UVM_INFO, <span class="hljs-string">&quot;my_drv&quot;</span>, drv_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_LOG);<br><span class="hljs-comment">//严重性与id组合</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_file</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, driver_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_file</span>(UVM_INFO, <span class="hljs-string">&quot;my_drv&quot;</span>, drv_log);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_LOG);<br><span class="hljs-comment">//严重性与id组合递归</span><br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_file_hier</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, driver_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_severity_id_file_hier</span>(UVM_INFO, <span class="hljs-string">&quot;my_drv&quot;</span>, drv_log); env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.set_report_id_action_hier</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_LOG);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="347-控制打印行为">3.4.7 控制打印行为</span></h4><p>UVM中的打印信息的行为<code>uvm_action_type</code>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>    UVM_NO_ACTION   = <span class="hljs-number">&#x27;b000000</span>,<span class="hljs-comment">//不做任何操作（可以关闭信息输出）</span><br>    UVM_DISPLAY     = <span class="hljs-number">&#x27;b000001</span>,<span class="hljs-comment">//输出到标准输出上</span><br>    UVM_LOG         = <span class="hljs-number">&#x27;b000010</span>,<span class="hljs-comment">//输出到日志文件中</span><br>    UVM_COUNT       = <span class="hljs-number">&#x27;b000100</span>,<span class="hljs-comment">//作为计数目标</span><br>    UVM_EXIT        = <span class="hljs-number">&#x27;b001000</span>,<span class="hljs-comment">//直接退出仿真</span><br>    UVM_CALL_HOOK   = <span class="hljs-number">&#x27;b010000</span>,<span class="hljs-comment">//调用一个回调函数</span><br>    UVM_STOP        = <span class="hljs-number">&#x27;b100000</span><span class="hljs-comment">//停止仿真，进入命令行交互模式</span><br>&#125; uvm_action_type;<br></code></pre></div></td></tr></table></figure>
<p>多行为可叠加(类似field automation中的标志位)：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">UVM_DISPLAY| UVM_COUNT | UVM_LOG<br></code></pre></div></td></tr></table></figure>
<p>默认严重级对应的行为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">set_severity_action(UVM_INFO, UVM_DISPLAY);<br>set_severity_action(UVM_WARNING, UVM_DISPLAY);<br>set_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_COUNT);<br>set_severity_action(UVM_FATAL, UVM_DISPLAY | UVM_EXIT);<br></code></pre></div></td></tr></table></figure>
<h3><span id="35-config_db机制">3.5 <mark>config_db机制</mark></span></h3><p>一般在<code>build_phase</code>中使用</p>
<h4><span id="351-uvm中的路径">3.5.1 UVM中的路径</span></h4><ul>
<li>使用<code>get_full_name()</code>函数得到component路径</li>
<li>使用<code>comp::get()</code>得到某componet的句柄</li>
</ul>
<p><strong>1.路径分析</strong></p>
<p>UVM中的路径图（new函数而不是factory中的create是为了方便）</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221124215734579-167920883830624.png" srcset="/img/loading.gif" lazyload alt="image-20221124215734579"></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_driver::build_phase();<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%s&quot;</span>, get_full_name());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>打印值为<code>uvm_test_top.env.i_agt.drv</code></p>
<p><code>uvm_top</code>：</p>
<ul>
<li><code>uvm_top</code>的名字是<code>__top__</code>，但是在显示路径的时候，并不会显示出这 个名字，而只显示从<code>uvm_test_top</code>开始的路径</li>
</ul>
<p><code>uvm_test_top</code>：</p>
<ul>
<li><code>uvm_test_top</code>实例化时的名字是 <code>uvm_test_top</code>，这个名字是由UVM在run_test时自动指定的</li>
</ul>
<p>路径与层次：</p>
<ul>
<li>路径是<code>create</code>或<code>new</code>传递的名字组成</li>
<li>层次结构是由组件句柄的引用</li>
</ul>
<p>尽量保持保持组件句柄与实例时传递名称统一，否则：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">如果drv在<span class="hljs-keyword">new</span>时指定的名字不是drv，而是driver，即：<br>drv = my_driver::type_id::create(<span class="hljs-string">&quot;driver&quot;</span>);<br>那么drv在my_casen看来，层次结构依然是env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span>，但其路径变为了env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.driver</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="352-set与get函数的参数">3.5.2 set与get函数的参数</span></h4><p><mark>config_db</mark>用于在UVM验证平台间传递参数，通常成对出现（但是在某些情况下可以只有set而没有get语句，即省略get语句3.5.2节）：</p>
<ul>
<li>get收信</li>
<li>set寄信</li>
</ul>
<p><strong>1.在某个casen的build_phase中可以使用如下方式寄信：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(int)::set(this, &quot;env.i_agt.drv&quot;, &quot;pre_num&quot;, 100)</span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>第一个和第二个参数联合起来组成目标路径，与此路径符合的目标才能收信</p>
</li>
<li><p>第一个参数<code>cntxt</code>必须是一个<code>uvm_component</code>实例的指针</p>
<ul>
<li><p>set第一个参数若为null，UVM会自动把第一个参数替换为代码<code>uvm_root::get()</code>，即<code>uvm_top</code></p>
</li>
<li><p>第一个参数应该尽量使用<code>this</code>。在无法得到<code>this</code>指针的情况下(如在top_tb中)，使用<code>null</code>或者<code>uvm_root::get()</code></p>
</li>
</ul>
</li>
<li><p>第二个参数<code>inst_name</code>是相对此实例的路径</p>
</li>
<li><p>第三个参数<code>field_name</code>表示一个记号，用以说明这个值是传给目标中的哪个成员的</p>
</li>
<li><p>第四个参数是要设置的值</p>
</li>
</ul>
<p><strong>2.在driver中的build_phase使用如下方式收信：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(int)::get(this, &quot;&quot;, &quot;pre_num&quot;, pre_num)</span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>第一个参数和第二个参数联合起来组成路径</li>
<li><p>第一个参数<code>cntxt</code>也必须是一个<code>uvm_component</code>实例的指针<code>cntxt</code></p>
<ul>
<li>get第一个参数若为null，UVM会自动把第一个参数替换为代码<code>uvm_root::get()</code>，即<code>uvm_top</code></li>
<li>第一个参数应该尽量使用<code>this</code>。在无法得到<code>this</code>指针的情况下(如在top_tb中，或者seq中)，使用<code>null</code>或者<code>uvm_root::get()</code></li>
</ul>
</li>
<li><p>第二个参数<code>inst_name</code>是相对此实例的路径（使用组件cntxt作为起始搜索点 ，获取inst_name中field_name的值，如果cntxt是配置对象适用的实例，则inst_name可以是空字符串）</p>
</li>
<li>第三个参数<code>field_name</code>就是set函数中的第三个参数，<strong>这两个参数必须严格匹配</strong></li>
<li>第四个参数则是要设置的变量</li>
</ul>
<p><strong>3.默认句柄：</strong></p>
<ul>
<li>set/get第一个参数为null，UVM会自动把第一个参数替换为代码<code>uvm_root::get()</code>，即<code>uvm_top</code>，以下两种写法是完全等价的：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;vif&quot;, input_if)</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(uvm_root::get(), &quot;uvm_test_top.env.i_ag t. drv&quot;, &quot;vif&quot;, input_if)</span>;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<p><strong>4.set参数也可以这么写</strong></p>
<p>既然set函数的第一个和第二个参数联合起来组成路径，那么在castn的build_phase中可以通过如下的方式设置<code>env.i_agt.drv</code>中<code>pre_num_max</code>的值：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(int)::set(this.env, &quot;i_agt.drv&quot;, &quot;pre_num_max&quot;, 100)</span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>第一个参数把<code>this</code>替换为了<code>this.env</code></li>
<li>第二个参数是<code>my_driver</code>相对于<code>env</code>的路径</li>
</ul>
<p><strong>5.get参数也可以这么写</strong></p>
<p>get函数的参数</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(int)::get(this.parent, &quot;drv&quot;, &quot;pre_num_max&quot;, pre_num_max)</span>;<br>或者：<br>uvm_config_db<span class="hljs-variable">#(int)::get(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;pre_num_max&quot;, p re_num_max)</span>;<span class="hljs-comment">//第二个参数相当于直接写了一遍绝对路径</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>这些写法都是可以的，只是它们相对于本节最开始的写法没有任何优势。所以还是提倡使用最开始的写法。但是这种写法也 并不是一无是处，在3.5.6节中会介绍它们的一种应用</p>
</blockquote>
<p><strong>6.常用写法</strong></p>
<ul>
<li>get中用于接收此comp的：参数1：<code>null</code>或<code>uvm_root::get()</code>，参数2：<code>get_full_name()</code>或<code>从uvm_test_top开始的绝对路径字符串</code></li>
<li>set中一般用<code>this</code>：参数1：<code>this</code>，参数2：<code>子节点的相对路径字符串</code></li>
</ul>
<h4><span id="353-省略get语句">3.5.3 省略get语句</span></h4><p>set与get函数一般都是成对出现，但是在某些情况下，是可以只有set而没有get语句，即省略get语句</p>
<p><strong>某些情况：</strong>指的给在component中使用field automation机制注册的变量传值时，收信方在<code>build_phase</code>中调用<code>super.build_phase()</code>后就可以省略<code>config_db::get</code>直接读取了</p>
<p><strong>示例如下：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(my_transaction)</span>;<br><br>   <span class="hljs-keyword">virtual</span> my_if vif;<br><br>   <span class="hljs-keyword">int</span> pre_num;<br>   <span class="hljs-meta">`uvm_component_utils_begin(my_driver)</span><br>   <span class="hljs-meta">`uvm_field_int(pre_num, UVM_ALL_ON)//在组件中使用了field automation</span><br>   <span class="hljs-meta">`uvm_component_utils_end</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>      pre_num = <span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, $sformatf(&quot;before super.build_phase, the pre_num is %0d&quot;, pre_num), UVM_LOW) </span><br>       <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<span class="hljs-comment">//调用后就相当于get了，可以直接读了</span><br>      <span class="hljs-meta">`uvm_info(&quot;my_driver&quot;, $sformatf(&quot;after super.build_phase, the pre_num is %0d&quot;, pre_num), UVM_LOW) </span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> drive_one_pkt(my_transaction tr);<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>原理：</strong></p>
<p>这里的关键是<code>build_phase</code>中的<code>super.build_phase</code>语句，当执行到driver的<code>super.build_phas</code>e时，会<u>自动执行<code>get</code>语句</u></p>
<p><strong>这种做法的前提是：</strong></p>
<ul>
<li>组件（这里是my_driver）必须使用<code>`uvm_component_utils</code>宏注册</li>
<li>收信参数（这里是pre_num）必须使用<code>`uvm_field_int</code>宏注册</li>
<li>在调用set函数的时候，set函数的第三个参数必须与要get函数中变量的名字相一致（这里是pre_num）</li>
<li><strong>所以上节中，虽然说这两个参数可以不一致，但是最好的情况下还是一致</strong></li>
</ul>
<h4><span id="354-355-多重设置">3.5.4-3.5.5 多重设置</span></h4><p>在前面的所有例子中，都是设置一次(<code>config_db#(T)::set</code>)，获取一次<code>config_db#(T)::get</code>。但是假如设置多次，而只获取一次，最终会得到哪个值呢？</p>
<ul>
<li>跨层次-&gt;组件判断</li>
<li>同层次-&gt;时间判断（最后优先级最高）</li>
</ul>
<p><strong>1.跨层次的多重设置</strong></p>
<p>UVM规定层次越高，那么它的优先级越高。这里的层次指的是在UVM树中的位置，越靠近根结点<code>uvm_top</code>，则认为其层次越高。</p>
<p>如何判断set是哪一层的？</p>
<ul>
<li>通过第一个参数：<code>uvm_config_db#(int)::set(this, &quot;env.i_agt.drv&quot;, &quot;pre_num&quot;, 100);</code></li>
<li>如果第一个参数不是<code>this</code>而是<code>uvm_root::get()</code>，则都是从<code>uvm_top</code>树根设置，需要进行同层次时间判断</li>
<li>因此，无论如何，在调用<code>set</code>函数时其第一个参数应该尽量使用<code>this</code>。在无法得到<code>this</code>指针的情况下(如在top_tb中)，使用<code>null</code>或者<code>uvm_root::get()</code></li>
</ul>
<p><strong>2.同层次的多重设置</strong></p>
<p>处于同一层次时，是时间优先，例如下面两个语句同时出现在测试用例的<code>build_phase</code>中时，driver最终获取到的值将会是109：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(int)::set(this, &quot;env.i_agt.drv&quot;, &quot;pre_num&quot;, 100)</span>;<br>uvm_config_db<span class="hljs-variable">#(int)::set(this, &quot;env.i_agt.drv&quot;, &quot;pre_num&quot;, 109)</span>;<br></code></pre></div></td></tr></table></figure>
<p>像上面的这种用法看起来完全是胡闹，没有任何意义</p>
<h4><span id="356-非直线与直线的设置与获取">3.5.6 非直线与直线的设置与获取</span></h4><p>直线设置：在被设置的树干的某个节点组件上设置</p>
<p>非直线设置：在其他节点组件设置</p>
<p>直线获取：在被设置的节点组件上获取</p>
<p>非直线获取：从别的被设置的节点组件那里获取</p>
<blockquote>
<p>举例：</p>
<p>在图3-4所示的UVM树中，driver的路径为<code>uvm_test_top.env.i_agt.drv</code></p>
<ul>
<li>在<code>uvm_test_top</code>，<code>env</code>或者<code>i_agt</code>中，对<code>driver</code>中的某些变量通过<code>config_db</code>机制进行设置，称为直线设置</li>
<li>但是若在其他<code>component</code>，如<code>scoreboard</code>中，对<code>driver</code>的某些变量使用<code>config_db</code>机制进行设置，称为非直线设置</li>
</ul>
<ul>
<li>在<code>my_driver</code>中使用<code>config_db::get</code>获得其他任意<code>component</code>设置给<code>my_driver</code>的参数，称为直线的获取</li>
<li>假如要在其他的<code>component</code>，如在<code>reference model</code>中获取其他<code>component</code>设置给<code>my_driver</code>的参数的值，称为非直线的获取</li>
</ul>
</blockquote>
<p><strong>非直线设置的危险：</strong></p>
<p>在UVM树中，<code>build_phase</code>是自上而下执行的，UVM并没有明文指出同一级别的<code>build_phase</code>的执行顺序。所以当<code>my_driver</code>在获取参数值时，<code>my_scoreboard</code>的<code>build_phase</code>可能已经执行了，也可能没有执行，所以，这种非直线的设置，会有一定的风险，应该避免这种情况的出现</p>
<p><strong>非直线获取的便捷（一次设置，多个获取）：</strong></p>
<p>非直线的获取可以在某些情况下避免<code>config::set</code>的冗余。上面的例子在<code>reference model</code>中获取<code>driver</code>的<code>pre_num</code>的值，如果不这样做，而采用直线获取的方式，那么需要在测试用例中通过<code>config_db::set</code>分别给<code>reference model</code>和<code>driver</code>设置<code>pre_num</code>的值。 同样的参数值设置出现在不同的两条语句中，这大大增加了出错的可能性。因此，非直线的获取可以在验证平台中多个组件（UVM树结点）需要使用同一个参数时，减少<code>config_db::set</code>冗余</p>
<h4><span id="357-config_db机制对通配符的支持使用星号">3.5.7 config_db机制对通配符的支持（使用星号）</span></h4><p>在<code>config_db::set</code>操作时，其第二个参数都提供了完整的路径，但实际上也可以不提供完整的路径而使用通配符<code>*</code>代替</p>
<p><strong>1.举例说明</strong></p>
<p>2.5.2节的top_tb.sv中，使用完整路径设置virtual interface的代码可以写成这样：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//方法1 完整设置</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;vif&quot;, input_if)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.mon&quot;, &quot;vif&quot;, input_if)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.o_agt.mon&quot;, &quot;vif&quot;, output_if)</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//方法2 通配符（尽量少用，交接不好维护）</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt*&quot;, &quot;vif&quot;, input_if)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.o_agt*&quot;, &quot;vif&quot;, output_if)</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//方法3 不推荐非常省略的使用通配符!</span><br>uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;*i_agt*&quot;, &quot;vif&quot;, input_if)</span>;<br></code></pre></div></td></tr></table></figure>
<h4><span id="358-检查字符串路径检查config_db参数二">3.5.8 检查字符串路径（检查config_db参数二）</span></h4><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">check_config_usage`函数检查，一般用在`connect_phase<br></code></pre></div></td></tr></table></figure>
<hr>
<p>config_db机制一个致命缺点是，其set函数的第二个参数是字符串，如果字符串写错，那么根本就不能正确地设置参数值，而且SystemVerilog的仿真器也不会给出任何参数错误提示</p>
<p><strong>1.解决方法</strong></p>
<p>UVM提供了一个函数check_config_usage：</p>
<ul>
<li>它可以显示出截止到此函数调用时有哪些参数是被设置过但是却没有被获取过</li>
<li>由于config_db的set及get语句一般都用于build_phase阶段，所以此函数一般在connect_phase被调用</li>
</ul>
<p>使用示例</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//文件：src/ch3/section3.5/3.5.8/my_case0.sv</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    check_config_usage();<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>default sequence也会被检查出来：是因为default sequence是设置给<code>main_phase</code>的，它在<code>main_phase</code>的时候被获 取，而<code>main_phase</code>是在<code>connect_phase</code>之后执行的</p>
<h4><span id="359-set_config与get_config">3.5.9 set_config与get_config</span></h4><p><strong>UVM1.2发布，set_config与get_config被从UVM标准中移除，成为过时的用法</strong></p>
<p>1.介绍</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">set_config`与`get_config`这种写法最初来自OVM中，一共有这几种：`set/get_config_int`、`set/get_config_string`和`set/get_config_object`，对应`uvm_config_db#(int/string/uvm_objec t)set/get<br></code></pre></div></td></tr></table></figure>
<p><code>config_db</code>比<code>set/get_config</code>强大的地方在于，它设置的参数类型并不局限于以上三种。常见的枚举类型、virtual interface、bit类 型、队列等都可以成为config_db设置的数据类型</p>
<p>2.使用示例</p>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//文件：src/ch3/section3.5/3.5.9/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<br>   set_config_int(<span class="hljs-string">&quot;env.i_agt.drv&quot;</span>, <span class="hljs-string">&quot;pre_num&quot;</span>, <span class="hljs-number">999</span>);<br>   set_config_int(<span class="hljs-string">&quot;env.mdl&quot;</span>, <span class="hljs-string">&quot;rm_value&quot;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-comment">//文件: src/ch3/section3.5/3.5.9/my_model.sv</span><br>&gt;<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_model::build_phase(uvm_phase phase);<br><span class="hljs-keyword">int</span> rm_value;<br><span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-keyword">this</span>);<br>   ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">void</span>&#x27;(get_config_int(<span class="hljs-string">&quot;rm_value&quot;</span>, rm_value));<br>   <span class="hljs-meta">`uvm_info(&quot;my_model&quot;, $sformatf(&quot;get the rm_value %0d&quot;, rm_value), UVM_LOW)</span><br>   <span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>命令行使用：</p>
<p>UVM提供命令行参数来对它们进行设置</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_config_int=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt;<br>&lt;sim <span class="hljs-built_in">command</span>&gt; +uvm_set_config_string=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在设置int型参数时，可以在其前加上如下的前缀：’b、’o、’d、’h，分别表示二进制、八进制、十进制和十六进制的数据。如果不加任何前缀，则默认为十进制</p>
</blockquote>
</blockquote>
<h4><span id="3510-config_db的调试">3.5.10 config_db的调试</span></h4><ul>
<li><code>chech_config_usage(void)</code>：显示出截止到函数调用时，系统中有哪些参数被设置过但是没有被读取过</li>
<li><code>print_config(int num)</code>：参数为1表示递归的查询，若为0则只显示当前component的信息，用于找出哪些被设置过的信息对于它们是可见的（不会列出default sequence的相关设置）</li>
<li><code>UVM_CONFIG_DB_TRACE</code>命令行参数</li>
</ul>
<p>无论哪种方式，如果set函数的第二个参数设置错误，都不会给出错误信息。</p>
<p>本书会在10.6.3节提供一个函数，它会检查set函数的第二个参数，如果不可达，将会给出UVM_ERROR的信息。</p>
<h2><span id="第四章uvm中的tlm10通信">第四章UVM中的TLM1.0通信</span></h2><h3><span id="41-tlm10">4.1 TLM1.0</span></h3><p>UVM中通信主要有两种方案：</p>
<ul>
<li>方案1：使用IMP直连（4.1-4.2）</li>
<li>方案2：使用FIFO连接</li>
</ul>
<p>方案1直连需要在例化IMP的类中实现相关的功能任务/函数；一定需要一个IMP；在一个类中具有多个IMP时需要使用特殊的宏进行声明，不然会导致该功能函数/任务重载</p>
<p>方案2使用FIFO，可以看作一块缓存加两个IMP，因此不必要实现相关任务，只需要专注于数据</p>
<h4><span id="411-验证平台内部的通信">4.1.1 验证平台内部的通信</span></h4><p>如果要在两个uvm_component之间通信，如一个monitor向一个scoreboard传递一个数据（如图所示）有哪些方法呢？</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126200628230.png" srcset="/img/loading.gif" lazyload alt="image-20221126200628230"></p>
<blockquote>
<p>方法一：全局变量</p>
<p>使用全局变量，最简单的方法。在monitor里对此全局变量进行赋值，在scoreboard里监测此全局变量值的改变。这种方法 简单、直接，不过要避免使用全局变量，滥用全局变量只会造成灾难性的后果</p>
<p>方法二：从外部访问类的内部成员变量</p>
<p>从外部访问类的内部成员变量。在scoreboard中有一个变量，这个变量设置为外部可以直接访问的，即public类型的，在monitor中对此变量赋值。这个方法的问题在于，整个scoreboard里面的所有非local类型的变量都对monitor是可见的，而假如monitor的开发人员不小心改变了scoreboard中的一些变量，那么后果将可能会是致命的</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126213948859.png" srcset="/img/loading.gif" lazyload alt="使用public变量通信"></p>
<p>方法三：config_db机制，设置与接收<code>uvm_object</code>.</p>
<p>步骤：</p>
<ul>
<li>从<code>uvm_object</code>派生出一个参数类<code>config_object</code>，在此类中有monitor要传给 scoreboard的变量</li>
<li>在<code>base_test</code>中，实例化这个<code>config_object</code>，并将其指针通过<code>config_db#(config_object):set</code>传递给scoreboard和monitor</li>
<li>当monitor要和scoreboard通信时，只要把此<code>config_object</code>中相应变量的值改变即可。scoreboard中则监测变量值的改变， 监测到之后做相应动作</li>
</ul>
<p>这种方法比上面的两种方法都要好，但是仍然显得有些<strong>笨拙</strong>：</p>
<ul>
<li>一是要引入一个专门的config_object类</li>
<li>二是一定要有<code>base_test</code>这个第三方的参与。在大多数情况下，这个第三方是不会惹麻烦的。但是永远不能保证某一个从<code>base_test</code>派生而来的类会不会改变这个<code>config_object</code>类中某些变量的值。也就是说，依然存在一定的风险</li>
</ul>
<p>方法四：最佳方案</p>
<p>使用TLM</p>
<p>为什么不用sv中的机制？</p>
<p>这些问题使用现行的SystemVerilog中的一些机制，如Semaphore、Mailbox，再结合其他的一些技术等都能实现，但是这其中的问题在于这种通信显得<strong>非常复杂</strong>，用户需要浪费大量时间<strong>编写通信相关的代码</strong></p>
<p>解决办法：使用UVM的各种端口</p>
<p><u>UVM中的各种端口就可以实现这种功能</u>：在monitor和scoreboard之间专门建立一个通道，让信息只能在这个通道内流动，scoreboard也只能从这个通道中接收信息</p>
<ul>
<li>可以保证scoreboard中的信息只能从monitor中来，而不能从别的地方来；</li>
<li>同时赋予这个通道阻塞或者非阻塞等特性</li>
</ul>
</blockquote>
<h4><span id="412-tlm的定义">4.1.2 TLM的定义</span></h4><p>TLM是Transaction Level Modeling(事务级建模)的缩写，起源于SystemC的一种通信标准。</p>
<p>其他内容请参考《UVM入门进阶5(了解)：TLM2与同步通信元件》</p>
<p>TLM通信常用术语：</p>
<ul>
<li><code>put</code>操作，通信的发起者A把一个transaction发送给B</li>
<li><code>get</code>操作，A向B索取一个<code>transaction</code></li>
<li><code>transport</code>操作/<code>requeset-response</code>操作，相当于一次put操作加一次get操作，这两次操作的”发起者”都是A，目标都是B（现实世界中， 相当于是A向B提交了一个请求request，而B返回给A一个响应response。所以这种transport操作也常常被称做request-response操作）</li>
</ul>
<p>TLM中一共有三种端口：</p>
<ul>
<li>PORT</li>
<li>EXPORT</li>
<li>IMP（见4.2.2）</li>
</ul>
<p><strong>上面三种端口的控制流优先级为：<code>PORT</code>&gt;<code>EXPORT</code>&gt;<code>IMP</code>，在调用<code>connect</code>函数时只能高优先级调用，低优先级的端口作为入参</strong></p>
<p>方框为PORT，圆圈为EXPORT，三角为IMP，PORT和EXPORT体现的是<mark>控制流而不是数据流</mark></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126230440906.png" srcset="/img/loading.gif" lazyload alt="image-20221126230440906"></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221126230451710.png" srcset="/img/loading.gif" lazyload alt="image-20221126230451710"></p>
<h4><span id="413-port与export">4.1.3 PORT与EXPORT</span></h4><p>对应于不同的操作，有不同的PORT与EXPORT</p>
<p>UVM中常用的15个PORT有：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br>uvm_blocking_put_port<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_put_port<span class="hljs-variable">#(T)</span>;<br>uvm_put_port<span class="hljs-variable">#(T)</span>;<br><span class="hljs-comment">//get</span><br>uvm_blocking_get_port<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_get_port<span class="hljs-variable">#(T)</span>;<br>uvm_get_port<span class="hljs-variable">#(T)</span>;<br><span class="hljs-comment">//transport</span><br>uvm_blocking_transport_port<span class="hljs-variable">#(REQ, RSP)</span>;<br>uvm_nonblocking_transport_port<span class="hljs-variable">#(REQ, RSP)</span>;<br>uvm_transport_port<span class="hljs-variable">#(REQ, RSP)</span>;<br><span class="hljs-comment">// peek，与get系列端口类似，用于FIFO中，只读取而不使FIFO弹出数据（get读取时会让FIFO弹出数据，参考4.3.4）</span><br>uvm_blocking_peek_port<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_peek_port<span class="hljs-variable">#(T)</span>;<br>uvm_peek_port<span class="hljs-variable">#(T)</span>;<br><span class="hljs-comment">// get_peek，集合了get操作和peek操作两者的功能</span><br>uvm_blocking_get_peek_port<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_get_peek_port<span class="hljs-variable">#(T)</span>;<br>uvm_get_peek_port<span class="hljs-variable">#(T)</span>;<br></code></pre></div></td></tr></table></figure>
<p>UVM中常用的15个EXPORT，与上面15PORT一一对应：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_blocking_put_export<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_put_export<span class="hljs-variable">#(T)</span>;<br>uvm_put_export<span class="hljs-variable">#(T)</span>;<br><br>uvm_blocking_get_export<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_get_export<span class="hljs-variable">#(T)</span>;<br>uvm_get_export<span class="hljs-variable">#(T)</span>;<br><br>uvm_blocking_transport_export<span class="hljs-variable">#(REQ, RSP)</span>;<br>uvm_nonblocking_transport_export<span class="hljs-variable">#(REQ, RSP)</span>;<br>uvm_transport_export<span class="hljs-variable">#(REQ, RSP)</span>;<br><br>uvm_blocking_peek_export<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_peek_export<span class="hljs-variable">#(T)</span>;<br>uvm_peek_export<span class="hljs-variable">#(T)</span>;<br>     <br>uvm_blocking_get_peek_export<span class="hljs-variable">#(T)</span>;<br>uvm_nonblocking_get_peek_export<span class="hljs-variable">#(T)</span>;<br>uvm_get_peek_export<span class="hljs-variable">#(T)</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>参数：</strong></p>
<ul>
<li><code>T</code>：这个<code>PORT</code>/<code>EXPORT</code>中的数据流类型</li>
<li><code>REQ, RSP</code>：发起请求时传输的数据类型，返回的数据类型</li>
</ul>
<p><strong>blocking、nonblocking</strong></p>
<ul>
<li>都没有表示端口既可以用作是阻塞的，也可以用作是非阻塞的</li>
<li><code>blocking</code>表示该端口只能用作阻塞</li>
<li><code>nonblocking</code>表示该端口只能用作非阻塞</li>
<li>补充：这种划分方法可以看出，UVM把一个端口<strong>固定为只能执行某种操作</strong>（如对于<code>uvm_blocking_put_port#(T)</code>，它只能执行阻塞的put操作，想要执行非阻塞的put操作是不行的，想要执行get操作，也是不行的）</li>
</ul>
<h3><span id="42a-直连通信">4.2a 直连通信</span></h3><ul>
<li>4.2.1节至4.2.6节以<code>blocking_put</code>系列端口为例介绍<code>PORT</code>，<code>EXPORT</code>及<code>IMP</code>之间的互相连接</li>
<li>4.2.7节介绍<code>blocking_get</code>系列端口的连接</li>
<li>4.2.8节介绍<code>blocking_transport</code>系列端口的连接</li>
</ul>
<h4><span id="421-port与export的连接">4.2.1 PORT与EXPORT的连接</span></h4><p><strong>1.UVM中使用<code>connect</code>函数来建立连接</strong></p>
<p>如A要和B通信（A是发起者）则使用<code>A.port.connect(B.export)</code>，但不能写成<code>B.export.connect(A.port)</code>。（因为在通信的过程中，A是发起者，B是被动承担者。这种通信时的主次顺序也适用于连接时，只有发起者才能调用connect函数，而被动承担者则作为connect的参数）</p>
<p><strong>2.代码示例：A,B定义</strong></p>
<p>类A的定义（PORT）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>    uvm_blocking_put_port<span class="hljs-variable">#(my_transaction)</span> A_port;<span class="hljs-comment">//port声明</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    A_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_port&quot;</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//port实例化代码</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>port实例化参数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, <br>          uvm_component parent,<br>          <span class="hljs-keyword">int</span> min_size = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">int</span> max_size = <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<ul>
<li>参数<code>name</code>是该PORT名字</li>
<li>参数<code>parent</code>是<code>uvm_component</code>父节点变量</li>
<li>参数<code>min_size</code>是必须连接到这个PORT的下级端口数量的最小值</li>
<li>参数<code>max_size</code>是必须连接到这个PORT的下级端口数量的最大值</li>
<li>补充：如果不看参数<code>min_size</code>与<code>max_size</code>，new函数实际上是一个<code>uvm_component</code>的new函数</li>
</ul>
</blockquote>
<p>类B的定义（EXPORT）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_blocking_put_export<span class="hljs-variable">#(my_transaction)</span> B_export;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_export&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::main_phase(uvm_phase phase);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>EXPORT实例化参数：</p>
<p>参考PORT</p>
</blockquote>
<p><strong>3.直接建立<code>A_port</code>与<code>B_export</code>的实例变量连接是错误的</strong></p>
<p>我们将在下一节讨论IMP中实现A,B的连接，这节先说明直接连接是错误的</p>
<p>env中A,B错误的直接连接：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   A   A_inst;<br>   B   B_inst;<br>   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>      A_inst = A::type_id::create(<span class="hljs-string">&quot;A_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_inst<span class="hljs-variable">.A_port</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>运行上述代码，可以看到仿真器给出如下的错误提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># UVM_ERROR @ 0: uvm_test_top.env.B_inst.B_export [Connection Error] connection count of 0 does not meet</span><br><span class="hljs-comment"># UVM_ERROR @ 0: uvm_test_top.env.A_inst.A_port [Connection Error] connection count of 0 does not meet</span><br><span class="hljs-comment"># UVM_FATAL @ 0: reporter [BUILDERR] stopping due to build errors</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>解释：A_port，B_export相当于两道门，直接相连没有数据存储，这笔transaction一定要由B_export后续的某个组件进行<strong>处理</strong>。在UVM中，完成这种<strong>后续处理的也是一种端口：IMP</strong></p>
</blockquote>
<h4><span id="422-uvm中的imp">4.2.2 UVM中的IMP</span></h4><p>IMP是UVM中的精髓，承担了UVM中TLM的绝大部分实现代码，它的作用：完成接收数据后的处理工作，在UVM中这种后续处理也是端口，即<code>IMP</code></p>
<p>按照控制流的优先级排序，UVM中三种端口顺序为：<code>PORT</code>、<code>EXPORT</code>、<code>IMP</code>。IMP的优先级最低，一个PORT可以连接到一个IMP，并发起三种操作，反之则不行</p>
<p>UVM中的IMP示例（这15种IMP与15种PORT和15种EXPORT一一对应）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_blocking_put_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_nonblocking_put_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_put_imp<span class="hljs-variable">#(T, IMP)</span>;<br><br>uvm_blocking_get_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_nonblocking_get_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_get_imp<span class="hljs-variable">#(T, IMP)</span>;<br><br>uvm_blocking_transport_imp<span class="hljs-variable">#(REQ, RSP, IMP)</span>;<br>uvm_nonblocking_transport_imp<span class="hljs-variable">#(REQ, RSP, IMP)</span>;<br>uvm_transport_imp<span class="hljs-variable">#(REQ, RSP, IMP)</span>;<br><br>uvm_blocking_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_nonblocking_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br><br>uvm_blocking_get_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_nonblocking_get_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br>uvm_get_peek_imp<span class="hljs-variable">#(T, IMP)</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>参数：</strong></p>
<ul>
<li>T是这个IMP传输的数据类型</li>
<li>IMP为实现这个接口的一个<code>component</code></li>
</ul>
<blockquote>
<p>IMP参数怎么理解？</p>
<p>以blocking_put端口为例，在下图中，<code>A_port</code>被连接到<code>B_export</code>，而<code>B_export</code>被连接到<code>B_imp</code>。当写下 <code>A.A_port.put(transaction)</code>时，此时<code>B.B_imp</code>会通知B有<code>transaction</code>过来了，这个过程是如何进行的呢？可以简单理解成<code>A.A_port.put(transaction)</code>这个任务会调用<code>B.B_export</code>的put，<code>B.B_export</code>的<code>put(transaction)</code>又会调用<code>B.B_imp</code>的<code>put(transaction)</code>，而<code>B_imp.put</code>最终又会调用B的相关任务，如<code>B.put(transaction)</code>。所以关于<code>A_port</code>的操作最终会落到<code>B.put</code>这个 任务上，这个任务是属于B的一个任务，与A无关，与A的PORT无关，也与B的EXPORT和IMP无关</p>
<p>也就是说，<u><strong>（重要）这些put操作最终还是要由B这个component来实现，即要由一个component来实现接口的操作。所以每一个IMP要和一个component相对应。</strong></u></p>
<p>总结，处理程序调用顺序：</p>
<p>调用A_port.put时的过程：<code>A_port.put-调用-&gt;B_export.put-调用-&gt;B_imp.put-调用-&gt;B.put</code></p>
<p>重点！</p>
<p>理解下图中A连接到B_export，B_export连接到B_imp这个过程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221128220610915.png" srcset="/img/loading.gif" lazyload alt="image-20221128220610915"></p>
<p><strong>2.代码示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch4/section4.2/4.2.2/A.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_blocking_put_port<span class="hljs-variable">#(my_transaction)</span> A_port;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_port&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      A_port<span class="hljs-variable">.put</span>(tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">//src/ch4/section4.2/4.2.2/B.sv</span><br><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_blocking_put_export<span class="hljs-variable">#(my_transaction)</span> B_export;<span class="hljs-comment">//</span><br>   uvm_blocking_put_imp<span class="hljs-variable">#(my_transaction, B)</span> B_imp;<span class="hljs-comment">//</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> put(my_transaction tr);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_export&quot;</span>, <span class="hljs-keyword">this</span>);<br>   B_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_imp&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   B_export<span class="hljs-variable">.connect</span>(B_imp);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::put(my_transaction tr);<span class="hljs-comment">//关键是这个！定义了一个put函数，A_port.put最终会调用这个</span><br>   <span class="hljs-meta">`uvm_info(&quot;B&quot;, &quot;receive a transaction&quot;, UVM_LOW) </span><br>   tr<span class="hljs-variable">.print</span>();<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::main_phase(uvm_phase phase);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">//src/ch4/section4.2/4.2.2/my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_inst<span class="hljs-variable">.A_port</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>连接解释：</p>
<p>A_port连接到B_export，B_export连接到B_imp（参考本节第一部分）</p>
<p>如果不实现B的put函数/任务没有实现，则运行代码会报错（为什么要实现B的put，请参考【IMP参数怎么理解？】）</p>
</blockquote>
<h4><span id="423-portexport与imp的连接">4.2.3 PORT/EXPORT与IMP的连接</span></h4><p>TLM中一共有三种端口：</p>
<ul>
<li>PORT</li>
<li>EXPORT</li>
<li>IMP（见4.2.2）</li>
</ul>
<p><strong>上面三种端口的控制流优先级为：<code>PORT</code>&gt;<code>EXPORT</code>&gt;<code>IMP</code>，在调用<code>connect</code>函数时只能高优先级调用，低优先级的端口作为入参</strong></p>
<p><strong>1.实现PORT与IMP的连接</strong></p>
<p>背景：有三个component：A、B和env，其中env是A和B的父结点，现在要把A中的PORT和B中的IMP 连接起来实现通信</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129170140433.png" srcset="/img/loading.gif" lazyload alt="image-20221129170140433"></p>
<p>主要步骤：</p>
<blockquote>
<p>第一步：A,B中的端口声明</p>
<p>A中采用了<code>uvm_blocking_put</code>类型的PORT，因此B中IMP相应的类型是<code>uvm_blocking_put_imp</code></p>
<p>补充：参数解释</p>
<p><code>uvm_blocking_put_imp#(T, IMP)</code>的参数T和IMP：T（要传输的transaction），IMP（实现接口功能的uvm_comonent，这里时B_imp所在的uvm_component B）</p>
<p>第二步：功能接口实现：</p>
<p>B中的关键是定义一个任务/函数put，A_port的put操作最终要落到B的put上</p>
<p>补充：功能函数的名称要求</p>
<ul>
<li>A_port与B_imp是<code>blocking_put</code>时B内需要定义1个成员：<code>B.put</code>任务/函数</li>
<li>A_port与B_imp是<code>nonblocking_put</code>时B内需要定义2个成员：<code>B.try_put</code>函数，<code>B.can_put</code>函数</li>
<li>A_port与B_imp是<code>put</code>时B内需要定义3个成员：<code>B.put</code>任务/函数，<code>B.try_put</code>函数，<code>B.can_put</code>函数</li>
</ul>
<ul>
<li>A_port与B_imp是<code>blocking_get</code>时B内需要定义1个成员：<code>B.get</code>任务/函数</li>
<li>A_port与B_imp是<code>nonblocking_get</code>时B内需要定义2个成员：<code>B.try_get</code>函数，<code>B.can_get</code>函数</li>
<li>A_port与B_imp是<code>get</code>时B内需要定义3个成员：<code>B.get</code>任务/函数，<code>B.try_get</code>函数，<code>B.can_get</code>函数</li>
</ul>
<ul>
<li>A_port与B_imp是<code>blocking_peek</code>时B内需要定义1个成员：<code>B.peek</code>任务/函数</li>
<li><p>A_port与B_imp是<code>nonblocking_peek</code>时B内需要定义2个成员：<code>B.try_peek</code>函数，<code>B.can_peek</code>函数</p>
</li>
<li><p>A_port与B_imp是<code>peek</code>时B内需要定义3个成员：<code>B.peek</code>任务/函数，<code>B.try_peek</code>函数，<code>B.can_peek</code>函数</p>
</li>
</ul>
<ul>
<li>A_port与B_imp是<code>blocking_get_peek</code>时B内需要定义2个成员：<code>B.peek</code>任务/函数，<code>B.get</code>任务/函数</li>
<li><p>A_port与B_imp是<code>nonblocking_get_peek</code>时B内需要定义4个成员：<code>B.try_peek</code>函数，<code>B.can_peek</code>函数，<code>B.try_get</code>函数，<code>B.can_get</code>函数</p>
</li>
<li><p>A_port与B_imp是<code>get_peek</code>时B内需要定义6个成员：<code>B.peek</code>任务/函数，<code>B.try_peek</code>函数，<code>B.can_peek</code>函数，<code>B.get</code>任务/函数，<code>B.try_get</code>函数，<code>B.can_get</code>函数</p>
</li>
</ul>
<ul>
<li>A_port与B_imp是<code>blocking_transport</code>时B内需要定义1个成员：<code>B.transport</code>任务/函数</li>
<li>A_port与B_imp是<code>nonblocking_transport</code>时B内需要定义1个成员：<code>B.nb_transport</code>函数</li>
<li>A_port与B_imp是<code>transport</code>时B内需要定义2个成员：<code>B.transport</code>任务/函数，<code>B.nb_transport</code>函数</li>
</ul>
<p>在前述的这些规律中，对于所有<code>blocking</code>系列的端口可以是任务，也可以是函数。但是对于<code>nonblocking</code>系列端口来说，只能定义函数。</p>
<p>第三步：连接</p>
<p>一定要在<mark>connect_phase</mark>中调用<code>connect</code>进行连接，具体实现如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br> <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br> A_inst<span class="hljs-variable">.A_port</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_imp</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>（可选）第四步调用put：</p>
<p>A发送数据到B调用<code>put</code>函数，具体实现如下（也是上一节A定义的代码）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//文件：src/ch4/section4.2/4.2.3/my_env.sv</span><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>my_transaction tr;<br><span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>   #<span class="hljs-number">10</span>;<br>   tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>   <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>   A_port<span class="hljs-variable">.put</span>(tr);<span class="hljs-comment">//调用了十次put</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>2.EXPORT与IMP的连接</strong></p>
<p>除了端口声明不同，其他与PORT和IMP连接完全一样（与4.2.2相比，这里export作为起点，而不是中间点），示例代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// A.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_blocking_put_export<span class="hljs-variable">#(my_transaction)</span> A_export;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br>       <br>...<br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      A_export<span class="hljs-variable">.put</span>(tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">// my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    A_inst<span class="hljs-variable">.A_export</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_imp</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="425-不同层次之间的连接port与portexport与export">4.2.5 不同层次之间的连接（PORT与PORT，EXPORT与EXPORT）</span></h4><p><strong>1.PORT与PORT的连接</strong></p>
<ul>
<li>在前面的连接中，都是不同类型的端口之间连接（PORT与IMP、PORT与EXPORT、EXPORT与IMP），且不存在层次的关系。在UVM中，支持带层次的连接关系，如下图所示</li>
<li>PORT与PORT之间的连接不只局限于两层，可以有无限多层</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129213614571.png" srcset="/img/loading.gif" lazyload alt="image-20221129213614571"></p>
<p>代码片段如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// A.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   C C_inst;<br>   uvm_blocking_put_port<span class="hljs-variable">#(my_transaction)</span> A_port;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_port&quot;</span>, <span class="hljs-keyword">this</span>);<br>   C_inst = C::type_id::create(<span class="hljs-string">&quot;C_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   C_inst<span class="hljs-variable">.C_port</span><span class="hljs-variable">.connect</span>(<span class="hljs-keyword">this</span><span class="hljs-variable">.A_port</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>隐含了控制流关系，内层port调用<code>connect</code></p>
</blockquote>
<p><strong>2.EXPORT与EXPORT的连接</strong></p>
<p>除了支持PORT与PORT之间的连接外，UVM同样支持EXPORT与EXPORT之间的连接，如下图所示</p>
<p>EXPORT与EXPORT之间的连接也不只局限于两层，也可以有无限多层</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129213843287.png" srcset="/img/loading.gif" lazyload alt="image-20221129213843287"></p>
<blockquote>
<p>A中是PORT，B与C中是EXPORT，B中还有一个IMP。UVM支持C的EXPORT连接到B的EXPORT，并最终连接 到B的IMP</p>
</blockquote>
<p>示例代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// C.sv</span><br><span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(C)</span><br><br>   B B_inst;<br><br>   uvm_blocking_put_export<span class="hljs-variable">#(my_transaction)</span> C_export;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> C::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   C_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;C_export&quot;</span>, <span class="hljs-keyword">this</span>);<br>   B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>); <br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> C::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   <span class="hljs-keyword">this</span><span class="hljs-variable">.C_export</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_export</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> C::main_phase(uvm_phase phase);<br><br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">// my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    A_inst<span class="hljs-variable">.A_port</span><span class="hljs-variable">.connect</span>(C_inst<span class="hljs-variable">.C_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>隐含了控制流方向，所以是外层调用内层</p>
</blockquote>
<h3><span id="42b-其他功能系列">4.2b 其他功能系列</span></h3><h4><span id="427-get">4.2.7 get</span></h4><p>前面几节中都是以<code>blocking_put</code>系列端口为例进行介绍，本节介绍<code>blocking_get</code>系列端口的应用</p>
<p>get系列端口与put系列端口在某些方面<strong>完全相反</strong>，若要实现下图从A到B的通信，使用<code>blocking_get</code>系列端口的框图</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129221442784.png" srcset="/img/loading.gif" lazyload alt="image-20221129221442784"></p>
<blockquote>
<p>数据流依然是从A到B，但是A由动作发起者变成了动作接收者，而B由动作接收者变成了动作发起者</p>
</blockquote>
<p><strong>1.主要步骤：</strong></p>
<blockquote>
<p>第一步：A,B中的端口声明</p>
<p>B_port的类型为<code>uvm_blocking_get_port</code></p>
<p>A_export的类型为<code>uvm_blocking_get_export</code>，A_imp的类型为<code>uvm_blocking_get_imp</code></p>
<p>第二步：实现功能（与put类似）</p>
<p><code>uvm_blocking_get_imp</code>所在的component要实现一个名字为<code>get</code>的函数/任务</p>
<p>第三步：连接</p>
<p>第四步：调用get</p>
</blockquote>
<p><strong>2.代码详解</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_blocking_get_export<span class="hljs-variable">#(my_transaction)</span> A_export;<br>   uvm_blocking_get_imp<span class="hljs-variable">#(my_transaction, A)</span> A_imp;<br>   my_transaction tr_q[$];<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> get(<span class="hljs-keyword">output</span> my_transaction tr);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_export&quot;</span>, <span class="hljs-keyword">this</span>);<br>   A_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_imp&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_export<span class="hljs-variable">.connect</span>(A_imp);<span class="hljs-comment">//连接</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::get(<span class="hljs-keyword">output</span> my_transaction tr);<br>   <span class="hljs-keyword">while</span>(tr_q<span class="hljs-variable">.size</span>() == <span class="hljs-number">0</span>) #<span class="hljs-number">2</span>;<br>   tr = tr_q<span class="hljs-variable">.pop_front</span>();<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      tr_q<span class="hljs-variable">.push_back</span>(tr); <br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>①定义接口：<code>A_export</code>，<code>A_imp</code></p>
<p>②定义功能：数据最终流向A，所以需要A_imp，需要实现数据处理功能，即<code>get</code>，改功能主要将A内transaction发送到B</p>
<p>③连接：在A中把A_export与A_imp连接</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_blocking_get_port<span class="hljs-variable">#(my_transaction)</span> B_port;<span class="hljs-comment">//①</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_port&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      B_port<span class="hljs-variable">.get</span>(tr);<span class="hljs-comment">//④</span><br>      <span class="hljs-meta">`uvm_info(&quot;B&quot;, &quot;get a transaction&quot;, UVM_LOW) </span><br>      tr<span class="hljs-variable">.print</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>① 端口定义</p>
<p>④调用<code>get</code>，这个get最终会调用到A.get，从而获取到A中transcation</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   A   A_inst;<br>   B   B_inst;<br>   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>      A_inst = A::type_id::create(<span class="hljs-string">&quot;A_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   B_inst<span class="hljs-variable">.B_port</span><span class="hljs-variable">.connect</span>(A_inst<span class="hljs-variable">.A_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>③ B_port与A_export连接</p>
</blockquote>
<p><strong>3.其他get端口连接</strong></p>
<p>与<code>blocking_put</code>系列端口类似：</p>
<ul>
<li><code>blocking_get_port</code>也可以直接连接到<code>blocking_get_imp</code></li>
<li><code>blocking_get_port</code>也可以连接到<code>blocking_get_port</code></li>
<li><code>blocking_get_export</code>也可以连接到<code>blocking_get_export</code></li>
</ul>
<p>在这些连接关系中，需要谨记的是连接的终点必须是一个IMP</p>
<h4><span id="428-transport">4.2.8 transport</span></h4><p>特性：<strong>双向</strong>，与<code>*_get</code>和<code>*_put</code>不同，在<code>*_transport</code>系列端口中， 通信变成了双向的，即又有<code>get</code>又有<code>put</code></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221129221331582.png" srcset="/img/loading.gif" lazyload alt="image-20221129221331582"></p>
<p><strong>1.主要步骤：</strong></p>
<blockquote>
<p>第一步：A,B中的端口声明</p>
<p>A中定义一个<code>uvm_blocking_transport_*</code></p>
<p>B中需要定义一个类型为<code>uvm_blocking_transport_imp</code>的IMP</p>
<p>第二步：实现功能</p>
<p>IMP所在的component要实现一个名字为<code>transport</code>任务/函数</p>
<p>第三步：连接</p>
<p>第四步：调用<code>transport</code></p>
</blockquote>
<p><strong>2.代码详解</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_blocking_transport_port<span class="hljs-variable">#(my_transaction, my_transaction)</span> A_transport;<span class="hljs-comment">//①</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_transport = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_transport&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction rsp;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      A_transport<span class="hljs-variable">.transport</span>(tr, rsp);<br>      <span class="hljs-meta">`uvm_info(&quot;A&quot;, &quot;received rsp&quot;, UVM_MEDIUM)</span><br>      rsp<span class="hljs-variable">.print</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>① A中定义一个<code>uvm_blocking_transport_port</code></p>
<p>④ 调用<code>transport</code>，把生成的<code>transaction</code>作为第一个参数<code>REQ</code>发送到B_imp，B_imp接收到这个参数调用<code>transport</code>任务做了点什么，最后把操作的结果作为<code>transport</code>第二个参数<code>RSP</code>返回回去，A根据<code>RSP</code>进行后面操作</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_blocking_transport_imp<span class="hljs-variable">#(my_transaction, my_transaction, B)</span> B_imp;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">task</span> transport(my_transaction req, <span class="hljs-keyword">output</span> my_transaction rsp);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_imp&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::transport(my_transaction req, <span class="hljs-keyword">output</span> my_transaction rsp);<br>   <span class="hljs-meta">`uvm_info(&quot;B&quot;, &quot;receive a transaction&quot;, UVM_LOW) </span><br>   req<span class="hljs-variable">.print</span>();<br>   <span class="hljs-comment">//do something according to req</span><br>   #<span class="hljs-number">5</span>;<br>   rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>① B中需要定义一个类型为<code>uvm_blocking_transport_imp</code>的IMP</p>
<p>② 实现<code>transport</code>，通过A调用主要实现：A把生成的<code>transaction</code>作为第一个参数<code>REQ</code>发送到B_imp，B_imp接收到这个参数调用<code>transport</code>任务做了点什么，最后把操作的结果作为<code>transport</code>第二个参数<code>RSP</code>返回回去，A根据<code>RSP</code>进行后面操作</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   A   A_inst;<br>   B   B_inst;<br>   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>      A_inst = A::type_id::create(<span class="hljs-string">&quot;A_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_inst<span class="hljs-variable">.A_transport</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_imp</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>③ A_transport_port与B_imp连接</p>
</blockquote>
<p><strong>3.其他连接</strong></p>
<ul>
<li>在本例中：<code>uvm_blocking_transport_port</code>直接连接到<code>uvm_blocking_transport_imp</code></li>
<li>还可以：<code>uvm_blocking_transport_port</code>前者还可以连接到<code>uvm_blocking_transport_export</code></li>
<li>总结：<code>uvm_blocking_transport_port</code>，<code>uvm_blocking_transport_export</code>，<code>uvm_blocking_transport_imp</code>连接关系与<code>uvm_blocking_put</code>系列端口类似</li>
</ul>
<h4><span id="429-nonblocking">4.2.9 nonblocking</span></h4><p>特性：<strong>非阻塞</strong>，nonblocking端口的所有操作都是非阻塞的，换言之，<strong>必须用函数实现，而不能用任务实现</strong>，以用nonblocking端口实现图4-8所示的连接关系为例</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130000841385.png" srcset="/img/loading.gif" lazyload alt="没用错"></p>
<p><strong>1.主要步骤：</strong></p>
<blockquote>
<p>第一步：A,B中的端口声明</p>
<p>A中定义一个<code>uvm_nonblocking_*_*_port</code></p>
<p>B中需要定义一个类型为<code>uvm_nonblocking_*_imp</code>的IMP</p>
<p>第二步：实现功能</p>
<p>IMP所在的component要实现：<code>can_put/get/peek</code>函数，<code>try_put/get/peek</code>函数</p>
<p>第三步：连接</p>
<p>第四步：调用</p>
<p>由于端口变为了非阻塞的，所以在送出<code>transaction</code>之前需要调用<code>can_put</code>函数来确认是否能够执行put操作。can_put最终会调用 B中的can_put，然后再调用<code>try_put</code>真正发送到B_imp中</p>
</blockquote>
<p><strong>2.代码详解</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_nonblocking_put_port<span class="hljs-variable">#(my_transaction)</span> A_port;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_port&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      <span class="hljs-keyword">while</span>(!A_port<span class="hljs-variable">.can_put</span>()) #<span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">void</span>&#x27;(A_port<span class="hljs-variable">.try_put</span>(tr));<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>① A中定义一个类型为<code>uvm_nonblocking_put_port</code>的PORT</p>
<p>④ 调用<code>can_put</code>查询是否能发送，<code>try_put</code>进行发送</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_nonblocking_put_imp<span class="hljs-variable">#(my_transaction, B)</span> B_imp;<br>   my_transaction tr_q[$];<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> can_put();<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> try_put(my_transaction tr);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_imp&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> B::can_put();<br>   <span class="hljs-keyword">if</span>(tr_q<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span> <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> B::try_put(my_transaction tr);<br>   <span class="hljs-meta">`uvm_info(&quot;B&quot;, &quot;receive a transaction&quot;, UVM_LOW) </span><br>   <span class="hljs-keyword">if</span>(tr_q<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      tr_q<span class="hljs-variable">.push_back</span>(tr);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::main_phase(uvm_phase phase);<br>    my_transaction tr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>       <span class="hljs-keyword">if</span>(tr_q<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>)<br>          tr = tr_q<span class="hljs-variable">.pop_front</span>();<br>       <span class="hljs-keyword">else</span><br>          #<span class="hljs-number">25</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>① B中定义一个类型为<code>uvm_nonblocking_put_imp</code>的IMP</p>
<p>② 实现<code>can_put</code>查询是否能发送的函数，<code>try_put</code>进行发送数据的处理（这里是直接接收了）</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   A   A_inst;<br>   B   B_inst;<br>   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>      A_inst = A::type_id::create(<span class="hljs-string">&quot;A_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_inst<span class="hljs-variable">.A_port</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_imp</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>涉及：</p>
<p>③ A_port与B_imp连接</p>
</blockquote>
<h4><span id="4210-peek">4.2.10 peek</span></h4><p>详情参考4.3.4节，FIFO中的内容</p>
<blockquote>
<p>peek端口与get相似，其数据流、控制流都相似，唯一的区别在于当get任务被调用时，FIFO内部缓存中会少一个transaction，而 peek被调用时，FIFO会把transaction复制一份发送出去，其内部缓存中的transaction数量并不会减少</p>
</blockquote>
<h4><span id="431-analysis">4.3.1 analysis</span></h4><p>除了4.2提到的5个功能系列（get/put/transport/peek/get_peek），UVM中还有一个功能系列（analysis）可以实现一对多通信的功能，即广播功能，主要有一下三个</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_analysis_port<br>uvm_analysis_export<br>uvm_analysis_imp<br></code></pre></div></td></tr></table></figure>
<p><strong>1.analysis端口与普通端口的区别：</strong></p>
<ul>
<li>一个analysis_port（analysis_export）可以连接多个IMP，且IMP的类型必须是uvm_analysis_imp</li>
<li>对于analysis_port和analysis_export来说，没有阻塞和非阻塞的概念。 因为它本身就是广播，不必等待与其相连的其他端口的响应，所以不存在阻塞和非阻塞</li>
<li>对于analysis系列端口来说，只有一种操作：<code>write</code>（对于普通的put系列端口，有<code>put</code>、<code>try_put</code>、<code>can_put</code>等操作，对于普通的get系列端口，有<code>get</code>、<code>try_get</code>和<code>can_get</code>等操作）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130142739555.png" srcset="/img/loading.gif" lazyload alt="image-20221130142739555"></p>
<p><strong>2.上图analysis端口关键代码实现定义</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////////////// A.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(A)</span><br><br>   uvm_analysis_port<span class="hljs-variable">#(my_transaction)</span> A_ap;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> A::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   A_ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_ap&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> A::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      A_ap<span class="hljs-variable">.write</span>(tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">///////////////////////////// B.sv</span><br><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   uvm_analysis_imp<span class="hljs-variable">#(my_transaction, B)</span> B_imp;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(my_transaction tr);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   B_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;B_imp&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> B::write(my_transaction tr);<br>   <span class="hljs-meta">`uvm_info(&quot;B&quot;, &quot;receive a transaction&quot;, UVM_LOW) </span><br>   tr<span class="hljs-variable">.print</span>();<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> B::main_phase(uvm_phase phase);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">///////////////////////////// C.sv</span><br>除了类型名不一样，实现完全与B一样<br><span class="hljs-comment">//////////////////////////// my_env.sv</span><br><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   A   A_inst;<br>   B   B_inst;<br>   C   C_inst;<br>   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>      A_inst = A::type_id::create(<span class="hljs-string">&quot;A_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      B_inst = B::type_id::create(<span class="hljs-string">&quot;B_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br>      C_inst = C::type_id::create(<span class="hljs-string">&quot;C_inst&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   A_inst<span class="hljs-variable">.A_ap</span><span class="hljs-variable">.connect</span>(B_inst<span class="hljs-variable">.B_imp</span>);<br>   A_inst<span class="hljs-variable">.A_ap</span><span class="hljs-variable">.connect</span>(C_inst<span class="hljs-variable">.C_imp</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="432a-跨层次的三种连接方案">4.3.2a 跨层次的三种连接方案</span></h4><p>考虑图2-13中o_agt的monitor与scoreboard之间的通信，使用analysis_port实现</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////////// mon.sv</span><br><span class="hljs-keyword">class</span> monitor <span class="hljs-keyword">extends</span> uvm_monitor;<br>    uvm_analysis_port<span class="hljs-variable">#(my_transaction)</span> ap;<br>    <br>    <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>        my_transaction tr;<br>        …<br>        ap<span class="hljs-variable">.write</span>(tr);<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">///////////////////////// scb.sv</span><br><span class="hljs-keyword">class</span> scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;<br>    uvm_analysis_imp<span class="hljs-variable">#(my_transaction, scoreboard)</span><br>    scb_imp;<br>    <span class="hljs-keyword">task</span> write(my_transaction tr);<br>        <span class="hljs-comment">//do something on tr</span><br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">///////////////////////// my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>    三种连接方案！<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>在env中可以使用connect连接。由于monitor与scoreboard在UVM树中间隔了o_agt，所以这里有三种连接方式</p>
<p><strong>1.第一种：直接跨层次引用</strong></p>
<p>直接在env中跨层次引用monitor中的ap：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>    o_agt<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scb<span class="hljs-variable">.scb_imp</span>);<br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.第二种：例化端口连接</strong></p>
<p>在agent中声明一个ap并实例化它，在connect_phase将其与monitor的ap相连，并可以在env中把agent的ap直接连接到 scoreboard的imp：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////////// my_agent.sv</span><br><span class="hljs-keyword">class</span> my_agent <span class="hljs-keyword">extends</span> uvm_agent ;<br>    uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span> ap;<span class="hljs-comment">//定义port</span><br>…<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>        ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//例化port</span><br>…<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::connect_phase(uvm_phase phase);<br>        mon<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(<span class="hljs-keyword">this</span><span class="hljs-variable">.ap</span>);<span class="hljs-comment">//连接port</span><br>…<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">///////////////////////// my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>    o_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scb<span class="hljs-variable">.scb_imp</span>);<br>…<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.第三种：间接跨层次引用（推荐）</strong></p>
<p>在agent中声明一个ap，但是不实例化它，让其指向monitor中的ap。在env中可以直接连接agent的ap到scoreboard的 imp：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////////// my_agent.sv</span><br><span class="hljs-keyword">class</span> my_agent <span class="hljs-keyword">extends</span> uvm_agent;<br>    uvm_analysis_port <span class="hljs-variable">#(my_transaction)</span> ap;<br>…<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::connect_phase(uvm_phase phase);<br>        ap = mon<span class="hljs-variable">.ap</span>;<br>…<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">///////////////////////// my_env.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>    o_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scb<span class="hljs-variable">.scb_imp</span>);<br>…<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>第一种最简单，但是其层次关系并不好，第二种稍显麻烦，第三种既具有明显的层次关系，同时其实现也较简单</p>
</blockquote>
<h4><span id="432b-一个component内有多个imp">4.3.2b 一个component内有多个IMP</span></h4><p>问题背景：在上面的例子中，scoreboard只接收一路数据，但在现实情况中，scoreboard除了接收monitor的数据之外，还要接收reference model的数据。相应的scoreboard就要再添加一个 uvm_analysis_imp的IMP，如model_imp。此时问题就出现了，由于接收到的两路数据应该做不同的处理，所以这个新的IMP也要有一个write任务与其对应。但是write只有一个，怎么办？</p>
<p>一句话问题背景（以下内容都以<code>analysis</code>为例）：当一个comp中需要连接多个端口，需要例化多个IMP，多个IMP需要多个<code>write</code>函数，这可怎么办？</p>
<p>方案1：使用FIFO通信，直接不用实现<code>write</code>函数了（4.3中进行解释）</p>
<p>方案2：使用<code>`uvm_analysis_imp_decl</code>宏，直接添加（本节解释）</p>
<hr>
<p><strong>使用方案2：</strong></p>
<p>UVM考虑到了这种情况，它定义了一个宏<code>`uvm_analysis_imp_decl</code>来解决这个问题，其使用方式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////////// my_scoreboard.sv</span><br><span class="hljs-meta">`uvm_analysis_imp_decl(_monitor)//从而声明了后缀_monitor</span><br><span class="hljs-meta">`uvm_analysis_imp_decl(_model)//从而声明了后缀_model</span><br><span class="hljs-keyword">class</span> my_scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;<br>   my_transaction  expect_queue[$];<br>   <br>   uvm_analysis_imp_monitor<span class="hljs-variable">#(my_transaction, my_scoreboard)</span> monitor_imp;<span class="hljs-comment">//imp端口1</span><br>   uvm_analysis_imp_model<span class="hljs-variable">#(my_transaction, my_scoreboard)</span> model_imp;<span class="hljs-comment">//imp端口2</span><br>   <span class="hljs-meta">`uvm_component_utils(my_scoreboard)</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent = <span class="hljs-literal">null</span>);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write_monitor(my_transaction tr);<span class="hljs-comment">//功能函数1</span><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write_model(my_transaction tr);<span class="hljs-comment">//功能函数2</span><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span> <br><br></code></pre></div></td></tr></table></figure>
<p>步骤：</p>
<ul>
<li>上述代码通过宏<code>`uvm_analysis_imp_decl</code>声明了两个后缀<code>_monitor</code>和<code>_model</code><ul>
<li>UVM会根据这两个后缀定义两个新的IMP类： <code>uvm_analysis_imp_monitor</code>和<code>uvm_analysis_imp_model</code>，</li>
</ul>
</li>
<li>在<code>my_scoreboard</code>中分别声明并实例化这两个类：<code>monitor_imp</code>和<code>model_imp</code></li>
<li>当与<code>monitor_imp</code>相连接的<code>analysis_port</code>执行<code>write</code>函数时，会自动调用<code>write_monitor</code>函数</li>
<li>当与<code>model_imp</code>相连接的<code>analysis_port</code>执行<code>write</code>函数时，会自动调用<code>write_model</code>函数</li>
</ul>
<p>所以，只要完成后缀的声明，并在<code>write</code>后面添加上相应的后缀就可以正常工作了</p>
<h4><span id="我的一点总结">我的一点总结</span></h4><p>4.2主要提到了TLM中的三个端口：<code>PORT</code>，<code>EXPORT</code>，<code>IMP</code>，优先级从左往右，控制流从左往右（还有两种端口ananlaysis，4.3节进行分析）</p>
<p>三种端口又根据功能，分为了不同类型：<code>blocking_put</code>，<code>blocking_get</code>，<code>blocking_transport</code>，<code>noblocking_put</code>，<code>noblocking_get</code>，<code>noblocking_transport</code></p>
<p>三种端口在一个连接中应保持功能类型的统一，例如：这是一条完整的<code>put</code>通路从<code>blocking_put_port</code>到<code>blocking_put_export</code>再到<code>blocking_put_imp</code></p>
<p>功能特性主要有：<code>put</code>发送，<code>get</code>接收，<code>transport</code>双向，<code>noblocking</code>非阻塞</p>
<ul>
<li>阻塞：实现的时候可以是任务，从而有了阻塞时间</li>
<li>非阻塞：实现的时候应该全都是函数，不应该有时间</li>
</ul>
<p>IMP类型的端口，需要对数据进行处理，具体讲是需要在定义了IMP端口的类中，实现不同的功能特性任务/函数（对于非阻塞而言只有函数）</p>
<ul>
<li>对于<code>put</code>功能，需要实现数据的接收</li>
<li>对于<code>get</code>功能，需要实现数据的发送（因为port调用了get，get对应到imp.get并最终调用到该类中的相关函数/任务）</li>
<li>对于<code>transport</code>功能，需要实现接收一个请求，返回一个响应</li>
<li>对于<code>nonblocking</code>，需要实现<code>try_*</code>处理函数，以及<code>can_*</code>来判断是否能调用处理函数</li>
</ul>
<h3><span id="43-fifo通信">4.3 FIFO通信</span></h3><p>FIFO的类型有两种：</p>
<ul>
<li>一种是4.3.3中的<code>uvm_tlm_analysis_fifo</code></li>
<li>另外一种是<code>uvm_tlm_fifo</code></li>
</ul>
<p>这两者的唯一差别在于前者有一个<code>analysis_export</code>端口，并且有一个<code>write</code>函数，而后者没有。4.3.4节中介绍的所有端口同时适用于这两者</p>
<h4><span id="433-使用fifo通信">4.3.3 使用FIFO通信</span></h4><p>4.3.2a节中monitor和scoreboard的通信，monitor占据主动地位， 而scoreboard只能被动地接收</p>
<p>那么有没有简单的方法呢？让scoreboard实现主动的接收呢？这两个问题的答案都是肯定的，那就是使用第2章使用的方式：利用<strong>FIFO</strong>来实现monitor和scoreboard的通信</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130152626953.png" srcset="/img/loading.gif" lazyload alt="image-20221130152626953"></p>
<blockquote>
<p>4-14解释</p>
<p>如图4-14b所示，在agent和scoreboard之间添加一个<code>uvm_analysis_fifo</code>，<strong>FIFO的本质是一块缓存加两个IMP</strong></p>
<p>FIFO的连接关系中：</p>
<ul>
<li>在monitor与与FIFO的连接关系中，monitor中依然是<code>analysis_port</code></li>
<li>FIFO中是<code>uvm_analysis_imp</code>，数据流和控制流的方向相同</li>
<li>在scoreboard与FIFO的连接关系中，scoreboard中使用<code>blocking_get_port</code>端口</li>
</ul>
</blockquote>
<p>FIFO的本质：<strong>FIFO的本质是一块缓存加两个IMP</strong></p>
<p><strong>2.FIFO的例化与连接</strong></p>
<p>主要展示my_env.sv（设计框架参考4.3.2a中提到的），FIFO例化与连接的代码</p>
<p>这里再解释一下为什么例化三个FIFO，因为是参考第二章的例子：</p>
<ul>
<li><code>agt_scb_fifo</code>意思是从agent到scoreboard</li>
<li><code>agt_mdl_fifo</code>意思是从agent到model</li>
<li><code>mdl_scb_fifo</code>意思是从model到scoreboard</li>
</ul>
<p>实现了两条到scoreboard的事务级内部通信：</p>
<p>①<code>dut-&gt;agent(monitor)-&gt;scoreboard</code></p>
<p>②<code>agent(drv)-&gt;model-&gt;scoreboard</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">///////////////////// my_env.sv</span><br><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><br>   my_agent   i_agt;<br>   my_agent   o_agt;<br>   my_model   mdl;<br>   my_scoreboard scb;<br>   <br>   uvm_tlm_analysis_fifo <span class="hljs-variable">#(my_transaction)</span> agt_scb_fifo;<br>   uvm_tlm_analysis_fifo <span class="hljs-variable">#(my_transaction)</span> agt_mdl_fifo;<br>   uvm_tlm_analysis_fifo <span class="hljs-variable">#(my_transaction)</span> mdl_scb_fifo;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_env&quot;</span>, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      i_agt = my_agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      o_agt = my_agent::type_id::create(<span class="hljs-string">&quot;o_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>      i_agt<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;<br>      o_agt<span class="hljs-variable">.is_active</span> = UVM_PASSIVE;<br>      mdl = my_model::type_id::create(<span class="hljs-string">&quot;mdl&quot;</span>, <span class="hljs-keyword">this</span>);<br>      scb = my_scoreboard::type_id::create(<span class="hljs-string">&quot;scb&quot;</span>, <span class="hljs-keyword">this</span>);<br>      agt_scb_fifo = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;agt_scb_fifo&quot;</span>, <span class="hljs-keyword">this</span>);<br>      agt_mdl_fifo = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;agt_mdl_fifo&quot;</span>, <span class="hljs-keyword">this</span>);<br>      mdl_scb_fifo = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;mdl_scb_fifo&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_env)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   i_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.analysis_export</span>);<br>   mdl<span class="hljs-variable">.port</span><span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.blocking_get_export</span>);<br>    <br>   mdl<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(mdl_scb_fifo<span class="hljs-variable">.analysis_export</span>);<br>   scb<span class="hljs-variable">.exp_port</span><span class="hljs-variable">.connect</span>(mdl_scb_fifo<span class="hljs-variable">.blocking_get_export</span>);<br>    <br>   o_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(agt_scb_fifo<span class="hljs-variable">.analysis_export</span>);<br>   scb<span class="hljs-variable">.act_port</span><span class="hljs-variable">.connect</span>(agt_scb_fifo<span class="hljs-variable">.blocking_get_export</span>); <br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>构造函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent = <span class="hljs-literal">null</span>, <span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<ul>
<li>FIFO在本质上是一个component，所以其前两个参数是uvm_component的<code>new</code>函数中的两个参数</li>
<li>第三个参数是<code>size</code>，用于设 定FIFO缓存的上限，在默认的情况下为<u>1</u>，如果为<u>0</u>则缓存无限</li>
</ul>
<p>连接要点：</p>
<ul>
<li>使用FIFO通信后，连接主要是FIFO的连接</li>
<li>FIFO上没有<code>IMP</code>，因为<code>EXPORT</code>就是<code>IMP</code>实现的，解释见下方</li>
</ul>
<p>连接到FIFO的是EXPORT而不是IMP</p>
<p>原因：</p>
<p>实际上，FIFO中的<code>analysis_export</code>和<code>blocking_get_export</code>虽然名字中有关键字export，但是其类型却是IMP。UVM为了掩饰IMP的存在，在它们的命名中加入了export关键字。如<code>analysis_export</code>的原型如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&gt;uvm_analysis_imp <span class="hljs-variable">#(T, uvm_tlm_analysis_fifo #(T))</span> analysis_export;<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>3.FIFO连接的好处</strong></p>
<p>第一个好处是不必在scoreboard中再写一个名字为write的函数。scoreboard可以按照自己的节奏工作，而不必跟着monitor的节奏</p>
<p>第二个好处是FIFO的存在隐藏了IMP，这对于初学者来说比较容易理解</p>
<p>第三个好处是可以轻易解决上一节讲到的当reference model和monitor同时连接到scoreboard应如何处理的问题。事实上，FIFO的存在自然而然地解决了它，这根本就不是一个问题了</p>
<h4><span id="434a-fifo上的端口">4.3.4a FIFO上的端口</span></h4><p>4.3.3介绍了FIFO上的<code>blocking_get_export</code>（用于数据获取）和<code>analysis_export</code>（用于数据输入）端口（两个端口实际上是IMP），实际上FIFO端口有众多接口。<code>uvm_tlm_analysis_fifo</code>端口示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130165225736.png" srcset="/img/loading.gif" lazyload alt="image-20221130165225736"></p>
<blockquote>
<p>端口：</p>
<p>一共有12+1+2=15个端口，其中12个export是除transport系列外的12种IMP，1个是<code>uvm_tlm_analysis_fifo</code>的<code>analysis_export</code>，2个是<code>analysis_port</code></p>
<p>2个<code>analysis_port</code>的作用：</p>
<blockquote>
<p><code>put_ap</code>：</p>
<ul>
<li>大致内容：FIFO的<code>put</code>任务被调用后，不仅会缓存数据到FIFO，还会通过<code>put_ap</code>端口额外发送出transaction</li>
<li>具体细节：当FIFO上的<code>blocking_put_export</code>或者<code>put_export</code>被连接到一 个<code>blocking_put_port</code>或者<code>put_port</code>上时，FIFO内部被定义的<code>put</code>任务被调用，这个<code>put</code>任务把传递过来的transaction放在FIFO内部的缓存里，<strong>同时</strong>，把这个<code>transaction</code>通过<code>put_ap</code>使用<code>write</code>函数发送出去。FIFO的put任务定义如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> put(<span class="hljs-keyword">input</span> T t);<br>    m<span class="hljs-variable">.put</span>(t);<span class="hljs-comment">//m即是FIFO内部的缓存，使用SystemVerilog中的mailbox来实现</span><br>    put_ap<span class="hljs-variable">.write</span>(t);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><code>get_ap</code>：</p>
<ul>
<li>与<code>put_ap</code>相似，当FIFO的<code>get</code>任务被调用时，同样会有一个transaction从get_ap上发出，FIFO的get任务定义如下</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> get(<span class="hljs-keyword">output</span> T t);<br>    m_pending_blocked_gets++;<br>    m<span class="hljs-variable">.get</span>(t);<br>    m_pending_blocked_gets--;<br>    get_ap<span class="hljs-variable">.write</span>(t);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
</blockquote>
<h4><span id="434b-fifo的调试函数">4.3.4b FIFO的调试函数</span></h4><p>UVM也提供了几个函数用于FIFO的调试</p>
<ul>
<li><code>used()</code>函数用于查询FIFO缓存中有多少transaction</li>
<li><code>is_empty()</code>函数用于判断当前FIFO缓存是否为空</li>
<li><code>is_full()</code>用于判断当前FIFO缓存是否已经满了</li>
<li><code>flush()</code>用于清空FIFO缓存中的所有数据，一般用于复位</li>
</ul>
<h3><span id="44-用fifo还是用imp端口数组与for循环">4.4 用FIFO还是用IMP（端口数组与for循环）</span></h3><p>每个人对于这个问题都有各自不同的答案</p>
<p>FIFO优点：</p>
<ul>
<li>在用FIFO通信的方法中，完全隐藏了IMP这个UVM中特有、而TLM中根本就没有的东西。用户可以完全不关心IMP。因此，对于用户来说，只需要知道<code>analysis_port</code>、<code>blocking_get_port</code>即可。这大大简化了初学者的工作量。尤其是在scoreboard面临多个IMP，且需要为IMP声明一个后缀时，这种优势更加明显</li>
<li>对于使用<strong>端口数组</strong>的情况，FIFO要优于IMP，可以使用for循环进行例化、函数调用和端口连接（端口数组&lt;—&gt;FIFO数组的端口）</li>
</ul>
<p>FIFO缺点：FIFO连接的方式增加了env中代码的复杂度，满满的看上去似乎都是与FIFO相关的代码。尤其是当要连接的端口数量众多时，这个缺点更加明显（毕竟直连不需要在env中例化FIFO，且只需要写一行connect就够了）</p>
<p>2022年11月30日，20:25:04</p>
<h2><span id="第5章-uvm验证平台的运行">第5章 UVM验证平台的运行</span></h2><h3><span id="51-phase机制">5.1 <mark>phase机制</mark></span></h3><h4><span id="511-phase基础"><strong>5.1.1 phase基础</strong></span></h4><p><strong>1.phase分类</strong></p>
<p>UVM中的phase，按照其是否消耗仿真时间（<code>$time</code>打印出的时间）的特性，可以分成两大类：</p>
<ul>
<li>function phase：下图中白色的phase</li>
<li>task phase：下图中灰色的phase，包括<code>run_phase</code>和12个<code>run-tiime phase</code></li>
</ul>
<p>对于task phase分为两种，一种是<code>run_phase</code>，一种是<code>run-time(运行时/动态运行时) phase</code>，其中<code>run-time phase</code>包括12个小phase</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221130205806862.png" srcset="/img/loading.gif" lazyload alt="image-20221130205806862"></p>
<blockquote>
<p>总结：</p>
<ul>
<li><code>reset_phase</code>主要做一些清理工作，并等待复位完成</li>
</ul>
<p>为什么这么多phase</p>
<ul>
<li>不会都用：在一般的应用中，无论是<code>function phase</code>还是<code>task phase</code>都不会将它们全部用上</li>
<li>使用频率最高：的是<code>build_phase</code>、<code>connect_phase</code>和<code>main_phase</code></li>
<li>好处，方便迁移：这么多phase除了方便验证人员将不同的代码写在不同的phase外，还有利于其他验证方法学向UVM迁移。一般的验证方法学都会把仿真分成不同的阶段，但是这些阶段的划分通常没有UVM分得这么多、这么细致。所以一般来说，当其他验证方法学向UVM迁移的时候，总能找到一个phase来对应原来方法学中的仿真阶段，这为迁移提供了便利</li>
</ul>
<p><code>run-time phase</code>引入时间：动态运行（run-time）phase是UVM1.0引入的新的phase，其他phase则在UVM1.0之前（即UVM1.0EA版和OVM中）就已经存在了</p>
<p>为什么引入12个<code>run-time phase</code>？</p>
<ul>
<li>为了精细化的控制：分成小的phase是为了实现更加精细化的控制。reset、configure、main、shutdown四个phase是核心，这四个phase通常模拟DUT的正常工作方式，在reset_phase对DUT进行复位、初始化等操作，在configure_phase则进行DUT的配置，DUT的运行主要在main_phase完成，shutdown_phase则是做一些与DUT断电相关的操作。通过细分实现对DUT更 加精确的控制。假设要在运行过程中对DUT进行一次复位（reset）操作，在没有这些细分的phase之前，这种操作要在 scoreboard、reference model等加入一些额外的代码来保证验证平台不会出错。但是有了这些小的phase之后，分别在scoreboard、 reference model及其他部分（如driver、monitor等）的reset_phase写好相关代码，之后如果想做一次复位操作，那么只要通过phase的跳转，就会自动跳转回reset_phase。（关于跳转的内容，请参考5.1.7节）</li>
<li><code>run_phase</code>是OVM遗留的</li>
</ul>
<p>phase作用</p>
<ul>
<li>function phase：八个<code>phase</code></li>
<li>task phase：<code>run_phase</code>以及12个<code>run-time phase</code></li>
</ul>
<blockquote>
<p>function phase</p>
<blockquote>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">connect_phase</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>传递实例句柄，包括：<ul>
<li><code>reg_model</code>实例在base中传递给<code>env</code>，<code>env</code>传递给<code>ref_model</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><code>run-time phase</code>：</p>
<blockquote>
<p><code>reset</code>、<code>configure</code>、<code>main</code>、<code>shutdown</code>四个phase是核心，这四个phase通常模拟DUT的正常工作方式，通过细分实现对DUT更加精确的控制</p>
</blockquote>
<ul>
<li>在<code>reset_phase</code>对DUT进行复位、初始化等操作</li>
<li>在<code>configure_phase</code>则进 行DUT的配置</li>
<li>DUT的运行主要在<code>main_phase</code>完成</li>
<li><code>shutdown_phase</code>则是做一些与DUT断电相关的操作</li>
</ul>
<p><code>run_phase</code>是OVM遗留的</p>
</blockquote>
</blockquote>
<p><strong>2.phase执行的时间顺序</strong></p>
<p>phase首先是按照时间决定当前应该执行哪个phase，再从空间中遍历所有组件运行，当所有组件执行完后该phase进入到下一个phase</p>
<p>所有的phase都会按照图5-1中的顺序<strong>自上而下</strong>自动执行/启动：</p>
<ul>
<li>对于function phase同一时间只有一个phase在执行</li>
<li>对于task phase有两个phase并行：<code>run_phase</code>和某个<code>run-time phase</code>并行运行，顺序大致如下代码<ul>
<li>对于<code>run-time phase</code>，执行也是从上到下进行</li>
<li>使用domain特性可将不同组件的<code>run-time phase</code>分隔（见5.3节）</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span><br>    <span class="hljs-keyword">begin</span><br>        run_phase();<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">begin</span><br>        pre_reset_phase(); <br>        reset_phase();<br>        post_reset_phase();<br>        pre_configure_phase();<br>        configure_phase();<br>        post_configure_phase();<br>        pre_main_phase();<br>        main_phase();<br>        post_main_phase();<br>        pre_shutdown_phase();<br>        shutdown_phase();<br>        post_shutdown_phase();<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">join</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.phase执行的空间顺序（以UVM树的视角）</strong></p>
<blockquote>
<p>主要顺序：</p>
<ul>
<li>build_phase：自上而下</li>
<li>其他所有phase(function,task phase)：自下而上</li>
</ul>
<p>同一层次顺序：根据例化时的名称使用字典序的排序</p>
<p>注意：UVM并未保证一直会是这个顺序（这个顺序是在UVM1.1d源代码中找到的，UVM并未保证一直会是这个顺序）。如果代码存在依赖这种顺序的执行，必须立刻修改，并杜绝这种依赖出现</p>
<p>UVM树的遍历顺序：深度优先</p>
<p>注意：如果存在要求位于不同分支的两个组件，某一组件phase提前于另一组件phase执行的代码，必须立刻修改，并杜绝这种依赖出现</p>
<p>不同组件的<code>task phase</code>顺序并行启动</p>
<p><code>task phase</code>运行耗费时间，所以它并不是等到“下面”的phase（如driver的<code>run_phase</code>）执行完才执行“上面”的phase（如agent 的<code>run_phase</code>），而是将这些<code>run_phase</code>通过<code>fork…join_none的</code>形式全部启动。所以，更准确的说法是自下而上的启动，同时在运行</p>
<p>不同组件的<code>task phase</code>执行同步（三个同步）：</p>
<ul>
<li>所有组件<code>run-time phase</code>之间需要同步（即所有组件某一<code>run-time phase</code>都进行结束，才代表该<code>run-time phase</code>进行结束，否则提前结束的组件进行等待）</li>
<li>所有组件<code>run_phase</code>需要同步（即所有组件<code>run_phase</code>都进行结束，才代表<code>run_phase</code>进行结束，否则提前结束的组件进行等待）</li>
<li><code>run_phase</code>与<code>post_shutdown_phase</code>的同步（即所有组件的<code>run_phase</code>和<code>pose_shutdown_phase</code>都结束，才代表<code>task phase</code>结束，进入<code>extract_phase</code>）</li>
</ul>
</blockquote>
<h4><span id="515-superphase的使用">5.1.5 super.phase的使用</span></h4><p>前文代码中有的地方调用<code>super.xxx_phase</code>有的地方不调用，这里做下总结</p>
<hr>
<p><strong>1.前文代码中</strong></p>
<p>在<code>main_phase</code>中，有时出现<code>super.main_phase</code>， 有时又不会；</p>
<p>在<code>build_phase</code>中，一般都会出现<code>super.build_phase</code></p>
<p><strong>2.何时调用<code>super.xxx_phase</code></strong></p>
<p>何时调用<code>super.xxx_phase</code>？</p>
<ul>
<li>场景1（使用机制）：对于<code>build_phase</code>且需要自动获取<code>config_dg::set</code>设置参数(<mark>config_db</mark>)，或使用了<mark>field automation</mark>的时需要调用<code>super.build_phase</code>（如果<code>build_phase</code>不需要自动获得参数就不调用<code>super.build_phase</code>）</li>
<li>场景2（继承）：对于用户自定义类的子类，如果自定义的父类在某个<code>phase</code>中定义了重要内容，则子类中应该调用<code>super.xxx_phase</code></li>
<li>其他大多数情况完全可以不加上<code>super.xxxx_phase</code>语句，如第2章中所有的<code>super.main_phase</code>都可以去掉。因为除了<code>build_phase</code>外，UVM实现的基础<code>phase</code>没有任何作用，如下代码所示</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::connect_phase(uvm_phase phase);<br>    connect();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::start_of_simulation_phase(uvm_phase phase);<br>    start_of_simulation();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::end_of_elaboration_phase(uvm_phase phase);<br>    end_of_elaboration();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">task</span> uvm_component::run_phase(uvm_phase phase);<br>    run();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::extract_phase(uvm_phase phase);<br>    extract();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::check_phase(uvm_phase phase);<br>    check();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::report_phase(uvm_phase phase);<br>    report();<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::connect(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::start_of_simulation(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::end_of_elaboration(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> uvm_component::run(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::extract(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::check(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::report(); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_component::final_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> uvm_component::pre_reset_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::reset_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::post_reset_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::pre_configure_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::configure_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::post_configure_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::pre_main_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::main_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::post_main_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::pre_shutdown_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::shutdown_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> uvm_component::post_shutdown_phase(uvm_phase phase); <span class="hljs-keyword">return</span>; <span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.补充</strong></p>
<p>以下是我在搜索资料的时候找到的内容</p>
<blockquote>
<p>函数/任务内部成员变量定义应在最前面</p>
<p>在my_model中，super用于my_transaction 声明之前如图 </p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/165940jab2g1y11hkftt9a-166989718169113.png" srcset="/img/loading.gif" lazyload alt="428448-20160630154322874-1802420566.png"></p>
<p>会出现下图错误</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/165847yqpta82scoqsot2t-166989716460610.png" srcset="/img/loading.gif" lazyload alt="428448-20160630154322874-1802420566.png"></p>
<p>这样定义则正常，如图</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/170049kzs3ssxc0zzt09xt.png" srcset="/img/loading.gif" lazyload alt="428448-20160630154322874-1802420566.png"></p>
<p>原因：SystemVerilog要求，声明必须位于语句之前（调用<code>super.xxx_phase</code>就已经开始运行语句了）</p>
<p><a target="_blank" rel="noopener" href="https://bbs.eetop.cn/thread-852901-1-1.html">https://bbs.eetop.cn/thread-852901-1-1.html</a></p>
<p><code>new</code>构造函数</p>
<p><code>new</code>构造函数必须调用<code>super.new(name, parent);</code>，原因：SystemVerilog要求扩展类构造函数调用</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37672145/example-with-super-function-call-in-uvm">https://stackoverflow.com/questions/37672145/example-with-super-function-call-in-uvm</a></p>
</blockquote>
<h4><span id="516-build_phase与uvm_error">5.1.6 build_phase与UVM_ERROR</span></h4><p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201203549829.png" srcset="/img/loading.gif" lazyload alt="image-20221201203549829"></p>
<p>在<code>end_of_elaboration_phase</code>及其前的phase中，如果出现了一个或多个<code>UVM_ERROR</code>，那么UVM就认为出现了致命错误，会调用uvm_fatal结束仿真。</p>
<blockquote>
<p>好处：提高debug效率</p>
<p>UVM的这个特性在小型设计中体现不出优势，但是在大型设计中，这一特性非常有用。大型设计中，真正仿真前的编译、优化可能会花费一个多小时的时间。完成编译、优化后开始仿真，几秒钟后，出现一个<code>uvm_fatal</code>就停止仿真。当修复了这个问题后，再次重新运行，发现又有一个<code>uvm_fatal</code>出现。如此反复，可能会耗费大量时间。但是如果将这些<code>uvm_fatal</code>替换为<code>uvm_error</code>，将所有类似的问题一次性暴露出来，一次性修复，这会极大缩减时间，提高效率</p>
<p>2.2.4节</p>
<p>我们在<code>connect_phase</code>中，如果<code>config_db::set</code>没有设置成功用则调用<code>`uvm_fatal</code>来结束仿真</p>
<p>事实上这里调用<code>`uvm_error</code>也能结束仿真</p>
</blockquote>
<h4><span id="517-phase的跳转">5.1.7 phase的跳转</span></h4><p>整个验证平台的phase可以实现跳转，通过调用下方两个函数，进行跳转和参数的获取（补充：多domain的<code>run-time phase</code>跳转phase的跳转只能局限在某一domain中（原文5.3.3））</p>
<blockquote>
<p>跳转函数<code>jump</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_phase::jump(uvm_phase phase);<br></code></pre></div></td></tr></table></figure>
<ul>
<li>参数必须是一个<code>uvm_phase</code>类型的变量</li>
</ul>
<p><code>uvm_phase</code>类型的变量获取方式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_build_phase::get();<br>uvm_connect_phase::get();<br>uvm_end_of_elaboration_phase::get();<br>uvm_start_of_simulation_phase::get();<br>uvm_run_phase::get();<br>uvm_pre_reset_phase::get();<br>uvm_reset_phase::get();<br>uvm_post_reset_phase::get();<br>uvm_pre_configure_phase::get();<br>uvm_configure_phase::get();<br>uvm_post_configure_phase::get();<br>uvm_pre_main_phase::get();<br>uvm_main_phase::get();<br>uvm_post_main_phase::get();<br>uvm_pre_shutdown_phase::get();<br>uvm_shutdown_phase::get();<br>uvm_post_shutdown_phase::get()<br>uvm_extract_phase::get();<br>uvm_check_phase::get();<br>uvm_report_phase::get();<br>uvm_final_phase::get();<br></code></pre></div></td></tr></table></figure>
<p>那些phase可以作为jump的参数呢？</p>
<ul>
<li><code>uvm_reset_phase::get();</code>及以后的phase（除<code>run_phase</code>）</li>
<li><code>run_phase</code>也是不可以跳转的</li>
</ul>
<p>向前跳转与向后跳转</p>
<p>从<code>main_phase</code>跳转到reset_phase是一种向前跳转，这种向前跳转中，只能是<code>main_phase</code>前的动态运行(run-time phase)中的一个</p>
<p>从<code>main_phase</code>跳转到<code>shutdown_phase</code>是一种向后跳转，在向后跳转中，除了动态运行的phase外(run-time phase)，还可以是函数phase，如可以从<code>main_phase</code>跳转到<code>final_phase</code></p>
</blockquote>
<p>我知道你在找这张图</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201230236248.png" srcset="/img/loading.gif" lazyload alt="image-20221201230236248"></p>
<p><strong>2.一个示例</strong></p>
<p>假如在验证平台中监测到reset_n信号为低电平，则马上从<code>main_phase</code>跳转到<code>reset_phase</code>，driver的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::reset_phase(uvm_phase phase);<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>); <br>   <span class="hljs-meta">`uvm_info(&quot;driver&quot;, &quot;reset phase&quot;, UVM_LOW)</span><br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>); <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_info(&quot;driver&quot;, &quot;main phase&quot;, UVM_LOW)</span><br>   <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>         drive_one_pkt(req);<br>         seq_item_port<span class="hljs-variable">.item_done</span>();<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>         @(<span class="hljs-keyword">negedge</span> vif<span class="hljs-variable">.rst_n</span>);<br>         phase<span class="hljs-variable">.jump</span>(uvm_reset_phase::get());<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">reset_phase`主要做一些清理工作，并等待复位完成。`main_phase`中一旦监测到reset_n为低电平，则马上跳转到`reset_phase<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>在my_case中控制objection代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case0::reset_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_info(&quot;case0&quot;, &quot;reset_phase&quot;, UVM_LOW)</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-meta">`uvm_info(&quot;case0&quot;, &quot;main_phase&quot;, UVM_LOW)</span><br>   #<span class="hljs-number">10000</span>;<br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>运行上面例子的结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># UVM_INFO my_case0<span class="hljs-variable">.sv</span>(<span class="hljs-number">15</span>) @ <span class="hljs-number">0</span>: uvm_test_top [case0] reset_phase<br># UVM_INFO my_driver<span class="hljs-variable">.sv</span>(<span class="hljs-number">25</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span> [driver] reset phase<br># UVM_INFO my_case0<span class="hljs-variable">.sv</span>(<span class="hljs-number">20</span>) @ <span class="hljs-number">1100</span>: uvm_test_top [case0] main_phase<br># UVM_INFO my_driver<span class="hljs-variable">.sv</span>(<span class="hljs-number">34</span>) @ <span class="hljs-number">1100</span>: uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span> [driver] main phase<br># UVM_INFO /home/landy/uvm/uvm-<span class="hljs-number">1</span><span class="hljs-variable">.1d</span>/src/base/uvm_phase<span class="hljs-variable">.svh</span>(<span class="hljs-number">1314</span>) @ <span class="hljs-number">4000</span>: repo-rter[PH_JUMP] phase main<br># UVM_WARNING @ <span class="hljs-number">4000</span>: main_objection [OBJTN_CLEAR] Object &#x27;uvm_top&#x27; cleared ob jection counts <span class="hljs-keyword">for</span> main_objection<br># UVM_INFO my_case0<span class="hljs-variable">.sv</span>(<span class="hljs-number">15</span>) @ <span class="hljs-number">4000</span>: uvm_test_top [case0] reset_phase<br># UVM_INFO my_driver<span class="hljs-variable">.sv</span>(<span class="hljs-number">25</span>) @ <span class="hljs-number">4000</span>: uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span> [driver] reset phase<br># UVM_INFO my_case0<span class="hljs-variable">.sv</span>(<span class="hljs-number">20</span>) @ <span class="hljs-number">7100</span>: uvm_test_top [case0] main_phase<br># UVM_INFO my_driver<span class="hljs-variable">.sv</span>(<span class="hljs-number">34</span>) @ <span class="hljs-number">7100</span>: uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span> [driver] main phase<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>结果整个验证平台都从<code>main_phase</code>跳转到了<code>reset_phase</code></strong></li>
<li>出现了一个UVM_WARNING</li>
<li>整个验证平台phase的运行结果图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221201232244548.png" srcset="/img/loading.gif" lazyload alt="image-20221201232244548"></p>
<blockquote>
<p>为什么会有<code>UVM_WARNING</code>？</p>
<p>这是因为在 my_driver中调用jump时，并没有把my_case0中提起的objection进行撤销</p>
</blockquote>
<p><strong>3.跳转的清理！！！</strong></p>
<p>跳转中最难的地方在于跳转前后的清理和准备工作。如上面的运行结果中的警告信息就是因为没有及时对objection进行清理</p>
<p>对于scoreboard来说，这个问题可能尤其严重。在跳转前，scoreboard的<code>expect_queue</code>中的数据应该清空，同时要容忍跳转后DUT可能输出一些异常数据。</p>
<h4><span id="518-phase机制的必要性">5.1.8 phase机制的必要性</span></h4><p><strong>1.Verilog背景</strong></p>
<p>Verilog中有非阻塞赋值和阻塞赋值，相对应的，在仿真器中要实现分为NBA区域和Active区域[1]，这样在不同的区域做不同 的事情，可以避免因竞争关系导致的变量值不确定的情况。同样的，验证平台是很复杂的，要搭建一个验证平台是一件相当繁杂的事情，要正确地掌握并理顺这些步骤是一个相当艰难的过程</p>
<blockquote>
<p>[1] 可以参照《IEEE Std 1364—2005 IEEE Standard Verilog® Hardware Description Language》</p>
<p>其他参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dinghj3/article/details/122513314">https://blog.csdn.net/dinghj3/article/details/122513314</a></p>
</blockquote>
<p><strong>2.UVM的phase</strong></p>
<ul>
<li>在不同时间做不同的事情，这就是UVM中phase的设计哲学</li>
<li>仅仅划分成phase是不够的，phase的自动执行功能才极大方便了用户</li>
<li>phase的引入在很大程度上解决了因代码顺序杂乱可能会引发的问题。遵循UVM的代码顺序划分原则（如build_phase做实例化工作，connect_phase做连接工作等），可以在很大程度上减少验证平台开发者的工作量，使其从一部分杂乱的工作中解脱出来</li>
</ul>
<h4><span id="519-phase的调试">5.1.9 phase的调试</span></h4><p>如果碰到问题后每次都使用<code>`uvm_info</code>在每个phase打印不同的信息显然是不能满足要求的，使用命令行参数自动打印</p>
<p>命令行参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&lt;sim <span class="hljs-built_in">command</span>&gt; +UVM_PHASE_TRACE<br></code></pre></div></td></tr></table></figure>
<p>运行时命令输出：</p>
<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1124) @ 0: reporter [PH/TRC/STRT] Phase &#x27;uvm </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1203) @ 0: reporter [PH/TRC/SKIP] Phase &#x27;uvm </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1381) @ 0: reporter [PH/TRC/DONE] Phase &#x27;uvm </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1403) @ 0: reporter [PH/TRC/SCHEDULED] Phase </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1124) @ 0: reporter [PH/TRC/STRT] Phase &#x27;uvm </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1203) @ 0: reporter [PH/TRC/SKIP] Phase &#x27;uvm </span><br><span class="hljs-meta"># UVM_INFO /home/landy/uvm/uvm-1.1d/src/base/uvm_phase.svh(1381) @ 0: reporter [PH/TRC/DONE] Phase &#x27;uvm</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="5110-超时退出">5.1.10 超时退出</span></h4><p>超时背景：在验证平台运行时，有时测试用例会出现挂起（hang up）的情况。在这种状态下，仿真时间一直向前走，driver或者monitor并没有发出或者收到transaction，也没有<code>UVM_ERROR</code>出现</p>
<p>测试用例特性：一个测试用例的运行时间是可以预计的，如果超出了这个时间，那么通常就是出错了。在UVM中通过<code>uvm_root</code>的<code>set_timeout</code>函数可以设置超时时间：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//文件：src/ch5/section5.1/5.1.10/base_test.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    env = my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);<br>    uvm_top<span class="hljs-variable">.set_timeout</span>(<span class="hljs-number">500</span>ns, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>如上的代码将超时的时间定为500ns。如果达到500ns时，测试用例还没有运行完毕，则会给出一条uvm_fatal的提示信息，并退出仿真</p>
<p><code>set_timeout</code>：</p>
<ul>
<li>参数1：要设置的时间</li>
<li>参数2：此设置是否可以被其后的其他set_timeout语句覆盖（0不可以，1可以）</li>
</ul>
<p><code>`UVM_DEFAULT_TIMEOUT</code>宏：</p>
<ul>
<li>默认的超时退出时间是9200s，是通过宏<code>`UVM_DEFAULT_TIMEOUT</code>来指定的</li>
</ul>
<p>命令行</p>
<ul>
<li>除了可以在代码中设置超时退出时间外，还可以在命令行中设置</li>
<li>其中<code>timeout</code>是要设置的时间，<code>overridable</code>表示能否被覆盖，其值可以是YES或者NO</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +UVM_TIMEOUT=&lt;timeout&gt;,&lt;overridable&gt;<br>如<br>&lt;sim command&gt; +UVM_TIMEOUT=<span class="hljs-string">&quot;300ns, YES&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>总结一下提到过让验证平台停止的方法：</p>
<ol>
<li>直接<code>`uvm_fatal</code></li>
<li>设置<code>UVM_ERROR</code>阈值</li>
<li>在<code>end_of_elaboration_phase</code>及其前的phase中，直接调用<code>`uvm_error</code></li>
<li><code>set_timeout</code>超时退出</li>
<li><code>drop_objection</code>通知系统可以关闭验证平台（之前需要先<code>raise_objection</code>）</li>
</ol>
</blockquote>
<h3><span id="52-objection机制">5.2 <mark>objection机制</mark></span></h3><p>objection字面的意思——反对、异议</p>
<h4><span id="521-objection与task-phase">5.2.1 objection与task phase</span></h4><p>objection的引入是为了解决何时结束仿真的问题，它更多面向<code>task phase</code>，而不是面向<code>function phase</code>，不过在<code>function phase</code>中使用也不报错（原文5.2.2）</p>
<p><strong>1.机制使用</strong></p>
<p>在验证平台中，可以通过<code>drop_objection</code>来通知系统可以关闭验证平台。当然，在撤销 之前首先要</p>
<p><code>raise_objection</code>，示例代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> main_phase(uvm_phase phase); =<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>…<br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>endtas<br></code></pre></div></td></tr></table></figure>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> raise_objection (   uvm_object  obj  =  <span class="hljs-literal">null</span>,<br>                                      <span class="hljs-keyword">string</span>  description  =  <span class="hljs-string">&quot;&quot;</span>,<br>                                      <span class="hljs-keyword">int</span>     count    =  <span class="hljs-number">1</span>   )<br></code></pre></div></td></tr></table></figure>
<ul>
<li>第一个形参phase是加入objection的phase，如果未指定<em>object</em>或为 null，则选择隐式顶级组件<a target="_blank" rel="noopener" href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.1c/html/files/base/uvm_root-svh.html#uvm_root">uvm_root</a></li>
<li>第二个形参是字符串，用于标记特定的反对意见，用于跟踪/调试，默认为空</li>
<li>第三个形参为objection的数量，默认为1</li>
</ul>
</blockquote>
<p><strong>2.phase与objection</strong></p>
<p><strong>1.UVM</strong></p>
<ul>
<li>在进入到某一phase时，UVM会收集此phase提出的所有objection，并实时监测所有objection是否已经被撤销</li>
<li>当发现所有objection都已经撤销后，那么就会关闭此phase，开始进入下一个phase</li>
<li>如果UVM发现此phase没有提起任何objection，那么将会直接跳转到下一个phase中</li>
<li>当所有的phase都执行完毕后，就会调用<code>$finish</code>来将整个的验证平台关掉</li>
</ul>
<p><strong>2.<code>run_phase</code>与<code>run-time phase</code>的objection</strong></p>
<p>对于<code>run_phase</code>来说，有两种方式<code>rasie_objection</code>：</p>
<ul>
<li>方式1：其他<code>run-time phase</code>中有<code>rasie_objection</code></li>
<li>方式2：自己<code>rasie_objection</code></li>
</ul>
<p>对于<code>run-time phase</code>只能自己<code>rasie_objection</code>，在<code>run_phase</code>中的<code>rasie_objection</code>对它没有作用</p>
<h4><span id="522-形参phase的必要性">5.2.2 形参phase的必要性</span></h4><p>所有phase的函数/任务的形参中，都有一个<code>phase</code>，如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br></code></pre></div></td></tr></table></figure>
<p>为什么要有这个形参？</p>
<p>因为要便于在任何component的phase中都能<code>raise_objection</code>，而要<code>raise_objection</code>则必须通过<code>phase.raise_objection</code>来完成，所以必须将phase作为参数传递到<code>main_phase</code>等任务中。可以想象，如果没有这个phase参数，那么想要提起一个objection就会比较麻烦了</p>
<hr>
<p>作者真能扯</p>
<h4><span id="523-在哪控制objection">5.2.3 在哪控制objection</span></h4><blockquote>
<p>在第2章的例子中，最初是在driver中<code>raise_objection</code>，但是事实上，在driver中<code>raise_objection</code>的时刻并不多。这是因为driver中通常都是一个无限循环的代码，由于无限循环的特性，<code>phase.drop_objection</code>永远不会被执行到</p>
</blockquote>
<p>在<code>driver</code>，<code>monitor</code>和<code>reference model</code>中，有类似的情况，它们都是无限循环的，因此一般其中控制objection</p>
<hr>
<p>一般来说，在一个实际的验证平台中，通常会选择以下两种方案之一：</p>
<p><strong>方案1</strong>：在<code>scoreboard</code>中进行控制</p>
<p>在2.3.6节中，<code>scoreboard</code>的<code>main_phase</code>被做成一个无限循环如果要在<code>scoreboard</code>中控制objection，则需要去除这个无限循环，通过<code>config_db::set</code>的方式设置收集到的transaction的数量<code>pkt_num</code>，当收集到足够数量的transaction后跳出循环：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">fork</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            exp_port<span class="hljs-variable">.get</span>(get_expect);<br>            expect_queue<span class="hljs-variable">.push_back</span>(get_expect);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pkt_num; i++) <span class="hljs-keyword">begin</span><br>            act_port<span class="hljs-variable">.get</span>(get_actual);<br>            …<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">join_any</span><br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>上述代码中将原本的<code>fork...join</code>语句改为了<code>fork...join_any</code>。当收集到足够的transaction后，第二个进程终结，从而跳出 fork…join_any，执行<code>drop_objection</code>语句</p>
<p><strong>方案2</strong>：如在第2章中介绍的例子那样，在<code>sequence</code>中提起<code>sequencer</code>的objection，当<code>sequence</code>完成后，再撤销此objection</p>
<p><strong>总结</strong>：以上两种方式在验证平台中都有应用。其中用得最多的是第二种，这种方式是UVM提倡的方式。UVM的设计哲学就是全部 由sequence来控制激励的生成，因此<u><strong>一般情况下只在sequence中控制objection</strong></u></p>
<h4><span id="524-drain_time撤销objection延时">5.2.4 drain_time（撤销objection延时）</span></h4><p>在sequence中，n时刻发送完毕最后一个transaction，如果此时立刻<code>drop_objection</code>，那么最后在n+p时刻DUT输出的包将无法接收到。因此，在sequence中，最后一个包发送完毕后，要延时p时间才能<code>drop_objection</code></p>
<p><strong>1.考虑两种实现方式</strong></p>
<p>第一种，直接<code>#</code>（无法控制延迟时间）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>    <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>        starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span> <br>        <span class="hljs-meta">`uvm_do(m_trans)</span><br>    <span class="hljs-keyword">end</span><br>    #<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>        starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>缺点：</p>
<ul>
<li>随机发送激励时，延时的大小也是随机的，所以<strong>无法精确地控制延时</strong>，只能根据激励选择一个最大的延时</li>
<li>如果某一天，DUT对于同样的激励，其处理延时变大，那就要修改所有的延时大小</li>
</ul>
</blockquote>
<p>第二种，使用drain_time</p>
<p>所谓drain_time，就是所有objection被撤销后等待一段时间，在这段时间内，那些正在运行的线程依然在正常地运转，drain_time过去才进入下一phase</p>
<p>drain_time的设置方式为：<code>phase.phase_done.set_drain_time</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 文件：src/ch5/section5.2/5.2.4/base_test.sv</span><br><span class="hljs-keyword">task</span> base_test::main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.phase_done</span><span class="hljs-variable">.set_drain_time</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">200</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>phase_done</code>是uvm_phase内定义的一个成员变量：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_objection phase_done; <span class="hljs-comment">// phase done objection</span><br></code></pre></div></td></tr></table></figure>
<p>一个phase对应一个drain_time，并不是所有的phase共享一个drain_time</p>
<p>在没有设置的情况下，drain_time的默认值为0</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221202145232206.png" srcset="/img/loading.gif" lazyload alt="image-20221202145232206"></p>
<h4><span id="525-objection的调试">5.2.5 objection的调试</span></h4><p>与phase的调试一样，UVM同样提供了命令行参数来进行objection的调试：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +UVM_OBJECTION_TRACE<br></code></pre></div></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># UVM_INFO @ <span class="hljs-number">0</span>: main_objection [OBJTN_TRC] Object uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.case0_sequence</span> raised <span class="hljs-number">1</span> ob<br># UVM_INFO @ <span class="hljs-number">10000</span>: main_objection [OBJTN_TRC] Object uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.case0_sequence</span> dropped<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在调用raise_objection时，count=1表示此次只提起了这一个objection，下面代码是提起两个objection的结果</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># UVM_INFO @ <span class="hljs-number">0</span>: main_objection [OBJTN_TRC] Object uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.case0_sequence</span> raised <span class="hljs-number">2</span> ob <br># UVM_INFO @ <span class="hljs-number">10000</span>: main_objection [OBJTN_TRC] Object uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.case0_sequence</span> dropped<br></code></pre></div></td></tr></table></figure>
<h3><span id="53-domain">5.3 domain</span></h3><h4><span id="531-domain简介">5.3.1 domain简介</span></h4><p>问题背景：设DUT分成两个相对独立的部分，这两个独立的部分可 以分别复位、配置、启动，但如果没有domain的概念，那么这两块独立的部分则必须同时在<code>reset_phase</code>复位，同时在<code>configure_phase</code>配置，同时进入<code>main_phase</code>开始正常工作。这种协同性当然是没有问题的，但是没有体现出独立性。图5-6中画出了这两个部分的driver位于同一domain的情况</p>
<p>解决方案，使用不同domain划分多个时钟域，这图5-7中列出了两个driver位于不同domain的情况，实现了两个driver的<code>run-time phase</code>异步执行</p>
<p>domain特性：</p>
<ul>
<li>默认情况下，验证平台中所有component都位于一个名字为<code>common_domain</code>的domain中</li>
<li>domain只能隔离<code>run-time phase</code>，无法隔离<code>run_phase</code>和<code>function phase</code></li>
<li>phase的跳转只能局限在某一domain中（原文5.3.3）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221202151230913.png" srcset="/img/loading.gif" lazyload alt="image-20221202151230913"></p>
<h4><span id="532-多domain的例子">5.3.2 多domain的例子</span></h4><p>如何把某个组件置于新的domain中：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> uvm_component;<br>   uvm_domain new_domain;<br>   <span class="hljs-meta">`uvm_component_utils(B)</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>      new_domain = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_domain&quot;</span>);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>      set_domain(new_domain);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> reset_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> post_reset_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span>  <span class="hljs-keyword">task</span> post_main_phase(uvm_phase phase);<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>步骤：</p>
<ol>
<li><p>声明一个了一个<code>uvm_domain</code>：<code>uvm_domain new_domain;</code></p>
</li>
<li><p>在构造函数中实例化该<code>uvm_domain</code>：<code>new_domain = new(&quot;new_domain&quot;);</code></p>
</li>
<li><p>在<code>connect_phase</code>中将该组件加入到domain中：<code>set_domain(new_domain);</code></p>
<p><code>function void uvm_component::set_domain(uvm_domain domain, int hier=1);</code></p>
</li>
</ol>
<ul>
<li>第二个参数表示是否递归调用，如果为1，则<code>domain</code>及其子节点都将全部加入到该<code>domain</code>中。由于子节点的实例化一般在<code>build_phase</code>中完成，所以这里一般在<code>connect_phase</code>中调用<code>set_domain</code></li>
</ul>
</blockquote>
<p>2022-12-02 15:45:38</p>
<h2><span id="第六章-uvm中的sequence-seedling">第六章 UVM中的<mark>sequence</mark> :seedling:</span></h2><h3><span id="61-sequence基础">6.1 sequence基础</span></h3><h4><span id="611-激励产生从driver中剥离激励产生功能">6.1.1 激励产生（从driver中剥离激励产生功能）</span></h4><p><strong>为什么激励最初产生在driver中，后来产生在sequence中？</strong></p>
<ul>
<li>原因：如果要修改激励，则需要将driver.main_phase重新写了一遍，可扩展性太差</li>
</ul>
<p>分析后发现<code>main_phase</code>代码只有中间的改变了，那<strong>为什么不定义一个<code>gen_pkt</code>用于专门产生激励的函数来替代这段代码？</strong></p>
<ul>
<li>原因1：如果直接定义两个<code>gen_pkt</code>则不符合sv，造成重复定义</li>
<li>原因2：如果使用虚函数，则需要定义新的子类<code>driver</code>，重载<code>gen_pkt</code>函数，更麻烦了</li>
</ul>
<p>为解决上面的问题，UVM引入了<mark>sequence机制</mark>，在解决的过程中还使用了<mark>factory机制</mark>、<mark>config机制</mark>，具体来讲：使用sequence机制之后，在不同的测试用例中，将不同的sequence设置成sequencer的<code>main_phase</code>的<code>default_sequence</code>。当sequencer执行到<code>main_phase</code>时，发现有<code>default_sequence</code>，那么它就启动sequence</p>
<p><strong>sequence机制和TLM的区别？</strong></p>
<ul>
<li>sequence机制描述的是，sequence、sequencer、agent、driver之间的关系</li>
<li>TLM描述的是其他组件之间的事务级连接</li>
</ul>
<p>sequence机制如何实现的？<mark>猜测resource_db机制</mark></p>
<p>resource_db机制与config_db机制的底层实现是一样的，uvm_config_db类就是从uvm_resource_db类派生而来的。在寄存器模型的sequence中，get操作是通过resource_db来进行的（详见7.6.2）</p>
<h4><span id="612-sequence机制回顾">6.1.2 sequence机制回顾</span></h4><p>sequence的实例化有两种方式：</p>
<ul>
<li>手动调用<code>seq::start(sqr)</code>函数</li>
<li>使用<code>default_sequence</code></li>
</ul>
<p><strong>执行逻辑：</strong></p>
<p><code>body</code>：</p>
<ul>
<li>每一个sequence都有<code>pre_body</code>、<code>body</code>、<code>post_body</code>任务</li>
<li>当一个sequence启动后会自动执行sequence的<code>pre_body</code>、<code>body</code>、<code>post_body</code>任务</li>
<li>作用：<ul>
<li>发送transcation（<code>`uvm_do</code>，<code>`uvm_send</code>…)</li>
<li>控制objection机制</li>
</ul>
</li>
</ul>
<p>sequence机制参考实现步骤（2.4.3）：</p>
<blockquote>
<ol>
<li>sqr定义（只用简单注册一下sqr到factory，其他不用实现）</li>
<li>sqr实例化（在agent中例化sqr，drv，mon）</li>
<li>seq定义（主要定义<code>body()</code>函数，并在该函数内调用<code>`uvm_do</code>用来发送激励）</li>
<li>seq的实例化（两种方案：手动<code>new</code>；或者在使用<code>default_sequence</code>是参数四指定为<code>case0_sequence::type_id::get()</code>形式</li>
<li>seq启动（在case/env中启动，有两种方案：手动<code>seq.start(sqr)</code>或<code>default_sequence</code>）</li>
<li>连接driver与sqr（在agent中连接，使用继承自UVM各自组件的端口，代码：<code>drv.seq_item_port.connect(sqr.seq_item_export)</code>）</li>
<li>drv申请item（在driver的<code>main_phase</code>向sqr申请数据，使用到<code>seq_item_port.get_next_item(req);</code>和<code>seq_item_port.item_done();</code><ul>
<li><code>item_done</code>还可以用来返回response（6.7.1）</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong><code>default_sequence</code>如何使用</strong>：调用<code>uvm_config_db</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<br>   参数一,<span class="hljs-comment">//this</span><br>    参数二,<span class="hljs-comment">//sqr相对this的路径</span><br>    参数三,<span class="hljs-comment">//字符串&quot;default_sequence&quot;</span><br>    参数四,<span class="hljs-comment">//两种方式：①seq类的id，如case0_sequence::type_id::get() ②seq实例，如某seq</span><br>)<br></code></pre></div></td></tr></table></figure>
<p><strong>方式总结</strong></p>
<p>方式①：手动实例化+手动启动（在case中直接定义）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//6.2.1/no_pri/my_case0.sv</span><br><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>   <span class="hljs-keyword">fork</span><br>      seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>方式②：工厂实例化+手动启动（在vseq中定义，vseq在case中使用default_sequence自动实例化）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//7.1.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br><br>   <span class="hljs-meta">`uvm_object_utils(case0_vseq)</span><br>   <span class="hljs-meta">`uvm_declare_p_sequencer(my_vsqr)</span><br>   <br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_vseq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      case0_sequence dseq;<br>      case0_bus_seq  bseq;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      bseq = case0_bus_seq::type_id::create(<span class="hljs-string">&quot;bseq&quot;</span>);<br>      bseq<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_bus_sqr</span>);<br>      dseq = case0_sequence::type_id::create(<span class="hljs-string">&quot;dseq&quot;</span>);<br>      dseq<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_my_sqr</span>);<br>      <br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>方式③：手动实例化 + default_sequence（seq实例，如某<code>seq</code>）</p>
<p>这样做的好处就是，既可以利用default_sequence，又可以配置<code>sequence_library_cfg</code>省去繁杂的配置（6.8.4）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//6.1.2/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   case0_sequence cseq;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   cseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;cseq&quot;</span>);<br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_base)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           cseq);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>方式④：直接default_sequence（seq类的id，如<code>case0_sequence::type_id::get()</code>）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//6.3.2/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>default_sequence做了什么？</p>
<p>① 在uvm_sequence这个基类中，有一个变量名为starting_phase，它的类型是uvm_phase，sequencer在启动default_sequence时，会执行如下代码，实现在sequence中使用starting_phase进行提起和撤销objection：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">seq<span class="hljs-variable">.starting_phase</span> = phase;<br>seq<span class="hljs-variable">.start</span>(<span class="hljs-keyword">this</span>);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h3><span id="62-sequence的仲裁机制">6.2 sequence的仲裁机制</span></h3><h4><span id="621-在同一sequencer上启动多个sequence">6.2.1 在同一sequencer上启动多个sequence</span></h4><p>1.如何定义</p>
<p>定义两个sequence，运行后会显示两个sequence交替产生transaction</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>   <span class="hljs-keyword">fork</span><br>      seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.优先级</strong></p>
<blockquote>
<p>sequencer根据什么选择使用哪个sequence的transaction呢？</p>
<p>依据创建的transaction的优先级、sequencer的仲裁算法、sequence的优先级，优先级越高越容易选中</p>
<ul>
<li>使用<code>`uvm_do(SEQ_OR_ITEM) 或  `uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS)</code>宏时创建的seq默认优先级为-1</li>
<li>默认sqr的仲裁算法为<code>SEQ_ARB_FIFO</code>，它会严格遵循先入先出的顺序，而不会考虑优先级</li>
<li>seq时启动时可以指定seq的优先级：<code>seq.start(sqr, null, pri);</code></li>
</ul>
<p><strong>改变transaction优先级</strong></p>
<p>可以通过<code>`uvm_do_pri(SEQ_OR_ITEM, PRIORITY) 或 `uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)</code>改变所产生的transaction的优先级，其中形参<code>pri</code>必须≥-1，代码示例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;sequence0&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_pri(m_trans, 100)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence0&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(sequence0)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> sequence1 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;sequence1&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_pri_with(m_trans, 200, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(sequence1)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>仲裁算法</strong></p>
<p>如果只设置了优先级，则两个sequence还是交替产生transaction，因为默认的仲裁算法为<code>SEQ_ARB_FIFO</code>为先进先出不考虑优先级，sequencer的仲裁算法有以下几种：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">SEQ_ARB_FIFO,<br>SEQ_ARB_WEIGHTED,<span class="hljs-comment">//加权的仲裁</span><br>SEQ_ARB_RANDOM,<span class="hljs-comment">//完全随机选择</span><br>SEQ_ARB_STRICT_FIFO,<span class="hljs-comment">//严格按照优先级，当有多个同一优先级的sequence时，按照先入先出的顺序选择</span><br>SEQ_ARB_STRICT_RANDOM,<span class="hljs-comment">//严格按照优先级，当有多个同 一优先级的sequence时，随机从最高优先级中选择</span><br>SEQ_ARB_USE<span class="hljs-comment">//用户自定义一种新的仲裁算法</span><br></code></pre></div></td></tr></table></figure>
<p>想使优先级起作用，应该使用sqr的方法<code>set_arbitration</code>设置仲裁算法为<code>SEQ_ARB_STRICT_FIFO</code>或者<code>SEQ_ARB_STRICT_RANDOM</code>，设置示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>   env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);<span class="hljs-comment">//调用set_arbitration设置</span><br>   <span class="hljs-keyword">fork</span><br>      seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>改变sequence优先级</strong></p>
<p>对sequence设置优先级的本质即设置其内产生的transaction的优先级，通过调用的启动任务<code>virtual task start(sequencer, parent_sequence=null, this_priority=-1, call_pre_porst=1)</code>，优先级参数<code>this_priority</code>选择不同的参数进行sequence优先级的改变，使用示例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>   env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);<br>   <span class="hljs-keyword">fork</span><br>      seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">100</span>);<br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">200</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="622-lock操作与仲裁进一步理解">6.2.2 lock操作与仲裁进一步理解</span></h4><p>使用方式：直接调用<code>uvm_sequence</code>方法<code>lock()</code>与<code>unlock()</code></p>
<p>定义：所谓lock，就是一个使用了<code>lock</code>操作的sequence向sequencer发送一个请求，这个请求与其他sequence发送事务的请求一同被放入sequencer的仲裁队列中。当其前面的所有请求被处理完毕后，sequencer就开始响应这个使用<code>lock</code>的sequence，此后sequencer会一直连续发送此sequence的transaction，直到<code>unlock</code>被调用</p>
<p>补充：如果两个sequence都使用了<code>lock</code>操作，则先被处理的sequence先占用sequencer，直到<code>unlock</code>被调用</p>
<p>一个使用lock操作的sequence为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence1 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;sequence1&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      lock();<br>      <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;locked the sequencer &quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">4</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;unlocked the sequencer &quot;, UVM_MEDIUM)</span><br>      unlock();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(sequence1)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="623-grab">6.2.3 grab</span></h4><p>grab与lock类似，用于<strong>立即</strong>占用sequencer</p>
<p>使用方式：直接调用<code>uvm_sequence</code>方法<code>grab()</code>与<code>ungrab()</code></p>
<p>定义：grab操作比lock操作优先级更高。lock请求是被插入 sequencer仲裁队列的最后面，等到它时，它前面的仲裁请求都已经结束了。grab请求则被放入sequencer仲裁队列的最前面，它几乎是一发出就拥有了sequencer的所有权</p>
<p>补充：</p>
<ul>
<li>如果两个sequence都使用了<code>grab</code>操作，则先被处理的sequence先占用sequencer，直到<code>ungrab</code>被调用（与lock一样）</li>
<li>如果sequencer已经被某个sequence使用<code>lock</code>占用，另一个使用<code>grab</code>操作的请求依旧需要等待，不能打断</li>
</ul>
<p>一个使用grab操作的sequence为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence1 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;sequence1&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      grab();<br>      <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;grab the sequencer &quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">4</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;ungrab the sequencer &quot;, UVM_MEDIUM)</span><br>      ungrab();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size &lt; 500;&#125;)</span><br>         <span class="hljs-meta">`uvm_info(&quot;sequence1&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(sequence1)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="624-sequence的有效性">6.2.4 sequence的有效性</span></h4><p>使用方式（成对重载，不然会报错）：</p>
<ol>
<li>重载自定义的<code>uvm_sequence</code>子类的<code>is_relevant()</code>函数</li>
<li>重载自定义的<code>uvm_sequence</code>子类的<code>wait_for_relevant()</code>函数，该函数要使sequence无效的条件清除</li>
<li>成对重载上面两个函数不然会报错：<code>UVM_FATAL @ 1166700: uvm_test_top.env.i_agt.sqr@@seq0 [RELMSM] is_relevant()was implemented without def</code>（代码6-19没有重载是因为巧妙设计了延迟，可以保证调用不到<code>wait_for_relevant()</code>）</li>
</ol>
<p>执行逻辑：</p>
<ol>
<li>sequencer在仲裁时，会查看sequence的<code>is_relevant()</code>函数的返回结果。如果为1，说明此sequence有效，否则无效</li>
<li>当sequencer发现在其上启动的所有sequence都无效时，此时会调用sequence的<code>wait_for_relevant()</code>函数，当<code>wait_for_relevant</code>返回后，sequencer会继续调用sequence的<code>is_relevant</code>，发现依然是无效状态，则继续调用 <code>wait_for_relevant</code>，系统会处于死循环的状态。（这个过程中，其他有效的seq照样发送，即等待的是该发射无效seq的线程而不是sqr整体）</li>
</ol>
<h3><span id="63-sequence相关宏">6.3 sequence相关宏</span></h3><h4><span id="631-uvm_do系列宏">6.3.1 uvm_do系列宏</span></h4><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`uvm_do(SEQ_OR_ITEM)</span><br><span class="hljs-meta">`uvm_do_pri(SEQ_OR_ITEM, PRIORITY)</span><br><span class="hljs-meta">`uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS)</span><br><span class="hljs-meta">`uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)</span><br><span class="hljs-meta">`uvm_do_on(SEQ_OR_ITEM, SEQR)</span><br><span class="hljs-meta">`uvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY)</span><br><span class="hljs-meta">`uvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS)</span><br><span class="hljs-meta">`uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>使用注意事项：</p>
<ul>
<li>只能在sequence类里面用</li>
</ul>
<p>①<code>`uvm_do(SEQ_OR_ITEM)</code></p>
<p>作用：</p>
<ul>
<li>将一个my_transaction的变量m_trans实例化</li>
<li>将m_trans随机化</li>
<li>最终将m_trans送给sequencer</li>
</ul>
<p>如果不用<code>`uvm_do</code>宏，也可以直接使用<code>start_item</code>与<code>finish_item</code>的方式产生transaction</p>
<p>什么时候返回：等待driver的<code>item_done</code></p>
<p>使用方法（2.4.2 sequence机制）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;my_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">1000</span>;<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(my_sequence)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>②<code>`uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS)</code></p>
<p>作用：类似于<code>`uvm_do</code>，<code>CONSTRAINTS</code>参数用于在随机化时提供对某些字段的<strong>约束</strong></p>
<p>补充：参考2.5.2</p>
<p>③<code>`uvm_do_pri(SEQ_OR_ITEM, PRIORITY)</code></p>
<p>作用：类似于<code>`uvm_do</code>，<code>PRIORITY</code>参数用于给trans添加优先级</p>
<p>补充：参考6.2节</p>
<p>④<code>`uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)</code></p>
<p>作用：类似于<code>`uvm_do_with</code>，<code>PRIORITY</code>参数用于给trans添加优先级</p>
<p>⑤<code>`uvm_do_on(SEQ_OR_ITEM, SEQR)</code></p>
<p>作用：用于显式地指定使用哪个sequencer发送此transaction</p>
<p>参数：</p>
<ul>
<li><code>SEQ_OR_ITEM</code>：transaction的指针</li>
<li><code>SEQR</code>：sequencer的指针</li>
</ul>
<p>补充：</p>
<ul>
<li><code>uvm_do</code>等价于：<code>`uvm_do_on(tr, this.m_sequencer)</code></li>
<li>当在sequence中使用<code>`uvm_do</code>等宏时，其默认的sequencer就是此sequence启动时为其指定的sequencer，sequence将这个sequencer的指针放在其成员变量m_sequencer中</li>
<li>在这里看起来指定使用哪个sequencer似乎并没有用，它的真正作用要在6.5节virtual sequence中得到体现</li>
</ul>
<p>⑥<code>`uvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY)</code></p>
<p>作用：<code>uvm_do_on</code>和<code>uvm_do_pri</code></p>
<p>⑦<code>`uvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS)</code></p>
<p>作用：<code>`uvm_do_on</code>和<code>`uvm_do_with</code></p>
<p>⑧<code>`uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)</code></p>
<p>作用：<code>uvm_do_on</code>和<code>uvm_do_pri</code>和<code>uvm_do_with</code></p>
<p>补充：<code>`uvm_do</code>系列的其他七个宏其实都是，<code>`uvm_do_on_pri_with</code>宏来实现的。如uvm_do宏：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> uvm_do(SEQ_OR_ITEM) \</span><br> <span class="hljs-meta">`uvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, -1, &#123;&#125;)</span><br></code></pre></div></td></tr></table></figure>
<p>⑨其他产生transaction的方法：</p>
<p>除了使用<code>`uvm_do</code>宏产生transaction，还可以使用<code>`uvm_create</code>宏与<code>`uvm_send</code>宏来产生</p>
</blockquote>
<h4><span id="632-uvm_send系列">6.3.2 uvm_send系列</span></h4><p>除了使用<code>`uvm_do</code>宏产生transaction，还可以使用<code>`uvm_create</code>宏，<code>`uvm_send</code>宏来产生</p>
<blockquote>
<p>①<code>`uvm_create</code>与<code>`uvm_send</code></p>
<p>产生transaction步骤：</p>
<ul>
<li><code>`uvm_create</code>实例化transaction；或者直接使用new进行实例化</li>
<li>对transaction实例做自定义操作</li>
<li><code>`uvm_send</code>发送transaction</li>
</ul>
<p>好处：比<code>`uvm_do</code>系列宏更灵活</p>
<p>使用实例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">/* 一个使用`uvm_create与`uvm_send的实例 */</span><br><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">int</span> p_sz;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         num++;<br>         <span class="hljs-meta">`uvm_create(m_trans)</span><br>         <span class="hljs-keyword">assert</span>(m_trans<span class="hljs-variable">.randomize</span>());<br>         p_sz = m_trans<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>();<br>         &#123;m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">4</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">3</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">2</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">1</span>]&#125; <br>          = num; <br>         <span class="hljs-meta">`uvm_send(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(case0_sequence)</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-comment">/* 一个使用new与`uvm_send的实例*/</span><br>...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">int</span> p_sz;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         num++;<br>         m_trans = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;m_trans&quot;</span>)<br>         <span class="hljs-keyword">assert</span>(m_trans<span class="hljs-variable">.randomize</span>());<br>         p_sz = m_trans<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>();<br>         &#123;m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">4</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">3</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">2</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">1</span>]&#125; <br>          = num; <br>         <span class="hljs-meta">`uvm_send(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>...<br></code></pre></div></td></tr></table></figure>
<p>②<code>`uvm_send_pri</code></p>
<p>除<code>`uvm_send</code>外，还有<code>`uvm_send_pri</code>用于将transaction交给sequencer时设定优先级</p>
<p>③<code>`uvm_rand_send</code>系列</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`uvm_rand_send(SEQ_OR_ITEM)</span><br><span class="hljs-meta">`uvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY)</span><br><span class="hljs-meta">`uvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS)</span><br><span class="hljs-meta">`uvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)</span><br></code></pre></div></td></tr></table></figure>
<p>作用：<code>`uvm_rand_send</code>与<code>`uvm_send</code>系列类似，唯一区别是对transaction进行随机化</p>
<p>使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`uvm_rand_send(m_trans</span><br><span class="hljs-meta">`uvm_rand_send_pri(m_trans, 100)</span><br><span class="hljs-meta">`uvm_rand_send_with(m_trans, &#123;m_trans.pload.size == 100;&#125;)</span><br><span class="hljs-meta">`uvm_rand_send_pri_with(m_trans, 100, &#123;m_trans.pload.size == 100;&#125;)</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="634-不使用宏产生transactionstart_item与finish_item">6.3.4 不使用宏产生transaction（<code>`start_item</code>与<code>`finish_item</code>）</span></h4><p>不使用宏产生transaction的方式要依赖于两个任务：<code>`start_item</code>与<code>`finish_item</code></p>
<blockquote>
<p><code>`start_item</code>与<code>`finish_item</code></p>
<p>产生步骤（必须先实例化transaction）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>start_item(tr);<br>finish_item(tr);<br></code></pre></div></td></tr></table></figure>
<p>指定优先级：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">start_item(tr, <span class="hljs-number">100</span>);<br>finish_item(tr, <span class="hljs-number">100</span>);<br></code></pre></div></td></tr></table></figure>
<p>加入随机化与assert：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>start_item(tr);<br><span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>() == <span class="hljs-number">200</span>;&#125;);<br>finish_item(tr);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h4><span id="635-精细化控制pre_do-mid_do与post_do">6.3.5 精细化控制（pre_do、mid_do与post_do）</span></h4><p><code>`uvm_do</code>宏封装了从transaction实例化到发送的一系列操作，封装的越多，则其灵活性越差</p>
<p>为了增加uvm_do系列宏的功能， UVM提供了几个接口：<code>wait_for_grant</code>、<code>pre_do</code>，<code>mid_do</code>、<code>send_request</code>、<code>wait_for_item_done</code>、<code>post_do</code></p>
<p><strong>这几个函数/方法执行顺序如图：</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20221221220313662.png" srcset="/img/loading.gif" lazyload alt="image-20221221220313662"></p>
<p><strong>其中：</strong></p>
<ul>
<li><code>pre_do</code>是一个任务，在<code>start_item</code>中被调用，是<code>start_item</code>返回前执行的最后一行代码<ul>
<li>一个参数，用于表明<code>`uvm_do</code>宏是在对一个transaction还是在对一个sequence进行操作（参考6.4.1）</li>
</ul>
</li>
<li><code>mid_do</code>是一个函数，位于<code>finish_item</code>的最开始<ul>
<li>一个参数，是正在操作的sequence或者item的指针，但其类型是<code>uvm_sequence_item</code>，需要调用<code>$cast</code>来转为自定义的seq或item用于自定义操作</li>
</ul>
</li>
<li><code>post_do</code>是一个函数，位于<code>finish_item</code>中，是<code>finish_item</code>返回前执行的最后一行代码<ul>
<li>一个参数，同<code>mid_do</code></li>
</ul>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-keyword">int</span> num;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_do(<span class="hljs-keyword">bit</span> is_item);<br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-meta">`uvm_info(&quot;sequence0&quot;, &quot;this is pre_do&quot;, UVM_MEDIUM)</span><br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> mid_do(uvm_sequence_item this_item);<br>      my_transaction tr;<br>      <span class="hljs-keyword">int</span> p_sz;<br>      <span class="hljs-meta">`uvm_info(&quot;sequence0&quot;, &quot;this is mid_do&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">void</span>&#x27;(<span class="hljs-built_in">$cast</span>(tr, this_item));<br>      p_sz = tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>();<br>      &#123;tr<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">4</span>],<br>       tr<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">3</span>],<br>       tr<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">2</span>],<br>       tr<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">1</span>]&#125; = num;<br>      tr<span class="hljs-variable">.crc</span> = tr<span class="hljs-variable">.calc_crc</span>();<br>      tr<span class="hljs-variable">.print</span>();<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> post_do(uvm_sequence_item this_item);<br>      <span class="hljs-meta">`uvm_info(&quot;sequence0&quot;, &quot;this is post_do&quot;, UVM_MEDIUM)</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         num++;<br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(case0_sequence)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="64-sequence进阶">6.4 sequence进阶</span></h3><h4><span id="641-嵌套sequence">6.4.1 嵌套sequence</span></h4><p>在sequence中，除了可以使用<code>`uvm_do</code>宏产生transaction外，其实还可以启动其他的sequence，实现嵌套sequence</p>
<p><strong>补充：</strong>一个seq中所有的transaction应保持一种类型，嵌套的seq也应保持transaction一致，详情6.4.3</p>
<p><strong>方法1：</strong>手动new与start</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   ...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      crc_seq cseq;<br>      long_seq lseq;<br><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         cseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;cseq&quot;</span>);<br>         cseq<span class="hljs-variable">.start</span>(m_sequencer);<br>         lseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;lseq&quot;</span>);<br>         lseq<span class="hljs-variable">.start</span>(m_sequencer);<br>      <span class="hljs-keyword">end</span><br><br>   <span class="hljs-keyword">endtask</span><br>   ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>方法2：</strong>调用<code>`uvm</code>系列宏</p>
<p>之前介绍的，uvm_do宏、uvm_send宏、uvm_rand_send宏、uvm_create宏，其第一个参数是<code>SEQ_OR_ITEM</code>的都可以是sequence的指针</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   ...   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      crc_seq cseq;<br>      long_seq lseq;<br><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(cseq)</span><br>         <span class="hljs-meta">`uvm_do(lseq)</span><br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span><br>   ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>嵌套的好处：</strong></p>
<p>如果不嵌套，在不同seq中一个一个写同样约束的transaction会显得特别麻烦。产生的两种不同的包中，第一个约束条件有两个，第二个约束条件有三个。但是假如约束条件有十个呢？如果整个验证平台中有30个测试用例都用到这样的两种包，那就要在这30个测试用例的sequence中加入这些代码，这是一件相当恐怖的事情，而且特别容易出错</p>
<h4><span id="642-在sequence中使用rand类型变量">6.4.2 在sequence中使用rand类型变量</span></h4><p><strong>介绍：</strong></p>
<p>不仅在transaction中可以使用rand对变量进行修饰，在sequence中也可以。</p>
<p>sequence与transaction都可以调用<code>randomize</code>进行随机化，都可以有rand修饰符的成员变量，从某种程度上来说，二者的界限比较模糊</p>
<p><strong>注意，不要相同命名！：</strong></p>
<p>sequence与transaction中定义的rand变量名称需要注意，在约束中编译器会优先寻找transaction中的变量，若rand变量名称相同则会忽略掉seq中的变量，即出现下面的情况</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//定义了一个transaction</span><br><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br>   ...<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>   ...<br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//定义了一个seq</span><br><span class="hljs-keyword">class</span> long_seq <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(my_transaction)</span>;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac; <br>   <span class="hljs-meta">`uvm_object_utils(long_seq)</span><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;long_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      <span class="hljs-meta">`uvm_do_with(tr, &#123;tr.crc_err == 0;</span><br>                        tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>() == <span class="hljs-number">1500</span>;<br>                        tr<span class="hljs-variable">.dmac</span> == dmac;&#125;)<br>      tr<span class="hljs-variable">.print</span>();<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//第17~19行代码等价于</span><br><span class="hljs-meta">`uvm_do_with(tr, &#123;tr.crc_err == 0;</span><br>                  tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>() == <span class="hljs-number">1500</span>;<br>                  tr<span class="hljs-variable">.dmac</span> == tr<span class="hljs-variable">.dmac</span>;&#125;)<br></code></pre></div></td></tr></table></figure>
<h4><span id="643-transaction类型匹配">6.4.3 transaction类型匹配</span></h4><p><strong>相同类型匹配：</strong></p>
<p>一个sequencer只能产生一种类型的transaction，一个sequence如果要想在此sequencer上启动，那么其所产生的transaction的类型 必须是这种transaction或者派生自这种transaction。</p>
<p>如果一个sequence中产生的transaction的类型不是此种transaction，那么将会报错：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<span class="hljs-comment">//这里参数为my_transaction</span><br>    your_transaction y_trans;<span class="hljs-comment">//但这里操作的却是your_transaction，所以会产生错误</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span> <span class="hljs-meta">`uvm_do(y_trans)</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>使用父类参数实现启动不同类型的transaction</strong></p>
<p>有没有办法将两个截然不同的transaction交给同一个sequencer呢？</p>
<p>可以，只是需要将sequencer和driver能够接受的数据类型设置为<code>uvm_sequence_item</code>（即自定义transaction的父类）</p>
<p>具体步骤：</p>
<ul>
<li>sequence<ul>
<li>类型内部定义不同的transaction，并在body中调用uvm系列宏启动</li>
</ul>
</li>
<li>sequencer<ul>
<li>更改类型定义参数：<code>class my_sequencer extends uvm_sequencer #(uvm_sequence_item);</code></li>
</ul>
</li>
<li>driver<ul>
<li>更改类型定义参数：<code>class my_driver extends uvm_driver#(uvm_sequence_item);</code></li>
<li>如果要使用子类transaction的变量或方法需要调用<code>$cast</code>进行强制类型转换</li>
</ul>
</li>
</ul>
<h4><span id="644-m_sequencer和p_sequencer">6.4.4 m_sequencer和p_sequencer</span></h4><p><strong>1.回顾m_sequencer</strong></p>
<ul>
<li><code>m_sequencer</code>是每个sequence中都有的默认成员变量</li>
<li>用途：作为<code>`uvm_do</code>系列宏的默认sequencer（详情参考6.3.1）、<code>seq.start(m_sequencer)</code>手动启动（代码6-46），等在sequence中的uvm框架函数使用到的sequencer指针</li>
<li>类型是<code>uvm_sequencer_base</code>类型（注意该指针是<code>uvm_sequencer_base</code>类型，即父类指针）</li>
<li>sequencer启动该sequence时，<code>m_sequencer</code>会被赋值为启动的sequencer</li>
</ul>
<p><strong>2.p_sequencer</strong></p>
<ul>
<li><code>p_sequencer</code>需要使用宏<code>`uvm_declare_p_sequencer(自定义的sequencer类)</code>声明，该宏等同于<code>自定义的sequencer类p_sequencer;</code></li>
<li>用途：通过该变量使得sequence可以引用sequencer中的变量</li>
<li>类型为调用宏时声明的自定义sequencer类（注意该指针是子类指针）</li>
<li>UVM会自动将<code>m_sequencer</code>通过<code>cast</code>转换成<code>p_sequencer</code></li>
</ul>
<p><strong>3.p_sequencer解决的问题</strong></p>
<p>简化了操作：如果在my_sequencer中设置了某些参数，在my_sequence中通过句柄<code>m_sequence</code>参数访问的时候由于是父类句柄无法访问到，这时可通过<code>p_sequencer</code>进行访问</p>
<h4><span id="645-sequence的派生">6.4.5 sequence的派生</span></h4><p><strong>1.sequence的派生</strong></p>
<p>sequence作为一个类，是可以从其中派生其他sequence的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//////////////////////////////</span><br><span class="hljs-keyword">class</span> base_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br> <span class="hljs-comment">//define some common function and task </span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//////////////////////////////</span><br><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> base_sequence; <br>  ...<br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//////////////////////////////</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.补充p_sequencer情况</strong></p>
<ul>
<li>父类sequence中使用宏声明的<code>p_sequencer</code>在子类中依然可以使用，无需在子类中在此调用宏声明</li>
<li>若子类在此调用宏声明，则和正常声明变量一样，产生子类父类两个<code>p_sequencer</code>变量</li>
</ul>
<h3><span id="65-virtual-sequence的使用">6.5 virtual sequence的使用</span></h3><p><strong>virtual sequence与virtual sequencer</strong></p>
<p><code>virtual sequence</code>就是控制其他sequence的sequence，不发送transaction起到统一调度作用，定义方式和普通sequence一样，就是功能不一样。在virtual sequence中也可启动其他的virtual sequence。</p>
<p><code>virtual sequencer</code>为了使用virtual sequence，一般需要一个virtual sequencer。virtual sequencer里面包含指向其他真实sequencer的指针，从而保证了在default_sequence为该vsqr的情况下，vseq可以通过该vsqr引用刀不同的sqr</p>
<p><strong>sequencer对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>virtual sequencer</th>
<th>sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例化位置</td>
<td>base_test（uvm_test）</td>
<td>agent</td>
</tr>
<tr>
<td>路径对比</td>
<td>uvm_test_top.v_sqr</td>
<td>uvm_test_top.env0.i_agt.sqr</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230117171156899-16739467200511.png" srcset="/img/loading.gif" lazyload alt="image-20230117171156899"></p>
<h4><span id="651-带双路输入输出端口的dut">6.5.1 带双路输入输出端口的DUT</span></h4><p>在2.2.1节所示的DUT的基础上增加了一组数据口，这组新的数据口与原先的数据口功能完全一样，具体实现分为这几步：</p>
<ul>
<li>在<code>base_test</code>中添加一个<code>env</code>，</li>
<li>在<code>top_tb</code>模块中添加一组<code>interface</code>，并使用<code>config_db</code>与新<code>env</code>中的组件进行连接</li>
<li>在<code>casen</code>中添加针对该<code>env</code>中的<code>sequencer</code>的<code>default_sequence</code></li>
<li>其中<code>base_test</code>是<code>uvm_test</code>的子类，casen是<code>base_test</code>的子类，top_tb是DUT与interface的例化模块</li>
</ul>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.5/6.5.1/base_test.sv</span><br><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env0;<br>   my_env         env1;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;base_test&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_component_utils(base_test)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env0  =  my_env::type_id::create(<span class="hljs-string">&quot;env0&quot;</span>, <span class="hljs-keyword">this</span>); <br>   env1  =  my_env::type_id::create(<span class="hljs-string">&quot;env1&quot;</span>, <span class="hljs-keyword">this</span>); <br><span class="hljs-keyword">endfunction</span><br><span class="hljs-comment">//src/ch6/section6.5/6.5.1/top_tb.sv</span><br><span class="hljs-keyword">module</span> top_tb;<br>...<br>my_if input_if0(clk, rst_n);<br>my_if input_if1(clk, rst_n);<br>my_if output_if0(clk, rst_n);<br>my_if output_if1(clk, rst_n);<br><br>dut my_dut(<span class="hljs-variable">.clk</span>(clk),<br>           <span class="hljs-variable">.rst_n</span>(rst_n),<br>           <span class="hljs-variable">.rxd0</span>(input_if0<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.rx_dv0</span>(input_if0<span class="hljs-variable">.valid</span>),<br>           <span class="hljs-variable">.rxd1</span>(input_if1<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.rx_dv1</span>(input_if1<span class="hljs-variable">.valid</span>),<br>           <span class="hljs-variable">.txd0</span>(output_if0<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.tx_en0</span>(output_if0<span class="hljs-variable">.valid</span>),<br>           <span class="hljs-variable">.txd1</span>(output_if1<span class="hljs-variable">.data</span>),<br>           <span class="hljs-variable">.tx_en1</span>(output_if1<span class="hljs-variable">.valid</span>));<br>...<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env0.i_agt.drv&quot;, &quot;vif&quot;, input_if0)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env0.i_agt.mon&quot;, &quot;vif&quot;, input_if0)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env0.o_agt.mon&quot;, &quot;vif&quot;, output_if0)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env1.i_agt.drv&quot;, &quot;vif&quot;, input_if1)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env1.i_agt.mon&quot;, &quot;vif&quot;, input_if1)</span>;<br>   uvm_config_db<span class="hljs-variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env1.o_agt.mon&quot;, &quot;vif&quot;, output_if1)</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br><span class="hljs-comment">//src/ch6/section6.5/6.5.1/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env0.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env1.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="652-sequence之间的简单同步">6.5.2 sequence之间的简单同步</span></h4><p><strong>问题背景：</strong>基于6.5.1的验证平台</p>
<p><strong>实现：</strong>DUT要求driver0必须先发送一个最大长度的包，在此基础上driver1才可以发送包，如何进行sequence的同步？</p>
<p><strong>两种解决方案</strong>：</p>
<p>①使用全局变量（不建议使用全局变量）（本节介绍的方案）</p>
<p>②使用virtual sequence进行不同sequence的控制（下一节介绍的方案）</p>
<p><strong>方案①的问题：</strong></p>
<ul>
<li>应该尽量避免全局变量的使用<code>send_over</code>，以防在其他地方错误的使用同名变量</li>
<li>只是实现了一次同步，如果有多次同步则实现非常笨拙</li>
</ul>
<p><strong>方案②的好处</strong></p>
<ul>
<li>解决了方案①带来的问题</li>
<li>不用刻意地同步，体现调度功能强大</li>
<li>只需要使用一个default_sequence，减少<code>config_db</code>语句的使用，减少出错概率（假如验证平台中的sequencer有多个，如10个，那么就需要写10个uvm_config_db语句，这是一件很 令人厌烦的事情。使用virtual sequence后可以将这10句只压缩成一句）</li>
</ul>
<p><strong>方案①</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.5/6.5.2/my_case0.sv</span><br><span class="hljs-keyword">event</span> send_over;<span class="hljs-comment">//global event</span><br><span class="hljs-keyword">class</span> drv0_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-meta">`uvm_object_utils(drv0_seq)</span><br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;drv0_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.pload.size == 1500;&#125;)</span><br>      -&gt;send_over;<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         <span class="hljs-meta">`uvm_info(&quot;drv0_seq&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> drv1_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-meta">`uvm_object_utils(drv1_seq)</span><br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;drv1_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      @send_over;<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         <span class="hljs-meta">`uvm_info(&quot;drv1_seq&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><code>drv1_seq</code>要等待<code>send_over</code>事件的到来，所以它并不会马上产生transaction</p>
<p><code>drv0_seq</code>则会直接产生transaction。当<code>drv0_seq</code>发送完一个最长包后，<code>send_over</code>事件被触发，于<code>drv1_seq</code>开始产生 transaction</p>
<h4><span id="653-sequence之间的复杂同步">6.5.3 sequence之间的复杂同步</span></h4><p>实现sequence之间同步的最好的方式就是使用virtual sequence，它不发送transaction，只是控制其他的sequence，起统一调度的作用</p>
<p>如图所示，为了使用virtual sequence，一般需要一个virtual sequencer。virtual sequencer里面包含指向其他真实sequencer的指针</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230117171156899-16739467200511.png" srcset="/img/loading.gif" lazyload alt="image-20230117171156899"></p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>定义一个vsqr类<code>my_vsqr</code>，内部声明两个sqr指针</li>
<li>在<code>base_test</code>类中，工厂模式创建vsqr以及env（env内部agent组件创建了sqr），并将两个sqr赋值给vsqr中的sqr的指针</li>
<li>在vseq中实现控制逻辑<ul>
<li>使用<code>`uvm_do_on</code>系列宏指定sqr来发送transaction。或者使用手动启动sequence，手动启动优势是可以向seq传递一些值</li>
</ul>
</li>
</ul>
<p><strong>`uvm_do_on启动如下：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.5/6.5.3/uvm_do_on/my_vsqr.sv</span><br><span class="hljs-keyword">class</span> my_vsqr <span class="hljs-keyword">extends</span> uvm_sequencer;<br>  <br>   my_sequencer p_sqr0;<br>   my_sequencer p_sqr1;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-meta">`uvm_component_utils(my_vsqr)</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//src/ch6/section6.5/6.5.3/uvm_do_on/base_test.sv</span><br><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env0;<br>   my_env         env1;<br>   my_vsqr        v_sqr;   <br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;base_test&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_component_utils(base_test)</span><br><span class="hljs-keyword">endclass</span><br>       <br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env0  =  my_env::type_id::create(<span class="hljs-string">&quot;env0&quot;</span>, <span class="hljs-keyword">this</span>); <br>   env1  =  my_env::type_id::create(<span class="hljs-string">&quot;env1&quot;</span>, <span class="hljs-keyword">this</span>); <br>   v_sqr =  my_vsqr::type_id::create(<span class="hljs-string">&quot;v_sqr&quot;</span>, <span class="hljs-keyword">this</span>); <br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::connect_phase(uvm_phase phase);<br>   v_sqr<span class="hljs-variable">.p_sqr0</span> = env0<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>;<br>   v_sqr<span class="hljs-variable">.p_sqr1</span> = env1<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-comment">//src/ch6/section6.5/6.5.3/uvm_do_on/my_case0.sv</span><br><span class="hljs-keyword">class</span> drv0_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-meta">`uvm_object_utils(drv0_seq)</span><br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;drv0_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         <span class="hljs-meta">`uvm_info(&quot;drv0_seq&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> drv1_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-meta">`uvm_object_utils(drv1_seq)</span><br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;drv1_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         <span class="hljs-meta">`uvm_info(&quot;drv1_seq&quot;, &quot;send one transaction&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>   <span class="hljs-meta">`uvm_object_utils(case0_vseq)</span><br>   <span class="hljs-meta">`uvm_declare_p_sequencer(my_vsqr) </span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;case0_vseq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      drv0_seq seq0;<br>      drv1_seq seq1;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-meta">`uvm_do_on_with(tr, p_sequencer.p_sqr0, &#123;tr.pload.size == 1500;&#125;)</span><br>      <span class="hljs-meta">`uvm_info(&quot;vseq&quot;, &quot;send one longest packet on p_sequencer.p_sqr0&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">fork</span><br>         <span class="hljs-meta">`uvm_do_on(seq0, p_sequencer.p_sqr0);</span><br>         <span class="hljs-meta">`uvm_do_on(seq1, p_sequencer.p_sqr1);</span><br>      <span class="hljs-keyword">join</span> <br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> my_case0 <span class="hljs-keyword">extends</span> base_test;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_case0&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase); <br>   <span class="hljs-meta">`uvm_component_utils(my_case0)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;v_sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_vseq::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>my_case0.sv包括：seq1、seq2、vseq</p>
<p><strong>手动启动如下</strong></p>
<ul>
<li>（补充）解决问题：在<code>read_file_seq</code>中，需要一个字符串的文件名字，在手工启动时可以指定文件名字，但是uvm_do系列宏无法实现这个功能， 因为string类型变量前不能使用rand修饰符。这就是手工启动sequence的优势</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>   <span class="hljs-meta">`uvm_object_utils(case0_vseq)</span><br>   <span class="hljs-meta">`uvm_declare_p_sequencer(my_vsqr) </span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;case0_vseq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      read_file_seq seq0;<br>      drv1_seq seq1;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-meta">`uvm_do_on_with(tr, p_sequencer.p_sqr0, &#123;tr.pload.size == 1500;&#125;)</span><br>      <span class="hljs-meta">`uvm_info(&quot;vseq&quot;, &quot;send one longest packet on p_sequencer.p_sqr0&quot;, UVM_MEDIUM)</span><br>      seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>      seq0<span class="hljs-variable">.file_name</span> = <span class="hljs-string">&quot;data.txt&quot;</span>;<span class="hljs-comment">//指定了文件名</span><br>      seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>      <span class="hljs-keyword">fork</span><br>         seq0<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_sqr0</span>);<br>         seq1<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_sqr1</span>);<br>      <span class="hljs-keyword">join</span> <br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="654-仅在virtual-sequence中控制objection">6.5.4 仅在virtual sequence中控制objection</span></h4><p>5.2.3节中提过要么在scoreboard中控制objection，要么在sequence中控制</p>
<p>当virtual sequence存在时，尤其是virtual sequence中又可以启动其他的virtual sequence时，有三个地方可以控制objection：一是普通的sequence、二是中间层的virtual sequence（如代码清单6-76中的cfg_vseq）、三是最顶层的virtual sequence（代码清单6-76中的case0_vseq）。<strong>一般来说，只在最顶层的virtual sequence中控制objection</strong></p>
<p><strong>回顾：如何在seq中控制seq</strong></p>
<p>调用<code>starting_phase.raise_objection(this);</code>与<code>starting_phase.drop_objection(this)</code></p>
<p>starting_phase哪来的？</p>
<ul>
<li><code>uvm_sequence</code>内部变量</li>
<li>赋值位置：<ul>
<li>default_sequence时自动产生</li>
<li>手动启动seq时赋值<code>seq0.starting_phase = phase;</code></li>
</ul>
</li>
</ul>
<h4><span id="655-在sequence中慎用fork-join_none">6.5.5 在sequence中慎用fork join_none</span></h4><p><strong>问题背景：</strong>将6.5.1节中的DUT的数据口扩展为4路，那么相应的验证平台中也要有4个完全相同的driver、sequencer</p>
<p><strong>对于四个seq在vseq的启动有以下种写法：</strong></p>
<p>①使用在for循环中使用<code>fork join_none</code>开个线程（错误用法）</p>
<p>②增加<code>wait fork</code>来改进方案①</p>
<p>③直接<code>fork join</code>手动写四个线程</p>
<p><strong>第一种写法（错误写法）：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>   <span class="hljs-meta">`uvm_object_utils(case0_vseq)</span><br>   <span class="hljs-meta">`uvm_declare_p_sequencer(my_vsqr) </span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;case0_vseq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      drv_seq dseq[<span class="hljs-number">4</span>];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>         <span class="hljs-keyword">fork</span><br>            <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-meta">`uvm_do_on(dseq[j], p_sequencer.p_sqr[j]);</span><br>         <span class="hljs-keyword">join_none</span> <br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="66-在sequence中使用config_db">6.6 在sequence中使用config_db</span></h3><p>config_db机制也对sequence机制提供了支持，可以在sequence中获取或设置参数</p>
<h4><span id="661-在sequence中获取参数">6.6.1 在sequence中获取参数</span></h4><p>sequence是一个<code>uvm_object</code>，可以通过在sequence调用<code>get_full_name</code>函数获取位置，本节示例的调用结果为：<code>uvm_test_top.env.i_agt.sqr.case0_sequence</code></p>
<p><strong>代码示例：</strong></p>
<p><strong>set代码</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.6/6.6.1/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   ...<br>   uvm_config_db<span class="hljs-variable">#(int)::set(this, &quot;env.i_agt.sqr.*&quot;, &quot;count&quot;, 9)</span>;<br>   ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>set函数的第二个路径参数里面出现了通配符<code>*</code>，这是因为sequence在实例化时名字一般是不固定的，而且有时是未知的（比如 使用default_sequence启动的sequence的名字就是未知的），所以使用通配符</p>
</blockquote>
<p><strong>sequence的get代码</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.6/6.6.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    ...  <br>       uvm_config_db<span class="hljs-variable">#(int)::get(null, get_full_name(), &quot;count&quot;, count)</span><br>    ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在get函数原型中，第一个参数必须是一个component，而sequence不是一个component， 所以这里不能使用this指针，只能使用null或者<code>uvm_root::get()</code>（前文已经提过，当使用null时，UVM会自动将其替换为<code>uvm_root::get()</code></p>
<p>再加上第二个参数<code>get_full_name()</code>，就可以完整地得到此sequence的路径，从而得到参数</p>
</blockquote>
<h4><span id="662-在sequence中设置参数">6.6.2 在sequence中设置参数</span></h4><p><strong>sequence的set代码</strong></p>
<p>向scoreboard中传递了一个<code>cmp_en</code>参数</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.6/6.6.2/component/my_case0.sv</span><br>uvm_config_db<span class="hljs-variable">#(bit)::set(uvm_root::get(), &quot;uvm_test_top.env0.scb&quot;, &quot;cmp_en&quot;, 0)</span>;<br></code></pre></div></td></tr></table></figure>
<p>也可以向sequence中传递参数，下面例子是sequence向自己传了一个<code>first_start</code>参数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.6/6.6.2/sequence/my_case0.sv</span><br>uvm_config_db<span class="hljs-variable">#(bit)::set(uvm_root::get(), &quot;uvm_test_top.v_sqr.*&quot;, &quot;first_start&quot;, 0)</span>;<br><span class="hljs-comment">/* set代码对应的get也在set位置附近 */</span><br>uvm_config_db<span class="hljs-variable">#(bit)::get(uvm_root::get(), get_full_name(), &quot;first_start&quot;, first_start)</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>在sequence中启动sequence带来的路径不同：</strong></p>
<p>可以看到上面set的例子中直接使用了<code>&quot;uvm_test_top.v_sqr.*&quot;</code>路径，这是因为我们要设置的sequence是由该virtual sequence启动的，而不是像之前一样通过default_sequence由sqr启动的（这种路径会是<code>&quot;uvm_test_top.env0.i_agt.sqr.*&quot;</code></p>
<h4><span id="663-wait_modified的使用">6.6.3 wait_modified的使用</span></h4><p><strong>问题背景：</strong>为了解决使用<code>config_db</code>时，设置参数时间不确定问题</p>
<p><strong>解决方法：</strong><code>wait_modified</code>任务</p>
<p><strong>任务原型：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">static</span> <span class="hljs-keyword">task</span> wait_modified(<br>                     uvm_component  cntxt,<br>                           <span class="hljs-keyword">string</span>   inst_name,<br>                     <span class="hljs-keyword">string</span>   field_name  );<br></code></pre></div></td></tr></table></figure>
<ul>
<li>参数与<code>config_db::get</code>前三个参数使用方法一致</li>
<li><code>wait_modified</code>检测到第三个参数的值被更新过后返回，否则一直等待在那里</li>
<li>与<code>config_db::get</code>类似，可在sequence中调用</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch6/section6.6/6.6.3/component/my_scoreboard.sv</span><br><span class="hljs-keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);  <br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>         uvm_config_db<span class="hljs-variable">#(bit)::wait_modified(this, &quot;&quot;, &quot;cmp_en&quot;)</span>;<br>         <span class="hljs-keyword">void</span>&#x27;(uvm_config_db<span class="hljs-variable">#(bit)::get(this, &quot;&quot;, &quot;cmp_en&quot;, cmp_en))</span>; <br>         <span class="hljs-meta">`uvm_info(&quot;my_scoreboard&quot;, $sformatf(&quot;cmp_en value modified, the new value is %0d&quot;, cmp_en), UVM_LOW)</span><br>      <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>wait_modified与main_phase中的其他进程在同一时刻被fork起来，当检测到参数值被设置后，立刻调用 config_db：：get得到新的参数。其他进程可以根据新的参数值决定后续的比对策略。</p>
</blockquote>
<h3><span id="67-response的使用">6.7 response的使用</span></h3><p>sequence机制提供了一种sequence→sequencer→driver的单向数据传输机制</p>
<p>但是在复杂的验证平台中，sequence需要根据 driver对transaction的反应来决定接下来要发送的transaction，换言之，sequence需要得到driver的一个反馈</p>
<p>sequence机制使用response来支持这种反馈（这种反馈只能在driver、sequencer、sequence之间，即sequence机制支持的组件）</p>
<h4><span id="671-put_response与get_response">6.7.1 put_response与get_response</span></h4><p><strong>如何实现sequence收到response：</strong></p>
<p>方法一：使用response机制</p>
<ul>
<li>sequence中调用<code>get_response</code></li>
<li>driver中<ul>
<li>设置rsp的id：调用<code>set_id_info</code>函数（只有设置了rsp的id等信息，sequencer才知道将response返回给哪个sequence）</li>
<li>发送response：调用<code>put_response</code>任务，或者直接将rsp作为<code>item_done</code>函数的参数（只在只有一个response的情况下可以作为<code>item_done</code>的参数，详情见下一节）</li>
</ul>
</li>
</ul>
<p>方案二：使用另类的response</p>
<ul>
<li>sequence中使用<code>`uvm_do</code>系列宏（即seq的基本操作）</li>
<li>driver中直接对req进行赋值（把req看作rsp）</li>
</ul>
<blockquote>
<p><strong>方案一与方案二的不同：</strong></p>
<p><code>put_response</code>、<code>get_response</code>或者<code>response_handler</code>，都是新建了一个transaction，并将其返回给sequence</p>
<p>事实上，当一个<code>`uvm_do</code>语 句执行完毕后，其第一个参数并不是一个空指针，而是指向刚刚被送给driver的transaction。利用这一点，可以实现一种另类的response</p>
<p>补充：rsp与req是哪里来的？</p>
</blockquote>
<p><strong>方案一代码示例</strong></p>
<p>sequence中获取rsp</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>  ...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         get_response(rsp);<br>         <span class="hljs-meta">`uvm_info(&quot;seq&quot;, &quot;get one response&quot;, UVM_MEDIUM)</span><br>         rsp<span class="hljs-variable">.print</span>();<br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br>   ...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>driver中设置id与发送rsp：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>      rsp<span class="hljs-variable">.set_id_info</span>(req);<br>      seq_item_port<span class="hljs-variable">.put_response</span>(rsp);<br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>driver中直接将response作为item_done参数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>      rsp<span class="hljs-variable">.set_id_info</span>(req);<br>      seq_item_port<span class="hljs-variable">.item_done</span>(rsp);<br>   <span class="hljs-keyword">end</span><br>endtas<br></code></pre></div></td></tr></table></figure>
<p><strong>方案二代码示例</strong></p>
<p>sequence正常发送transaction</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>         <span class="hljs-meta">`uvm_info(&quot;seq&quot;, $sformatf(&quot;get information from driver: %0s&quot;, m_trans.frm_drv), UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br>...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>driver中对req相应字段赋值，写入响应</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      req<span class="hljs-variable">.frm_drv</span> = <span class="hljs-string">&quot;this is information from driver&quot;</span>;<br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="672-response的数量问题">6.7.2 response的数量问题</span></h4><p>UVM支持一个transaction对应多个response的情况（但通常是一对一）</p>
<p><strong>实现方式：</strong>在sequence中需要多次调用<code>get_response</code>，而在driver中多次调用<code>put_response</code></p>
<p><strong>重要特性：</strong></p>
<ul>
<li>当存在多个response时，将response作为<code>item_done()</code>参数的方式就不适用了。由于一个transaction只能对应一个<code>item_done()</code>，所以多次调用<code>item_done(rsp)</code>是会出错的</li>
<li>response机制的原理是driver将rsp推送给sequencer，sequencer内部维持一个队列，这个队列默认大小为<strong>8</strong>，如果溢出UVM会<strong>报错</strong></li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_do(m_trans)</span><br>            get_response(rsp);<br>            rsp<span class="hljs-variable">.print</span>();<br>            get_response(rsp);<br>            rsp<span class="hljs-variable">.print</span>();<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endtask</span><br>endclas<br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        drive_one_pkt(req); rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>        rsp<span class="hljs-variable">.set_id_info</span>(req);<br>        seq_item_port<span class="hljs-variable">.put_response</span>(rsp);<br>        seq_item_port<span class="hljs-variable">.put_response</span>(rsp);<br>        seq_item_port<span class="hljs-variable">.item_done</span>();<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="673-response-handler">6.7.3 response handler</span></h4><p><strong>问题背景：</strong></p>
<ul>
<li>在sequence中启动<code>get_response</code>时，进程就会阻塞在那里，一直到<code>response_queue</code>中被放入新的记录</li>
<li>sequence中发送<code>transaction</code>与<code>get_response</code>是在同一个进程中执行的，<code>get_response</code>阻塞会导致无法发送transaction</li>
</ul>
<p><strong>解决方法：</strong>重定义<code>response handle</code>，实现sequence中发送<code>transaction</code>与<code>get_response</code>功能分离</p>
<p><strong>具体步骤：</strong></p>
<ul>
<li>调用<code>use_response_handler()</code>函数，打开sequence的<code>response handler</code>功能（<strong>默认关闭</strong>）</li>
<li>需要重载虚函数<code>response_handler(uvm_sequence_item response);</code></li>
<li>在<code>response_handle</code>中<code>$cast</code>强制转换入参<code>response</code>为该sequence类的<code>RSP</code>类型</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_body();<br>      use_response_handler(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">endtask</span><br>  <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> response_handler(uvm_sequence_item response);<br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(rsp, response))<br>         <span class="hljs-meta">`uvm_error(&quot;seq&quot;, &quot;can&#x27;t cast&quot;)</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_info(&quot;seq&quot;, &quot;get one response&quot;, UVM_MEDIUM)</span><br>         rsp<span class="hljs-variable">.print</span>();<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(m_trans)</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   <span class="hljs-meta">`uvm_object_utils(case0_sequence)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="674-req与rsp">6.7.4 REQ与RSP</span></h4><p><strong>req变量来自哪里？</strong>：sequencer与driver的内部变量，可以直接使用</p>
<p><strong>回顾UVM中<code>uvm_driver</code>、<code>uvm_sequence</code>、<code>uvm_sequencer</code>类型声明</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> uvm_driver #(<br>      <span class="hljs-keyword">type</span>  REQ    =    uvm_sequence_item,<br>      <span class="hljs-keyword">type</span>  RSP    =    REQ<br>) <span class="hljs-keyword">extends</span> uvm_component<br>    <br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">class</span> uvm_sequence #(<br>      <span class="hljs-keyword">type</span>  REQ    =    uvm_sequence_item,<br>      <span class="hljs-keyword">type</span>  RSP    =    REQ<br>) <span class="hljs-keyword">extends</span> uvm_sequence_base<br> <br><span class="hljs-keyword">class</span> uvm_sequencer #(<br>      <span class="hljs-keyword">type</span>  REQ    =    uvm_sequence_item,<br>   RSP    =    REQ<br>) <span class="hljs-keyword">extends</span> uvm_sequencer_param_base <span class="hljs-variable">#(REQ, RSP)</span><br><br></code></pre></div></td></tr></table></figure>
<p>本书自定义<code>my_driver</code>、<code>my_sequence</code>、<code>my_sequencer</code>等类中使用一个参数即<code>my_transaction</code>，表示该子类的RSP、REQ泛型均为<code>my_transaction</code></p>
<p><strong>同时REQ与RSQ两种类型也可以不同</strong></p>
<p>使用如下几种方式产生的子类REQ与RSQ不同，也可以使用<code>response handler</code>，这与req及rsp类型相同时完全一样</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(my_transaction, your_transaction)</span>;<br><span class="hljs-keyword">class</span> my_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer <span class="hljs-variable">#(my_transaction, your_transaction)</span>;<br><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction, your_transaction)</span>;<br></code></pre></div></td></tr></table></figure>
<h3><span id="68-sequence-library">6.8 sequence library</span></h3><h4><span id="681-sequence-library基础">6.8.1 sequence library基础</span></h4><p>sequence library，就是一系列sequence的集合。sequence_library类的原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> uvm_sequence_library <span class="hljs-variable">#(type REQ=uvm_sequence_item,RSP=REQ) extends uvm_sequence #(REQ,RSP)</span>;<br></code></pre></div></td></tr></table></figure>
<p>由上述代码可以看出sequence library派生自<code>uvm_sequence</code>，从本质上说它是一个sequence</p>
<p><strong>作用</strong>：sequence library根据特定的算法（详见6.8.2）随机选择注册其中的一些sequence，并在body中执行这些sequence</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>自定义一个sequence library</p>
<ol>
<li>自定义一个<code>uvm_sequence_library</code>子类，REQ与RSQ参数与定义<code>sequence</code>相同</li>
<li>在该子类的<code>new</code>函数中要调用<code>init_sequence_library</code>，否则其内部的候选sequence队列就是空的</li>
<li>在该子类中调用宏<code>`uvm_sequence_library_utils</code>进行注册</li>
</ol>
</li>
<li><p>将某个sequence添加到sequence library中</p>
<ul>
<li>一个sequence在定义时使用宏<code>`uvm_add_to_seq_lib</code>来将其加入某个<code>sequence library</code>中，下面两条是该宏的补充说明<ul>
<li><code>uvm_add_to_seq_lib</code>有两个参数，第一个是此sequence的名字，第二个是要加入的sequence library的名字</li>
<li>一个sequence可以加入多个不同的sequence library中</li>
</ul>
</li>
</ul>
</li>
<li>sequence与sequence library定义好后，可以将sequence library作为sequencer的default sequence</li>
</ol>
<p><strong>代码示例：</strong></p>
<p>自定义一个sequence library</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> simple_seq_library <span class="hljs-keyword">extends</span> uvm_sequence_library<span class="hljs-variable">#(my_transaction)</span>;<br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;simple_seq_library&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>      init_sequence_library();<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils(simple_seq_library)</span><br>   <span class="hljs-meta">`uvm_sequence_library_utils(simple_seq_library);</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>将某个sequence添加到sequence library中</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> seq0 <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(my_transaction)</span>;<br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;seq0&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils(seq0)</span><br>   <span class="hljs-meta">`uvm_add_to_seq_lib(seq0, simple_seq_library)</span><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_do(req)</span><br>         <span class="hljs-meta">`uvm_info(&quot;seq0&quot;, &quot;this is seq0&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span> <br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//seq1，seq2，seq3三者与seq0类似，故不再重复说明</span><br></code></pre></div></td></tr></table></figure>
<p>将sequence library作为sequencer的default sequence</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           simple_seq_library::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="682-控制选择算法">6.8.2 控制选择算法</span></h4><p><strong>selection_mode变量</strong></p>
<p>sequence library中的变量<code>selection_mode</code>决定sequence library从其sequence队列中选择的模式，默认为<code>UVM_SEQ_LIB_RAND</code></p>
<p><code>selection_mode</code>原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_sequence_lib_mode selection_mode;<br></code></pre></div></td></tr></table></figure>
<p>其中<code>uvm_sequence_lib_mode</code>为一个枚举类型：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>   UVM_SEQ_LIB_RAND, <span class="hljs-comment">//selection_mode的默认值，完全的随机</span><br>    UVM_SEQ_LIB_RANDC,<span class="hljs-comment">//将加入其中的sequence随机排一个顺序，然后按照此顺序执行。这可以保证每个sequence执行一 遍，在所有的sequence被执行完一遍之前，不会有sequence被执行第二次</span><br>    UVM_SEQ_LIB_ITEM,<span class="hljs-comment">//sequence library退化成为一个普通的sequence，不再执行其sequence队列中的sequence</span><br>    UVM_SEQ_LIB_USER<span class="hljs-comment">//用户自定义选择的算法，需要用户重载select_sequence参数</span><br>&#125; uvm_sequence_lib_mode<br></code></pre></div></td></tr></table></figure>
<p><strong>如何设置</strong><code>selection_mode</code></p>
<p>使用<code>config_db::set</code>机制，示例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   <span class="hljs-comment">//设置default_sequence</span><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           simple_seq_library::type_id::get());<br>   <span class="hljs-comment">//设置selection_mode</span><br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_lib_mode)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.selection_mode&quot;</span>, <br>                                           UVM_SEQ_LIB_RANDC);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>如何自定义算法</strong></p>
<blockquote>
<p>假设有4个sequence加入了sequence library中：seq0、seq1、seq2和seq3。</p>
<p>现在由于各种原因，不想使用seq2了。上述代码的<code>select_sequence</code>第一次被调用时初始化index队列，把seq0、seq1和seq3在sequences中的索引号存入其中。之后，从index中随机选择一个值返回，相当于是从seq0、seq1和seq3随机选一个执行。sequences是sequence library中存放候选sequence的队列。</p>
<p><code>select_sequence</code>会传入一个参数max，<code>select_sequence</code>函数必须返回一个介于0到max之间的数值。如果sequences队列的大小为4，那么传入的max的数值是3，而不是4</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> simple_seq_library <span class="hljs-keyword">extends</span> uvm_sequence_library<span class="hljs-variable">#(my_transaction)</span>;<br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;simple_seq_library&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>      init_sequence_library();<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils(simple_seq_library)</span><br>   <span class="hljs-meta">`uvm_sequence_library_utils(simple_seq_library);</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> select_sequence(<span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> max);<br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> index[$];<br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">bit</span> inited;<br>      <span class="hljs-keyword">int</span> value;<br>      <span class="hljs-keyword">if</span>(!inited) <span class="hljs-keyword">begin</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max; i++) <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>((sequences[i]<span class="hljs-variable">.get_type_name</span>() == <span class="hljs-string">&quot;seq0&quot;</span>) ||<br>               (sequences[i]<span class="hljs-variable">.get_type_name</span>() == <span class="hljs-string">&quot;seq1&quot;</span>) ||<br>               (sequences[i]<span class="hljs-variable">.get_type_name</span>() == <span class="hljs-string">&quot;seq3&quot;</span>))<br>               index<span class="hljs-variable">.push_back</span>(i);<br>         <span class="hljs-keyword">end</span><br>         inited = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">end</span><br>      value = $urandom_range(<span class="hljs-number">0</span>, index<span class="hljs-variable">.size</span>() - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> index[value];<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           simple_seq_library::type_id::get());<br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_lib_mode)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.selection_mode&quot;</span>, <br>                                           UVM_SEQ_LIB_USER);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="683-控制执行次数">6.8.3 控制执行次数</span></h4><p><strong>min_random_count与max_random_count</strong></p>
<p>sequence library内部的两个变量控制生成sequence次数，默认都为10，变量定义原型如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> min_random_count=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> max_random_count=<span class="hljs-number">10</span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>sequence library会在<code>min_random_count</code>和<code>max_random_count</code>之间随意选择一个数来作为执行次数。这里只能选择10</li>
<li>当<code>selection_mode</code>为<code>UVM_SEQ_LIB_ITEM</code>时，将会产生10个item；为其他模式时，将会顺序启动10个sequence。可以设置这两个值为其他值来改变迭代次数</li>
</ul>
<p><strong>如何设置min_random_count与max_random_count**</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           simple_seq_library::type_id::get());<br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_lib_mode)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.selection_mode&quot;</span>, <br>                                           UVM_SEQ_LIB_ITEM);<br>   uvm_config_db<span class="hljs-variable">#(int unsigned)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.min_random_count&quot;</span>, <br>                                           <span class="hljs-number">5</span>);<br>   uvm_config_db<span class="hljs-variable">#(int unsigned)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.max_random_count&quot;</span>, <br>                                           <span class="hljs-number">20</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>上述设置将会产生最多20个，最少5个transaction</p>
<h4><span id="684-设置sequence-library的简便方案">6.8.4 设置sequence library的简便方案</span></h4><p><strong>问题背景</strong>：前几节使用3个config_db设置迭代次数和选择算法稍显麻烦</p>
<p>两种解决方案：</p>
<p>方案①：使用UVM提供了一个类<code>uvm_sequence_library_cfg</code>来对 sequence library进行配置</p>
<ul>
<li>声明一个<code>uvm_sequence_library_cfg</code>类的对象</li>
<li>调用该对象的构造函数<code>new</code>，并配置相应形参</li>
<li>使用<code>config_db::set</code>设置<code>default_sequence.config</code>与<code>default_sequence</code></li>
</ul>
<p>方案②：使用6.1.2中的方法3启动sequence，步骤如下：</p>
<ul>
<li>手动实例化seq</li>
<li>配置参数</li>
<li>使用<code>config_db::set</code>设置<code>default_sequence</code></li>
</ul>
<p><strong>代码示例</strong></p>
<p><strong>方案①</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   uvm_sequence_library_cfg cfg;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   cfg = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;cfg&quot;</span>, UVM_SEQ_LIB_RANDC, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>);<br>   <br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           simple_seq_library::type_id::get());<br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_library_cfg)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence.config&quot;</span>, <br>                                           cfg);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>方案②</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   simple_seq_library seq_lib;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   seq_lib = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq_lib&quot;</span>);<br>   seq_lib<span class="hljs-variable">.selection_mode</span> = UVM_SEQ_LIB_RANDC;<br>   seq_lib<span class="hljs-variable">.min_random_count</span> = <span class="hljs-number">10</span>;<br>   seq_lib<span class="hljs-variable">.max_random_count</span> = <span class="hljs-number">15</span>; <br>   uvm_config_db<span class="hljs-variable">#(uvm_sequence_base)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           seq_lib);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>‎2023‎年‎1‎月‎17‎日 18:36:58</p>
<h2><span id="第七章-uvm中的寄存器模型">第七章 UVM中的寄存器模型</span></h2><p>任何系统设计通常都面临两大挑战：缩小技术节点的尺寸和 TTM（上市时间）。为了应对竞争激烈的市场格局的速度，大多数系统都以通用方式设计——这意味着相同的设计可以以不同的方式用于不同的配置。配置的数量越多，设计中的寄存器数量就越多。最重要的是，由于当前市场对数据存储的高需求，内存容量也越来越大。要访问和验证大量的寄存器和巨大的内存，需要一些创新的方法。</p>
<p>因此，UVM提供了一个用于寄存器管理及其访问的基类库，称为UVM RAL（Register Abstraction Layer）。</p>
<p>UVM RAL 顾名思义，是一个高级的面向对象的抽象层，用于访问设计寄存器。RAL模型模仿设计寄存器，整个模型是完全可配置的。由于其抽象行为，RAL 模型可以很容易地从块级迁移到系统级</p>
<p><a target="_blank" rel="noopener" href="https://www.design-reuse.com/articles/46675/uvm-ral-model-usage-and-application.html">https://www.design-reuse.com/articles/46675/uvm-ral-model-usage-and-application.html</a></p>
<h3><span id="71-寄存器模型简介">7.1 寄存器模型简介</span></h3><p><strong>问题背景</strong>：</p>
<ul>
<li>在本书以前所有的例子中，DUT为最简单的DUT，只有数据端口，没有行为控制口，这样的DUT几乎是没有任何价值的</li>
<li>DUT一般都会有一组控制端口，用来配置DUT中的寄存器，DUT可以根据寄存器的值来改变行为（可以参考代码清单中B-2的DUT实现）</li>
</ul>
<p>操作指南：</p>
<ul>
<li>read</li>
<li>mirror：7.7.2</li>
<li>set：7.5.1</li>
<li>update：7.5.1</li>
<li>write：7.5.1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230201023224980.png" srcset="/img/loading.gif" lazyload alt="image-20230201023224980"></p>
<h4><span id="711-带寄存器配置总线的dut">7.1.1 带寄存器配置总线的DUT</span></h4><p><strong>B-2中DUT介绍：</strong></p>
<p>该DUT接口如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/dut/dut.sv</span><br><span class="hljs-keyword">input</span>          clk;<br><span class="hljs-keyword">input</span>          rst_n;<br><span class="hljs-keyword">input</span>          bus_cmd_valid;<span class="hljs-comment">//总线数据有效信号：为1时表示总线数据有效，只持续一个时钟</span><br>                             <span class="hljs-comment">//DUT应该在其为1期间采样总线数据：</span><br>                             <span class="hljs-comment">//如果是读操作，应该在下一个时钟给出读数据</span><br>                             <span class="hljs-comment">//如果是写操作，应该在下一个时钟把数据写入</span><br><span class="hljs-keyword">input</span>          bus_op;<span class="hljs-comment">//为1时表示写操作，为0表示读操作</span><br><span class="hljs-keyword">input</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]  bus_addr;<span class="hljs-comment">//16位总线地址（用于控制寄存器）</span><br><span class="hljs-keyword">input</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]  bus_wr_data;<span class="hljs-comment">//16位总线写数据（用于控制寄存器）</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]  bus_rd_data;<span class="hljs-comment">//16位总线读数据（用于控制寄存器）</span><br><span class="hljs-keyword">input</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   rxd;<span class="hljs-comment">//功能端口，用于接收输入数据</span><br><span class="hljs-keyword">input</span>          rx_dv;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   txd;<span class="hljs-comment">//功能端口，用于发送输出数据</span><br><span class="hljs-keyword">output</span>         tx_en;<br></code></pre></div></td></tr></table></figure>
<p>该DUT仅具有一个1bit的控制寄存器<code>invert</code>，其地址为<code>16&#39;h9</code>，用于实现以下功能：</p>
<ul>
<li><code>invert</code>值为1，那么DUT在输出时会将输入的数据取反</li>
<li><code>invert</code>值为0，那么DUT在输出时会将输入数据直接发送出去</li>
</ul>
<p><strong>验证平台框图：</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230119164542281.png" srcset="/img/loading.gif" lazyload alt="图7-1 新验证平台框图"></p>
<p><strong>验证平台相关重点代码：</strong></p>
<p>有如下的transaction定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.1/7.1.1/bus_transaction.sv</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;BUS_RD, BUS_WR&#125; bus_op_e;<br><br><span class="hljs-keyword">class</span> bus_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] rd_data;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] wr_data;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] addr;<br><br>   <span class="hljs-keyword">rand</span> bus_op_e  bus_op;<br><br>   <span class="hljs-meta">`uvm_object_utils_begin(bus_transaction)</span><br>      <span class="hljs-meta">`uvm_field_int(rd_data, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(wr_data, UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_int(addr   , UVM_ALL_ON)</span><br>      <span class="hljs-meta">`uvm_field_enum(bus_op_e, bus_op, UVM_ALL_ON)</span><br>   <span class="hljs-meta">`uvm_object_utils_end</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;bus_transaction&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>();<br>   <span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>有如下的driver定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> bus_driver::run_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.bus_cmd_valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_op</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_addr</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_wr_data</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> bus_driver::drive_one_pkt(bus_transaction tr);<br>   <span class="hljs-meta">`uvm_info(&quot;bus_driver&quot;, &quot;begin to drive one pkt&quot;, UVM_LOW);</span><br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">1</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <br>   vif<span class="hljs-variable">.bus_cmd_valid</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>   vif<span class="hljs-variable">.bus_op</span> &lt;= ((tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>   vif<span class="hljs-variable">.bus_addr</span> = tr<span class="hljs-variable">.addr</span>;<br>   vif<span class="hljs-variable">.bus_wr_data</span> &lt;= ((tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? <span class="hljs-number">0</span> : tr<span class="hljs-variable">.wr_data</span>);<br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   vif<span class="hljs-variable">.bus_cmd_valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_op</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_addr</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_wr_data</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.bus_op</span> == BUS_RD) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.rd_data</span> = vif<span class="hljs-variable">.bus_rd_data</span>;   <br>      <span class="hljs-comment">//$display(&quot;@%0t, rd_data is %0h&quot;, $time, tr.rd_data);</span><br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-meta">`uvm_info(&quot;bus_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.1/7.1.1/my_case0.sv</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br><span class="hljs-comment">/* 在sequence中，可以使用如下方式进行读操作，返回值通过另类的response直接引用返回的m_trans.rd_data */</span><br>     <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.addr == 16&#x27;h9;</span><br>                            m_trans<span class="hljs-variable">.bus_op</span> == BUS_RD;&#125;)<br>     <span class="hljs-meta">`uvm_info(&quot;case0_bus_seq&quot;, $sformatf(&quot;invert&#x27;s initial value is %0h&quot;, m_trans.rd_data), UVM_LOW)</span><br><span class="hljs-comment">/* 在sequence中，以如下的方式进行写操作 */</span><br>     <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.addr == 16&#x27;h9;</span><br>                            m_trans<span class="hljs-variable">.bus_op</span> == BUS_WR;<br>                            m_trans<span class="hljs-variable">.wr_data</span> == <span class="hljs-number">16&#x27;h1</span>;&#125;)<br>     <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.addr == 16&#x27;h9;</span><br>                            m_trans<span class="hljs-variable">.bus_op</span> == BUS_RD;&#125;)<br>     <span class="hljs-meta">`uvm_info(&quot;case0_bus_seq&quot;, $sformatf(&quot;after set, invert&#x27;s value is %0h&quot;, m_trans.rd_data), UVM_LOW)</span><br>     <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.addr == 16&#x27;h9;</span><br>                            m_trans<span class="hljs-variable">.bus_op</span> == BUS_WR;<br>                            m_trans<span class="hljs-variable">.wr_data</span> == <span class="hljs-number">16&#x27;h0</span>;&#125;)<br>     <span class="hljs-meta">`uvm_do_with(m_trans, &#123;m_trans.addr == 16&#x27;h9;</span><br>                            m_trans<span class="hljs-variable">.bus_op</span> == BUS_RD;&#125;)<br>     <span class="hljs-meta">`uvm_info(&quot;case0_bus_seq&quot;, $sformatf(&quot;after set, invert&#x27;s value is %0h&quot;, m_trans.rd_data), UVM_LOW)</span><br>   <span class="hljs-keyword">endtask</span><br><br><br></code></pre></div></td></tr></table></figure>
<h4><span id="712-概述">7.1.2 概述</span></h4><p><strong>问题背景：如何在参考模型中读取DUT中一个寄存器的值呢？</strong></p>
<p>没有寄存器模型的情况下：我们只能先通过使用<code>bus_driver</code>向总线上发送读指令，并给出要读的寄存器地址来查看一个寄存器的值。要实现这个过程，需要启动一个sequence，这个sequence会发送一个transaction给<code>bus_driver</code>，这会带来两个问题：</p>
<ul>
<li>第一个问题是，如何在参考模型的控制下来启动一个sequence以读取寄存器</li>
<li>第二个问题是，sequence读取的寄存器的值如何传递给参考模型</li>
</ul>
<p>解决第一个问题有两种方法：</p>
<ul>
<li>方法1：一个简单的想法是设置一个全局事件，然后在参考模型中触发这个事件。在virtual sequence中等待这个事件的到来，等到了，则启动sequence（全局变量，非常不好！）</li>
<li>方法2：用一个非全局事件来代替。利用config机制分别为<code>virtual sequencer</code>和<code>scoreboard</code>设置一个 <code>config_object</code>，在此object中设置一个事件，如<code>rd_reg_event</code>，然后在scoreboard中触发这个事件，而在<code>virtual sequence</code>中则要等待这个事件的到来（代码可以是<code>@p_sequencer.config_object.rd_reg_event;</code>），这个事件等到后就启动一个sequence，开始读寄存器</li>
<li>方法3：详见7.3.1</li>
</ul>
<p>解决第二个问题：当sequence读取到寄存器后，可以再通过6.6.2节所示的config_db传递给参考模型，在参考模型中使用6.6.3 节所示的<code>wait_modified</code>来更新数据</p>
<p><strong>可以看到看出这个过程相当麻烦</strong>，如果有了寄存器模型，只要一条语句就可以实现上述复杂的过程。像启动sequence及将读取结果返回这些事情，都会由寄存器模型来自动完成。这个过程就可以简化为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>    …<br>    reg_model<span class="hljs-variable">.INVERT_REG</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>    …<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>下图指出了读取寄存器的过程</strong>，其中左图为不使用寄存器模型，右图为使用寄存器模型的读取方式</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230120170703668.png" srcset="/img/loading.gif" lazyload alt="不使用寄存器模型（左）  使用寄存器模型（右）"></p>
<p><strong>后门与前门的使用，以及寄存器模型的优势</strong></p>
<p>在没有寄存器模型之前，验证平台内模块只能启动sequence通过<mark>前门（FRONTDOOR）访问</mark>的方式来读取寄存器</p>
<p>有了寄存器模型之后，验证平台内模块<u><strong>只</strong>与寄存器模型打交道</u>，无论是发送读的指令还是获取读操作的返回值，都可以由寄存器模型完成</p>
<p>有了寄存器模型后，可以<u>在<strong>任何</strong>耗费时间的phase中使用寄存器模型</u>以<strong>前门访问或后门（BACKDOOR）</strong>访问的方式来读取寄存器的值</p>
<p>有了寄存器模型后，还能<u>在<strong>某些</strong>不耗费时间的phase(如check_phase)中</u>使用<mark><strong>后门访问</strong></mark>的方式来读取寄存器的值</p>
<p><strong>前门访问与后门访问</strong>：<u>是两种寄存器的访问方式</u>，关于前门访问与后门访问的问题，将会在7.3节中详细说明</p>
<p><strong>前门访问：</strong></p>
<ul>
<li>概念：指的是通过模拟cpu在总线上发出读指令，进行读写操作。在这个过程中，仿真时间（<code>$time</code>函数得到的时间）是一直往前走的</li>
<li>前门访问的工作流程：7.2.2</li>
</ul>
<p><strong>后门访问：</strong>是与前门访问相对的概念。它并不通过总线进行读写操作，而是直接通过层次化的引用来改变寄存器的值</p>
<p><strong>UVM寄存器模型的本质就是重新定义了验证平台与DUT的寄存器接口，使验证人员更好地组织及配置寄存器，简化流程、减少工作量</strong></p>
<blockquote>
<p><strong>前门访问（FRONTDOOR）</strong>：启动sequence产生待操作寄存器的读写控制和地址，在driver中通过总线（Bus）驱动至DUT，并在monitor中采集Bus输出数据，该方式需要<strong>消耗仿真时间</strong> ；<br><strong>后门访问（BACKDOOR）</strong>：在仿真环境中通过DUT实例名进行<strong>点操作</strong>，直接访问DUT内部的寄存器，该方式的缺点是，点操作需要通过绝对路径操作，如果寄存器数量庞大，会导致验证环境臃肿繁杂，容易出错</p>
<p>如下图所示，RAL Model中包含MEM和 block，它们分别用于对 DUT 中的寄存器和memory进行建模，其行为和硬件行为保持一致（其实是尽可能保持一致），ADDR MAP用于实现访问寄存器的相对地址和绝对地址的转换</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/1039625-20191116113321329-1067463265.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p><strong>寄存器模型注意有以下优势：</strong></p>
<p>  a.方便对 DUT 中寄存器进行读写；<br>  b.在软件仿真时，可以不耗时的获取寄存器的值（直接从 RAL Model 中获取）；<br>  c.可以很方便的正对寄存器的coverage验证点的收集</p>
</blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dreamCll/p/11756898.html">https://www.cnblogs.com/dreamCll/p/11756898.html</a></p>
<p><strong>我的理解</strong></p>
<p>RAL model是验证平台用于获取DUT内部寄存器状态的一个桥梁，通过调用RAL model的<code>read/write</code>函数（前门/后门访问）或<code>peek/poke</code>（后门访问），可以很轻松以不同方式实现验证平台对DUT内部寄存器的读写</p>
<p>而具体实现DUT内部寄存器读写的总线操作，是通过bus_agent进行的</p>
</blockquote>
<h4><span id="713-寄存器模型中的基本概念">7.1.3 寄存器模型中的基本概念</span></h4><ul>
<li><code>uvm_reg_field</code>：寄存器域，这是寄存器模型中的最小单位</li>
<li><code>uvm_reg</code>：寄存器，一个比较小的单位，比<code>uvm_reg_field</code>高一个级别。<u>一个<code>uvm_reg</code>中至少包含一个<code>uvm_reg_field</code></u></li>
<li><code>uvm_reg_block</code>：寄存器块，一个比较大的单位，在其中可以加入许多的<code>uvm_reg</code>，也可加其他的<code>uvm_reg_block</code>。<u>一个寄存器模型中至少包含一个<code>uvm_reg_block</code></u></li>
<li><code>uvm_reg_map</code>：寄存器地址映射，每个寄存器在加入寄存器模型时都有其地址，<code>uvm_reg_map</code>就是存储这些地址，并将其转换成可以访问的物理 地址（因为加入寄存器模型中的寄存器地址一般都是偏移地址，而不是绝对地址）。当寄存器模型使用<u>前门访问方式</u>来实现读或写操作时，<code>uvm_reg_map</code>就会将地址转换成绝对地址，启动一个读或写的sequence，并将读或写的结果返回。<u>在每个<code>uvm_reg_block</code>内部，至少有一个（通常也只有一个）<code>uvm_reg_map</code></u></li>
</ul>
<p><strong><code>uvm_reg</code>与<code>uvm_reg_field</code>对比：</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230125235342862.png" srcset="/img/loading.gif" lazyload alt="image-20230125235342862"></p>
<p>如上的状态寄存器共有四个域，分别是empty、full、overflow、underflow。这四个域对应寄存器模型中的uvm_reg_field。名字 为“reserved”的并不是一个域</p>
<blockquote>
<p>我的理解：（多个域的寄存器配置方法略有不同）</p>
<p>field，寄存器内的域</p>
<ul>
<li>不用自定义，需要在reg中例化并配置</li>
</ul>
<p>reg，寄存器</p>
<ul>
<li>需要自定义</li>
<li>在<code>new</code>函数中向<code>super.new</code>传递寄存器基本信息，如位宽等</li>
<li>内部需要对不同field例化并配置</li>
</ul>
<p>block，多个寄存器组成的块</p>
<ul>
<li>需要自定义</li>
<li>在<code>new</code>函数中调用<code>super.new</code></li>
<li>内部需要对所有reg例化并配置，configure参数3设置为路径字符串用作后门访问地址，同时调用reg.build函数配置field</li>
<li>内部需要对内部成员default_map进行例化与配置</li>
<li>将所有reg添加到default_map中</li>
<li>一般在base_test中例化，一般会实现两级结构（见7.4.1）</li>
<li>（可选）reg_file实例化并配置，修改reg的configure参数3为该reg_file指针</li>
</ul>
<p>map，地址映射</p>
<ul>
<li>不用自定义</li>
</ul>
<p>base_test</p>
<ul>
<li>adapter相关<ul>
<li>声明，例化adapter</li>
<li>将adpater与bus_sequencer告知reg model中的default_map</li>
</ul>
</li>
<li><p>reg model相关（7.2.2）</p>
<ul>
<li>声明、例化block（这个就是reg model）、配置reg model以及后门访问路径（一般不用设置，可以在reg的配置里设置）、build其内部所有reg，锁定reg model、复位reg model</li>
<li>将reg model中的default_map设置为自动预测状态</li>
<li>将reg model指针传递给env，env再传递给其他组件</li>
</ul>
</li>
<li><p>后门访问</p>
<ul>
<li>需要设置根路径<code>rm.set_hdl_path_root(&quot;top_tb.my_dut&quot;);</code></li>
</ul>
</li>
</ul>
<p>reg_file</p>
<ul>
<li><p>mem</p>
</li>
<li></li>
</ul>
</blockquote>
<h3><span id="72-简单的寄存器模型">7.2 简单的寄存器模型</span></h3><h4><span id="721-只有一个寄存器的寄存器模型">7.2.1 只有一个寄存器的寄存器模型</span></h4><p>考虑之前只存在一个寄存器<code>invert</code>的DUT，为其建造寄存器模型，主要有以下几步：</p>
<ol>
<li>定义一个<code>uvm_reg</code>的派生类（<em>reg定义</em>）<ul>
<li>在其<code>new</code>函数中向<code>super.new</code>传递寄存器基本信息</li>
<li>在其<code>build</code>函数内实例化所有<code>uvm_reg_field</code>对象，并调用<code>configure</code>函数配置（<em>field实例化</em>）</li>
</ul>
</li>
<li>定义一个<code>uvm_reg_block</code>派生类（<em>block定义</em>）<ul>
<li>在其<code>build</code>函数内实现所有<code>uvm_reg</code>对象的实例化，并调用其<code>configure</code>与<code>build</code>函数，完成配置与构建（<em>reg实例化</em>）</li>
<li>在其<code>build</code>函数内，使用内部变量<code>default_map</code>创建并参数配置一个<code>uvm_reg_map</code>，将上面实例化的reg加入该map中（<em>map实例化</em>）</li>
</ul>
</li>
</ol>
<p><strong>补充：一个<code>uvm_reg_block</code>中一定要对应一个<code>uvm_reg_map</code></strong></p>
<p><strong>分步分析</strong></p>
<p><strong>1、定义一个<code>uvm_reg</code>的派生类</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/reg_model.sv</span><br><span class="hljs-keyword">class</span> reg_invert <span class="hljs-keyword">extends</span> uvm_reg;<br><br>    <span class="hljs-keyword">rand</span> uvm_reg_field reg_data;<br><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        reg_data = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;reg_data&quot;</span>);<br>        <span class="hljs-comment">// parameter: parent, size, lsb_pos, access, volatile, reset value, has_reset, is_rand, individually accessible</span><br>        reg_data<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">endfunction</span><br><br>    <span class="hljs-meta">`uvm_object_utils(reg_invert)</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_invert&quot;</span>);<br>        <span class="hljs-comment">//parameter: name, size, has_coverage</span><br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">16</span>, UVM_NO_COVERAGE);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>new构造方法</p>
<p>在new函数中，要调用<code>super.new</code>函数，该函数有三个参数：</p>
<ul>
<li>参数1：</li>
<li>参数2：该寄存器的位数（如对于一个16位的寄存器，其中可能只使用了8位，那么这里要填写的是16，而不是8。这个数字一般与系统总线的宽度一致）</li>
<li>参数3：该寄存器是否要加入覆盖率的支持，是为<code>UVM_COVERAGE</code>，否为<code>UVM_NO_COVERAGE</code></li>
</ul>
<p>build方法</p>
<p>每一个派生自<code>uvm_reg</code>的类都有一个<code>build</code>，这个<code>build</code>与<code>uvm_component</code>的<code>build_phase</code>并不一样，它不会自动执行，而需要手工调用，与<code>build_phase</code>相似的是所有的<code>uvm_reg_field</code>都在这里实例化</p>
<p>配置字段</p>
<p>当<code>uvm_reg_field</code>（<code>reg_data</code>）实例化后，要调用<code>uvm_reg_field.configure</code>（<code>reg_data.configure</code>）函数来配置这个字段</p>
<p><code>configure</code>：</p>
<ul>
<li>第一个参数就是此域（<code>uvm_reg_field</code>）的父辈，也即此域位于哪个<code>uvm_reg</code>中，这里当然是填写this</li>
<li>第二个参数是此域的宽度，由于DUT中invert的宽度为1，所以这里为1</li>
<li>第三个参数是此域的最低位在整个寄存器中的位置，从0开始计数</li>
</ul>
<blockquote>
<p>假如一个寄存器如图所示，其低3位和高5位没有使用，其中只有一个字段，此字段的有效宽度为8位，那么在调用configure时，第二个参数就要填写8，第三个参数则要填写3，因为此<code>uvm_reg_field</code>是从第4位开始的</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230121014833931.png" srcset="/img/loading.gif" lazyload alt="image-20230121014833931"></p>
</blockquote>
<ul>
<li>第四个参数表示此字段的存取方式。UVM共支持如下25种存取方式（事实上，寄存器的种类多种多样，25种存取方式有时并不能满足用户的需求，这时就需要自定义寄存器的模型）：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-number">1</span>）RO：读写此域都无影响<br><span class="hljs-number">2</span>）RW：会尽量写入，读取时对此域无影响<br><span class="hljs-number">3</span>）RC：写入时无影响，读取时会清零<br><span class="hljs-number">4</span>）RS：写入时无影响，读取时会设置所有的位<br><span class="hljs-number">5</span>）WRC：尽量写入，读取时会清零<br><span class="hljs-number">6</span>）WRS：尽量写入，读取时会设置所有的位<br><span class="hljs-number">7</span>）WC：写入时会清零，读取时无影响<br><span class="hljs-number">8</span>）WS：写入时会设置所有的位，读取时无影响<br><span class="hljs-number">9</span>）WSRC：写入时会设置所有的位，读取时会清零<br><span class="hljs-number">10</span>）WCRS：写入时会清零，读取时会设置所有的位<br><span class="hljs-number">11</span>）W1C：写<span class="hljs-number">1</span>清零，写<span class="hljs-number">0</span>时无影响，读取时无影响<br><span class="hljs-number">12</span>）W1S：写<span class="hljs-number">1</span>设置所有的位，写<span class="hljs-number">0</span>时无影响，读取时无影响<br><span class="hljs-number">13</span>）W1T：写<span class="hljs-number">1</span>入时会翻转，写<span class="hljs-number">0</span>时无影响，读取时无影响<br><span class="hljs-number">14</span>）W0C：写<span class="hljs-number">0</span>清零，写<span class="hljs-number">1</span>时无影响，读取时无影响<br><span class="hljs-number">15</span>）W0S：写<span class="hljs-number">0</span>设置所有的位，写<span class="hljs-number">1</span>时无影响，读取时无影响<br><span class="hljs-number">16</span>）W0T：写<span class="hljs-number">0</span>入时会翻转，写<span class="hljs-number">1</span>时无影响，读取时无影响<br><span class="hljs-number">17</span>）W1SRC：写<span class="hljs-number">1</span>设置所有的位，写<span class="hljs-number">0</span>时无影响，读清零<br><span class="hljs-number">18</span>）W1CRS：写<span class="hljs-number">1</span>清零，写<span class="hljs-number">0</span>时无影响，读设置所有位<br><span class="hljs-number">19</span>）W0SRC：写<span class="hljs-number">0</span>设置所有的位，写<span class="hljs-number">1</span>时无影响，读清零<br><span class="hljs-number">20</span>）W0CRS：写<span class="hljs-number">0</span>清零，写<span class="hljs-number">1</span>时无影响，读设置所有位<br><span class="hljs-number">21</span>）WO：尽可能写入，读取时会出错<br><span class="hljs-number">22</span>）WOC：写入时清零，读取时出错<br><span class="hljs-number">23</span>）WOS：写入时设置所有位，读取时会出错<br><span class="hljs-number">24</span>）W1：在复位（reset）后，第一次会尽量写入，其他写入无影响，读取时无影响<br><span class="hljs-number">25</span>）WO1：在复位后，第一次会尽量写入，其他的写入无影响，读取时会出错<br></code></pre></div></td></tr></table></figure>
<ul>
<li>第五个参数表示是否是易失的（<code>volatile</code>），这个参数一般不会使用</li>
<li>第六个参数表示此域上电复位后的默认值。</li>
<li>第七个参数表示此域是否有复位，一般的寄存器或者寄存器的域都有上电复位值，因此这里一般也填写<code>1</code></li>
<li>第八个参数表示这个域是否可以随机化。这主要用于对寄存器进行随机写测试，如果选择了0，那么此域将不会随机化，而一直是复位值，否则将会随机出一个数值来。这一个参数当且仅当第四个参数为RW、WRC、WRS、WO、W1、WO1时才有效</li>
<li>第九个参数表示这个域是否可以单独存取</li>
</ul>
</blockquote>
<p><strong>2、定义一个<code>uvm_reg_block</code>派生类</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>   <span class="hljs-keyword">rand</span> reg_invert invert;<br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>      default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br><br>      invert = reg_invert::type_id::create(<span class="hljs-string">&quot;invert&quot;</span>, , get_full_name());<br>      invert<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>      invert<span class="hljs-variable">.build</span>();<br>      default_map<span class="hljs-variable">.add_reg</span>(invert, <span class="hljs-number">&#x27;h9</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-meta">`uvm_object_utils(reg_model)</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_model&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, UVM_NO_COVERAGE);<br>    <span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>new构造方法</p>
<p>在new函数中，要调用<code>super.new</code>函数</p>
<p>build方法</p>
<p><strong>每一个由<code>uvm_reg_block</code>派生的类也要定义一个build函数，一般在此函数中实现所有寄存器的实例化</strong></p>
<p><strong>步骤：</strong></p>
<ol>
<li>实例化<code>uvm_map</code>：调用<code>create_map</code>函数，为内部成员<code>default_map</code>实例化</li>
</ol>
<blockquote>
<p>一个<code>uvm_reg_block</code>中一定要对应一个<code>uvm_reg_map</code>，系统已经有一个声明好的<code>default_map</code>，只需要在<code>build</code>中将其实例化</p>
<p><code>default_map</code>的过程并不是直接调用<code>uvm_reg_map</code>的<code>new</code>函数，而是通过调用<code>uvm_reg_block</code>的<code>create_map</code>来实现</p>
<p><code>create_map</code>参数：</p>
<ul>
<li>第一个参数是名字</li>
<li>第二个参数是基地址</li>
<li>第三个参数则是系统总线的宽度，这里的单位是byte而不是bit</li>
<li>第四个参数是大小端</li>
<li>最后一个参数表示是否能够按照byte寻址</li>
</ul>
</blockquote>
<ol>
<li>实例化<strong>所有</strong><code>uvm_reg</code>：使用工厂方法，实例化之前定义的<code>uvm_reg</code>衍生类</li>
<li>配置<code>uvm_reg</code>的实例：调用之前实例化的<code>uvm_reg</code>变量的<code>configure</code>函数</li>
</ol>
<blockquote>
<p><code>configure</code>函数：这个函数的主要功能是指定寄存器进行后门访问路径</p>
<p><code>configure</code>参数：</p>
<ul>
<li>第一个参数是此寄存器所在uvm_reg_block的指针，这里填写this</li>
<li>第二个参数是reg_file的指针（7.4.2节将会介绍reg_file的概念）这里暂时填写null</li>
<li>第三个参数是此寄存器的<strong>后门访问路径</strong>，关于这点请参考7.3节，这里暂且为空</li>
</ul>
</blockquote>
<ol>
<li>实例化<code>uvm_field</code>：当调用完<code>configure</code>时，需要手动调用<code>uvm_reg</code>变量的build函数，将该寄存器中的域实例化</li>
<li>将<code>uvm_reg</code>变量加入<code>default_map</code>中：调用<code>add_reg</code>函数</li>
</ol>
<blockquote>
<p><code>uvm_reg_map</code>的作用是存储所有寄存器的地址，因此必须将实例化的寄存器加入<code>default_map</code>中，否则无法进行<u>前门访问</u>操作</p>
<p><code>add_reg</code>函数参数：</p>
<ul>
<li>第一个参数是要加入的寄存器</li>
<li>第二个参数是寄存器的地址</li>
<li>第三个参数是此寄存器的存取方式</li>
</ul>
</blockquote>
</blockquote>
<h4><span id="722-寄存器模型集成">7.2.2 寄存器模型集成</span></h4><p><strong>前门访问方式工作流程：</strong></p>
<p>寄存器模型的前门访问方式工作流程如图所示，其中图a为读操作，图b为写操作</p>
<p>寄存器模型的前门访问操作可以分成读和写两种，<strong>步骤如下：</strong></p>
<ol>
<li>无论是读或写，RAL model在调用 <code>read/write</code>函数时都会通过启动一个 <code>sequence</code>(用户不可见) 产生一个 <code>uvm_reg_bus_op</code> 的变量，此变量中存储着操作类型（读还是写），操作的地址，如果是写操作，还会有要写入的数据</li>
</ol>
<blockquote>
<p>此变量中存储着操作类型（读还是写）和操作的地址</p>
<p>如果是写操作，还会有要写入的数据</p>
</blockquote>
<ol>
<li><p>此变量中的信息要经过一个转换器（ <code>adapter</code> ）转换之后，交给<code>bus_sequencer</code></p>
</li>
<li><p>随后<code>bus_sequencer</code>交给<code>bus_driver</code>，由<code>bus_driver</code>实现最终的前门访问读写操作</p>
</li>
</ol>
<blockquote>
<p><strong>因此，必须要定义好一个转换器</strong></p>
<p><strong>寄存器模型的前门访问操作最终都将由<code>uvm_reg_map</code>完成</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126002422689.png" srcset="/img/loading.gif" lazyload alt="image-20230126002422689"></p>
<p><strong>一个简单的转换器的代码：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/my_adapter.sv</span><br><span class="hljs-keyword">class</span> my_adapter <span class="hljs-keyword">extends</span> uvm_reg_adapter;<br>    <span class="hljs-keyword">string</span> tID = get_type_name();<br><br>    <span class="hljs-meta">`uvm_object_utils(my_adapter)</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;my_adapter&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> : <span class="hljs-keyword">new</span><br><br>   <span class="hljs-keyword">function</span> uvm_sequence_item reg2bus(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> uvm_reg_bus_op rw);<br>      bus_transaction tr;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>); <br>      tr<span class="hljs-variable">.addr</span> = rw<span class="hljs-variable">.addr</span>;<br>      tr<span class="hljs-variable">.bus_op</span> = (rw<span class="hljs-variable">.kind</span> == UVM_READ) ? BUS_RD: BUS_WR;<br>      <span class="hljs-keyword">if</span> (tr<span class="hljs-variable">.bus_op</span> == BUS_WR)<br>         tr<span class="hljs-variable">.wr_data</span> = rw<span class="hljs-variable">.data</span>; <br>      <span class="hljs-keyword">return</span> tr;<br>   <span class="hljs-keyword">endfunction</span> : reg2bus<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> bus2reg(uvm_sequence_item bus_item, <span class="hljs-keyword">ref</span> uvm_reg_bus_op rw);<br>      bus_transaction tr;<br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(tr, bus_item)) <span class="hljs-keyword">begin</span><br>         <span class="hljs-meta">`uvm_fatal(tID,</span><br>          <span class="hljs-string">&quot;Provided bus_item is not of the correct type. Expecting bus_transaction&quot;</span>)<br>          <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">end</span><br>      rw<span class="hljs-variable">.kind</span> = (tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? UVM_READ : UVM_WRITE;<br>      rw<span class="hljs-variable">.addr</span> = tr<span class="hljs-variable">.addr</span>;<br>      rw<span class="hljs-variable">.byte_en</span> = <span class="hljs-number">&#x27;h3</span>;<br>      rw<span class="hljs-variable">.data</span> = (tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? tr<span class="hljs-variable">.rd_data</span> : tr<span class="hljs-variable">.wr_data</span>;<br>      rw<span class="hljs-variable">.status</span> = UVM_IS_OK;<br>   <span class="hljs-keyword">endfunction</span> : bus2reg<br><br><span class="hljs-keyword">endclass</span> : my_adapter<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>转换器实现步骤</strong>：一个转换器要定义好两个函数<code>reg2bus</code>、<code>bus2reg</code></p>
<ul>
<li><code>reg2bus</code>，其作用为将寄存器模型通过<code>sequence</code>发出的<code>uvm_reg_bus_op</code>型的变量转换成 <code>bus_sequencer</code>能够接受的形式</li>
<li><code>bus2reg</code>，其作用为当监测到总线上有操作时，它将收集来的<code>transaction</code>转换成寄存器模型能够接受的形式，以便寄存器模型能够更新相应的寄存器的值</li>
</ul>
</blockquote>
<p><strong>补充：读操作细节、虚线解释</strong></p>
<p>说到这里，不得不考虑寄存器模型发起的读操作的数值是如何返回给寄存器模型的？(如果你搞不懂为什么这里是寄存器模型读操作返回给寄存器模型，请参考7.1.2我的理解内容)</p>
<ul>
<li>由于总线的特殊性，<code>bus_driver</code>在驱动总线进行读操作时，它也能顺便获取要读的数值</li>
<li>如果它将此值放入从<code>bus_sequencer</code>获得的<code>bus_transaction</code>中时，那么<code>bus_transaction</code>中就会有读取的值</li>
<li>此值经过<code>adapter</code>的<code>bus2reg</code>函数的传递，最终被寄存器模型获取</li>
</ul>
<p>这个过程如图7-5a所示。由于并没有实际的transaction的传递，所以从<code>bus_driver</code>到<code>adapter</code>使用了<strong>虚线</strong></p>
<p><strong>把寄存器模型集成到bast_test中</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/base_test.sv</span><br><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env;<br>   my_vsqr        v_sqr;<br>   reg_model      rm;<br>   my_adapter     reg_sqr_adapter;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;base_test&quot;</span>, uvm_component parent = <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span><br>   <br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">extern</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);<br>   <span class="hljs-meta">`uvm_component_utils(base_test)</span><br><span class="hljs-keyword">endclass</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env  =  my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>); <br>   v_sqr =  my_vsqr::type_id::create(<span class="hljs-string">&quot;v_sqr&quot;</span>, <span class="hljs-keyword">this</span>);<br>   rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>   rm<span class="hljs-variable">.configure</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>   rm<span class="hljs-variable">.build</span>();<br>   rm<span class="hljs-variable">.lock_model</span>();<br>   rm<span class="hljs-variable">.reset</span>();<br>   reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>   env<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   v_sqr<span class="hljs-variable">.p_my_sqr</span> = env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>;<br>   v_sqr<span class="hljs-variable">.p_bus_sqr</span> = env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.sqr</span>;<br>   v_sqr<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br>   rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_sequencer</span>(env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.sqr</span>, reg_sqr_adapter);<br>   rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_auto_predict</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::report_phase(uvm_phase phase);<br>   uvm_report_server server;<br>   <span class="hljs-keyword">int</span> err_num;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.report_phase</span>(phase);<br><br>   server = get_report_server();<br>   err_num = server<span class="hljs-variable">.get_severity_count</span>(UVM_ERROR);<br><br>   <span class="hljs-keyword">if</span> (err_num != <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST CASE FAILED&quot;</span>);<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST CASE PASSED&quot;</span>);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>集成步骤：</p>
<ol>
<li><strong>至少需要在base_test中定义两个成员变量</strong>：<code>reg_model</code>（这是一个<code>uvm_reg_block</code>的自定义衍生类）、<code>reg_sqr_adapter</code>（这是一个<code>uvm_reg_adapter</code>的自定义衍生类）</li>
<li><code>build_phase</code>：<ul>
<li>所有用到的类进行实例化（<code>reg_model</code>、<code>reg_sqr_adapter</code>…）</li>
<li>对于<code>reg_model</code>还要做四件事：<ul>
<li>第一是调用<code>configure()</code>函数，其第一个参数是<code>parent block</code>，由于是最顶层的<code>reg_block</code>，因此填写<code>null</code>，<strong>第二个参数是后门访问路径</strong>，请参考7.3节，这里传入一个空的字符串</li>
<li>第二是调用<code>build()</code>函数，将所有的寄存器实例化</li>
<li>第三是调用<code>lock_model()</code>函数，调用此函数后，<code>reg_model</code>中就不能再加入新的寄存器了</li>
<li>第四是调用<code>reset()</code>函数，如果不调用此函数，那么<code>reg_model</code>中所有寄存器的值都是<code>0</code>，调用此函数后，所有寄存器的值都将变为设置的复位值</li>
</ul>
</li>
</ul>
</li>
<li><code>connect_phase</code>：<ul>
<li>将转换器和<code>bus_sequencer</code>通过<code>set_sequencer()</code>函数告知<code>reg_model</code>的<code>default_map</code></li>
<li>通过<code>set_auto_predict(1)</code>函数，将<code>default_map</code>设置为<strong>自动预测状态</strong>（因为寄存器模型中涉及到的前门访问操作最终都将由<code>uvm_reg_map</code>完成，所以需要告知<code>default_map</code>）</li>
</ul>
</li>
</ol>
</blockquote>
<h4><span id="723-如何使用寄存器模型">7.2.3 如何使用寄存器模型</span></h4><p><strong>本节基本内容</strong></p>
<ul>
<li>当一个寄存器模型被建立好后，可以在sequence和其他component中使用</li>
<li>本节以前门访问为例，介绍寄存器模型提供了两个基本的任务：<code>read</code>和<code>write</code>，用于其他类对寄存器模型的读写</li>
</ul>
<p><strong>寄存器模型与transaction类型：</strong></p>
<p>寄存器模型对sequence的transaction类型没有任何要求。因此，可以在一个发送my_transaction的sequence中使用寄存器模型对寄存器进行读写操作</p>
<p><strong>在参考模型中读取寄存器</strong></p>
<p>使用<code>read</code>任务：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/my_model.sv</span><br><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   uvm_status_e status;<br>   uvm_reg_data_t value;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   p_rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.copy</span>(tr);<br>      <span class="hljs-comment">//`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>      <span class="hljs-comment">//new_tr.print();</span><br>      <span class="hljs-keyword">if</span>(value)<br>         invert_tr(new_tr);<br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>参考模型中获得寄存器模型的指针</strong></p>
<p>以在参考模型中使用为例，需要在参考模型中有一个寄存器模型的指针：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/my_model.sv</span><br><span class="hljs-keyword">class</span> my_model <span class="hljs-keyword">extends</span> uvm_component;<br>...<br> reg_model p_rm;<br>...<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>这个指针的实例获取方式：</p>
<ul>
<li>在<code>base_test</code>实例化<code>reg_model</code>时传递给<code>env</code>，</li>
<li>再由<code>env</code>传递给<code>ref_model</code></li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<p>在7.8.1使用新方法<code>get_root_block</code>可以在不使用指针传递的情况下得到寄存器模型的指针</p>
</blockquote>
<p><code>read</code>任务参数</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126020234630.png" srcset="/img/loading.gif" lazyload alt="image-20230126020234630"></p>
<p>它有多个参数，常用的是其前三个参数：</p>
<ul>
<li>其中第一个是<code>uvm_status_e</code>型的变量，这是一个输出，用于表明读操作是否成功</li>
<li>第二个是读取的数值，也是一个输出</li>
<li>第三个是读取的方式，可选<code>UVM_FRONTDOOR</code>和<code>UVM_BACKDOOR</code></li>
</ul>
</blockquote>
<p><strong>在virtual sequence中写入寄存器</strong></p>
<p>由于参考模型一般不会写寄存器，因此对于<code>write</code>任务，以在virtual sequence进行写操作为例说明</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_cfg_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br><br>   <span class="hljs-meta">`uvm_object_utils(case0_cfg_vseq)</span><br>   <span class="hljs-meta">`uvm_declare_p_sequencer(my_vsqr)</span><br>   <br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;case0_cfg_vseq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      uvm_status_e   status;<br>      uvm_reg_data_t value;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>      <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s initial value is %0h&quot;, value), UVM_LOW)</span><br>      p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.write</span>(status, <span class="hljs-number">1</span>, UVM_FRONTDOOR);<br>      p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>      <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;after set, invert&#x27;s value is %0h&quot;, value), UVM_LOW)</span><br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>virtual sequence中获得寄存器模型的指针</strong></p>
<p>这个指针的实例获取方式：</p>
<ul>
<li>在<code>base_test</code>（该类实例化了<code>reg_model</code>）的<code>connect_phase()</code>时把<code>reg_model</code>传递给<code>v_sqr</code></li>
<li>在sequence中使用寄存器模型，通常通过<code>p_sequencer</code>的形式</li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<p>在7.8.1使用新方法<code>get_root_block</code>可以在不使用指针传递的情况下得到寄存器模型的指针</p>
</blockquote>
<p><code>write</code>任务参数</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230126020356516.png" srcset="/img/loading.gif" lazyload alt="image-20230126020356516"></p>
<p>它的参数也有很多个，但是与read类似，常用的也只有前三个：</p>
<ul>
<li>第一个为<code>uvm_status_e</code>型的变量，这是一个输出，用于表明写操作是否成功</li>
<li>第二个要写的值，是一个输入</li>
<li>第三个是写操作的方式，可选<code>UVM_FRONTDOOR</code>和<code>UVM_BACKDOOR</code></li>
</ul>
</blockquote>
<h3><span id="73-前门访问与后门访问">7.3 前门访问与后门访问</span></h3><h4><span id="731-uvm中的前门访问实现">7.3.1 UVM中的前门访问实现</span></h4><p><strong>前门访问</strong></p>
<p>所谓前门访问操作就是通过寄存器配置总线（如APB协议、OCP协议、I2C协议等）来对<mark><strong>DUT</strong></mark>进行操作</p>
<p>无论在任何总线协议中，前门访问操作<strong>只有两种：读操作和写操作</strong>。前门访问操作是比较正统的用法。对一块实际焊接在电路板上正常工作的芯片来说，此时若要访问其中的某些寄存器，前门访问操作是<strong>唯一的方法</strong></p>
<p><strong>本节内容：</strong></p>
<ol>
<li>不使用RAL model来实现前门访问</li>
<li>使用RAL model进行前门访问的不同（使用RAL model来实现前门访问的方法在7.2已经描述完了）</li>
<li>transaction与adapter的转换实现：uvm_reg_item</li>
<li>使用RAL model进行前门访问的读操作完整流程</li>
<li>应答机制</li>
<li>使用RAL model进行前门访问的写操作完整流程</li>
</ol>
<p><strong>1.不使用RAL model来实现前门访问</strong></p>
<p>在7.1.2节中介绍寄存器模型时曾经讲过，对于参考模型来说，最大的问题是如何在其中启动一个sequence，当时列举了全局变量和config_db的两种方式。除了这两种方式之外，如果能够在参考模型中得到一个sequencer的指针，也可以在此sequencer上启动一个sequence。这通常比较容易实现，只要在其中设置一个<code>p_sqr</code>的变量，并在env中将sequencer的指针赋值给此变量即可</p>
<p><strong>代码实现：</strong></p>
<p>一个读写的sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/7.3.1/reg_access_sequence.sv</span><br><span class="hljs-keyword">class</span> reg_access_sequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(bus_transaction)</span>;<br>   <span class="hljs-keyword">string</span> tID = get_type_name();<br><br>   <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] addr;<br>   <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] rdata;<br>   <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] wdata;<br>   <span class="hljs-keyword">bit</span>       is_wr;<br><br>   <span class="hljs-meta">`uvm_object_utils(reg_access_sequence)</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;reg_access_sequence&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      bus_transaction tr;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>      tr<span class="hljs-variable">.addr</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.addr</span>;<br>      tr<span class="hljs-variable">.wr_data</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.wdata</span>;<br>      tr<span class="hljs-variable">.bus_op</span> = (is_wr ? BUS_WR : BUS_RD);<br>      <span class="hljs-meta">`uvm_info(tID, $sformatf(&quot;begin to access register: is_wr = %0d, addr = %0h&quot;, is_wr, addr), UVM_MEDIUM)</span><br>      <span class="hljs-meta">`uvm_send(tr)</span><br>      <span class="hljs-meta">`uvm_info(tID, &quot;successfull access register&quot;, UVM_MEDIUM)</span><br>      <span class="hljs-keyword">this</span><span class="hljs-variable">.rdata</span> = tr<span class="hljs-variable">.rd_data</span>;<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在参考模型中使用如下的方式来进行读操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.2/7.3.1/my_model.sv</span><br><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   reg_access_sequence reg_seq;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   reg_seq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_seq&quot;</span>);<br>   reg_seq<span class="hljs-variable">.addr</span> = <span class="hljs-number">16&#x27;h9</span>;<br>   reg_seq<span class="hljs-variable">.is_wr</span> = <span class="hljs-number">0</span>;<br>   reg_seq<span class="hljs-variable">.start</span>(p_sqr);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.copy</span>(tr);<br>      <span class="hljs-comment">//`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>      <span class="hljs-comment">//new_tr.print();</span><br>      <span class="hljs-keyword">if</span>(reg_seq<span class="hljs-variable">.rdata</span>)<br>         invert_tr(new_tr);<br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>sequence是自动执行的，但是在其执行完毕后（body及post_body调用完成），为此sequence分配的内存依然是有效的，所以 可以使用<code>reg_seq</code>继续引用此sequence。上述读操作正是用到了这一点</p>
</blockquote>
<p><strong>2. 使用RAL model进行前门访问的不同（使用RAL model来实现前门访问的方法在7.2已经描述完了）</strong></p>
<p>对UVM来说，其在寄存器模型中使用的方式也与此类似</p>
<p>上述操作方式的关键是在参考模型中有一个sequencer的指针，而在寄存器模型中也有一个这样的指针，它就是7.2.2节中，在base_test的connect_phase为default map设置的sequencer指针</p>
<p><strong>3.transaction与adapter的转换实现：uvm_reg_item</strong></p>
<p>对于UVM来说，它是一种通用的验证方法学，所以要能够处理各种transaction类型。幸运的是，这些要处理的 transaction都非常相似，在综合了它们的特征后，UVM内建了一种transaction：<code>uvm_reg_item</code>。通过adapter的<code>bus2reg</code>及<code>reg2bus</code>，可以实现<code>uvm_reg_item</code>与目标transaction的转换</p>
<p><strong>4.以读操作为例，其完整的流程为</strong></p>
<ul>
<li>参考模型调用寄存器模型的读任务</li>
<li>寄存器模型产生sequence，并产生<code>uvm_reg_item rw</code></li>
<li>产生driver能够接受的transaction：<code>bus_req = adapter.reg2bus(rw)</code></li>
<li>把<code>bus_req</code>交给bus_sequencer</li>
<li>driver得到<code>bus_req</code>后驱动它，得到读取的值，并将读取值放入<code>bus_req</code>中，调用<code>item_done()</code></li>
<li>寄存器模型调用<code>adapter.bus2reg(bus_req，rw)</code>将<code>bus_req</code>中的读取值传递给<code>rw</code></li>
<li>将<code>rw</code>中的读数据返回参考模型</li>
</ul>
<p><strong>5.应答机制的作用</strong></p>
<p>问题背景：介绍sequence的应答机制时提到过，如果driver一直发送response而sequence不收集response，那么将会导致sequencer的应答队列溢出</p>
<p>解决方案：UVM考虑到这种情况，在<code>uvm_reg_adapter</code>中声明了一个内部成员<code>provide_responses</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">class</span> uvm_reg_adapter <span class="hljs-keyword">extends</span> uvm_object;<br>…<br><span class="hljs-keyword">bit</span> provides_responses;<br>…<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在设置了<code>provide_responses</code>后，寄存器模型在调用<code>bus2reg</code>将目标transaction转换成<code>uvm_reg_item</code>时，其传入的参数是<code>rsp</code>，而不是<code>req</code>，这样就不需要driver按照req一样返回rsp，从而增加sequence处理rsp</p>
<p>你可能好奇，这有什么用呢？简单来说driver把返回RAL model的bus_req过程替换为返回response，这样driver的reponse就相当于处理完了</p>
<p>使用应答机制的操作流程为：</p>
<ul>
<li>参考模型调用寄存器模型的读任务</li>
<li>寄存器模型产生sequence，并产生<code>uvm_reg_item rw</code></li>
<li>产生driver能够接受的<code>transaction bus_req = adapter.reg2bus(rw)</code></li>
<li>将<code>bus_req</code>交给bus_sequencer</li>
<li>driver得到<code>bus_req</code>，驱动它，得到读取的值，并将读取值放入<code>rsp</code>中，调用<code>item_done()</code></li>
<li>寄存器模型调用<code>adapter.bus2reg(rsp，rw)</code>将<code>rsp</code>中的读取值传递给rw</li>
<li>将rw中的读数据返回参考模型</li>
</ul>
<h4><span id="732-后门访问介绍">7.3.2 后门访问介绍</span></h4><p><strong>本节内容：</strong></p>
<ol>
<li>引入一个带有只读寄存器的DUT</li>
<li>后门访问操作的定义</li>
</ol>
<p><strong>1.引入一个带有只读寄存器的DUT</strong></p>
<p>从本节开始，将在7.1.1节的DUT的基础上引入一个新的DUT，如附录B的代码清单B-3所示。这个 DUT中加入了寄存器counter，它的功能就是统计<code>rx_dv</code>为高电平的时钟数。同时在上述DUT中，加法器的位宽被限制在16位。要实现32位的counter的加法操作，需要使用两个叠加的16位加法器（7.4.4节将会介绍使它们作为一个寄存器的方法）</p>
<blockquote>
<p>计数器的位数与加法器之间的故事</p>
<p>在通信系统中，有大量计数器用于统计各种包裹的数量，如超长包、长包、中包、短包、超短包等。这些计数器的一个共同 的特点是它们是只读的，DUT的总线接口无法通过前门访问操作对其进行写操作。除了是只读外，这些寄存器的位宽一般都比较 宽，如32位、48位或者64位等，它们的位宽超过了设计中对加法器宽度的上限限制。计数器在计数过程中需要使用加法器，对于加法器来说，在同等工艺下，<strong>位宽越宽则其时序越差</strong>，因此在设计中一般会规定加法器的最大位宽。在上述DUT中，加法器的位宽被限制在16位。要实现32位的counter的加法操作，需要使用两个叠加的16位加法器（7.4.4节将会介绍使它们作为一个寄存器的方法）</p>
</blockquote>
<p><strong>验证平台针对DUT更新RAL model相关内容（详情见7.3.5）：</strong></p>
<ul>
<li>添加该counter到RAL model层<ul>
<li>注意block中对reg的configure参数三的路径设置是否正确</li>
</ul>
</li>
<li>在<code>bast_test</code>添加正确的hdl路径</li>
</ul>
<p><strong>2.后门访问</strong></p>
<p>后门访问是与前门访问相对的操作，从广义上来说，所有不通过DUT的总线而对DUT内部的寄存器或者存储器进行存取的操作都是后门访问操作。所有后门访问操作都是不消耗仿真时间（即$time打印的时间）而只消耗运行时间</p>
<p>后门访问示例：在top_tb中可以使用如下方式对counter赋初值</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.3/7.3.2/top_tb.sv</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    @(<span class="hljs-keyword">posedge</span> rst_n);<br>    my_dut<span class="hljs-variable">.counter</span> = <span class="hljs-number">32&#x27;hFFFD</span>;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<p><strong>后门访问的意义</strong></p>
<ul>
<li>后门访问操作能够更好地完成前门访问操作所做的事情：后门访问不消耗仿真时间，与前门访问操作相比，它消耗的运行时间要远小于前门访问操作的运行时间。在一个大型芯片的验证中，在其正常工作前需要配置众多的寄存器，配置时间可能要达到一个或几个小时，而如果使用后门访问操作，则时间可能缩短为原来1/100</li>
<li>后门访问操作能够完成前门访问操作不能完成的事情：如在网络通信系统中，计数器通常都是只读的（有一些会附加清零功能），无法对其指定一个非零的初值。而大部分计数器都是多个加法器的叠加，需要测试它们的进位操作。本节DUT的counter使用了两个叠加的16位加法器，需要测试当计数到32’hFFFF时能否顺利进位成为32’h1_0000，这可以通过延长仿真时间来使其 计数到32‘hFFFF，这在本节的DUT中是可以的，因为计数器每个时钟都加1。但是在实际应用中，可能要几万个或者更多的时钟才会加1，因此需要大量的运行时间，如几天。这只是32位加法器的情况，如果是48位的计数器，情况则会更坏。这种情况下，后门访问操作能够完成前门访问操作完成的事情，给只读的寄存器一个初值</li>
</ul>
<p><strong>后门访问相对于前门访问的劣势</strong></p>
<p>与前门访问操作相比，后门访问操作也有其劣势：</p>
<p>如所有的前门访问操作都可以在波形文件中找到总线信号变化的波形及所有操作的记录，但是后门访问操作则无法在波形文件中找到操作痕迹。其操作记录只能仰仗验证平台编写者在进行后门访问操作时输出的打印信息，这样便<strong>增加了调试的难度</strong></p>
<h4><span id="733-后门访问操作实现概述">7.3.3 后门访问操作实现概述</span></h4><p>本书第七章提到了如下几种后门访问方式：</p>
<ol>
<li>绝对路径访问</li>
<li>使用接口封装绝对路径进行访问（常用）</li>
<li>使用UVM中DPI+VPI定义的函数</li>
<li>UVM的RAL model（常用）</li>
</ol>
<p>第一、第二都是使用sv特性</p>
<p>第三、第四方式将在下两节进行解释</p>
<p><strong>1.绝对路径访问</strong></p>
<p>其中方式1就是上一节中的代码，在top_tb中使用绝对路径对寄存器进行后门访问操作，这需要更改top_tb.sv文件，但是这个文件一般是固定的，不会因测试用例的不同而变化，所以这种方式的可操作性不强。在driver等组件中也可以使用这种绝对路径的方式进行后门访问操作，但强烈建议不要在driver等验证平台的组件中使用绝对路径。这种方式的可移植性不强。代码我再写一遍：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.3/7.3.2/top_tb.sv</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    @(<span class="hljs-keyword">posedge</span> rst_n);<br>    my_dut<span class="hljs-variable">.counter</span> = <span class="hljs-number">32&#x27;hFFFD</span>;<span class="hljs-comment">//直接绝对路径给过去</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.使用接口封装绝对路径进行访问</strong></p>
<p>如果想在driver或monitor中使用后门访问，一种方法是使用接口。可以新建一个后门interface，其中<code>poke_counter()</code>为后门写，而<code>peek_counter()</code>为后门读：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.3/7.3.3/backdoor_if.sv</span><br><span class="hljs-keyword">interface</span> backdoor_if(<span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> rst_n);<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> poke_counter(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] value);<br>      top_tb<span class="hljs-variable">.my_dut</span><span class="hljs-variable">.counter</span> = value;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> peek_counter(<span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] value);<br>      value = top_tb<span class="hljs-variable">.my_dut</span><span class="hljs-variable">.counter</span>;<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endinterface</span><br></code></pre></div></td></tr></table></figure>
<p>在测试用例（或者drvier、scoreboard）中，若要对寄存器赋初值可以直接调用此函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.3/7.3.3/my_case0.sv</span><br><span class="hljs-keyword">task</span> my_case0::configure_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.rst_n</span>);<br>    vif<span class="hljs-variable">.poke_counter</span>(<span class="hljs-number">32&#x27;hFFFD</span>);<br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p><strong>这种方法的缺点：</strong>如果有n个寄存器，那么需要写n个poke函数，同时如果有读取要求的话，还要写n个peek函数，这限制了其使用，且此文件完 全没有任何移植性</p>
<p><strong>这种方法的应用：</strong>这种方式在实际中是有应用的，它适用于不想使用寄存器模型提供的后门访问或者根本不想建立寄存器模型，同时又必须要对DUT中的一个寄存器或一块存储器（memory）进行后门访问操作的情况</p>
<h4><span id="734-uvm中后门访问操作的实现原理dpivpi">7.3.4 UVM中后门访问操作的实现原理：DPI+VPI</span></h4><p><strong>VPI介绍</strong></p>
<p>在实际的验证平台中，还有在C/C++代码中对DUT中的寄存器进行读写的需求</p>
<p>Verilog提供VPI接口，可以将DUT的层次结构开放给外部的C/C++代码，常用的VPI接口有如下两个：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">vpi_get_value(obj, p_value);<br>vpi_put_value(obj, p_value, p_time, flags)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>vpi_get_value()</code>用于从RTL中得到一个寄存器的值</p>
<p><code>vpi_put_value()</code>用于将RTL中的寄存器设置为某个值</p>
</blockquote>
<p><strong>DPI介绍</strong></p>
<p>VPI的不足：如果单纯地使用VPI进行后门访问操作，在SystemVerilog与C/C++之间传递参数时将非常麻烦</p>
<p>为了提供更好的用户体验，SystemVerilog提供了一种更好的接口：DPI，DPI如何实现自己百度</p>
<blockquote>
<p>注意：</p>
<p>本书介绍的后门访问，都是以SV视角，而不是C/C++，别搞混了，C/C++只是实现的中间件</p>
<p>在UVM中相应的DPI函数在UVM的C++源码中已经给你定义好了，你只需要在需要调用的地方声明即可，或者直接使用RAL model的特性</p>
<p>两个DPI函数的声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">context</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> uvm_hdl_read(<span class="hljs-keyword">string</span> path, <span class="hljs-keyword">output</span> uvm_hdl_data_t value);<span class="hljs-comment">//用于读操作</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">context</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> uvm_hdl_deposit(<span class="hljs-keyword">string</span> path, uvm_hdl_data_t value);<span class="hljs-comment">//用于写操作</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<p><strong>使用DPI+VPI实现后门访问读操作</strong></p>
<p>在SystemVerilog中像普通函数一样调用<code>uvm_hdl_read</code>函数了。这种方式比单纯地使用VPI的方式简练许多。它可以直接将参数传递给C/C++中的相应函数，省去了单纯使用VPI时繁杂的注册系统函数的步骤</p>
<p>SystemVerilog中读操作的代码可以是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_hdl_read(<span class="hljs-string">&quot;top_tb.my_dut.counter&quot;</span>, value);<br></code></pre></div></td></tr></table></figure>
<p>DPI+VPI的优势：路径被抽像成了一个字符串，从而可以以参数的形式传递，并可以存储， 这为建立寄存器模型提供了可能。一个单纯的Verilog路径，如<code>top_tb.my_dut.counter</code>，它是不能被传递的，也是无法存储的</p>
<p>读操作的整个过程如图：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128014745459.png" srcset="/img/loading.gif" lazyload alt="image-20230128014745459"></p>
<h4><span id="735-uvm中ral后门访问操作实现">7.3.5 UVM中RAL后门访问操作实现</span></h4><p><strong>1.寄存器模型集成与修改</strong></p>
<p>介绍完UVM中后门访问原理后，介绍使用RAL model的后门访问功能，我们需要对之前的验证环境进行修改，主要内容有：</p>
<ul>
<li>直接添加该counter到RAL model层（没有uvm_reg和uvm_reg_field这一套）<ul>
<li>补充：在<code>block</code>实例化<code>reg</code>，注意<code>configure()</code>参数</li>
</ul>
</li>
<li>在<code>bast_test</code>添加正确的hdl路径</li>
</ul>
<p><strong>设置好DUT内部路径</strong></p>
<p>在reg_block中调用uvm_reg的configure函数时，设置好第三个路径参数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>   <span class="hljs-keyword">rand</span> reg_invert invert;<br>   <span class="hljs-keyword">rand</span> reg_counter_high counter_high;<br>   <span class="hljs-keyword">rand</span> reg_counter_low counter_low;<br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>...<br>      invert<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;invert&quot;</span>);<br>      counter_high<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;counter[31:16]&quot;</span>);<br>      counter_low<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;counter[15:0]&quot;</span>);<br>...<br>   <span class="hljs-keyword">endfunction</span><br>...<br><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>设置好根路径hdl_root</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env  =  my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>); <br>   v_sqr =  my_vsqr::type_id::create(<span class="hljs-string">&quot;v_sqr&quot;</span>, <span class="hljs-keyword">this</span>);<br>   rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>   rm<span class="hljs-variable">.configure</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>   rm<span class="hljs-variable">.build</span>();<br>   rm<span class="hljs-variable">.lock_model</span>();<br>   rm<span class="hljs-variable">.reset</span>();<br>   rm<span class="hljs-variable">.set_hdl_path_root</span>(<span class="hljs-string">&quot;top_tb.my_dut&quot;</span>);<br>   reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>   env<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><em>上面两个路径合起来就是寄存器的路径</em></p>
<p><strong>2.使用RAL model进行后门访问</strong></p>
<p>UVM提供两类后门访问的函数：</p>
<ul>
<li>UVM_BACKDOOR形式的<code>read</code>和<code>write</code></li>
<li><code>peek</code>和<code>poke</code></li>
</ul>
<p>这两类函数的区别是，第一类会在进行操作时模仿DUT的行为，第二类则完全不管DUT的行为。如对一个只读的寄存器进行写操作，那么第一类由于要模拟DUT的只读行为，所以是写不进去的，但是使用第二类可以写进去</p>
<p><code>poke()</code>函数用于第二类写操作，其原型为：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128024721210.png" srcset="/img/loading.gif" lazyload alt="image-20230128024721210"></p>
<p><code>peek()</code>函数用于第二类的读操作，其原型为：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128024732855.png" srcset="/img/loading.gif" lazyload alt="image-20230128024732855"></p>
<blockquote>
<p>无论是peek还是poke，其常用的参数都是前两个：</p>
<ul>
<li>第一个参数表示操作是否成功</li>
<li>第二个参数表示读写的数据</li>
</ul>
</blockquote>
<p>在sequence中，可以使用如下的方式来调用这两个任务：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_cfg_vseq::body();<br>    uvm_status_e   status;<br>    uvm_reg_data_t value;<br>    p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter_low</span><span class="hljs-variable">.poke</span>(status, <span class="hljs-number">16&#x27;hFFFD</span>); <span class="hljs-comment">// 后门写寄存器</span><br>    p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter_low</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR); <span class="hljs-comment">// 前门读 </span><br>    <br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="74-复杂的寄存器模型">7.4 复杂的寄存器模型</span></h3><h4><span id="741-层次化的寄存器模型">7.4.1 层次化的寄存器模型</span></h4><p><strong>1.应用背景</strong></p>
<p>在现实应用中，一般会将block再加入一个block中，然后在base_test中实例化后者。从逻辑关系上看，呈现出的是两级的寄存器模型</p>
<p>具体来讲，一般只会在第一级的block中加入寄存器，而第二级的block通常只添加block，体现了较为清晰的结构</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230128125318552.png" srcset="/img/loading.gif" lazyload alt="层次化的寄存器模型"></p>
<p><strong>2.实现步骤与示例讲解</strong></p>
<p>假如一个DUT分了三个子模块：</p>
<ul>
<li>用于控制全局的global模块，global模块寄存器的地址为0x0000～0x0FFF</li>
<li>用于缓存数据的buf模块，buf部分的寄存器地址为0x1000～0x1FFF</li>
<li>用于接收发送以太网帧的mac模块，mac部分的寄存器地址为0x2000～0x2FFF</li>
</ul>
<p>那么可以按照如下方式定义寄存器模型</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.1/reg_model.sv</span><br><span class="hljs-keyword">class</span> global_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> buf_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> mac_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    … <br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    <span class="hljs-keyword">rand</span> global_blk gb_ins;<br>    <span class="hljs-keyword">rand</span> buf_blk bb_ins;<br>    <span class="hljs-keyword">rand</span> mac_blk mb_ins;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br>        gb_ins = global_blk::type_id::create(<span class="hljs-string">&quot;gb_ins&quot;</span>);<br>        gb_ins<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        gb_ins<span class="hljs-variable">.build</span>();<br>        gb_ins<span class="hljs-variable">.lock_model</span>();<br>        default_map<span class="hljs-variable">.add_submap</span>(gb_ins<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h0</span>);<br>        bb_ins = buf_blk::type_id::create(<span class="hljs-string">&quot;bb_ins&quot;</span>);<br>        bb_ins<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        bb_ins<span class="hljs-variable">.build</span>();<br>        bb_ins<span class="hljs-variable">.lock_model</span>();<br>        default_map<span class="hljs-variable">.add_submap</span>(bb_ins<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h1000</span>);<br>        mb_ins = mac_blk::type_id::create(<span class="hljs-string">&quot;mb_ins&quot;</span>);<br>        mb_ins<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        mb_ins<span class="hljs-variable">.build</span>();<br>        mb_ins<span class="hljs-variable">.lock_model</span>();<br>        default_map<span class="hljs-variable">.add_submap</span>(mb_ins<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h2000</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(reg_model)</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_model&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, UVM_NO_COVERAGE);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>多级block实现</strong></p>
<p>将一个子block加入父block中有两步：</p>
<ul>
<li>第一步是先实例化子block</li>
<li>第二步是调用子block的<code>configure()</code>函数<ul>
<li>需要使用<strong>后门访问</strong>，则<code>configure()</code>路径需要说明子block的路径，这个路径不是绝对路径，而是相对于父block来说的路径（上例子不使用，所以直接给空）</li>
</ul>
</li>
<li>第三步是调用子block的<code>build()</code>函数</li>
<li>第四步是调用子block的<code>lock_model()</code>函数</li>
<li>第五步则是将子block的default_map，以子map的形式加入父block的default_map中<ul>
<li>这是可以理解的，因为一般在子block中定义寄存器时，给定的都是寄存器的偏移地址，<strong>其实际物理地址还要再加上一个基地址</strong>。寄存器前门访问的读写操作最终都要通过default_map来完成。很显然，子block的default_map并不知道寄存器的基地址，它只知道寄 存器的偏移地址，只有将其加入父reg_block的default_map，并在加入的同时告知子map的偏移地址，这样父block的default_map就可以完成前门访问操作了</li>
</ul>
</li>
</ul>
<p><strong>基地址与偏移地址</strong></p>
<p>一般在子block中定义寄存器时，给定的都是寄存器的偏移地址，<strong>其实际物理地址还要再加上一个基地址</strong></p>
<p>一般将具有同一基地址的寄存器作为整体加入一个block中，而不同的基地址对应不同的block。每个block<strong>一般都有与其对应的物理地址空间</strong>。对于本节介绍的子block，其里面还可以加入小的block，这相当于将地址空间再次细化</p>
<h4><span id="742-添加uvm_reg_file">7.4.2 添加uvm_reg_file</span></h4><p>UVM的寄存器模型中还有一个称为<code>uvm_reg_file</code>的概念。这个类的引入主要是用于区分不同的hdl路径</p>
<p><strong>问题背景</strong></p>
<p>如果你有很多寄存器需要后门访问，寄存器包括不同的文件中，则<code>configure()</code>的时候需要加上地址如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">regA<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileA.regA&quot;</span>);<br>…<br>regB<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileB.regB&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>这种寄存器一多，如果”fileA”或”fileB”一改，则需要修改大量的设置代码，很容易出错</p>
<blockquote>
<p>下面是原文，一堆废话。。。</p>
<p>假设有两个寄存器regA和regB，它们的hdl路径分为”top_tb.mac_reg.fileA.regA”和”top_tb.mac_reg.fileB.regB”</p>
<p>延续上一节的例子，设top_tb.mac_reg下面所有寄存器的基地址为0x2000，这样，在最顶层的block中加入mac模块时，其hdl路径要写成：<code>mb_ins.configure(this, &quot;mac_reg&quot;);</code></p>
<p>相应的，在mac_blk的build中，要通过如下方式将regA和regB的路径告知寄存器模型：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">regA<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileA.regA&quot;</span>);<br>…<br>regB<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileB.regB&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>当fileA中的寄存器只有一个regA时，这种写法是没有问题的，但是假如fileA中有几十个寄存器时，那么很显然，fileA.*会几十次地出现在这几十个寄存器的<code>configure()</code>函数里。假如有一天，fileA的名字忽然变为filea_inst，那么就需要把这几十行中所有fileA替 换成filea_inst，这个过程很容易出错</p>
</blockquote>
<p>为了适应这种情况，在UVM的寄存器模型中引入了<code>uvm_reg_file</code>的概念。<code>uvm_reg_file</code>同<code>uvm_reg</code>相同是一个纯虚类，不能直接使用，而必须使用其派生类</p>
<p><strong>reg_file定义集成与使用示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.2/reg_model.sv</span><br><span class="hljs-keyword">class</span> regfile <span class="hljs-keyword">extends</span> uvm_reg_file;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;regfile&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(regfile)</span><br><span class="hljs-keyword">endclass</span><br>… <br><span class="hljs-keyword">class</span> mac_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    <span class="hljs-keyword">rand</span> regfile file_a;<br>    <span class="hljs-keyword">rand</span> regfile file_b;<br>    <span class="hljs-keyword">rand</span> reg_regA regA;<br>    <span class="hljs-keyword">rand</span> reg_regB regB;<br>    <span class="hljs-keyword">rand</span> reg_vlan vlan;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br>        file_a = regfile::type_id::create(<span class="hljs-string">&quot;file_a&quot;</span>, , get_full_name());<br>        file_a<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileA&quot;</span>);<br>        file_b = regfile::type_id::create(<span class="hljs-string">&quot;file_b&quot;</span>, , get_full_name());<br>        file_b<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileB&quot;</span>);<br>        …<br>        regA<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, file_a, <span class="hljs-string">&quot;regA&quot;</span>);<br>        …<br>        regB<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, file_b, <span class="hljs-string">&quot;regB&quot;</span>);<br>        …<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>reg_file定义与集成步骤</strong></p>
<ul>
<li>从<code>uvm_reg_file</code>派生一个reg_file类</li>
<li>然后在my_blk中实例化reg_file，之后调用其<code>configure()</code>函数<ul>
<li>第一个参数是其所在的block的指针</li>
<li><strong>第二个参数</strong>是假设此reg_file是另外一个reg_file的父文件，那么这里就填写其父reg_file的指针（由于这里 只有这一级reg_file，因此填写null）</li>
<li>第三个参数则是此reg_file的hdl路径</li>
</ul>
</li>
<li>在my_blk中实例化并配置寄存器<ul>
<li>当把reg_file实例化并配置好后，在调用寄存器的configure参数时，就可以将其第二个参数设为reg_file的指针</li>
</ul>
</li>
</ul>
<p><strong>reg_file的使用</strong></p>
<p>加入reg_file的概念后，当fileA变为filea_inst时，只需要将file_a的<code>configure()</code>参数值改变一下即可，其他则不需要做任何改变</p>
<h4><span id="743-多个域的寄存器">7.4.3 多个域的寄存器</span></h4><p>前面所有例子中的寄存器都是只有一个域的，如果一个寄存器有多个域时，那么在建立模型时会稍有改变</p>
<p><strong>问题背景</strong></p>
<p>某个寄存器有三个域，其中最低两位为filedA，接着三位为filedB，接着四位为filedC，其余位未使用</p>
<p><strong>实现步骤与示例讲解</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.3/reg_model.sv</span><br><span class="hljs-keyword">class</span> three_field_reg <span class="hljs-keyword">extends</span> uvm_reg;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field fieldA;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field fieldB;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field fieldC;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        fieldA = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;fieldA&quot;</span>);<br>        fieldB = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;fieldB&quot;</span>);<br>        fieldC = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;fieldC&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;three_field_reg&quot;</span>);<br>        <span class="hljs-comment">//parameter: name, size, has_coverage</span><br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">16</span>, UVM_NO_COVERAGE);<span class="hljs-comment">//指的是寄存器宽度，而不是field宽度，不用担心</span><br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> mac_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    …<br>    <span class="hljs-keyword">rand</span> three_field_reg tf_reg;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>    …<br>        tf_reg = three_field_reg::type_id::create(<span class="hljs-string">&quot;tf_reg&quot;</span>, , get_full_name());<br>        tf_reg<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        tf_reg<span class="hljs-variable">.build</span>();<br>        tf_reg<span class="hljs-variable">.fieldA</span><span class="hljs-variable">.configure</span>(tf_reg, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        tf_reg<span class="hljs-variable">.add_hdl_path_slice</span>(<span class="hljs-string">&quot;fieldA&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        tf_reg<span class="hljs-variable">.fieldB</span><span class="hljs-variable">.configure</span>(tf_reg, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        tf_reg<span class="hljs-variable">.add_hdl_path_slice</span>(<span class="hljs-string">&quot;fieldA&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        tf_reg<span class="hljs-variable">.fieldC</span><span class="hljs-variable">.configure</span>(tf_reg, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        tf_reg<span class="hljs-variable">.add_hdl_path_slice</span>(<span class="hljs-string">&quot;fieldA&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br>        default_map<span class="hljs-variable">.add_reg</span>(tf_reg, <span class="hljs-number">&#x27;h41</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<p><strong>reg定义内容</strong></p>
<ul>
<li>声明多个field</li>
<li><code>build()</code>中例化field，删除对field的<code>configure()</code></li>
</ul>
<p><strong>block定义内容</strong></p>
<ul>
<li>声明reg</li>
<li><code>build()</code>中例化reg，并配置reg，configure中的hdl参数为空</li>
<li><code>build()</code>中配置reg中的所有field，使用<code>add_hdl_path_slice()</code>给field添加hdl路径</li>
</ul>
<blockquote>
<p><strong>原文解释</strong></p>
<p>这里要先从uvm_reg派生一个类，在此类中加入3个uvm_reg_field。在reg_block中将此类实例化后，调用<code>tf_reg.configure()</code>时要注意，最后一个代表hdl路径的参数已经变为了空的字符串，在调用<code>tf_reg.build()</code>之后要调用tf_reg.fieldA的<code>configure()</code>函数</p>
<p>调用完fieldA的<code>configure()</code>函数后，需要将fieldA的hdl路径加入tf_reg中，此时用到的函数是<code>add_hdl_path_slice()</code>，这个函数的参数：</p>
<ul>
<li>第一个参数是要加入的路径</li>
<li>第二个参数则是此路径对应的域在此寄存器中的起始位数，如fieldA是从0开始的，而fieldB是从2开始的</li>
<li>第三个参数则是此路径对应的域的位宽</li>
</ul>
<p><strong>为什么</strong>在block中对field进行配置？上述<code>fieldA.configure()</code>和<code>tf_reg.add_hdl_path_slice()</code>其实也可以如7.2.1节那样在three_field_reg的build中被调用。这两者有什么区别呢？</p>
<p><strong>解释：</strong></p>
<p>如果是在所定义的uvm_reg类中调用，那么此uvm_reg其实就<strong>已经定型了</strong>，不能更改了</p>
<p>例如7.2.1节中定义了具有一个域的uvm_reg派生类，现在假如有一个新的寄存器，它也是只有一个域，但是这个域并不是如7.2.1节中那样占据了1bit，而只占据了8bit，那么此时就需要重新从uvm_reg派生一个类，然后再重新定义。如果7.2.1节中的reg_invert在定义时并没有在其build中调用reg_data的<code>configure()</code>函数，那么就不必重新定义。<strong>因为没有调用<code>configure()</code>之前，这个域是不确定的</strong></p>
<p><strong>我的吐槽：</strong>作者是不是傻逼啊，直接在reg里面修改<code>configure()</code>不就行了吗。。。</p>
</blockquote>
<h4><span id="744-多个地址的寄存器">7.4.4 多个地址的寄存器</span></h4><p><strong>问题背景</strong></p>
<p>实际的DUT中，有些寄存器会同时占据多个地址，如7.3.2中counter被分成了高位和低位两个寄存器</p>
<p>这种方式的缺点：因其每次要读取counter的值时，都需要对counter_low和counter_high各进行一次读取操作，然后再将两次读取的值合成一个counter的值，所以这种方式使用起来非常不方便</p>
<p><strong>解决方法</strong></p>
<ol>
<li>定义一个32位reg，且只有一个宽度相同的field</li>
<li>定义default_map的总线宽度时指定为16位</li>
<li>对default_map使用<code>add_reg</code>时，给reg最小地址，存取方式为<code>UVM_LITTLE_ENDIAN</code></li>
</ol>
<blockquote>
<p>这种方法相对简单，可以定义一个reg_counter，并在其构造函数中指明此寄存器的大小为32位，此寄存器中只有一个域，此域的宽度也为32bit，之后在reg_model中将其实例化即可。在调用default_map的add_reg函数时，要指定寄存器的地址，这里只需要指明最小的一个地址即可。这是因为在前面实例化default_map时，已经指明了它使用UVM_LITTLE_ENDIAN形式，同时总线的 宽度为2byte，即16bit，UVM会自动根据这些信息计算出此寄存器占据两个地址。当使用前门访问的形式读写此寄存器时，寄存器模型会进行两次读写操作，即发出两个transaction，这两个transaction对应的读写操作的地址从0x05一直递增到0x06</p>
</blockquote>
<p><strong>代码示例</strong></p>
<p>寄存器模型示例</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.4/reg_model.sv</span><br><span class="hljs-keyword">class</span> reg_counter <span class="hljs-keyword">extends</span> uvm_reg;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field reg_data;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        reg_data = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;reg_data&quot;</span>);<br>        <span class="hljs-comment">// parameter: parent, size, lsb_pos, access, volatile, reset value, has_reset, is_rand, indi</span><br>        reg_data<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;W1C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(reg_counter)</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_counter&quot;</span>);<br>        <span class="hljs-comment">//parameter: name, size, has_coverage</span><br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">32</span>, UVM_NO_COVERAGE);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    <span class="hljs-keyword">rand</span> reg_invert invert;<br>    <span class="hljs-keyword">rand</span> reg_counter counter;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        …<br>        counter= reg_counter::type_id::create(<span class="hljs-string">&quot;counter&quot;</span>, , get_full_name());<br>        counter<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;counter&quot;</span>);<br>        counter<span class="hljs-variable">.build</span>();<br>        default_map<span class="hljs-variable">.add_reg</span>(counter, <span class="hljs-number">&#x27;h5</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.4/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_cfg_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        …<br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;counter&#x27;s initial value(FRONTDOOR) is %0h&quot;, value), UVM_LOW)</span><br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter</span><span class="hljs-variable">.poke</span>(status, <span class="hljs-number">32&#x27;h1FFFD</span>);<br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;after poke, counter&#x27;s value(FRONTDOOR) is %0h&quot;, value), UVM_LOW)</span><br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter</span><span class="hljs-variable">.peek</span>(status, value);<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;after poke, counter&#x27;s value(BACKDOOR) is %0h&quot;, value), UVM_LOW)</span><br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="745-加入存储器模型uvm_mem">7.4.5 加入存储器模型uvm_mem</span></h4><p><strong>1.存储器与地址</strong></p>
<p>除了寄存器外，DUT中还存在大量的存储器。这些存储器<strong>有些被分配了地址空间</strong>，<strong>有些没有</strong>。验证人员有时需要在仿真过程中得到存放在这些存储器中数据的值，从而与期望的值比较并给出结果</p>
<p><strong>2.后门访问的优势：一级检查与两级检查</strong></p>
<p>一个DUT的功能是接收一种数据，它经过一些相当复杂的处理（操作A）后将数据存储在存储器中，这块存储器是 DUT内部的存储器，并没有为其分配地址。当存储器中的数据达到一定量时，将它们读出，并再另外做一些复杂处理（如封装成另外一种形式的帧，操作B）后发送出去。在验证平台中如果只是将DUT输出接口的数据与期望值相比较，当数据不匹配情况出现时，则无法确定问题是出在操作A还是操作B中，如图7-8a所示。此时，如果在输出接口之前再增加一级比较，就可以快速地定位问题所在了，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230130224454181.png" srcset="/img/loading.gif" lazyload alt="image-20230130224454181"></p>
<p><strong>3.添加方法与示例分析</strong></p>
<p><strong>要在寄存器模型中加入存储器非常容易</strong></p>
<p>在一个16位的系统中加入一块1024×16（深度为1024，宽度为16）的存储器的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.5/ram1024x16/reg_model.sv</span><br><span class="hljs-keyword">class</span> my_memory <span class="hljs-keyword">extends</span> uvm_mem;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;my_memory&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">1024</span>, <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(my_memory)</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    …<br>    <span class="hljs-keyword">rand</span> my_memory mm;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        …<br>        mm = my_memory::type_id::create(<span class="hljs-string">&quot;mm&quot;</span>, , get_full_name());<br>        mm<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;stat_blk.ram1024x16_inst.array&quot;</span>);<br>        default_map<span class="hljs-variable">.add_mem</span>(mm, <span class="hljs-number">&#x27;h100</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>步骤：</strong></p>
<ul>
<li>首先由<code>uvm_mem</code>派生一个类my_memory，在其new函数中调用<code>super.new()</code>函数，这个函数有三个参数：<ul>
<li>第一个是名字</li>
<li>第二个是存储器的深度</li>
<li>第三个是宽度</li>
</ul>
</li>
<li>在reg_model的<code>build()</code>函数中，将存储器实例化，调用其<code>configure()</code>函数：<ul>
<li>第一个参数是所在 reg_block的指针</li>
<li>第二个参数是此块存储器的hdl路径</li>
</ul>
</li>
<li>最后调用<code>default_map.add_mem()</code>函数，将此块存储器加入default_map中，从 而可以对其进行前门访问操作。如果没有对此块存储器分配地址空间，那么这里可以不将其加入default_map中。在这种情况下，只能使用后门访问的方式对其进行访问</li>
</ul>
<p>如何访问mem：</p>
<p>要对此存储器进行读写，可以通过调用<code>read()</code>、<code>write()</code>、<code>peek()</code>、<code>poke()</code>实现。相比<code>uvm_reg</code>来说，这四个任务/函数在调用的时候需要额外加入一个offset的参数，说明读取此存储器的哪个地址：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// UVM 源代码</span><br><span class="hljs-keyword">task</span> uvm_mem::read(<span class="hljs-keyword">output</span> uvm_status_e status,<br>                    <span class="hljs-keyword">input</span>  uvm_reg_addr_t offset,<br>                    <span class="hljs-keyword">output</span> uvm_reg_data_t value,<br>                    <span class="hljs-keyword">input</span>  uvm_path_e path = UVM_DEFAULT_PATH,<br>                    …);<br><span class="hljs-keyword">task</span> uvm_mem::write(<span class="hljs-keyword">output</span> uvm_status_e status,<br>                    <span class="hljs-keyword">input</span> uvm_reg_addr_t offset,<br>                    <span class="hljs-keyword">input</span> uvm_reg_data_t value,<br>                    <span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>                    …);<br><span class="hljs-keyword">task</span> uvm_mem::peek(<span class="hljs-keyword">output</span> uvm_status_e status,<br>                    <span class="hljs-keyword">input</span> uvm_reg_addr_t offset,<br>                    ou tput uvm_reg_data_t value,<br>                    …);<br><span class="hljs-keyword">task</span> uvm_mem::poke(<span class="hljs-keyword">output</span> uvm_status_e status,<br>                    <span class="hljs-keyword">input</span> uvm_reg_addr_t offset,<br>                    <span class="hljs-keyword">input</span> uvm_reg_data_t value,<br>                    …);<br></code></pre></div></td></tr></table></figure>
<p><strong>4.存储器与总线位宽不同时</strong></p>
<p>上面存储器的宽度与系统总线位宽恰好相同。 假如存储器的宽度大于系统总线位宽时， 情况会略有不同。 如在一个16位的系统中加入512×32的存储器：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.4/7.4.5/ram512x32/reg_model.sv</span><br><span class="hljs-keyword">class</span> my_memory <span class="hljs-keyword">extends</span> uvm_mem;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;my_memory&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">512</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(my_memory)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>存储器模型代码的变更：在派生my_memory时， 就要在其new函数中指明其宽度为32bit， 在my_block中加入此memory的方法与前面的相同</p>
<blockquote>
<p>产生效果：进行多次总线访问</p>
<p>很明显，这里加入的存储器的一个单元占据两个物理地址， 共占据1024个地址。 那么当使用read、 write、 peek、 poke时，输入的参数offset 代表实际的物理地址偏移还是某一个存储单元偏移呢？ 答案是存储单元偏移。 在访问这块512×32的存储器时，offset的最大值是511， 而不是1023。 当指定一个offset， 使用前门访问操作读写时， 由于一个offset对应的是两个物理地址，所以寄存器模型会在总线上进行两次读写操作</p>
</blockquote>
<h3><span id="75-寄存器模型对dut的模拟">7.5 寄存器模型对DUT的模拟</span></h3><h4><span id="751-期望值与镜像值">7.5.1 期望值与镜像值</span></h4><p><strong>问题背景</strong></p>
<p>由于DUT中寄存器的值可能是<strong>实时变更的</strong>，寄存器模型并不能实时地知道这种变更，因此，寄存器模型中的寄存器的值有时与DUT中相关寄存器的值并不一致</p>
<p>注意！！！对于存储器来说，<mark><strong>并不存在期望值和镜像值</strong></mark>。寄存器模型不对存储器进行任何模拟。若要得到存储器中某个存储单元的值， 只能使用7.4.5节中的四种操作（不能使用本节介绍的get()、get_mirrored_value()、set()）</p>
<p><strong>镜像值（mirrored value）</strong></p>
<p>对于任意一个寄存器，寄存器模型中都会有一个专门的变量用于最大可能地与DUT保持同步，这个变量在寄存器模型中称为DUT的镜像值（mirrored value），获得方法：<code>get_mirrored_value()</code></p>
<p><strong>期望值（desired value）</strong></p>
<p>除了DUT的镜像值外，寄存器模型中还有期望值（desired value）。如目前DUT中invert的值为<code>&#39;h0</code>，寄存器模型中的镜像值也为<code>&#39;h0</code>，但是希望向此寄存器中写入一个<code>&#39;h1</code>，此时有两种方法：</p>
<ul>
<li>一种方法是直接调用前面介绍的<code>write()</code>任务，将<code>&#39;h1</code>写入，期望值与镜像值都更新为<code>&#39;h1</code></li>
<li>另外一种方法是通过<code>set()</code>函数将<strong>期望值</strong>设置为<code>&#39;h1</code>（此时镜像值依然为0），之后调用<code>update()</code>任务，<code>update()</code>任务会检查期望值和镜像值是否一致，如果不一致，那么将会把期望值写入DUT中，并且更新镜像值</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// src/ch7/section7.5/7.5.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_cfg_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        …<br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.set</span>(<span class="hljs-number">16&#x27;h1</span>);<br>        value = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.get</span>();<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s desired value is %0h &quot;, value), UVM_LOW)</span><br>        value = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.get_mirrored_value</span>();<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s mirrored value is %0h &quot;, value), UVM_LOW)</span><br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.update</span>(status, UVM_FRONTDOOR);<br>        value = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.get</span>();<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s desired value is %0h &quot;, value), UVM_LOW)</span><br>        value = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.get_mirrored_value</span>();<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s mirrored value is %0h &quot;, value), UVM_LOW)</span><br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.peek</span>(status, value);<br>        <span class="hljs-meta">`uvm_info(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;invert&#x27;s actual value is %0h&quot;, value), UVM_LOW)</span><br>        <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>            starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p><code>get()</code>函数可以得到寄存器的期望值</p>
</li>
<li><p><code>get_mirrored_value()</code>可以得到镜像值</p>
</li>
</ul>
<h4><span id="752-常用操作及其对期望值和镜像值的影响">7.5.2 常用操作及其对期望值和镜像值的影响</span></h4><p><strong>1.read&amp;write操作：</strong></p>
<p>无论通过后门访问还是前门访问的方式从DUT中读取或写入寄存器的值，在操作完成后，寄存器模型都会根据读写的结果更新期望值和镜像值（二者相等）</p>
<p><strong>2.peek&amp;poke操作：</strong></p>
<p>在操作完成后， 寄存器模型会根据操作的结果更新期望值和镜像值（二者相等）</p>
<p><strong>3.get&amp;set操作：</strong></p>
<p>set操作会更新期望值， 但是镜像值不会改变<br>get操作会返回寄存器模型中当前寄存器的期望值</p>
<p><strong>4.update操作：</strong></p>
<p>这个操作会检查寄存器的期望值和镜像值是否一致， 如果不一致， 那么就会将期望值写入DUT中， 并且更新镜像值， 使其与期望值一致</p>
<p>每个由uvm_reg派生来的类都会有update操作， 其使用方式在上一节中已经介绍过<br>每个由 uvm_reg_block派生来的类也有update操作，它会<strong>递归</strong>地调用所有加入此reg_block的寄存器的update任务</p>
<p><strong>5.randomize操作：</strong></p>
<p>寄存器模型提供randomize接口。randomize之后， 期望值将会变为随机出的数值， 镜像值不会改变。 但是并不是寄存器模型中所有寄存器都支持此函数；如果不支持，则randomize调用后其期望值不变</p>
<p>若要关闭随机化功能，build中调用reg_xxx.configure时将其第八个参数设置为0即可</p>
<p>一般的， randomize不会单独使用而是和update一起。如在DUT上电复位后， 需要配置一些寄存器的值。 这些寄存器的值通过randomize获得， 并使用update任务配置到DUT中</p>
<h3><span id="76-寄存器模型中一些内建的sequencce">7.6 寄存器模型中一些内建的sequencce</span></h3><p>UVM提供了一系列的sequence，可以用于检查寄存器模型及DUT中的寄存器</p>
<h4><span id="761-检查后门访问中hdl路径的sequence">7.6.1 检查后门访问中hdl路径的sequence</span></h4><p><code>uvm_reg_mem_hdl_paths_seq</code>用于检查检查寄存器/存储器的hdl路径的正确性，原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> uvm_reg_mem_hdl_paths_seq <span class="hljs-keyword">extends</span> uvm_reg_sequence <span class="hljs-variable">#(uvm_sequence #(uvm_reg_item)</span><br></code></pre></div></td></tr></table></figure>
<p>这个sequence的运行依赖于在基类uvm_sequence中定义的一个<code>uvm_block</code>变量：<code>model</code></p>
<p><strong>使用方法与示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.6/7.6.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_cfg_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        ..<br>        uvm_reg_mem_hdl_paths_seq ckseq;<br>        …<br>        ckseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ckseq&quot;</span>);<br>        ckseq<span class="hljs-variable">.model</span> = p_sequencer<span class="hljs-variable">.p_rm</span>;<br>        ckseq<span class="hljs-variable">.start</span>(<span class="hljs-literal">null</span>);<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>方法</p>
<ul>
<li>在启动此sequence时必须给<code>model</code>赋值寄存器模型</li>
<li>可以在任意的sequence中，可以启动此sequence</li>
<li>调用的<code>start()</code>任务时传入参数为null（即不传入transaction）<ul>
<li>因为它正常工作不依赖于这个sequencer，而依赖于model变量</li>
</ul>
</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>这个sequence会试图读取hdl所指向的寄存器，如果无法读取，则给出错误提示。 由这个sequence的名字也可以看出，它除了<strong>检查寄存器外，还检查存储器</strong></li>
<li>如果某个寄存器/存储器在加入寄存器模型时没有指定其hdl路径，那么此sequence在检查时会跳过这个寄存器/存储器</li>
</ul>
<h4><span id="762-检查默认值的sequence">7.6.2 检查默认值的sequence</span></h4><p><code>uvm_reg_hw_reset_seq</code>用于检查上电复位后寄存器模型与DUT中寄存器的默认值是否相同，它的原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//来源： UVM 源代码</span><br><span class="hljs-keyword">class</span> uvm_reg_hw_reset_seq <span class="hljs-keyword">extends</span> uvm_reg_sequence <span class="hljs-variable">#(uvm_sequence #(uvm_reg_item))</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>复位与默认值（复位值）</strong></p>
<p>对于DUT来说， 在复位完成后， 其值就是默认值。但是对于寄存器模型来说， 如果只是将它集成在验证平台上， 而不做任何处理，那么它所有寄存器的值为0， 此时需要调用<code>reset()</code>函数来使其内寄存器的值变为默认值（复位值）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>    …<br>    rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>    …<br>    rm<span class="hljs-variable">.reset</span>();<br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>使用方法</strong></p>
<p>与<code>uvm_reg_mem_hdl_paths_seq</code>类似，在启动时也需要指定其<code>model</code>变量</p>
<p><strong>作用</strong></p>
<p>这个sequence在其检查前会调用model的reset函数，所以即使在集成到验证平台时没有调用reset函数，这个sequence也能正常工作。除了复位（reset）外，这个sequence所做的事情就是使用前门访问的方式读取所有寄存器的值，并将其与寄存器模型中的值比较</p>
<p><strong>如何跳过某个寄存器的检查</strong>：<mark>resource_db机制</mark></p>
<p>如果想跳过某个寄存器的检查，可以在启动此sequence前使用resource_db设置不检查此寄存器</p>
<p>resource_db机制与config_db机制的底层实现是一样的，uvm_config_db类就是从uvm_resource_db类派生而来的。由于在寄存器模型的sequence中，get操作是通过resource_db来进行的，所以这里使用resource_db来进行设置设置</p>
<p>这里可以通过设置<code>NO_REG_TESTS</code>或者<code>NO_REG_HW_RESET_TEST</code>，都可以实现跳过该寄存器检查：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.6/7.6.2/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.invert.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_REG_TESTS&quot;, 1, this)</span>;<br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>或者使用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.6/7.6.2/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.invert.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_REG_HW_RESET_TEST&quot;, 1, this)</span>;<br><span class="hljs-keyword">endfunction</span>   <br><br></code></pre></div></td></tr></table></figure>
<h4><span id="763-检查读写功能的sequence">7.6.3 检查读写功能的sequence</span></h4><p>UVM提供两个sequence分别用于检查寄存器和存储器的读写功能。<code>uvm_reg_access_seq</code>用于检查寄存器的读写，<code>uvm_mem_access_seq</code>用于检查存储器的读写</p>
<p><strong>1.<code>uvm_reg_access_seq</code></strong></p>
<p><strong><code>uvm_reg_access_seq</code>的原型为</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//来源： UVM 源代码</span><br><span class="hljs-keyword">class</span> uvm_reg_access_seq <span class="hljs-keyword">extends</span> uvm_reg_sequence <span class="hljs-variable">#(uvm_sequence #(uvm_reg_it em))</span><br></code></pre></div></td></tr></table></figure>
<p><strong>作用</strong></p>
<p>这个sequence会使用前门访问的方式向所有寄存器写数据，然后使用后门访问的方式读回，并比较结果。最后把这个过程反过来，使用后门访问的方式写入数据，再用前门访问读回</p>
<p><strong>使用方法</strong></p>
<p>与<code>uvm_reg_mem_hdl_paths_seq</code>类似，在启动时也需要指定其<code>model</code>变量，这个sequence要正常工作必须为所有的寄存器设置好hdl路径</p>
<p><strong>跳过寄存器检查</strong></p>
<p>如果要跳过某个寄存器的读写检查， 则可以在启动sequence前使用如下的两种方式之一进行设置：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.6/7.6.3/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    <span class="hljs-comment">//set for reg access sequence</span><br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.invert.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_REG_TESTS&quot;, 1, this)</span>;<br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.invert.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_REG_ACCESS_TEST&quot;, 1, this)</span>;<br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>2.<code>uvm_mem_access_seq</code></strong></p>
<p><strong>uvm_mem_access_seq原型为</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs VERILOG"><span class="hljs-comment">//来源： UVM 源代码</span><br><span class="hljs-keyword">class</span> uvm_mem_access_seq <span class="hljs-keyword">extends</span> uvm_reg_sequence <span class="hljs-variable">#(uvm_sequence #(uvm_reg_it em)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>作用</strong></p>
<p>这个sequence会通过使用前门访问的方式向所有存储器写数据，然后使用后门访问的方式读回，并比较结果。最后把这个过程反过来，使用后门访问的方式写入数据，再用前门访问读回</p>
<p><strong>使用方法</strong></p>
<p>与<code>uvm_reg_mem_hdl_paths_seq</code>类似，在启动时也需要指定其<code>model</code>变量，这个sequence要正常工作必须为所有的寄存器设置好hdl路径</p>
<p><strong>跳过寄存器检查</strong></p>
<p>如果要跳过某块存储器的检查，则可以使用如下的三种方式之一进行设置：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.6/7.6.3/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    <span class="hljs-comment">//set for mem access sequence</span><br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_REG_TESTS&quot;, 1, this)</span>;<br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_MEM_TESTS&quot;, 1, this)</span>;<br>    uvm_resource_db<span class="hljs-variable">#(bit)::set(&#123;&quot;REG::&quot;,rm.invert.get_full_name(),&quot;.*&quot;&#125;, &quot;NO_MEM_ACCESS_TEST&quot;, 1, this)</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="77-寄存器模型的高级用法">7.7 寄存器模型的高级用法</span></h3><h4><span id="771-两种读操作返回值数据通路">7.7.1 两种读操作返回值数据通路</span></h4><p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230131164418383.png" srcset="/img/loading.gif" lazyload alt="图7-9 两种读操作返回值数据通路"></p>
<p>有两种返回值数据通路：</p>
<p><strong>1.autp predict（左图）</strong></p>
<p>在7.2.2节讲述读操作的返回值时，介绍的这种这种方式要依赖于driver，当driver将读取值返回后，寄存器模型会更新寄存器的镜像值和期望值。这个功能被称为寄存器模型的<strong>auto predict</strong>功能</p>
<p><strong>使用方式</strong>：在建立寄存器模型时使用如下的语句打开此功能：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_auto_predict</span>(<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p><strong>2.手动创建<code>reg_predictor</code>（右图）</strong></p>
<p>如右图所示，方法2是由monitor将从总线上收集到的transaction交给寄存器模型，后者更新相应寄存器的值</p>
<p><strong>使用方法</strong></p>
<ul>
<li>需要实例化一个reg_predictor对象，并为这个reg_predictor实例化一个adapter</li>
<li>在connect_phase中，需要将reg_predictor和<code>bus_agt</code>的<code>ap</code>口连接在一起，并设置reg_predictor的<code>adapter</code>和<code>map</code>【只有设置了<code>map</code>后，才能将predictor和寄存器模型关联在一起】</li>
<li>关闭auto predict（也就是7-9中虚线路径）【因为经过之前的设置，事实上存在着两条更新寄存器模型的路径】</li>
</ul>
<p><strong>reg_predictor及其adapter集成与配置代码</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.7/7.7.1/base_test.sv</span><br><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br>    …<br>    reg_model rm;<br>    my_adapter reg_sqr_adapter;<br>    my_adapter mon_reg_adapter;<br>    uvm_reg_predictor<span class="hljs-variable">#(bus_transaction)</span> reg_predictor;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>    …<br>    rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>    rm<span class="hljs-variable">.configure</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    rm<span class="hljs-variable">.build</span>();<br>    rm<span class="hljs-variable">.lock_model</span>();<br>    rm<span class="hljs-variable">.reset</span>();<br>    reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>    mon_reg_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;mon_reg_adapter&quot;</span>);<br>    reg_predictor = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_predictor&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::connect_phase(uvm_phase phase);<br>    …<br>    rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_sequencer</span>(env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.sqr</span>, reg_sqr_adapter);<br>    rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_auto_predict</span>(<span class="hljs-number">1</span>);<br>    reg_predictor<span class="hljs-variable">.map</span> = rm<span class="hljs-variable">.default_map</span>;<br>    reg_predictor<span class="hljs-variable">.adapter</span> = mon_reg_adapter;<br>    env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(reg_predictor<span class="hljs-variable">.bus_in</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>关闭auto predict的代码</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_auto_predict</span>(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>两种返回值更新到寄存器的方法对比</strong></p>
<p>方法1：左图使用driver的返回值更新寄存器模型</p>
<p>方法2：右图使用monitor，并增加reg_predictor将返回值更新到寄存器模型</p>
<p><strong>两条读操作对比</strong></p>
<p>当总线上只有一个主设备（master）时，则图7-9的左图和右图是完全等价的</p>
<p>如果有多个主设备，则左图会漏掉某些trasaction</p>
</blockquote>
<h4><span id="772-其他操作">7.7.2 其他操作</span></h4><p>本节介绍UVM书7.7.2、7.7.3中内容，包括以下四种操作：</p>
<ul>
<li><code>mirror()</code></li>
<li><code>predictor()</code></li>
<li><code>randomize()</code>搭配<code>update</code></li>
</ul>
<p><strong>1.mirror操作</strong></p>
<p>UVM提供mirror操作，用于读取DUT中寄存器的值并将它们更新到寄存器模型中，函数原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-keyword">task</span> uvm_reg::mirror(<span class="hljs-keyword">output</span> uvm_status_e status,<br>                        <span class="hljs-keyword">input</span> uvm_check_e check = UVM_NO_CHECK,<br>                        <span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>                        …);<br></code></pre></div></td></tr></table></figure>
<p>它有多个参数，但是常用的只有前三个：</p>
<ul>
<li>第二个参数指的是如果发现DUT中寄存器的值与寄存器模型中的镜像值不一 致，那么在更新寄存器模型之前是否给出错误提示。其可选的值为<code>UVM_CHECK</code>和<code>UVM_NO_CHECK</code></li>
</ul>
<p>它有两种应用场景：</p>
<ul>
<li>一是在仿真中不断地调用它，使得到整个寄存器模型的值与DUT中寄存器的值保持一致，此时check选项是关闭的</li>
<li>二是在仿真即将结束时，检查DUT中寄存器的值与寄存器模型中寄存器的镜像值是否一致，这种情况下，check选项是打开的</li>
</ul>
<p>它会更新期望值和镜像值</p>
<p>它的调用逻辑（同update操作类似）：mirror操作既可以在<code>uvm_reg</code>级别被调用，也可以在<code>uvm_reg_block</code>级别被调用。当调用一个<code>uvm_reg_block</code>的mirror时，其实质是调用加入其中的所有寄存器的mirror</p>
<p><strong>2.predict操作</strong></p>
<p><strong>问题背景：</strong></p>
<p>前文已经说过，在通信系统中存在大量的计数器。当网络出现异常时，借助这些计数器能够快速地找出问题所在，所以必须要保证这些计数器的正确性。一般的，会在仿真即将结束时使用mirror操作检查这些计数器的值是否与预期值一致</p>
<p>在DUT中的计数器是不断累加的，但是寄存器模型中的计数器则保持静止。参考模型会不断统计收到了多少包，那么怎么将这些统计数据传递给寄存器模型呢？ 前文中介绍的所有的操作都无法完成这个事情，无论是set，还是write，或是poke；无论是后门访问还是前门访问</p>
<p><strong>我的理解：</strong></p>
<ul>
<li>predict就是不修改DUT的update，update会更新期望值到DUT中</li>
<li>为什么不直接用read？本质上这些操作是为了实现DUT与RAL model之间的同步，read底层也调用了该函数</li>
</ul>
<p><em>这个问题的实质是想人为地更新镜像值，但是同时又不要对DUT进行任何操作</em></p>
<p><strong>UVM提供predict操作来实现这样的功能，函数原型为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> uvm_reg::predict (uvm_reg_data_t value,<br>                                uvm_reg_byte_en_t be = -<span class="hljs-number">1</span>,<br>                                uvm_predict_e kind = UVM_PREDICT_DIRECT,<br>                                uvm_path_e path = UVM_FRONTDOOR,<br>                                …);<br></code></pre></div></td></tr></table></figure>
<p><strong>它的参数：</strong></p>
<ul>
<li>第一个参数表示要预测的值</li>
<li>第二个参数是byte_en，默认-1的意思是全部有效，第三个参数是预测的类型，第四个参数 是后门访问或者是前门访问</li>
<li>第三个参数预测类型</li>
<li>第四个参数是后门访问或者是前门访问</li>
</ul>
<p>第三个参数预测类型有如下几种可以选择：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>                UVM_PREDICT_DIRECT,<br>                UVM_PREDICT_READ,<br>                UVM_PREDICT_WRITE<br>                &#125; uvm_predict_e;<br></code></pre></div></td></tr></table></figure>
<p><strong>它与read/peek和write/poke</strong>：read/peek和write/poke操作在对DUT完成读写后，也会调用此函数，只是它们给出的参数是<code>UVM_PREDICT_READ</code>和 <code>UVM_PREDICT_WRITE</code>。要实现在参考模型中更新寄存器模型而又不影响DUT的参数为<code>UVM_PREDICT_DIRECT</code>，即默认值</p>
<p><strong>它会更新镜像值和期望值</strong></p>
<p><strong>使用示例</strong></p>
<p>使用predict更新镜像值</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.7/7.7.2/my_model.sv</span><br><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>    …<br>    p_rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        port<span class="hljs-variable">.get</span>(tr);<br>        …<br>        <span class="hljs-keyword">if</span>(value)<br>            invert_tr(new_tr);<br>        counter = p_rm<span class="hljs-variable">.counter</span><span class="hljs-variable">.get</span>();<br>        length = new_tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>() + <span class="hljs-number">18</span>;<br>        counter = counter + length;<br>        p_rm<span class="hljs-variable">.counter</span><span class="hljs-variable">.predict</span>(counter);<br>        ap<span class="hljs-variable">.write</span>(new_tr);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在my_model中，每得到一个新的transaction，就先从寄存器模型中得到counter的期望值（此时与镜像值一致），之后将新的transaction的长度加到counter中，最后使用<code>predict()</code>函数将新的counter值更新到寄存器模型中。predict操作会更新镜像值和期望值</p>
</blockquote>
<p>在测试用例中，仿真完成后可以检查DUT中counter的值是否与寄存器模型中的counter值一致：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.7/7.7.2/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        …<br>        dseq = case0_sequence::type_id::create(<span class="hljs-string">&quot;dseq&quot;</span>);<br>        dseq<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_my_sqr</span>);<br>        #<span class="hljs-number">100000</span>;<br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter</span><span class="hljs-variable">.mirror</span>(status, UVM_CHECK, UVM_FRONTDOOR);<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.randomize()</strong></p>
<p>randomize操作是实现reg/field随机化</p>
<p><strong>它更新寄存器模型中的预期值</strong>，不会更新期望值，一般和update一起使用将随机化后的参数更新到DUT中</p>
<p><strong>randomize与update作用</strong>：适用于在仿真开始时随机化并配置参数</p>
<p><strong>randomize前提</strong></p>
<p>对field的随机化除了满足定义条件外还需要满足定义条件，reg只需要满足定义条件即可</p>
<ol>
<li><p>定义条件</p>
<ul>
<li>field可随机化条件1：uvm_reg中将加入的uvm_reg_field定义为rand类型</li>
<li>reg可随机化条件：uvm_reg_block中将uvm_reg加入中定义为rand类型</li>
</ul>
</li>
<li><p>配置条件</p>
<ul>
<li>field可随机化条件2：<code>configure</code>参数8(is_rand)为1</li>
<li>field可随机化条件3：<code>configure</code>参数4(access)为可写类型</li>
</ul>
</li>
</ol>
<p><strong>补充</strong></p>
<ol>
<li>field配置参数</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// parameter: parent, size, lsb_pos, access, volatile, reset value, has_reset, is_rand, individually accessible</span><br>reg_data<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<ol>
<li>field读写类型<ul>
<li>可写：RW、WRC、WRS、WO、 W1、WO1</li>
<li>不可写：RO、RC、RS、WC、WS、W1C、W1S、W1T、W0C、W0S、W0T、W1SRC、W1CRS、W0SRC、 W0CRS、WSRC、WCRS、WOC、WOS</li>
</ul>
</li>
</ol>
<p><strong>随机化位置</strong></p>
<p>可以在uvm_reg_block级别调用randomize函数，也可以在uvm_reg级 别，甚至可以在uvm_reg_field级别调用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">assert</span>(rm<span class="hljs-variable">.randomize</span>());<br><span class="hljs-keyword">assert</span>(rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.randomize</span>());<br><span class="hljs-keyword">assert</span>(rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.reg_data</span><span class="hljs-variable">.randomize</span>());<br></code></pre></div></td></tr></table></figure>
<p><strong>只读类型</strong></p>
<p>既然存在randomize，那么也可以为它们定义constraint</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> reg_invert <span class="hljs-keyword">extends</span> uvm_reg;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field reg_data;<br>    <span class="hljs-keyword">constraint</span> cons&#123;<br>        reg_data<span class="hljs-variable">.value</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="774-扩展位宽">7.7.4 扩展位宽</span></h4><p><strong>1.扩展数据位宽</strong></p>
<p>在自定义uvm_reg的衍生类时，其构造函数调用了<code>super.new()</code>，其中第二个参数为系统总线的宽度，它可以是32、 64、128等。但在寄存器模型中，这个数字的默认最大值是64，它是通过<code>UVM_REG_DATA_WIDTH</code>宏来控制的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> UVM_REG_DATA_WIDTH</span><br> <span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_DATA_WIDTH 64</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>如果想要扩展系统总线的位宽，可以通过重新定义这个宏来扩展</p>
<p><strong>2.扩展地址位宽</strong></p>
<p>与数据位宽类似，地址位宽也有默认最大值限制，其默认值也是64，它是通过<code>UVM_REG_ADDR_WIDTH</code>控制</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> UVM_REG_ADDR_WIDTH</span><br> <span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_ADDR_WIDTH 64</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.扩展字选择信号位宽</strong></p>
<p>在默认情况下，字选择信号的位宽等于数据位宽除以8，它通过如下的宏来控制</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">来源： UVM 源代码<br><span class="hljs-meta">`<span class="hljs-meta-keyword">ifndef</span> UVM_REG_BYTENABLE_WIDTH</span><br> <span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_BYTENABLE_WIDTH ((`UVM_REG_DATA_WIDTH-1)/8+1)</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h3><span id="78-寄存器模型的其他常用函数">7.8 寄存器模型的其他常用函数</span></h3><h4><span id="781-get_root_blocks">7.8.1 <code>get_root_blocks</code></span></h4><p>在本章以前的例子中，若某处要使用寄存器模型，则必须将寄存器模型的指针传递过去</p>
<p>除了这种指针传递的形式外，UVM还提供其他函数，使得可以在不使用指针传递的情况下得到寄存器模型的指针</p>
<p><strong>该函数原型为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_reg_block::get_root_blocks(<span class="hljs-keyword">ref</span> uvm_reg_block blks[$]);<br></code></pre></div></td></tr></table></figure>
<p><strong>作用：</strong><code>get_root_blocks()</code>函数得到验证平台上所有的根块（root block）</p>
<p><strong>根块</strong>：指最顶层的block。如7.4.1节中的<code>reg_model</code>是root block，但是<code>global_blk</code>、<code>buf_blk</code>和<code>mac_blk</code>不是</p>
<p><strong>使用示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs VERILOG"><span class="hljs-comment">//src/ch7/section7.8/7.8.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> case0_cfg_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        uvm_status_e status;<br>        uvm_reg_data_t value;<br>        <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;<br>        uvm_reg_block blks[$];<br>        reg_model p_rm;<br>        …<br>        uvm_reg_block::get_root_blocks(blks);<br>        <span class="hljs-keyword">if</span>(blks<span class="hljs-variable">.size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-meta">`uvm_fatal(&quot;case0_cfg_vseq&quot;, &quot;can&#x27;t find root blocks&quot;)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(p_rm, blks[<span class="hljs-number">0</span>]))<br>                <span class="hljs-meta">`uvm_fatal(&quot;case0_cfg_vseq&quot;, &quot;can&#x27;t cast to reg_model&quot;)</span><br>        <span class="hljs-keyword">end</span><br>        p_rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意类型转换！</strong></p>
<p>在使用<code>get_root_blocks()</code>函数得到<code>reg_block</code>的指针后，要使用cast将其转化为目标<code>reg_block</code>形式（示例中为<code>reg_model</code>）。以后就可以直接使用<code>p_rm</code>来进行寄存器操作，而不必使用<code>p_sequencer.p_rm</code></p>
</blockquote>
<h4><span id="782-get_reg_by_offset函数">7.8.2 get_reg_by_offset函数</span></h4><p><strong>问题背景</strong></p>
<p>在建立了寄存器模型后，可以直接通过层次引用的方式访问寄存器：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(...);<br></code></pre></div></td></tr></table></figure>
<p>但是出于某些原因，如果依然要使用地址来访问寄存器模型，那么此时可以使用<code>get_reg_by_offset()</code>函数通过寄存器的地址得到一个uvm_reg的指针，再调用此uvm_reg的<code>read()</code>或<code>write()</code>就可以进行读写操作</p>
<p><strong>函数原型</strong></p>
<p><a target="_blank" rel="noopener" href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.1b/html/files/reg/uvm_reg_map-svh.html#uvm_reg_map.get_reg_by_offset">uvm_reg_map</a></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> uvm_reg get_reg_by_offset(     uvm_reg_addr_t  offset,     <br>                                                <span class="hljs-keyword">bit</span>     read     =  <span class="hljs-number">1</span>   )<br></code></pre></div></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.1b/html/files/reg/uvm_reg-svh.html#uvm_reg.get_addresses">uvm_reg</a></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> get_addresses (    uvm_reg_map     map  =  <span class="hljs-literal">null</span>,<br>                                        <span class="hljs-keyword">ref</span>     uvm_reg_addr_t  addr[]          )<br></code></pre></div></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li><code>get_reg_by_offset()</code>函数可以通过<strong>寄存器的地址</strong>得到一个uvm_reg的指针</li>
<li><code>get_addresses()</code>函数可以得到这个寄存器的所有地址，其返回值是一个动态数组addrs。其中无论是大端还是小端，addrs[0]是LSB 对应的地址</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch7/section7.8/7.8.2/my_case0.sv</span><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> read_reg(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] addr, <span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] value);<br>      uvm_status_e   status;<br>      uvm_reg target;<br>      uvm_reg_data_t data;<br>      uvm_reg_addr_t addrs[];<br>      target = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.default_map</span><span class="hljs-variable">.get_reg_by_offset</span>(addr);<br>      <span class="hljs-keyword">if</span>(target == <span class="hljs-literal">null</span>) <br>         <span class="hljs-meta">`uvm_error(&quot;case0_cfg_vseq&quot;, $sformatf(&quot;can&#x27;t find reg in register model with address: &#x27;h%0h&quot;, addr))</span><br>      target<span class="hljs-variable">.read</span>(status, data, UVM_FRONTDOOR);<br>      <span class="hljs-keyword">void</span>&#x27;(target<span class="hljs-variable">.get_addresses</span>(<span class="hljs-literal">null</span>,addrs));<br>      <span class="hljs-keyword">if</span>(addrs<span class="hljs-variable">.size</span>() == <span class="hljs-number">1</span>)<br>         value = data[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];     <span class="hljs-comment">// 39</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>         <span class="hljs-keyword">int</span> index;          <span class="hljs-comment">// 41</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; addrs<span class="hljs-variable">.size</span>(); i++) <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(addrs[i] == addr) <span class="hljs-keyword">begin</span><br>               data = data &gt;&gt; (<span class="hljs-number">16</span>*(addrs<span class="hljs-variable">.size</span>() - i));<br>               value = data[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br>               <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">end</span><br>         <span class="hljs-keyword">end</span>    <span class="hljs-comment">// 48</span><br>      <span class="hljs-keyword">end</span> <br>   <span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>代码分析</strong></p>
<p>通过调用最顶层的reg_block的<code>get_reg_by_offset()</code>，即可以得到任一寄存器的指针。如果如7.4.1节那样使用了层次的寄存器模型，从最顶层的reg_block的<code>get_reg_by_offset()</code>也可以得到子reg_block中的寄存器。即假如<code>buf_blk</code>的地址偏移是’h1000，其中有偏移 为’h3的寄存器（即此寄存器的实际物理地址是’h1003），那么可以直接由<code>p_rm.get_reg_by_offset(&#39;h1003)</code>得到此寄存器，而不必使用<code>p_rm.buf_blk.get_reg_by_offset(&#39;h3)</code></p>
<p><strong>多地址寄存器访问方案分析：</strong></p>
<p>如果没有使用7.4.4节所示的多地址寄存器，那么情况比较简单，上述代码会运行第39行的分支。当存在多个地址的情况下，通过get_addresses函数可以得到这个函数的所有地址，其返回值是一个动态数组addrs。其中无论是大端还是小端，addrs[0]是LSB 对应的地址。即对于7.3.2节DUT中的counter（此DUT是大端），那么addrs[0]中存放的是‘h6。而假如是小端，两个地址分别 是’h1005和’h1006，那么addrs[0]中存放的是’h1005。第41到48行通过比较addrs中的地址与目标地址，最终得到要访问的数据。</p>
<p>写寄存器与读操作类似，这里不再列出</p>
</blockquote>
<p>‎2023‎年‎1‎月‎31‎日 ‏‎16:08:39</p>
<h2><span id="第八章-uvm中的factory机制">第八章 UVM中的factory机制</span></h2><h3><span id="81-systemverilog对重载的支持">8.1 SystemVerilog对重载的支持</span></h3><h4><span id="811-任务与函数的重载">8.1.1 任务与函数的重载</span></h4><p>SystemVerilog是一种面向对象的语言。面向对象语言都有一大特征：重载</p>
<p>重载：</p>
<ul>
<li>当在父类中定义一个函数/任务时，如果将其设置为virtual类型，那么就可以在子类中重载这个函数/任务</li>
<li>重载的最大优势是使得一个子类的 指针以父类的类型传递时，其表现出的行为依然是子类的行为</li>
</ul>
<p>这种函数/任务重载的功能在UVM中得到了大量的应用。其实最典型的莫过于各个phase：在一个验证平台中，UVM树上的结点是各个类型的，UVM不必理会它们具体是什么类型，统一将它们当作uvm_component来对待，这极大方便了管理。当各个phase被调用时，以<code>build_phase</code>为例，实际上系统是使用如下的方式调用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">c_ptr<span class="hljs-variable">.build_phase</span>();<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>c_ptr是<code>uvm_component</code>类型的，而不是其他类型，如<code>my_driver</code>（但是<code>c_ptr</code>指向的实例却是<code>my_driver</code>类）</p>
</blockquote>
<h4><span id="812-约束的重载">8.1.2 约束的重载</span></h4><p><strong>1.问题背景</strong></p>
<p>在测试一个接收MAC功能的DUT时，有多种异常情况需要测试，如preamble错误、sfd错误、CRC错误等。针对这些错误，在 transaction中分别加入标志位：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] smac;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ether_type;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">byte</span> pload[];<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> crc_err;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> sfd_err;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> pre_err;<br>    …<br>    <span class="hljs-meta">`uvm_object_utils_begin(my_transaction)</span><br>        <span class="hljs-meta">`uvm_field_int(dmac, UVM_ALL_ON)</span><br>        <span class="hljs-meta">`uvm_field_int(smac, UVM_ALL_ON)</span><br>        <span class="hljs-meta">`uvm_field_int(ether_type, UVM_ALL_ON)</span><br>        <span class="hljs-meta">`uvm_field_array_int(pload, UVM_ALL_ON)</span><br>        <span class="hljs-meta">`uvm_field_int(crc, UVM_ALL_ON)</span><br>        <span class="hljs-meta">`uvm_field_int(crc_err, UVM_ALL_ON | UVM_NOPACK)</span><br>        <span class="hljs-meta">`uvm_field_int(sfd_err, UVM_ALL_ON | UVM_NOPACK)</span><br>        <span class="hljs-meta">`uvm_field_int(pre_err, UVM_ALL_ON | UVM_NOPACK)</span><br>    <span class="hljs-meta">`uvm_object_utils_end</span><br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>这些错误都是异常的情况，在正常的测试用例中，它们的值都应该为0（如果在每次产生transaction时进行约束会非常麻烦。PS：这里加约束也不写清楚原因，作者写的依托答辩）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//uvm_do系列宏启动sequenc，这里只能发送出去符合约束的transaction</span><br>uvm_do_with(tr, &#123;tr<span class="hljs-variable">.crc_err</span> == <span class="hljs-number">0</span>; sfd_err == <span class="hljs-number">0</span>; pre_err == <span class="hljs-number">0</span>;&#125;)<br></code></pre></div></td></tr></table></figure>
<p>由于它们出现的概率非常低，因此结合SV中的dist，在定义transaction时指定如下的约束，从而代表实际transaction的情况：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//对transaction添加约束，其中包括错误约束</span><br><span class="hljs-keyword">constraint</span> default_cons&#123;<br>    crc_err <span class="hljs-keyword">dist</span>&#123;<span class="hljs-number">0</span> := <span class="hljs-number">999_999_999</span>, <span class="hljs-number">1</span> := <span class="hljs-number">1</span>&#125;;<br>    pre_err <span class="hljs-keyword">dist</span>&#123;<span class="hljs-number">0</span> := <span class="hljs-number">999_999_999</span>, <span class="hljs-number">1</span> := <span class="hljs-number">1</span>&#125;;<br>    sfd_err <span class="hljs-keyword">dist</span>&#123;<span class="hljs-number">0</span> := <span class="hljs-number">999_999_999</span>, <span class="hljs-number">1</span> := <span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>问题出现：无法控制什么时候出现异常，我们只定义了正常测试用例，需要构造异常测试用例！</p>
<ul>
<li>上述语句是在随机化时，<code>crc_err</code>、<code>pre_err</code>和<code>sfd_err</code>只有1/1_000_000_000的可能性取值会为1，其余均为0。但最大的问题是其何时取1、何时取0是无法控制的。如果某个测试用例用于测试正常的功能，则不能有错误产生，即<code>crc_err</code>、 <code>pre_err</code>和<code>sfd_err</code>的值要一定为0。上面的constraint明显不能满足这种要求，虽然只有1/1_000_000_000的可能性，在运行特别长的测试用例时，如发送了1_000_000_000个包，那么有非常大的可能会产生一个<code>crc_err</code>、<code>pre_err</code>或<code>sfd_err</code>值为1的包</li>
</ul>
<p>补充：构建异常测试用例的方法有很多，如这里的factory机制的重载，还有下一节的callback机制</p>
<p><strong>有两种解决方法：</strong></p>
<ul>
<li>方法1：关闭约束（关闭某一个/所有约束）</li>
<li>方法2：对约束重载</li>
</ul>
<p><strong>方法1实现</strong></p>
<p>在transaction中使用如下方式定义约束</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br>    …<br>    <span class="hljs-keyword">constraint</span> crc_err_cons&#123;<br>        crc_err == <span class="hljs-number">1&#x27;b0</span>;<br>    &#125;<br>    <span class="hljs-keyword">constraint</span> sfd_err_cons&#123;<br>        sfd_err == <span class="hljs-number">1&#x27;b0</span>;<br>    &#125;<br>    <span class="hljs-keyword">constraint</span> pre_err_cons&#123;<br>        pre_err == <span class="hljs-number">1&#x27;b0</span>;<br>    &#125;<br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在正常的测试用例中，可以使用如下方式随机化</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">my_transaction tr;<br><span class="hljs-meta">`uvm_do(tr)</span><br></code></pre></div></td></tr></table></figure>
<p>在异常的测试用例中，可以使用如下方式随机化（关闭约束）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>    …<br>    m_trans = <span class="hljs-keyword">new</span>();<br>    <span class="hljs-meta">`uvm_info(&quot;sequence&quot;, &quot;turn off constraint&quot;, UVM_MEDIUM)</span><br>    m_trans<span class="hljs-variable">.crc_err_cons</span><span class="hljs-variable">.constraint_mode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-meta">`uvm_rand_send_with(m_trans, &#123;crc_err dist &#123;0 := 2, 1 := 1&#125;;&#125;)</span><br>    …<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>能够使用这种方式的前提是<strong>m_trans已经实例化</strong>。如果不实例化，直接使用<code>`uvm_do</code>宏会报空指针的错误</p>
<p>关闭约束：</p>
<p>上述语句中只是单独地关闭了某一个约束：<code>m_trans.crc_err_cons.constraint_mode(0);</code></p>
<p>也可以使用如下的语句关闭所有的约束：<code>mtrans.constraint_mode(0)</code>，这种情况下，随机化时就需要分别对crc_err、pre_err及sfd_err进行约束</p>
</blockquote>
<p><strong>方法2</strong></p>
<p>原理：SystemVerilog中一个非常有用的特性是<strong>支持约束的重载</strong>。</p>
<p>使用第一种方式中my_transaction的定义， 在其基础上派生一个新的transaction</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> new_transaction <span class="hljs-keyword">extends</span> my_transaction;<br>    <span class="hljs-meta">`uvm_object_utils(new_transaction)</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;new_transaction&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">constraint</span> crc_err_cons&#123;<br>        crc_err <span class="hljs-keyword">dist</span> &#123;<span class="hljs-number">0</span> := <span class="hljs-number">2</span>, <span class="hljs-number">1</span> := <span class="hljs-number">1</span>&#125;;<br>    &#125;<br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<p>这个新的transaction中将<code>crc_err_cons</code>重载了。因此在异常的测试用例中可使用如下方式随机化：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>    new_transaction ntr;<br>    …<br>    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>        <span class="hljs-meta">`uvm_do(ntr)</span><br>        ntr<span class="hljs-variable">.print</span>();<br>    <span class="hljs-keyword">end</span><br>    …<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="82-使用factory机制进行重载">8.2 使用factory机制进行重载</span></h3><h4><span id="821-factory机制式的重载">8.2.1 factory机制式的重载</span></h4><p>factory重载简介：factory机制最伟大的地方在于其具有重载功能（重载并不是factory机制的发明，所有面向对象的语言都支持函数/任务重载，另外<strong>SV还支持对约束的重载</strong>），只是factory机制的重载与这些重载都不一样</p>
<p><strong>1.SV的重载示例</strong></p>
<p>本段与下段将采用一个示例演示SV与factory重载的不同</p>
<p><strong>SV的重载：</strong></p>
<ul>
<li>可重载虚函数，在子类重新定义后，子类对象执行的是重载后的函数</li>
<li>普通函数，在子类重新定义后，子类对象执行的仍然是父类函数</li>
</ul>
<p><strong>SV重载示例：</strong></p>
<p>定义两个类：<code>bird</code>及其衍生类<code>parror</code>，其中hungry()函数为可被重载的虚函数，hungry2()不可被重载</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> bird <span class="hljs-keyword">extends</span> uvm_object;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a bird, I am hungry&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry2();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a bird, I am hungry2&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> parrot <span class="hljs-keyword">extends</span> bird;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a parrot, I am hungry&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry2();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a parrot, I am hungry2&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br><br></code></pre></div></td></tr></table></figure>
<p>执行下方代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::print_hungry(bird b_ptr);<br>    b_ptr<span class="hljs-variable">.hungry</span>();<br>    b_ptr<span class="hljs-variable">.hungry2</span>();<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    bird bird_inst;<br>    parrot parrot_inst;<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    bird_inst = bird::type_id::create(<span class="hljs-string">&quot;bird_inst&quot;</span>);<br>    parrot_inst = parrot::type_id::create(<span class="hljs-string">&quot;parrot_inst&quot;</span>);<br>    print_hungry(bird_inst);<br>    print_hungry(parrot_inst);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>出现如下结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">print_hungry(bird_inst)执行结果为：<br><span class="hljs-string">&quot;I am a bird, I am hungry&quot;</span><br><span class="hljs-string">&quot;I am a bird, I am hungry2&quot;</span><br>print_hungry(parrot_inst)执行结果为：<br><span class="hljs-string">&quot;I am a parrot, I am hungry&quot;</span><br><span class="hljs-string">&quot;I am a bird, I am hungry2&quot;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>总结一下：</strong></p>
<ul>
<li>可重载虚函数，在子类重新定义后，子类对象执行的是重载后的函数</li>
<li>普通函数，在子类重新定义后，子类对象执行的仍然是父类函数</li>
</ul>
</blockquote>
<p><strong>2.factory的重载示例</strong></p>
<p>factory的重载与SV执行的结果相反，是作用于父类的</p>
<p><strong>factory重载示例</strong></p>
<p>与SV重载代码类似，只不过需要在SV重载基础上，执行的时候另外添加factory的重载操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::print_hungry(bird b_ptr);<br>    b_ptr<span class="hljs-variable">.hungry</span>();<br>    b_ptr<span class="hljs-variable">.hungry2</span>();<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    set_type_override_by_type(bird::get_type(), parrot::get_type());<br>    bird_inst = bird::type_id::create(<span class="hljs-string">&quot;bird_inst&quot;</span>);<br>    parrot_inst = parrot::type_id::create(<span class="hljs-string">&quot;parrot_inst&quot;</span>);<br>    print_hungry(bird_inst);<br>    print_hungry(parrot_inst);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>出现如下结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">print_hungry(bird_inst)执行结果为：<br><span class="hljs-string">&quot;I am a parrot, I am hungry&quot;</span><br><span class="hljs-string">&quot;I am a bird, I am hungry2&quot;</span><br>print_hungry(parrot_inst)执行结果为：<br><span class="hljs-string">&quot;I am a parrot, I am hungry&quot;</span><br><span class="hljs-string">&quot;I am a bird, I am hungry2&quot;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>总结一下</strong></p>
<p>虽然<code>print_hungry()</code>接收的是<code>bird</code>类型的参数，但是从运行结果可以推测出来，无论是第一次还是第二次调用<code>print_hungry()</code>，传递的都是类型为<code>bird</code>但是指向<code>parrot</code>的指针</p>
<p>第二次调用就是正常的SV重载，可以很好理解</p>
<p>但第一次却使人很难接受，这就是factory机制的重载功能，其原理如图8-1所示</p>
</blockquote>
<p><strong>3.factory的重载分析</strong></p>
<p><strong>factory重载过程：</strong></p>
<ul>
<li>定义父类及其衍生类，内部定义可重载虚函数</li>
<li>实例化前执行<code>set_type_override_by_type(被重载的父类, 重载的子类)</code>对重载进行注册（形参不能颠倒，如颠倒会报错，8.2.2将会讲到参数）</li>
<li>使用工厂方式进行实例化<code>inst::type_id::create()</code></li>
</ul>
<p><strong>重载过程分析：</strong>对重载的一种注册</p>
<p>在实例化时，UVM会通过factory机制在自己内部的一张表格中查看是否有相关的重载记录<code>set_type_override_by_type()</code>语句相当于在factory机制的表格中加入了一条记录。当查到有重载记录时，会使用新的类型来替代旧的类型。所以虽然在build_phase中写明创建<code>bird</code>的实例，但是最终却创建了<code>parrot</code>的实例</p>
<p><strong>为什么会有这种操作？</strong></p>
<p>为了重载可以实现真正的重载，可以实现被重载函数的全部重载（我猜的）</p>
<p><strong>重载中子类、父类的实例化流程（图8-1）：</strong></p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230201231549666.png" srcset="/img/loading.gif" lazyload alt="图8-1 factory机制的原理"></p>
<p><strong>4.factory的重载四条件</strong></p>
<p>使用factory机制的重载是有前提的，并不是任意的类都可以互相重载。要想使用重载的功能，必须满足以下要求：</p>
<ul>
<li>① 子类父类都注册：无论是重载的类(parrot)还是被重载的类(bird)，都要在定义时注册到factory机制中</li>
<li>② 工厂进行实例化：被重载的类(bird)在实例化时，要使用factory机制式的实例化方式，而不能使用传统的new方式</li>
<li>③ 具有派生关系：最重要的是，重载的类(parrot)要与被重载的类(bird)有派生关系。重载的类必须派生自被重载的类，被重载的类必须是重载类的父类；如果没有则会报错</li>
<li>④ comp与object无法重载：component与object之间互相不能重载。虽然uvm_component派生自uvm_object，但这两者的血缘关系太远根本不能重载。从两者的new参数的函数就可以看出来，二者互相重载时，多出来的一个parent参数会使factory机制无所适从</li>
</ul>
<h4><span id="822-重载的方式及种类">8.2.2 重载的方式及种类</span></h4><p>本节介绍几个重载相关的函数，以及命令行重载：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数列表</th>
<th style="text-align:left">所属类</th>
<th>参数类型</th>
<th>作用区域</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_type_override_by_type</td>
<td style="text-align:left">uvm_component</td>
<td>uvm_object_wrapper</td>
<td>所有对象</td>
</tr>
<tr>
<td>set_inst_override_by_type</td>
<td style="text-align:left">uvm_component</td>
<td>uvm_object_wrapper</td>
<td>指定路径下的对象</td>
</tr>
<tr>
<td>set_type_override</td>
<td style="text-align:left">uvm_component</td>
<td>字符串</td>
<td>所有对象</td>
</tr>
<tr>
<td>set_inst_override</td>
<td style="text-align:left">uvm_component</td>
<td>字符串</td>
<td>指定路径下的对象</td>
</tr>
<tr>
<td>set_type_override_by_type</td>
<td style="text-align:left">uvm_factory</td>
<td>uvm_object_wrapper</td>
<td>所有对象</td>
</tr>
<tr>
<td>set_inst_override_by_type</td>
<td style="text-align:left">uvm_factory</td>
<td>uvm_object_wrapper</td>
<td>指定路径下的对象</td>
</tr>
<tr>
<td>set_type_override_by_name</td>
<td style="text-align:left">uvm_factory</td>
<td>字符串</td>
<td>所有对象</td>
</tr>
<tr>
<td>set_inst_override_by_name</td>
<td style="text-align:left">uvm_factory</td>
<td>字符串</td>
<td>指定路径下的对象</td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.</strong><code>set_type_override_by_type()</code>函数是uvm_component的函数，可以实现两种不同类型之间的重载，原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs VERILOG"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_type_override_by_type<br>                                    (uvm_object_wrapper original_type,<br>                                    uvm_object_wrapper override_type,<br>                                    <span class="hljs-keyword">bit</span> replace=<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p>在实际应用中一般只用前两个参数：</p>
<ul>
<li>第一个参数是被重载的类型</li>
<li>第二个参数是重载的类型</li>
<li>其中第三个参数是replace，将会在下节讲述这个参数</li>
</ul>
<p><strong>2.</strong><code>set_inst_override_by_type()</code>函数是uvm_component的函数，用于不是把验证平台中的A类型全部替换成B类型，而只是替换其中的某一部分，原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_inst_override_by_type(<span class="hljs-keyword">string</span> relative_inst_path,<br>                                            uvm_object_wrapper original_type,<br>                                            uvm_object_wrapper override_type);<br></code></pre></div></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>第一个参数是相对路径</li>
<li>第二个参数是被重载的类型</li>
<li>第三个参数是要重载的类型</li>
</ul>
<p><strong>使用示例</strong></p>
<p>以3.2.2节中的UVM树为例，要将env.o_agt.mon替换成new_monitor：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">set_inst_override_by_type(<span class="hljs-string">&quot;env.o_agt.mon&quot;</span>, my_monitor::get_type(), new_monitor::get_type());<br></code></pre></div></td></tr></table></figure>
<p><strong>3.</strong><code>set_type_override()</code>函数是uvm_component的函数，用于使用字符串来替代<code>get_type()</code>，实现两种不同类型的重载</p>
<p>无论是<code>set_type_override_by_type()</code>还是<code>set_inst_override_by_type()</code>，它们的参数都是一uvm_object_wrapper型的类型参数，这种参数通过<code>xxx::get_type()</code>的形式获得，UVM提供了这个函数来使用字符串替换这种晦涩的写法</p>
<p><code>set_type_override()</code>原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_type_override(<span class="hljs-keyword">string</span> original_type_name,<br>                                        <span class="hljs-keyword">string</span> override_type_name,<br>                                        <span class="hljs-keyword">bit</span> replace=<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p>要使用parrot替换bird，只需要添加如下语句：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">set_type_override(<span class="hljs-string">&quot;bird&quot;</span>, <span class="hljs-string">&quot;parrot&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>4.</strong><code>set_inst_override()</code>函数是uvm_component的函数，用于使用字符串来替代<code>get_type()</code>，实现两种不同类型的部分重载，原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_inst_override(<span class="hljs-keyword">string</span> relative_inst_path,<br>                                <span class="hljs-keyword">string</span> original_type_name,<br>                                <span class="hljs-keyword">string</span> override_type_name);<br></code></pre></div></td></tr></table></figure>
<p>对于上面使用new_monitor重载my_monitor的例子，可以使用语句：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">set_inst_override(<span class="hljs-string">&quot;env.o_agt.mon&quot;</span>, <span class="hljs-string">&quot;my_driver&quot;</span>, <span class="hljs-string">&quot;new_monitor&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p><strong>5.uvm_factory中的四个同名方法</strong></p>
<p>上述的所有函数都是uvm_component的函数，但是如果在一个无法使用component的地方，如在top_tb的initial语句里，就无法使用。UVM提供了另外四个函数来替换上述的四个函数，这四个函数的原型是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span><br>    <span class="hljs-keyword">void</span> set_type_override_by_type (uvm_object_wrapper original_type,<br>                                uvm_object_wrapper override_type,<br>                                <span class="hljs-keyword">bit</span> replace=<span class="hljs-number">1</span>);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span><br>    <span class="hljs-keyword">void</span> set_inst_override_by_type (uvm_object_wrapper original_type,<br>                                uvm_object_wrapper override_type,<br>                                <span class="hljs-keyword">string</span> full_inst_path);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span><br>    <span class="hljs-keyword">void</span> set_type_override_by_name (<span class="hljs-keyword">string</span> original_type_name,<br>                                <span class="hljs-keyword">string</span> override_type_name,<br>                                <span class="hljs-keyword">bit</span> replace=<span class="hljs-number">1</span>);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span><br>    <span class="hljs-keyword">void</span> set_inst_override_by_name (<span class="hljs-keyword">string</span> original_type_name,<br>                                <span class="hljs-keyword">string</span> override_type_name,<br>                                <span class="hljs-keyword">string</span> full_inst_path);<br></code></pre></div></td></tr></table></figure>
<p>这四个函数都位于uvm_factory类中：</p>
<ul>
<li>第一个函数与uvm_component中的同名函数类似，传递的参数相同。</li>
<li>第二个对应uvm_component中的同名函数，只是其输入参数变了，这里需要输入字符串类型的full_inst_path。<strong>这个full_inst_path就是要替换的实例使用get_full_name()得到的路径值</strong></li>
<li>第三个与uvm_component中的set_type_override类似，传递的参数相同</li>
<li>第四个对应uvm_component中的set_inst_override，<strong>也需要一个full_inst_path</strong></li>
</ul>
<p><strong>有两种调用方法：</strong></p>
<p>①系统中<strong>存在一个uvm_factory类型的全局变量factory</strong>。<strong>可以在initial语句里</strong>使用如下方式调用这四个函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    factory<span class="hljs-variable">.set_type_override_by_type</span>(bird::get_type(), parrot::get_type());<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<p>②在一个component内也完全可以直接调用factory机制的重载函数</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">factory<span class="hljs-variable">.set_type_override_by_type</span>(bird::get_type(), parrot::get_type());<br></code></pre></div></td></tr></table></figure>
<p><strong>这4个函数与uvm_componet中同名函数的关系</strong></p>
<p>事实上，uvm_component的四个重载函数直接调用了factory的相应函数</p>
<p><strong>6.使用命令行进行重载</strong></p>
<p>除了可以在代码中进行重载外，还可以在命令行中进行重载</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +uvm_set_inst_override=&lt;req_type&gt;,&lt;override_type&gt;,&lt;full_inst_path&gt;<br>&lt;sim command&gt; +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;]<br></code></pre></div></td></tr></table></figure>
<ul>
<li>uvm_set_inst_override对应<code>set_inst_override_by_name()</code></li>
<li>uvm_set_type_override对应<code>set_type_override_by_name()</code></li>
</ul>
<p>类型重载的命令行参数中有三个选项，其中最后一个<code>replace</code>表示是否可以被后面的重载覆盖。它的含义与代码清单8-20中的 replace一样，将会在下节讲述。</p>
<p><strong>使用示例</strong></p>
<p>对于实例重载（部分重载）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +uvm_set_inst_override=<span class="hljs-string">&quot;my_monitor,new_monitor,uvm_test_top.env.o_agt.mon&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>对于类型重载：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;sim command&gt; +uvm_set_type_override=<span class="hljs-string">&quot;my_monitor,new_monitor&quot;</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="823-复杂的重载">8.2.3 复杂的重载</span></h4><p>本节主要讲的内容：</p>
<ul>
<li>连续的重载</li>
<li>替换式的重载</li>
</ul>
<p><strong>1.连续的重载（子类的子类进行重载）</strong></p>
<p>依然以bird与parrot的例子讲述，现在从parrot又派生出了一个新的类big_parrot（子类的子类）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.2/8.2.3/consecutive/my_case0.sv</span><br><span class="hljs-keyword">class</span> big_parrot <span class="hljs-keyword">extends</span> parrot;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a big_parrot, I am hungry&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry2();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a big_parrot, I am hungry2&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(big_parrot)</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;big_parrot&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在build_phase中设置如下的连续重载，并调用print_hungry函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.2/8.2.3/consecutive/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    bird bird_inst;<br>    parrot parrot_inst;<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    set_type_override_by_type(bird::get_type(), parrot::get_type());<br>    set_type_override_by_type(parrot::get_type(), big_parrot::get_type());<br>    bird_inst = bird::type_id::create(<span class="hljs-string">&quot;bird_inst&quot;</span>);<br>    parrot_inst = parrot::type_id::create(<span class="hljs-string">&quot;parrot_inst&quot;</span>);<br>    print_hungry(bird_inst);<br>    print_hungry(parrot_inst);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>最终输出的都是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># I am a big_parrot, I am hungry<br># I am a bird, I am hungry2<br></code></pre></div></td></tr></table></figure>
<p><strong>2.替换式的重载（两个子类对父类重载）</strong></p>
<p>除了这种连续的重载外，还有一种是<strong>替换式的重载</strong>。假如从bird派生出了新的鸟sparrow：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sparrow <span class="hljs-keyword">extends</span> bird;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a sparrow,  I am hungry&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> hungry2();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;I am a sparrow, I am hungry2&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(sparrow)</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;sparrow&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在build_phase中设置如下重载：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    bird bird_inst;<br>    parrot parrot_inst;<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    set_type_override_by_type(bird::get_type(), parrot::get_type());<br>    set_type_override_by_type(bird::get_type(), sparrow::get_type());<br>    bird_inst = bird::type_id::create(<span class="hljs-string">&quot;bird_inst&quot;</span>);<br>    parrot_inst = parrot::type_id::create(<span class="hljs-string">&quot;parrot_inst&quot;</span>);<br>    print_hungry(bird_inst);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>那么最终的输出结果是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># I am a sparrow, I am hungry<br># I am a bird, I am hungry2<br></code></pre></div></td></tr></table></figure>
<p>这种替换式重载的前提是调用set_type_override_by_type时，其第三个<code>replace</code>参数被设置为1（默认情况下即为1）。如果为0那么最终得到的结果将会是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># I am a parrot, I am hungry<br># I am a bird, I am hungry2<br></code></pre></div></td></tr></table></figure>
<p><strong>结果分析</strong></p>
<ul>
<li>replace为1（默认值）：晚的重载</li>
<li>replace为0：早的重载</li>
</ul>
<p><strong>3.子类间的重载</strong></p>
<p>在创建bird的实例时，factory机制查询到两条相关的记录，它并不会在看完第一条记录后即直接创建一个parrot的实例，而是 最终看完第二条记录后才会创建sparrow的实例。由于是在读取完最后的语句后才可以创建实例，所以其实下列的重载方式也是允许的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    bird bird_inst;<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    set_type_override_by_type(bird::get_type(), parrot::get_type());<br><span class="hljs-number">86</span>  set_type_override_by_type(parrot::get_type(), sparrow::get_type(), <span class="hljs-number">0</span>);<br>    bird_inst = bird::type_id::create(<span class="hljs-string">&quot;bird_inst&quot;</span>);<br>    print_hungry(bird_inst);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>最终输出结果是：sparrow成功对父类进行了重载</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"># I am a sparrow, I am hungry<br># I am a bird, I am hungry2<br></code></pre></div></td></tr></table></figure>
<p><strong>结果分析</strong></p>
<p>虽然子类间的重载（代码第86行）前面的重载四前提的第三条相违背，sparrow并没有派生自parrot但依然可以重载parrot。这样使用依然是有条件的，最终创建出的实例是sparrow类型的，而最初是bird类型的，这两者之间依然有派生关系。代码去掉了对parrot_inst的实例化。因为在第86行存在的情况下再实例化一个parrot_inst会出错。所以，重载四前提的第三条应该改为：</p>
<p>在有多个重载时，最终重载的类必须派生自最初被重载的类，最初被重载的类必须是最终重载类的父类</p>
<h4><span id="824-factory机制的调试">8.2.4 factory机制的调试</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>所属类(可用的全局变量)</th>
<th>作用</th>
<th>推荐调用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>print_override_info函数</td>
<td>uvm_component</td>
<td>输出所有的打印信息</td>
<td></td>
</tr>
<tr>
<td>print函数</td>
<td>uvm_factory(factory)</td>
<td>根据参数打印信息</td>
<td></td>
</tr>
<tr>
<td>debug_create_by_name函数</td>
<td>uvm_factory(factory)</td>
<td>效果同print_override_info</td>
<td></td>
</tr>
<tr>
<td>debug_create_by_type函数</td>
<td>uvm_factory(factory)</td>
<td>效果同print_override_info</td>
<td></td>
</tr>
<tr>
<td>print_topology函数</td>
<td>uvm_root(uvm_top)</td>
<td>显示出整棵UVM树的拓扑结构</td>
<td>build_phase之后</td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.print_overrid_info函数</strong></p>
<p>UVM提供了print_override_info函数来输出所有的打印信息</p>
<p>以上节中的new_monitor重载my_monitor为例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">set_inst_override_by_type(<span class="hljs-string">&quot;env.o_agt.mon&quot;</span>, my_monitor::get_type(), new_monito r::get_type());<br></code></pre></div></td></tr></table></figure>
<p>验证平台中仅仅有这一句重载语句，那么调用print_override_info函数打印的方式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.2/8.2.4/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::connect_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    env<span class="hljs-variable">.o_agt</span><span class="hljs-variable">.mon</span><span class="hljs-variable">.print_override_info</span>(<span class="hljs-string">&quot;my_monitor&quot;</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>最终输出的信息为：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Given a request for an object of type &#x27;my_monitor&#x27; with an instance</span><br><span class="hljs-comment"># path of &#x27;uvm_test_top.env.o_agt.mon&#x27;, the factory encountered</span><br><span class="hljs-comment"># the following relevant overrides. An &#x27;x&#x27; next to a match indicates a</span><br><span class="hljs-comment"># match that was ignored.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Original Type Instance Path Override Type</span><br><span class="hljs-comment"># ------------- -------------------------- -------------</span><br><span class="hljs-comment"># my_monitor uvm_test_top.env.o_agt.mon new_monitor</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Result:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The factory will produce an object of type &#x27;new_monitor&#x27;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>你要查看哪个类？</strong></p>
<p>这里会明确地列出原始类型和新类型。在调用<code>print_override_info()</code>时，其输入的类型应该是<strong>原始的类型，而不是新的类型</strong></p>
</blockquote>
<p><strong>2.debug_create_by_name与debug_create_by_type函数</strong></p>
<p><code>print_override_info()</code>是个uvm_component的成员函数，它实质上是调用uvm_factory的<code>debug_create_by_name()</code>。 除该函数外，uvm_factory还有<code>debug_create_by_type()</code>，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span><br>    <span class="hljs-keyword">void</span> debug_create_by_type (uvm_object_wrapper requested_type,<br>                        <span class="hljs-keyword">string</span> parent_inst_path=<span class="hljs-string">&quot;&quot;</span>,<br>                        <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>使用它对new_monitor进行调试的代码为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">factory<span class="hljs-variable">.debug_create_by_type</span>(my_monitor::get_type(), <span class="hljs-string">&quot;uvm_test_top.env.o_agt.mon&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>其输出与使用print_override_info相同</p>
<p><strong>3.print函数</strong></p>
<p>除了上述两个函数外，uvm_factory还提供<code>print()</code>函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> print (<span class="hljs-keyword">int</span> all_types=<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p><strong>参数</strong>：这个函数只有一个参数，取值可能为0、1或2</p>
<ul>
<li><strong>0时仅打印被重载的实例和类型</strong>，其打印出的信息大体如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">#### Factory Configuration (*)<br>#<br># Instance Overrides:<br>#<br># Requested Type Override Path Override Type<br># -------------- -------------------------- -------------<br># my_monitor uvm_test_top<span class="hljs-variable">.env</span><span class="hljs-variable">.o_agt</span><span class="hljs-variable">.mon</span> new_monitor<br>#<br># No <span class="hljs-keyword">type</span> overrides are registered <span class="hljs-keyword">with</span> <span class="hljs-keyword">this</span> factory<br></code></pre></div></td></tr></table></figure>
<ul>
<li>1时打印参数为0时的信息，以及所有用户创建的、注册到factory的类的名称</li>
<li>2时打印参数为1时的信息，以及系统创建的、所有注册到factory的类的名称（如uvm_reg_item）</li>
</ul>
<p><strong>4.print_topology </strong></p>
<p>还有另外一个重要的工具可以显示出整棵UVM树的拓扑结构，这个工具就是uvm_root的<code>print_topology()</code>函数。UVM树在build_phase执行完成后才完全建立完成，因此，<strong>这个函数应该在build_phase之后调用</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs VERILOG">uvm_top<span class="hljs-variable">.print_topology</span>();<br></code></pre></div></td></tr></table></figure>
<p>最终显示的结果（部分）为：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230202024457390.png" srcset="/img/loading.gif" lazyload alt="image-20230202024457390"></p>
<p>从这个拓扑结构可以清晰地看出，env.o_agt.mon被重载成了new_monitor类型</p>
<p><code>print_topology()</code>这个函数<strong>非常有用</strong>，即使在不进行factory机制调试的情况下，也可通过调用它显示整个验证平台的拓扑结构是否与自己预期的一致。<strong>因此可以把其放在所有测试用例的基类base_test中。</strong></p>
<h3><span id="83-常用的重载">8.3 常用的重载</span></h3><h4><span id="831-重载transaction">8.3.1 重载transaction</span></h4><p>在有了factory机制的重载功能后，构建CRC错误的测试用例就多了一种选择</p>
<p>假设有如下的正常sequence，此sequence被作为某个测试用例的default_sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> normal_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_do(m_trans)</span><br>        <span class="hljs-keyword">end</span><br>        #<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">endtask</span><br>    <span class="hljs-meta">`uvm_object_utils(normal_sequence)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>现在要构建一个新的异常的测试用例测试CRC错误的情况。可以从这个transaction派生一个新的transaction：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.1/my_case0.sv</span><br><span class="hljs-keyword">class</span> crc_err_tr <span class="hljs-keyword">extends</span> my_transaction;<br>    …<br>    <span class="hljs-keyword">constraint</span> crc_err_cons&#123;<br>        crc_err == <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>如果按照上节内容，那么现在需要新建一个sequence，然后将这个sequence作为新的测试用例default_sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> abnormal_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    crc_err_tr tr;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_do(tr)</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    uvm_config_db <span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<br>                                        <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>,<span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                        abnormal_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>但有了factory机制的重载功能后，可以不用重新写一个abnormal_sequence，而继续使用normal_sequence作为新的测试用例的default_sequence，只是需要将my_transaction使用<code>crc_err_tr</code>重载：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.1/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    factory<span class="hljs-variable">.set_type_override_by_type</span>(my_transaction::get_type(), crc_err_tr::get_type());<br>    uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<br>                                        <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>,<span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                        normal_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>经过这样的重载后，normal_sequence产生的transaction就是CRC错误的transaction。这比新建一个CRC错误的sequence的方式简练了很多</p>
<p><strong>我的总结</strong></p>
<p>就是通过factory机制的重载，实现了父类my_transaction中函数的被重载（<strong>感觉确实很强大！</strong>）</p>
<h4><span id="832-重载sequence">8.3.2 重载sequence</span></h4><p>上节使用的<strong>transaction重载能工作的前提是约束也可以重载</strong>。但很多人可能并不习惯于这种用法，而习惯于最原始的方法</p>
<p>本节讲述的内容其实与上节的类似，都能实现同样的目的。这就是UVM的强大之处，对于同样的事情，它提供多种方式完成，用户可以自由选择</p>
<p>在其他测试用例中已经定义了如下的两个sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs VERILOG"><span class="hljs-comment">//src/ch8/section8.3/8.3.2/my_case0.sv</span><br><span class="hljs-keyword">class</span> normal_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-meta">`uvm_do(m_trans)</span><br>        m_trans<span class="hljs-variable">.print</span>();<br>    <span class="hljs-keyword">endtask</span><br>    <span class="hljs-meta">`uvm_object_utils(normal_sequence)</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> case_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        normal_sequence nseq;<br>        <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>            <span class="hljs-meta">`uvm_do(nseq)</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>这里使用了嵌套的sequence。case_sequence被作为default_sequence。现在新建一个测试用例时，可以依然将case_sequence作为default_sequence，只需要从normal_sequence派生一个异常的sequence：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.2/my_case0.sv</span><br><span class="hljs-keyword">class</span> abnormal_sequence <span class="hljs-keyword">extends</span> normal_sequence;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        m_trans = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;m_trans&quot;</span>);<br>        m_trans<span class="hljs-variable">.crc_err_cons</span><span class="hljs-variable">.constraint_mode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-meta">`uvm_rand_send_with(m_trans, &#123;crc_err == 1;&#125;)</span><br>        m_trans<span class="hljs-variable">.print</span>();<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>并且在build_phase中将normal_sequence使用abnormal_sequence重载掉：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.2/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    factory<span class="hljs-variable">.set_type_override_by_type</span>(normal_sequence::get_type(), <br>                                        abnorma l_sequence::get_type());<br>    uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<br>                                        <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>,<span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                        case_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<h4><span id="833-重载component">8.3.3 重载component</span></h4><p>前面分别使用重载transaction和重载sequence的方式产生异常的测试用例。其实还可以使用重载driver的方式产生</p>
<p>在本节所举的例子中看不出重载driver的优势，因为CRC错误是一个非常普通的异常测试用例。<strong>对于那些特别异常的测试用例</strong>，异常到使用sequence实现起来非常麻烦的情况，重载driver就会显示出其优势</p>
<p>假设某个测试用例使用normal_sequence作为其default_sequence。这是个只产生正常transaction的sequence，使用它构造的测试用例是正常的用例。现在假如要产生一个CRC错误的测试用例，可以依然使用这个sequence作为default_sequence，只是需要定义如下的driver：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.3/my_case0.sv</span><br><span class="hljs-keyword">class</span> crc_driver <span class="hljs-keyword">extends</span> my_driver;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> inject_crc_err(my_transaction tr);<br>        tr<span class="hljs-variable">.crc</span> = $urandom_range(<span class="hljs-number">10000000</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>        vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>        vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>        <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>            @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>            inject_crc_err(req);<br>            drive_one_pkt(req);<br>            seq_item_port<span class="hljs-variable">.item_done</span>();<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>然后在build phase中将my_driver使用crc_driver重载：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch8/section8.3/8.3.3/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>    …<br>    factory<span class="hljs-variable">.set_type_override_by_type</span>(my_driver::get_type(), crc_driver::get_type());<br>    uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>,<span class="hljs-string">&quot;default_sequence&quot;</span>,<br>                                            normal_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p><strong>参考模型的重载</strong></p>
<p>除driver可以重载外，scoreboard与参考模型等都可以重载。</p>
<p>尤其对于参考模型来说，处理异常的激励源是相当耗时的事情。可能一个DUT80%的代码都是用于处理异常情况，作为模拟DUT的参考模型来说更是如此。如果将所有异常情况都用一个参考模型实现，那么其代码量将会非常大。但如果将其分散为数十个参考模型，每个处理一种异常情况，当建立相应异常的测试用例时，将正常的参考模型由它替换掉。这样可使代码清晰并增加可读性。</p>
<h4><span id="834-不推荐重载driver以实现所有的测试用例">8.3.4 不推荐重载driver以实现所有的测试用例</span></h4><p>重载driver使得一些在sequence中比较难实现的测试用例轻易地在driver中实现。那么如果放弃sequence，只使用factory机制实现测试用例可能吗？答案确实是可能的。不用sequence时，那么要在driver中控制发送包的种类、数量，对于objection的控制又要从sequence中回到driver中，似乎一切都回到了起点。</p>
<p><strong>但不推荐这么做：</strong></p>
<ul>
<li>引入sequence的原因是将数据流产生的功能从driver中独立出来。取消sequence相当于一种倒退，会使得driver的职能不明确，与现代编程中模块化、功能化的趋势不合。</li>
<li>虽然用driver实现某些测试用例比sequence更加方便，但对于另外一些测试用例，在sequence里做起来会比driver中更加方便</li>
<li>sequence的强大之处在于，它可以在一个sequence中启动另外的sequence，从而可以最大程度实现不同测试用例之间sequence的重用。但driver要实现这样的功能，只能将一些基本的产生激励的函数写在基类driver中。用户会发现到最后这个driver的代码量非常恐怖</li>
<li>使用virtual sequence可以协调、同步不同激励的产生。当放弃sequence时，在不同的driver之间完成这样的同步则比较难</li>
</ul>
<p>基于以上原因，<strong>请不要将所有测试用例都使用driver重载实现</strong>。只有将driver的重载与sequence相结合，才与UVM的最初设计初衷相符合，才能构建起可重用性高的验证平台。完成同样的事情有很多种方式，应综合考虑选择最合理的方式</p>
<h3><span id="84-factory机制的原理与接口">8.4 factory机制的原理与接口</span></h3><h4><span id="factory机制的本质">factory机制的本质</span></h4><p>在没有factory机制之前要创建一个类的实例，只能使用new函数</p>
<p>但有了factory机制之后，<strong>可以根据类名创建这个类的一个实例；还可以在创建类的实例时根据是否有重载记录来决定是创建原始的类，还是创建重载的类的实例</strong></p>
<p>所以从本质上来看，<strong>factory机制其实是对SV中new函数的重载</strong>。因为这个原始的new函数实在太简单且功能太少。经过factory机制的改良之后，进行实例化的方法多了很多。这也体现了UVM编写的一个原则，<strong>一个好的库应该提供更多方便实用的接口，这种接口一方面是库自己写出来并开放给用户的，另外一方面就是改良语言原始的接口，使得更加方便用户的使用</strong></p>
<h4><span id="841-创建一个类的实例的方法">8.4.1 创建一个类的实例的方法</span></h4><p>原文中在这里就是使用SV的new创建了一个实例。。。</p>
<h4><span id="842-根据字符串来创建一个类">8.4.2 根据字符串来创建一个类</span></h4><p>factory机制根据字符串创建类的实例是如此强大，那么它是如何实现的呢？要实现这个功能，需要用到参数化的类。假设有如下的类：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> registry<span class="hljs-variable">#(type T=uvm_object, string Tname=&quot;&quot;)</span>;<br>    T inst;<br>    <span class="hljs-keyword">string</span> name = Tname;<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在定义一个类（如my_driver）时，同时声明一个相应的registry类及其成员变量：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_driver<br>    <span class="hljs-keyword">typedef</span> registry<span class="hljs-variable">#(my_driver, &quot;my_driver&quot;)</span> this_type;<br>    <span class="hljs-keyword">local</span> <span class="hljs-keyword">static</span> this_type me = get();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> this_type get();<br>        <span class="hljs-keyword">if</span>(me != <span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span><br>            me = <span class="hljs-keyword">new</span>();<br>            global_tab[me<span class="hljs-variable">.name</span>] = me;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span> me;<br>    <span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>向这个registry类传递了新定义类的类型及类的名称，并创建了这个registry类的一个实例。在创建实例时，把实例的指针和”my<em>driver”的名字放在一个联合数组global_tab中。上述的操作基本就是`uvm</em><em><em>utils<code>宏所实现的功能，只是</code>uvm</em></em>_utils`宏做得更多、更好</p>
</blockquote>
<p>当要根据类名”my_driver”创建一个my_driver的实例时，先从global_tab中找到”my_driver”索引对应的registry#(my_driver，”my_driver”)实例的指针me_ptr，然后调用<code>me_ptr.inst=new()</code>函数，最终返回me_ptr.inst**。整个过程如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_component create_component_by_name(<span class="hljs-keyword">string</span> name)<br>    registry<span class="hljs-variable">#(uvm_object, &quot;&quot;)</span> me_ptr;<br>    me_ptr = global_tab[name];<br>    me_ptr<span class="hljs-variable">.inst</span> = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;uvm_test_top&quot;</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> me_ptr<span class="hljs-variable">.inst</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>基本上使用factory机制根据类名创建一个类的实例的方式就是这样。<strong>真正的factory机制实现起来会复杂很多，这里只是为了说明而将它们简化到了极致</strong></p>
<h4><span id="843-用factory机制创建实例的接口">8.4.3 用factory机制创建实例的接口</span></h4><p>factory机制提供了一系列接口来创建实例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>所属类(可用的全局变量)</th>
<th>作用</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_object_by_name函数</td>
<td>uvm_factory(factory)</td>
<td>根据类名字创建一个object</td>
<td></td>
</tr>
<tr>
<td>create_object_by_type函数</td>
<td>uvm_factory(factory)</td>
<td>根据类型创建一个object</td>
<td></td>
</tr>
<tr>
<td>create_component_by_name函数</td>
<td>uvm_factory(factory)</td>
<td>根据类名创建一个component</td>
<td>一般只在一个component的new或build_phase中使用</td>
</tr>
<tr>
<td>create_component_by_type</td>
<td>uvm_factory(factory)</td>
<td>根据类型创建一个component</td>
<td>一般只在一个component的new或build_phase中使用</td>
</tr>
<tr>
<td>create_component</td>
<td>uvm_component</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.<code>create_object_by_name()</code></strong></p>
<p>用于根据类名字创建一个object，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_object uvm_factory::create_object_by_name (<br>                                                        <span class="hljs-keyword">string</span> requested_type_name,<br>                                                        <span class="hljs-keyword">string</span> parent_inst_path=<span class="hljs-string">&quot;&quot;</span>,<br>                                                        <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>一般只使用第一个参数，使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">my_transaction tr;<br><span class="hljs-keyword">void</span>&#x27;(<span class="hljs-built_in">$cast</span>(tr, factory<span class="hljs-variable">.create_object_by_name</span>(<span class="hljs-string">&quot;my_transaction&quot;</span>)));<br></code></pre></div></td></tr></table></figure>
<p><strong>2.<code>create_object_by_type()</code></strong></p>
<p>根据类型创建一个object，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_object uvm_factory::create_object_by_type (uvm_object_wrapper<br>                                                        requested_type,<br>                                                        <span class="hljs-keyword">string</span> parent_inst_path=<span class="hljs-string">&quot;&quot;</span>,<br>                                                        <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>一般只使用第一个参数，使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">my_transaction tr;<br><span class="hljs-keyword">void</span>&#x27;(<span class="hljs-built_in">$cast</span>(tr, factory<span class="hljs-variable">.create_object_by_type</span>(my_transaction::get_type())));<br></code></pre></div></td></tr></table></figure>
<p><strong>3.<code>create_component_by_name()</code></strong></p>
<p>根据类名创建一个component，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_component uvm_factory::create_component_by_name (<span class="hljs-keyword">string</span><br>                                                            requested_type_name,<br>                                                            <span class="hljs-keyword">string</span> parent_inst_path=<span class="hljs-string">&quot;&quot;</span>,<br>                                                            <span class="hljs-keyword">string</span> name,<br>                                                            uvm_component parent);<br></code></pre></div></td></tr></table></figure>
<p>有四个参数，在调用这个函数时，这四个参数都要使用：</p>
<ul>
<li>第一个参数是字符串类型的类名</li>
<li>第二个参数是父结点的全名</li>
<li>第三个参数是为这个新的component起的名字</li>
<li>第四个参数是父结点的指针</li>
</ul>
<p>使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">my_scoreboard scb;<br><span class="hljs-keyword">void</span>&#x27; (<span class="hljs-built_in">$cast</span>(scb, factory<span class="hljs-variable">.create_component_by_name</span>(<span class="hljs-string">&quot;my_transaction&quot;</span>, <br>                                                    get_full_name(), <span class="hljs-string">&quot;scb&quot;</span>, <span class="hljs-keyword">this</span>)));<br></code></pre></div></td></tr></table></figure>
<p>使用phase：</p>
<ul>
<li>这个函数<strong>一般只在一个component的new或build_phase中使用</strong></li>
<li>如果是在一个object中被调用则<strong>很难确认parent参数</strong></li>
<li>如果是在connect_phase之后调用，由于<strong>UVM要求component在build_phase及之前实例化完毕</strong>，所以会调用失败</li>
</ul>
<p><strong>4.<code>create_component()</code></strong></p>
<p>调用了<code>create_component_by_name()</code>，原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_component uvm_component::create_component (<span class="hljs-keyword">string</span> requested_type_name, <br>                                                        <span class="hljs-keyword">string</span> name);<br></code></pre></div></td></tr></table></figure>
<p>只有两个参数，<code>factory.create_component_by_name()</code>中剩余的两个参数分别就是<code>this</code>和<code>this.get_full_name()</code></p>
<p><strong>5.<code>create_component_by_type()</code></strong></p>
<p>根据类型创建一个component，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> uvm_component uvm_factory::create_component_by_type (uvm_object_wrap per<br>                                                            requested_type,<br>                                                            <span class="hljs-keyword">string</span> parent_inst_path=<span class="hljs-string">&quot;&quot;</span>,<br>                                                            <span class="hljs-keyword">string</span> name,<br>                                                            uvm_component parent);<br></code></pre></div></td></tr></table></figure>
<p>其参数与<code>create_component_by_name()</code>类似，也需要四个参数齐全</p>
<p>使用示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">my_scoreboard scb;<br><span class="hljs-keyword">void</span>&#x27; (<span class="hljs-built_in">$cast</span>(scb, factory<span class="hljs-variable">.create_component_by_type</span>(my_transaction::get_type(), <br>                                                    get_full_name(), <span class="hljs-string">&quot;scb&quot;</span>, <span class="hljs-keyword">this</span>)));<br></code></pre></div></td></tr></table></figure>
<p>‎2023‎年‎2‎月‎2‎日 ‏‎3:35:23</p>
<h2><span id="第九章-uvm中代码的可重用性">第九章 UVM中代码的可重用性</span></h2><p>本章主要内容：</p>
<ol>
<li>callback机制</li>
<li>参数化的类</li>
<li><strong>模块级、芯片级验证范例！（9.4节）</strong></li>
</ol>
<h3><span id="91-callback机制">9.1 <mark>callback机制</mark></span></h3><p>callback在UVM中的主要作用：</p>
<ul>
<li>callback机制的最大用处就是提高验证平台的可重用性。很多情况下验证人员期望在一个项目中开发的验证平台能够用于另外一个项目。但通常来说完全的重用是比较难实现的，两个项目之间或多或少会有一些差异。如果把两个项目<strong>不同的地方使用callback函数来做</strong>，而把<strong>相同的地方写成一个完整的env</strong>，这样重用时只要改变相关callback函数env可完全的重用</li>
<li>callback机制还<strong>用于构建异常的测试用例</strong>。只是在UVM中构建异常的测试用例有很多种方式，如factory机制的重载，callback机制只是其中的一种</li>
</ul>
<h4><span id="911-广义的callback函数">9.1.1 广义的callback函数</span></h4><blockquote>
<p><strong>书上讲的：</strong></p>
<p>举了一个<code>post_randomize()</code>的应用例子</p>
<p>分析了与callback的关系：<code>post_randomize</code>的例子似乎与本节引语中提到的callback机制不同，引语中强调两个项目之间。不过如果将SV语言的<strong>开发过程</strong>作为一个项目A，验证人员<strong>使用SV开发</strong>的是项目B。A的开发者预料到B可能会在<code>randomize()</code>函数完成后做一些事情，于是A给SystemVerilog添加了<code>post_randomize()</code>函数。B如A所料，使用了这个callback函数</p>
</blockquote>
<p><strong>我的理解：</strong></p>
<p>本节介绍了<code>post_randomize()</code>回调函数，虽然与9.1引言强调项目之间的重用不同，但也能解释的通</p>
<p><strong>callback函数</strong></p>
<p>SV中：<code>post_randomize()</code>、<code>pre_randomize()</code>等</p>
<p>UVM中：<code>pre_body()</code>和<code>post_body()</code>，除此之外还有<code>pre_do()</code>、<code>mid_do()</code>和<code>post_do()</code></p>
<h4><span id="912-callback机制的必要性">9.1.2 callback机制的必要性</span></h4><p>程序是固定的，其设计者有时不是使用者，所以作为<strong>使用者</strong>来说总希望程序的<strong>设计者</strong>能够提供一些<strong>接口</strong>满足自己的应用需求。作为这两者之间的协调，<strong>callback机制</strong>出现了。如上面例子，如果SV的设计者一意孤行只提供randomize函数，此函数执行完成之后就完成任务不做任何事情。幸运的是他听取意见加入了一个post_randomize的callback函数，这样可以使用户实现各自的想法</p>
<p>由上例可以看出:</p>
<ol>
<li>程序的开发者其实是不需要callback机制的，它完全是由程序的使用者要求的</li>
<li>程序的开发者必须能够准确地获取使用者的需求，知道使用者希望在程序的什么地方提供callback函数接口，如果无法获取使用者的需求，那么程序的开发者只能尽可能地预测使用者的需求</li>
</ol>
<p>对于<mark>VIP(Verification Intellectual Property)</mark>来说，一个很容易预测到的需求是在driver中，在发送transaction之前，用户可能会针对transaction做某些动作，因此应该提供一个pre_tran的接口，如用户A可能在pre_tran中将要发送内容的最后4个字节设置为发送的包的序号，这样在包出现比对错误时可以快速地定位，B用户可能在整个包发送之前先在线路上发送几个特殊的字节，C用户可能将整个包的长度截去一部分……总之不同的用户会有不同的需求。正是callback机制的存在满足了这种需求，扩大了VIP的应用范围</p>
<p>除上述情形外，还存在构建异常测试用例的需求。前面已经展示过多种构建异常测试用例的方式。如果在driver中实现测试用例，那么需要使用多个分支处理这些异常情况。在有callback机制的情况下，把<strong>异常测试用例的代码使用callback函数实现</strong>，而<strong>正常测试用例则正常处理</strong>。使用这种方式可以让driver的代码非常简洁。在没有factory机制的重载功能之前，使用callback函数构建异常测试用例是最好的实现方式</p>
<p>总结上面两段，callback在UVM中的主要作用有两个：</p>
<ol>
<li>实现多种功能：VIP的设计者与使用者，实现多种功能</li>
<li>使代码更简洁：</li>
</ol>
<h4><span id="913-callback机制原理">9.1.3 callback机制原理</span></h4><p>原文讲了如何使用SV手撸一个实现callback的场景，该实现没有使用factory机制重载，而是通过定义一个新类，并通过该类的衍生类的重载，实现callback的。在这个过程中，为了让调用callback的类得到重载后的实例，交代了一个概念<code>A_pool</code></p>
<p><strong>具体细节</strong>，如下</p>
<p>考虑如下<code>pre_tran()</code>这个callback函数/任务：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase();<br>    …<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        pre_tran(req);<br>        …<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>假设这是一个成熟VIP中的driver，那么考虑如何实现pre_tran的callback函数/任务呢？它应该是my_driver的一个函数/任务。如果按照上面post_randomize的经验，那么应该从my_driver派生一个类new_driver，然后重写pre_tran这个函数/任务</p>
<p>但这种想法是行不通的，因为这是一个完整的VIP，虽然从my_driver派生了new_driver，但这个VIP中正常运行时使用的依然是my_driver，而不是new_driver。new_driver这个派生类根本就没有实例化过，所以pre_tran从来不会运行。当然，可以使用factory机制的重载功能，但那样是factory机制的功能，而不是callback机制的功能，所以暂不考虑factory机制的重载功能</p>
<p>为解决这个问题，尝试新引入一个类：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase();<br>    …<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        A<span class="hljs-variable">.pre_tran</span>(req);<br>        …<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>这样可以避免重新定义一次my_driver，只需要重新定义A的pre_tran即可。重新派生A的代价是要远小于my_driver的</p>
<p>使用时只要从A派生一个类并将其实例化，然后重新定义其pre_tran函数，此时callback机制的目的就达到了</p>
<p>虽然看起来似乎一切顺利，但实际却忽略了一点。因为从A派生了一个类并实例化，<strong>但作为my_driver来说，怎么知道A派生了一个类呢？又怎么知道A实例化了呢？</strong>为应付这个问题，UVM中又引入了一个类，假设这个类称为<strong>A_pool</strong>，意思就是专门存放A或者A的派生类的一个池子。<strong>UVM约定会执行这个池子中所有实例的pre_tran函数/任务</strong>，即：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_driver::main_phase();<br>    …<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        <span class="hljs-keyword">foreach</span>(A_pool[i]) <span class="hljs-keyword">begin</span><br>            A_pool[i]<span class="hljs-variable">.pre_tran</span>(req);<br>        <span class="hljs-keyword">end</span><br>        …<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>这样在使用时，只要从A派生一个类并将其实例化，然后加入到A_pool中，那么系统运行到上面的<code>foreach(A_pool[i])</code>语句时，将会知道加入了一个实例，于是就会调用其pre_tran函数/任务</p>
<p>有了<code>A</code>和<code>A_pool</code>，真正的callback机制就可以实现了。UVM中的callback机制与此类似，不过其代码实现非常复杂</p>
<h4><span id="914-uvm中使用callback机制">9.1.4 UVM中使用callback机制</span></h4><p><strong>1.两个项目</strong></p>
<p>在这里我们要使用UVM的callback机制来实现重载，首先我们要确定的两个不同的项目A、B，这两个项目经过上一节的分析可以是：</p>
<ul>
<li>A：VIP的开发者（可以是开发验证平台、组件的人员），需要留出callback接口</li>
<li>B：VIP的使用者（可以是编写测试用例的人员），需要使用callback接口</li>
</ul>
<p><strong>2.callback机制步骤总结</strong></p>
<p>对于VIP的开发者来说，预留一个callback函数/任务接口时需要做以下几步：</p>
<ul>
<li>定义：定义一个回调类型A，内部定义虚函数用作接口</li>
<li>注册：在调用位置的D类内，使用<code>`uvm_register_cb</code>宏进行注册</li>
<li>调用：在要调用回调函数/任务接口的函数/任务中，使用<code>`uvm_do_callbacks</code>宏调用</li>
</ul>
<p>对于VIP的使用者来说，需要做如下几步：</p>
<ul>
<li>定义：从A派生一个类my_A，在这个类中重载接口函数</li>
<li>添加：在测试用例的connect_phase（或其他phase，但一定要在使用此callback函数/任务的phase之前）中将从A派生的类实例化，使用<code>`uvm_callbacks#(D, my_A)::add(xxx.xxx.d, ins_my_a)</code>将其加入A_pool中</li>
</ul>
<p>为了方便VIP使用者调用，开发者可以声明一个<code>A_pool</code>来替代使用到的<code>`uvm_callbacks#(D, my_A)</code>调用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/callbacks.sv</span><br><span class="hljs-keyword">typedef</span> uvm_callbacks<span class="hljs-variable">#(my_driver, A)</span> A_pool;<br></code></pre></div></td></tr></table></figure>
<p><strong>3.实例讲解</strong></p>
<p>要实现真正的pre_tran，需要首先定义上节所说的类A（1）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/callbacks.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_callback;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_tran(my_driver drv, <span class="hljs-keyword">ref</span> my_transaction tr);<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>定义callback的父类A的步骤：</p>
<ul>
<li>A类一定要从uvm_callback派生</li>
<li>另外还需要定义一个pre_tran的任务，此任务的类型一定要是virtual的，因为从A派生的类需要重载这个任务</li>
</ul>
</blockquote>
<p>接下来声明一个A_pool类（2）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/callbacks.sv</span><br><span class="hljs-keyword">typedef</span> uvm_callbacks<span class="hljs-variable">#(my_driver, A)</span> A_pool;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>A_pool的声明相当简单，只需要一个typedef语句即可。另外在这个声明中除了要指明这是一个A类型的池子外，还要指明这个池子将会被哪个类使用。本例中my_driver将会使用这个池子，所以要将此池子声明为my_driver专用的</p>
</blockquote>
<p>之后，<strong>在my_driver中要做如下声明</strong>（3）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/my_driver.sv</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">class</span> A;<br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(my_transaction)</span>;<br>    …<br>    <span class="hljs-meta">`uvm_component_utils(my_driver)</span><br>    <span class="hljs-meta">`uvm_register_cb(my_driver, A)</span><br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>这个声明与A_pool的类似，要指明my_driver和A</p>
</blockquote>
<p>最后，在my_driver的main_phase中调用pre_tran时并不如上节所示的那么简单，而是调用了一个宏来实现（4）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/my_driver.sv</span><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>    …<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        <span class="hljs-meta">`uvm_do_callbacks(my_driver, A, pre_tran(this, req))</span><br>        drive_one_pkt(req);<br>        seq_item_port<span class="hljs-variable">.item_done</span>();<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>`uvm_do_callbacks</code>宏的参数：</p>
<ul>
<li>第一个参数是<strong>调用pre_tran的类的名字</strong>，这里自然是my_driver</li>
<li>第二个参数是<strong>哪个类具有pre_tran</strong>，这里是A</li>
<li>第三个参数是<strong>调用的是函数/任务</strong>，这里是pre_tran，<strong>指明是pre_tran时要顺便给出pre_tran的参数</strong></li>
</ul>
</blockquote>
<hr>
<p>到目前为止是VIP的开发者应该做的事情，作为使用VIP的用户来说，需要做如下事情：</p>
<p>首先从A派生一个类（1）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/my_case0.sv</span><br><span class="hljs-keyword">class</span> my_callback <span class="hljs-keyword">extends</span> A;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_tran(my_driver drv, <span class="hljs-keyword">ref</span> my_transaction tr);<br>        <span class="hljs-meta">`uvm_info(&quot;my_callback&quot;, &quot;this is pre_tran task&quot;, UVM_MEDIUM)</span><br>    <span class="hljs-keyword">endtask</span><br>    <span class="hljs-meta">`uvm_object_utils(my_callback)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>其次，<strong>在测试用例中将my_callback实例化，并将其加入A_pool中</strong>（2）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.4/my_case0.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::connect_phase(uvm_phase phase);<br>    my_callback my_cb;<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    my_cb = my_callback::type_id::create(<span class="hljs-string">&quot;my_cb&quot;</span>);<br>    A_pool::add(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span>, my_cb);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>为什么在connect_phase实例化？</p>
<p>my_callback的实例化是在connect_phase中完成的，实例化完成后需要将<code>my_cb</code>加入A_pool中。同时在加入时需要指定是给哪个my_driver使用的。因为很可能整个base_test中实例化了多个my_env，从而有多个my_driver的实例，所以要将my_driver的路径作为add函数的第一个参数</p>
</blockquote>
<p>至此，一个简单的callback机制示例就完成了。这个示例几乎涵盖UVM中所有可能用到的callback机制的知识，大部分callback机制的使用都与这个例子相似</p>
<p>总结：<strong>对于VIP的开发者来说，预留一个callback函数/任务接口时</strong>需要做以下几步：</p>
<ul>
<li>定义一个<strong>A类</strong></li>
<li>声明一个<strong>A_pool类</strong></li>
<li>在要预留callback函数/任务接口的类中调用<code>`uvm_register_cb</code>宏，怼</li>
<li>在要<strong>调用callback函数/任务接口的函数/任务中，使用uvm_do_callbacks宏</strong></li>
</ul>
<p><strong>对于VIP的使用者来说</strong>，需要做如下几步：</p>
<ul>
<li>从A派生一个类，在这个类中定义好pre_tran</li>
<li>在测试用例的connect_phase（或其他phase，但一定要在使用此callback函数/任务的phase之前）中将从A派生的类实例化，并将其加入A_pool中</li>
</ul>
<p><strong>4.分工分析</strong></p>
<p>本节的my_driver是自己写的，my_case0也是自己写的。完全不存在VIP与VIP使用者的情况。不过换个角度来说，可能有两个验证人员共同开发一个项目，一个负责搭建测试平台(testbench)及my_driver等的代码，另一位负责创建测试用例。负责搭建测试平台的人员为搭建测试用例的人员留下了callback函数/任务接口。即使my_driver与测试用例都由同一个人来写，也完全可以接受</p>
<p>因为不同测试用例肯定会引起不同driver的行为。这些不同的行为差异可以在sequence中实现，也可在driver中实现。<strong>在driver中实现时既可以用driver的factory机制重载，也可使用callback机制</strong></p>
<h4><span id="915-子类继承父类的callback机制">9.1.5 子类继承父类的callback机制</span></h4><p><strong>1.问题背景</strong></p>
<p>考虑如下情况：</p>
<p>某公司有前后两代产品，第一代产品已经成熟，有一个已经搭建好的验证平台，要在此基础上开发第二代产品，需搭建一个新验证平台</p>
<p>这个新验证平台大部分与旧验证平台一致，只是<strong>需要扩展my_driver的功能</strong>，即需要从原来的driver中派生一个新的类new_driver。另外需保证第一代产品的所有测试用例在尽量不改动的前提下能在新验证平台上通过</p>
<p>第一代产品的测试用例中大量使用了callback机制。由于callback池（即A_pool）在声明时指明了这个池子只能装载用于my_driver的callback。那怎样才能使原来的callback函数/任务能用于new_driver中呢？</p>
<p>这就牵扯到子类继承父类的callback函数/任务问题</p>
<blockquote>
<p><strong>我的理解</strong></p>
<p>原来验证环境中，调用回调函数的类D，需要新的功能，因此派生出了new_D，但是如何让D中调用的回调函数，在newD中可以照样调用呢？使用子类继承父类的callback机制</p>
</blockquote>
<p><strong>2.子类继承父类的callback机制</strong></p>
<p>这个问题是站在VIP重新设计者的角度，没有对回调内容进行更改，而是调用回调函数的类进行了转移</p>
<p>我们的步骤是，在新的类D中：</p>
<ul>
<li>重新注册：使用宏<code>`uvm_set_super_type</code>把子类和父类关联在一起</li>
<li>重新调用：使用宏<code>`uvm_do_callbacks</code>重新调用回调函数（<code>`uvm_do_callbacks</code>内参数不用变）</li>
</ul>
<p><strong>2.实例讲解</strong></p>
<p>my_driver使用上节中的定义，在此基础上派生新的类new_driver（1）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.5/my_driver.sv</span><br><span class="hljs-keyword">class</span> new_driver <span class="hljs-keyword">extends</span> my_driver;<br>    <span class="hljs-meta">`uvm_component_utils(new_driver)</span><br>    <span class="hljs-meta">`uvm_set_super_type(new_driver, my_driver)</span><br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">task</span> new_driver::main_phase(uvm_phase phase);<br>    …<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>        <span class="hljs-meta">`uvm_info(&quot;new_driver&quot;, &quot;this is new driver&quot;, UVM_MEDIUM)</span><br>        <span class="hljs-meta">`uvm_do_callbacks(my_driver, A, pre_tran(this, req))</span><br>        drive_one_pkt(req);<br>        seq_item_port<span class="hljs-variable">.item_done</span>();<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>这里使用<code>`uvm_set_super_type</code>宏，把子类和父类关联在一起：</p>
<ul>
<li>第一个参数是子类</li>
<li>第二个参数是父类</li>
</ul>
<p>在main_phase中调用<code>`uvm_do_callbacks</code>宏时：</p>
<ul>
<li>其第一个参数是my_driver而不是new_driver，<strong>即调用方式与在my_driver中一样</strong>（意思是，如果<code>pre_tran（this,req)的this</code>参数没有要求，可以直接不用对原有代码进行修改？我猜的）</li>
</ul>
</blockquote>
<p>在my_agent中实例化此new_driver（2）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.5/my_agent.sv</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_agent::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    <span class="hljs-keyword">if</span> (is_active == UVM_ACTIVE) <span class="hljs-keyword">begin</span><br>        sqr = my_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);<br>        drv = new_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">end</span><br>    mon = my_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>这样，上节的my_case0不用经过任何修改就可以在新的验证平台上通过</p>
<h4><span id="916-callback替代sequence">9.1.6 callback替代sequence</span></h4><p>可以在pre_tran中做很多事情，那么是否可以将driver中的<code>drive_one_pkt</code>也移到pre_tran中呢？答案是可以的。更进一步，将<code>seq_item_port.get_nex_item</code>移到pre_tran中也是可以的。</p>
<p>其实完全可以不用sequence，<strong>只用callback函数/任务就可实现所有测试用例</strong>。假设A类定义如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.6/callbacks.sv</span><br><span class="hljs-keyword">class</span> A <span class="hljs-keyword">extends</span> uvm_callback;<br>    my_transaction tr;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> gen_tran();<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run(my_driver drv, uvm_phase phase);<br>        phase<span class="hljs-variable">.raise_objection</span>(drv);<br>        drv<span class="hljs-variable">.vif</span><span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>        drv<span class="hljs-variable">.vif</span><span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>        <span class="hljs-keyword">while</span>(!drv<span class="hljs-variable">.vif</span><span class="hljs-variable">.rst_n</span>)<br>            @(<span class="hljs-keyword">posedge</span> drv<span class="hljs-variable">.vif</span><span class="hljs-variable">.clk</span>);<br>        <span class="hljs-keyword">while</span>(gen_tran()) <span class="hljs-keyword">begin</span><br>            drv<span class="hljs-variable">.drive_one_pkt</span>(tr);<br>        <span class="hljs-keyword">end</span><br>        phase<span class="hljs-variable">.drop_objection</span>(drv);<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在my_driver的main_phase中去掉所有其他代码，只调用A的run：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.6/my_driver.sv</span><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>    <span class="hljs-meta">`uvm_do_callbacks(my_driver, A, run(this, phase))</span><br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>在建立新的测试用例时，只需要从A派生一个类，并重载其gen_tran函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.1/9.1.6/my_case0.sv</span><br><span class="hljs-keyword">class</span> my_callback <span class="hljs-keyword">extends</span> A;<br>    <span class="hljs-keyword">int</span> pkt_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> gen_tran();<br>        <span class="hljs-meta">`uvm_info(&quot;my_callback&quot;, &quot;gen_tran&quot;, UVM_MEDIUM)</span><br>        <span class="hljs-keyword">if</span>(pkt_num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>            tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>            <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>            pkt_num++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-meta">`uvm_object_utils(my_callback)</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>这种情况下新建测试用例相当于重载gen_tran。如果不满足要求，还可以将A类的run任务重载</p>
<p><u><strong>在这个示例中完全丢弃了sequence机制，在A类的run任务中进行控制objection</strong></u>，激励产生在gen_tran中</p>
<h4><span id="917-callback机制-sequence机制和factory机制">9.1.7 callback机制、sequence机制和factory机制</span></h4><blockquote>
<p>上一节使用callback函数/任务实现所有测试用例，几乎完全颠覆从头到尾一直在强调的sequence机制。再到上一章，使用factory机制重载driver来实现所有测试用例的情况</p>
<p>callback机制、sequence机制和factory机制在某种程度上来说很像，它们都能实现搭建测试用例的目的。<strong>只是sequence机制是UVM一直提倡的生成激励的方式</strong>，UVM为此做了大量的工作，如构建了许多宏、嵌套的sequence、virtual sequence、可重用性等</p>
<p>factory机制列出的那四条理由，依然适用于callback机制。虽然callback机制能够实现所有的测试用例，但某些测试用例用sequence实现更加方便。virtual sequence的协调功能在callback机制中就很难实现</p>
<p>callback机制、sequence机制和factory机制并不是互斥的，三者都能分别实现同一目的。当这三者互相结合时，又会产生许多新的解决问题的方式。如果在建立验证平台和测试用例时，<mark>能够择优选择其中最简单的一种实现方式</mark>，那么搭建出来的验证平台一定是足够强大、足够简练的。实现同一事情有多种方式，为用户提供了多种选择，高扩展性是UVM取得成功的一个重要原因</p>
</blockquote>
<p><strong>我的理解</strong></p>
<p>如何选择这三个机制：</p>
<ul>
<li>择优选择其中最简单的一种实现方式</li>
</ul>
<p>sequence不可替代的原因：</p>
<ul>
<li>UVM一直提倡的生成激励的方式，UVM为此做了大量的工作，如构建了许多宏、嵌套的sequence、virtual sequence、可重用性等</li>
<li>某些测试用例用sequence实现更加方便</li>
<li>virtual sequence的协调功能在callback机制中就很难实现</li>
</ul>
<p><strong>补充：我对SV与UVM中的callback实现的不同的理解</strong></p>
<ul>
<li>SV完全是通过重载虚方法实现的，在调用处使用父类句柄调用子类方法，是一种不完全的回调</li>
<li>UVM的回调机制则分离了VIP设计者与VIP使用者，通过VIP设计者插入和调用，以及VIP使用者继承和注册实现</li>
</ul>
<h3><span id="92-功能的模块化小而美">9.2 功能的模块化：小而美</span></h3><h4><span id="921-linux的设计哲学小而美">9.2.1 Linux的设计哲学：小而美</span></h4><p>广大IC开发者中，使用Linux的用户占绝大部分，尤其对验证人员来说更是如此。Linux+如此受欢迎的部分原因之一是它提供了众多的工具，如ls命令、grep命令、wc命令、echo命令等，使用这些命令的组合可以达到多种目的。这些小工具的共同点是每个都非常小但功能清晰。它们是Linux设计哲学中小而美的典型代表。</p>
<p>与小而美相对的就是大而全。比如下述命令就完全可以使用一个命令实现：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ls | grep <span class="hljs-string">&quot;aaa&quot;</span> | wc<br></code></pre></div></td></tr></table></figure>
<p>这个命令组合起来相当于集合了ls、grep、wc三个命令的参数，将这个命令命名为lsgrepwc。当查看这个命令的用法时，很多用户会被冗长的参数列表吓坏。当看到一个参数时，用户要自己判断这个参数属于三个功能中的哪一个。多出来的判断时间就是用户为大而全付出的时间</p>
<p><strong>小而美的本质是功能模块化、标准化，但小不一定意味着美</strong>。以前面的ls与grep命令为例，如果当初命令设计者取了ls一半的功能和grep一半的功能组成命令lgr，剩下的功能再拼凑成sep，这两个是什么命令？恐怕没有几个人会知道，这样的设计不知道会令多少用户崩溃。所以<strong>小而美的前提是功能模块划分要合理</strong>，一个不合理的划分是谈不上美的</p>
<p>同时，<strong>小而美也不能无限制地追求小</strong>。以ls为例，如果将ls、ls-a、ls-l分别当成三个不同的命令，那么也是一种不合理的划分。这三个新的命令有太多共同的参数，比如–color参数等。拆分的同时，参数却是原样拷贝到三个新的命令中，造成了参数的冗余</p>
<p><strong>在验证平台的设计中要尽量做到小而美</strong>，避免大而全</p>
<h4><span id="922-factory重载的小而美">9.2.2 factory重载的小而美</span></h4><p><strong>要点</strong></p>
<p>factory的重载机制时，被重载的A类应该尽可能多的进行任务/函数的小型化，从而避免在重载过程中大段的代码复制</p>
<blockquote>
<p><strong>下面随便看看</strong></p>
<p>factory机制重要的一点是提供重载功能。一般来说，<strong>如果要用B类重载A类，那么B类是要派生自A类的</strong>。在派生时要保留A类的大部分代码，只改变其中一小部分</p>
<p>假设原始A_driver的drive_one_pkt任务如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> A_driver::drive_one_pkt;<br>  drive_preamble();<br>  drive_sfd();<br>  drive_data();<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>上述代码将一个drive_one_pkt任务又分成了三个子任务。现在如果要构造一个sfd错误的例子，那么只需要从A_driver派生一个B_driver，并且重载其drive_sfd任务即可</p>
<p>如果上述代码不是分成三个子任务，而是一个完整的任务：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> A_driver::drive_one_pkt;<br>  <span class="hljs-comment">//drive preamble</span><br>  …<br>  <span class="hljs-comment">//drive sfd</span><br>  …<br>  <span class="hljs-comment">//drive data</span><br>  …<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>那么在B_driver中需要重载的是drive_one_pkt这个任务：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> B_driver::drive_one_pkt;<br>  <span class="hljs-comment">//drive preamble</span><br>  …<br>  <span class="hljs-comment">//drive new sfd</span><br>  …<br>  <span class="hljs-comment">//drive data</span><br>  …<br><span class="hljs-keyword">endtask</span><br></code></pre></div></td></tr></table></figure>
<p>此时，drive preamble和drive data部分代码需要复制到新的drive_one_pkt中。对于程序员来说要<strong>尽量避免复制的使用</strong>：</p>
<ul>
<li>在复制中由于不小心，<strong>很容易出现各种各样的错误</strong>。虽然这些错误只是短期的，马上就能修订，但毕竟要为此花费额外的时间</li>
<li>从长远来看，如果drive data相关的代码稍微有一点变动，此时A_driver和B_driver的drive_one_pkt都需要修改，这又需要额外花费时间。<strong>同样的代码只在验证平台上出现一处，如果要重用，将它们封装成可重载的函数/任务或者类</strong></li>
</ul>
</blockquote>
<h4><span id="923-放弃建造强大sequence的想法">9.2.3 放弃建造强大sequence的想法</span></h4><p>UVM的sequence功能非常强大，很多用户喜欢将他们的sequence写得非常完美，他们的目的是建造通用的sequence，有些用户甚至执着于一个sequence解决验证平台中所有的问题，使用时只需要配置参数即可</p>
<p>以一个my_sequence为例，有些用户可能希望这个sequence具有下列功能：</p>
<ul>
<li>能够产生正常的以太网包</li>
<li>通过配置参数产生CRC错误的包</li>
<li>通过配置参数产生sfd错误的包</li>
<li>通过配置参数产生preamble错误的包</li>
<li>通过配置参数产生CRC与sfd同时错误的包</li>
<li>通过配置参数产生CRC与preamble同时错误的包</li>
<li>通过配置参数产生sfd与preamble同时错误的包</li>
<li>通过配置参数产生CRC、sfd与preamble同时错误的包</li>
<li>通过配置参数控制错误的概率</li>
<li>通过配置参数选择要发送的数据是随机化的还是从文件读取</li>
<li>通过配置参数选择如果从文件读取，那么是多文件还是单文件</li>
<li>通过配置参数选择如果从文件读取，那么使用哪一种文件格式</li>
<li>通过配置参数选择是否将发送出去的包写入文件中</li>
<li>通过配置参数选择长包、中包、短包各自的阈值长度</li>
<li>通过配置参数选择长包、中包、短包的发送比例通过配置参数选择是否在包的负载中加入当前要发送的包的序号，以便于调试</li>
</ul>
<p>……</p>
<p>上述sequence确实是一个非常通用、强悍的sequence。但这个sequence存在两个问题：</p>
<ol>
<li>这个sequence<strong>代码量非常大，分支众多，后期维护相当麻烦</strong>。如果代码编写者与维护者不是同个人，那么对维护者来说简直就是灾难。即使代码编写者与维护者是同个人，在一段时间之后自己也可能被自己以前写的东西感到迷惑不已</li>
<li><strong>使用这个sequence的人面对如此多的参数</strong>要如何选择呢？他有时只想使用其中最基本的一个功能但却不知道怎么配置，只能所有参数都看一遍。如果看一遍能看懂还好，但有时即使看两三遍也看不懂</li>
</ol>
<p>如果用户非常坚持上述超级强大的sequence，那么请一定要做到以下两点之一：</p>
<ul>
<li>有一份完整的文档介绍它</li>
<li>有较多的代码注释</li>
</ul>
<p>文档的重视程度因公司而异，目前国内外的IC公司对于验证文档的重视普遍不够，很少有公司会为一个sequence建立专门的文档。当代码完成后很少会有代码编写者愿意再写文档。即使公司制度规定必须写，文档的质量也有高低之分且存在文档的后期维护问题。当sequence建立后为其建一个文档，但后来sequence升级，文档却没有升级。文档与代码不一致，这是目前IC公司中经常存在的问题</p>
<p>代码的注释与代码编写者的编码习惯有关。目前仅有少数编码习惯好的人能做到质量较好的注释。验证人员编写的代码通常比较灵活且更新频率较快。当设计变更时相关的验证代码就要变更。很多验证人员并没有写注释的习惯，即使有写注释，但当后来代码变更时，注释可能已经落伍了</p>
<p>因此<strong>强烈建议不要使用强大的sequence。可将一个强大的sequence拆分成小的sequence</strong>，如：</p>
<ul>
<li>normal_sequence</li>
<li>crc_err_sequence</li>
<li>rd_from_txt_sequence</li>
</ul>
<p>……</p>
<p><strong>尽量做到一看名字就知道这个sequence的用处</strong>，这样可以最大程度上方便自己，方便大家</p>
<h3><span id="93-参数化的类">9.3 参数化的类</span></h3><h4><span id="931-参数化类的必要性">9.3.1 参数化类的必要性</span></h4><p>代码的重用分为很多层次。凡是在某个项目中开发的代码用于其他项目，都可以称为重用，如：</p>
<ul>
<li>A用户在项目P中的代码被A用户自己用于项目P</li>
<li>A用户在项目P中的代码被A用户自己用于项目Q</li>
<li>A用户在项目P中的代码被B用户用于项目Q</li>
<li>A用户在项目P中开发的代码被B用户或者更多的用户用于项目P或项目Q</li>
</ul>
<p>以上四种应用场景对代码可重用性的要求逐渐提高。第一种可能只是几个sequence被几个不同的测试用例使用；在最后一种可能A用户开发的是一个总线功能模型，大家都会重用这些代码</p>
<p><strong>为了增加代码的可重用性，参数化的类是一个很好的选择</strong></p>
<p>UVM广泛使用了参数化的类。对用户来说<strong>使用最多的参数化的类莫过于uvm_sequence</strong>，其原型为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">class</span> uvm_sequence #(<span class="hljs-keyword">type</span> REQ=uvm_sequence_item, <br>                             <span class="hljs-keyword">type</span> RSP = REQ) <span class="hljs-keyword">extends</span> uvm_sequence_base;<br></code></pre></div></td></tr></table></figure>
<p><strong>在派生uvm_sequence时指定参数的类型，即transaction的类型，可以方便产生transaction并建立测试用例</strong>。 除了uvm_sequence外，还有uvm_analysis_port等，不再一一列举</p>
<p>相比普通的类，参数化的类在定义时会有些复杂，其古怪的语法可能会使人望而却步。<strong>并非所有类一定要定义成参数化的类</strong>。对于很多类来说根本没有参数可言，如果定义成参数化的类，根本没有任何优势可言。所以<strong>定义成参数化的类的前提是这个参数是有意义的、可行的</strong></p>
<h4><span id="932-uvm中的参数化">9.3.2 UVM中的参数化</span></h4><p><strong>1.factory中的参数化</strong></p>
<p>UVM对参数化类的支持首先体现在factory机制注册上。前面已经提到了<code>`uvm_object_param_util</code>和<code>`uvm_component_param_utils</code>这两个用于参数化的object和参数化的component注册的宏</p>
<p><strong>2.config_db中的参数化</strong></p>
<p>UVM的config_db机制可以用于传递virtual interface<strong>。</strong>SV支持参数化的interface：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> bus_if<span class="hljs-variable">#(int ADDR_WIDTH=16, int DATA_WIDTH=16)(input clk, input rst_n)</span>;<br>    <span class="hljs-keyword">logic</span> bus_cmd_valid;<br>    <span class="hljs-keyword">logic</span> bus_op;<br>    <span class="hljs-keyword">logic</span> [ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bus_addr;<br>    <span class="hljs-keyword">logic</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bus_wr_data;<br>    <span class="hljs-keyword">logic</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bus_rd_data;<br><span class="hljs-keyword">endinterface</span><br></code></pre></div></td></tr></table></figure>
<p>config_db机制同样支持传递参数化的interface：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(virtual bus_if#(16, 16))::set(null, &quot;uvm_test_top.env.bus_agt.mon&quot;, &quot;vif&quot; bif)</span>;<br>uvm_config_db<span class="hljs-variable">#(virtual bus_if#(ADDR_WIDTH, DATA_WIDTH))::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>3.sequence中的参数化</strong></p>
<p>sequence机制同样支持参数化的transaction：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> bus_sequencer<span class="hljs-variable">#(int ADDR_WIDTH=16, int DATA_WIDTH=16)</span> <span class="hljs-keyword">extends</span> uvm_sequencer <br>                                        <span class="hljs-variable">#(bus_transaction#(ADDR_WIDTH, DATA_WIDTH))</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>4.有默认参数的类</strong></p>
<p>很多参数化的类都有默认参数，用户在使用时经常会使用默认参数。但UVM的factory机制不支持参数化类中的默认参数。假如有如下的agent定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> bus_agent<span class="hljs-variable">#(int ADDR_WIDTH=16, int DATA_WIDTH=16)</span> <span class="hljs-keyword">extends</span> uvm_agent ;<br></code></pre></div></td></tr></table></figure>
<p>在声明agent时可以按照如下写法来省略参数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">bus_agent bus_agt;<br></code></pre></div></td></tr></table></figure>
<p>但在实例化时必须将省略的参数加上：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">bus_agt = bus_agent<span class="hljs-variable">#(16, 16)::type_id::create(&quot;bus_agt&quot;, this)</span>;<br></code></pre></div></td></tr></table></figure>
<h3><span id="94-模块级到芯片级的代码重用">9.4 模块级到芯片级的代码重用</span></h3><h4><span id="941-基于env的重用">9.4.1 基于env的重用</span></h4><p>现代芯片的验证通常分为两个层次：</p>
<ul>
<li>模块级别（block level，也称IP级别、unit级别）验证</li>
<li>芯片级别（也称SOC级别）验证</li>
</ul>
<p>一个大的芯片在开发时是分成多个小模块来开发的。每个模块开发一套独立的验证环境，通常每个模块有专门的验证人员负责。当在模块级别验证完成后需要做整个系统的验证</p>
<p>为简单起见，假设某芯片分成了三个模块，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160656552.png" srcset="/img/loading.gif" lazyload alt="图9-1 具有三个模块的简单芯片"></p>
<p>这三个模块在<strong>模块级别验证时</strong>，分别有自己的driver和sequencer，如图9-2所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160723445.png" srcset="/img/loading.gif" lazyload alt="图9-2 模块级别验证平台"></p>
<p><strong>当在芯片级别验证时</strong>，如果采用env级别的重用，那么B和C中的driver分别取消（因为芯片级按照设计，只有A一个输入），这可以通过设置各自i_agt的is_active来控制， 如图9-3所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160802325.png" srcset="/img/loading.gif" lazyload alt="图9-3 芯片级别验证平台一"></p>
<p>仔细观察图9-3，发现<code>o_agt(A)</code>和<code>i_agt(B)</code>两者监测的是同一接口，换言之，二者应该是同一个agent。在模块级别验证时，<code>i_agt(B)</code>被配置为<code>active</code>模式，在图9-3中则被配置为<code>passive</code>模式。被配置为<code>passive</code>模式的<code>i_agt(B)</code>其实和<code>o_agt(A)</code>完全一 样，二者监测同一接口，对外发出同样的transaction。或者说，其实可以将<code>i_agt(B)</code>取消，<code>model(B)</code>的数据来自<code>o_agt(A)</code>。<code>o_agt(B)</code>和<code>i_agt(C)</code>也是同样的情况。取消了<code>i_agt(B)</code>和<code>i_agt(C)</code>的芯片级别验证平台如图9-4所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203160959965.png" srcset="/img/loading.gif" lazyload alt="图9-4 芯片级别验证平台二"></p>
<p>为了实现上面的结构，每个模块验证需要在其env中添加一个analysis_port用于数据输出；添加一个analysis_export用于数据输入；在env中设置<code>in_chip</code>用于辨别不同的数据来源（0为外部输入芯片，1则是验证平台内部）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.4/9.4.1/ip/my_env.sv</span><br><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br>    …<br>    <span class="hljs-keyword">bit</span> in_chip;<br>    uvm_analysis_port<span class="hljs-variable">#(my_transaction)</span> ap;<br>    uvm_analysis_export<span class="hljs-variable">#(my_transaction)</span> i_export;<br>    …<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>        <span class="hljs-keyword">if</span>(!in_chip) <span class="hljs-keyword">begin</span><br>            i_agt = my_agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>            i_agt<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;<br>        <span class="hljs-keyword">end</span><br>        …<br>        <span class="hljs-keyword">if</span>(in_chip)<br>            i_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;i_export&quot;</span>, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::connect_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    ap = o_agt<span class="hljs-variable">.ap</span>;<br>    <span class="hljs-keyword">if</span>(in_chip) <span class="hljs-keyword">begin</span><br>        i_export<span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.analysis_export</span>);<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        i_agt<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(agt_mdl_fifo<span class="hljs-variable">.analysis_export</span>);<br>    <span class="hljs-keyword">end</span><br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>在<code>chip_env</code>中，实例化<code>env_A</code>、<code>env_B</code>、<code>env_C</code>，将<code>env_B</code>和<code>env_C</code>的<code>in_chip</code>设置为<code>1</code>，并将<code>env_A</code>的<code>ap</code>口与<code>env_B</code>的<code>i_export</code>相连， 将<code>env_B</code>的<code>ap</code>与<code>env_C</code>的<code>i_export</code>相连接：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.4/9.4.1/chip/chip_env.sv</span><br><span class="hljs-keyword">class</span> chip_env <span class="hljs-keyword">extends</span> uvm_env;<br>    <span class="hljs-meta">`uvm_component_utils(chip_env)</span><br>    my_env env_A;<br>    my_env env_B;<br>    my_env env_C;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> chip_env::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    env_A = my_env::type_id::create(<span class="hljs-string">&quot;env_A&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_B = my_env::type_id::create(<span class="hljs-string">&quot;env_B&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_B<span class="hljs-variable">.in_chip</span> = <span class="hljs-number">1</span>;<br>    env_C = my_env::type_id::create(<span class="hljs-string">&quot;env_C&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_C<span class="hljs-variable">.in_chip</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> chip_env::connect_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    env_A<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(env_B<span class="hljs-variable">.i_export</span>);<br>    env_B<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(env_C<span class="hljs-variable">.i_export</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>上面两种芯片级别验证平台各有其优缺点。前者的验证平台的各个env之间没有数据交互，从而各个env不必设置analysis_port及analysis_export，在连接上简单些。但<strong>推荐使用后者(9-4)的验证平台</strong></p>
<ul>
<li>整个验证平台中<strong>消除了冗余的monitor，这在一定程度上可以加快仿真速度</strong></li>
<li><strong>不同模块的验证环境之间有数据交互时，可以互相检查对方接口数据是否合乎规范</strong>。如A的数据送给了B，而B无法正常工作，那么要么是A收集的数据是错的，不符合B的要求，要么就是A收集的数据是对的，但B对接口数据理解有误</li>
</ul>
<h4><span id="942-寄存器模型的重用">9.4.2 寄存器模型的重用</span></h4><p>上节的重用中并没有考虑总线的重用。一般<strong>每个模块会有自已的寄存器配置总线</strong>。在集成到芯片时<strong>芯片有自己的配置总线</strong>，这些配置总线经过仲裁之后分别连接到各个模块，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203175708374.png" srcset="/img/loading.gif" lazyload alt="图9-5 从模块到芯片的总线连接变换"></p>
<p>在图7-1中，<code>bus_agt</code>是作为env的一部分的。但是从图9-5可以看出，这样的一个<strong>env是不可重用的</strong>，下图为7-1：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181838425.png" srcset="/img/loading.gif" lazyload alt="图7-1 验证平台框图"></p>
<p>因此，为了提高可重用性（即实现env的重用），在模块级别时，图7-1的<code>bus_agt</code>应该<strong>从env中移到base_test中</strong>，如图9-6所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181315705.png" srcset="/img/loading.gif" lazyload alt="图9-6 把bus_agt从env中移到base_test"></p>
<p>与<code>bus_agt</code>对应的是寄存器模型。在模块级别验证时，每个模块有各自的寄存器模型。很多用户习惯于在env中实例化寄存器模型：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br>    reg_model rm;<br>    …<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_env::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>    …<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>但<u>如果要实现env级别的重用，就不能在env中实例化寄存器模型</u>。每个模块都有其偏移地址，如A的偏移地址可能是<code>&#39;h0000</code>，B是<code>&#39;h4000</code>，C是<code>&#39;h8000</code>(即16位地址的高两位用于辨识不同模块)。如果在env级例化寄存器模型，那么在芯片级时不能指定其偏移地址。因此在模块级验证时需要在base_test中实例化寄存器模型，在env中设置一个寄存器模型的指针，在base_test中对它赋值</p>
<blockquote>
<p><strong>我的理解</strong></p>
<p>如果直接在env中实例化寄存器模型，而不是base_test，则每个模块的env都有对应的寄存器模型，访问也不需要指定偏移地址直接访问即可，最终导致与设计不符！</p>
</blockquote>
<p>为了在芯片级别使用寄存器模型，需建立一个新的寄存器模型：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//src/ch9/section9.4/9.4.2/chip/chip_reg_model.sv</span><br><span class="hljs-keyword">class</span> chip_reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    <span class="hljs-keyword">rand</span> reg_model A_rm;<br>    <span class="hljs-keyword">rand</span> reg_model B_rm;<br>    <span class="hljs-keyword">rand</span> reg_model C_rm;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>        default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br>        …<br>        default_map<span class="hljs-variable">.add_submap</span>(A_rm<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h0</span>);<br>        …<br>        default_map<span class="hljs-variable">.add_submap</span>(B_rm<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h4000</span>);<br>        …<br>        default_map<span class="hljs-variable">.add_submap</span>(C_rm<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h8000</span>);<br>    <span class="hljs-keyword">endfunction</span><br>    …<br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>这个新的寄存器模型中只需加入各个不同模块的寄存器模型并设置偏移地址和后门访问路径。建立芯片级寄存器模型的方式与建立多层次的寄存器模型一致</p>
<p>在chip_env中实例化此寄存器模型，并将各个模块的寄存器模型的指针赋值给各个env的p_rm：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> chip_env::build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    env_A = my_env::type_id::create(<span class="hljs-string">&quot;env_A&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_B = my_env::type_id::create(<span class="hljs-string">&quot;env_B&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_B<span class="hljs-variable">.in_chip</span> = <span class="hljs-number">1</span>;<br>    env_C = my_env::type_id::create(<span class="hljs-string">&quot;env_C&quot;</span>, <span class="hljs-keyword">this</span>);<br>    env_C<span class="hljs-variable">.in_chip</span> = <span class="hljs-number">1</span>;<br>    bus_agt = bus_agent::type_id::create(<span class="hljs-string">&quot;bus_agt&quot;</span>, <span class="hljs-keyword">this</span>);<br>    bus_agt<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;<br>    chip_rm = chip_reg_model::type_id::create(<span class="hljs-string">&quot;chip_rm&quot;</span>, <span class="hljs-keyword">this</span>);<br>    chip_rm<span class="hljs-variable">.configure</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    chip_rm<span class="hljs-variable">.build</span>();<br>    chip_rm<span class="hljs-variable">.lock_model</span>();<br>    chip_rm<span class="hljs-variable">.reset</span>();<br>    reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>    env_A<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.chip_rm</span><span class="hljs-variable">.A_rm</span>;<br>    env_B<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.chip_rm</span><span class="hljs-variable">.B_rm</span>;<br>    env_C<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.chip_rm</span><span class="hljs-variable">.C_rm</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure>
<p>加入寄存器模型后，整个验证平台的框图变为下图所示的形式：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181642832.png" srcset="/img/loading.gif" lazyload alt="图9-7 加入寄存器模型的芯片级别验证平台"></p>
<h4><span id="943-virtual-sequence与virtual-sequencer中的重用">9.4.3 virtual sequence与virtual sequencer中的重用</span></h4><p>对于9.4.1节的例子来说，每个模块的virtual sequencer分为两种情况：</p>
<ul>
<li>一种是只适用于模块级别，不能用于芯片级别；</li>
<li>另外一种是适用于模块和芯片级别</li>
</ul>
<p>前者的代表是<code>B</code>和<code>C</code>的virtual sequencer，后者的代表是<code>A</code>中的virtual sequencer。<code>B</code>和<code>C</code>的virtual sequencer不能出现在芯片级的验证环境中；<code>A</code>模块比较特殊是一个<strong>边界模块</strong>，它的virtual sequencer可以用于芯片级别验证中。所以不应在env中实例化virtual sequencer，而应在base_test中实例化（因为在env中实例化vsqr后，则无法对env进行重用，因为芯片级验证中B和C中是不需要vsqr的）</p>
<p>但前面只是一个简单的例子。现代的大型芯片可能不只<strong>一个边界输入</strong>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/GreensCH/blog-drawbed/main/common/image-20230203181933558.png" srcset="/img/loading.gif" lazyload alt="图9-8 具有多个输入的芯片"></p>
<blockquote>
<p><code>D</code>和<code>F</code>分别是边界输入模块。在整个芯片的virtual sequencer中，应该包含<code>A</code>、<code>D</code>和<code>F</code>的sequencer。因此<code>A</code>、<code>D</code>和<code>F</code>的virtual sequencer是不能直接用于芯片级验证的</p>
</blockquote>
<p>无论是像<code>B</code>、<code>C</code>、<code>E</code>这样的内部模块还是<code>A</code>、<code>D</code>、<code>F</code>这样的边界输入模块，统一推荐其virtual sequencer在base_test中实例化<strong>。</strong>在芯片级建立自己的virtual sequencer</p>
<p>相对应的virtual sequence，通常来说virtual sequence都使用<code>`uvm_declare_p_sequencer</code>宏来指定sequencer。这些sequence在模块级别是存在的，但在芯片级根本不存在，所以这些virtual sequence无法用于芯片级别验证</p>
<p>有两种模块级别的sequence可以直接用于芯片级别的验证：</p>
<p>①一种如<code>A</code>、<code>D</code>和<code>F</code>这样的边界输入端的普通的sequence(不是virtual sequence)，以A的某sequence为例，在模块级可以这样使用它：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        A_seq aseq;<br>        <span class="hljs-meta">`uvm_do_on(aseq, p_sequencer.p_sqr)</span><br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在芯片级这样使用它：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> chip_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        A_seq aseq;<br>        D_seq dseq;<br>        F_seq fseq;<br>        <span class="hljs-keyword">fork</span><br>            <span class="hljs-meta">`uvm_do_on(aseq, p_sequencer.p_a_sqr)</span><br>            <span class="hljs-meta">`uvm_do_on(aseq, p_sequencer.p_d_sqr)</span><br>            <span class="hljs-meta">`uvm_do_on(aseq, p_sequencer.p_f_sqr)</span><br>        <span class="hljs-keyword">join</span><br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>②另外一种是寄存器配置的sequence（<code>A_cfg_seq</code>）。这种sequence一般在定义时不指定transaction类</p>
<p>如果这些sequence做成如下形式，也是<strong>无法重用</strong>的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A_cfg_seq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.xxx</span><span class="hljs-variable">.write</span>();<span class="hljs-comment">//使用了p_sequence，从而无法生成ral </span><br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>要想能够在<strong>芯片级重用</strong>，需要使用如下的方式定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A_cfg_seq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    A_reg_model p_rm;<span class="hljs-comment">//芯片级直接定义一个ral model</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        p_rm<span class="hljs-variable">.xxx</span><span class="hljs-variable">.write</span>();<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在模块级以如下的方式启动它：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        A_cfg_seq c_seq;<br>        c_seq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;c_seq&quot;</span>);<br>        c_seq<span class="hljs-variable">.p_rm</span> = p_sequencer<span class="hljs-variable">.p_rm</span>;<span class="hljs-comment">//模块级引用ral model</span><br>        c_seq<span class="hljs-variable">.start</span>(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>在芯片级别以如下的方式启动：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> chip_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        A_cfg_seq A_c_seq;<br>        A_c_seq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;A_c_seq&quot;</span>);<br>        A_c_seq<span class="hljs-variable">.p_rm</span> = p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.A_rm</span>;<br>        A_c_seq<span class="hljs-variable">.start</span>(<span class="hljs-literal">null</span>);<br>        …<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure>
<p>除这种指针传递的形式外，还可通过<code>get_root_blocks()</code>来获得。在芯片级root block已经和模块级不同，单纯靠<code>get_root_blocks()</code>已无法满足要求。此时需要<code>find_blocks()</code>、<code>find_block()</code>、<code>get_blocks()</code>和<code>get_block_by_name()</code>等函数，这里不再一一介绍</p>
<h2><span id="附录">附录</span></h2><h3><span id="要点">要点</span></h3><p>在验证平台的设计中要尽量做到小而美，避免大而全（UVM实战，9.2）</p>
<p>factory的重载机制时，被重载的A类应该尽可能多的进行任务/函数的小型化，从而避免在重载过程中大段的代码复制（9.2.2）</p>
<p>尽量做到一看名字就知道这个sequence的用处，这样可以最大程度上方便自己，方便大家（9.2.3）</p>
<h3><span id="运行时命令行参数">运行时命令行参数</span></h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41979380/article/details/121656117">https://blog.csdn.net/weixin_41979380/article/details/121656117</a></p>
<p>命令行参数指的是<strong>运行时的命令行参数</strong>，而<strong>不是编译时的命令行参数</strong>（即可运行文件的命令行参数，而不是在编译时添加的宏定义）</p>
<hr>
<ol>
<li>打印出所有的命令行参数</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_DUMP_CMDLINE_ARGS<br></code></pre></div></td></tr></table></figure>
<ol>
<li>指定运行测试用例的名称：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_TESTNAME=&lt;class name&gt;<br>//使用示例<br>&lt;sim command&gt; +UVM_TESTNAME=my_case0<br></code></pre></div></td></tr></table></figure>
<ol>
<li>在命令行中设置冗余度阈值</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_VERBOSITY=&lt;verbosity&gt;<br>//使用示例<br>&lt;sim command&gt; +UVM_VERBOSITY=UVM_HIGH<br></code></pre></div></td></tr></table></figure>
<ol>
<li>设置打印信息的不同行为</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_action=&lt;comp&gt;,&lt;id&gt;,&lt;severity&gt;,&lt;action&gt;<br>//使用示例<br>&lt;sim command&gt; +uvm_set_action=&quot;uvm_test_top.env.i_agt.drv,my_driver,UVM_WARNING,UVM_DISPLAY|UVM_COUNT&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>重载冗余度</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_severity=&lt;comp&gt;,&lt;id&gt;,&lt;current severity&gt;,&lt;new severity&gt;<br>//使用示例<br>&lt;sim command&gt; +uvm_set_severity=&quot;uvm_test_top.env.i_agt.drv,my_driver,UVM_WAR NING,UVM_ERROR&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>设置全局的超时时间</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_TIMEOUT=&lt;timeout&gt;,&lt;overridable&gt;~<br>//使用示例<br>&lt;sim command&gt; +UVM_TIMEOUT=&quot;300ns, YES&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>ERROR到达一定数量退出仿真</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_MAX_QUIT_COUNT=&lt;count&gt;,&lt;overridable&gt;<br>//使用示例<br>&lt;sim command&gt; +UVM_MAX_QUIT_COUNT=6,NO<br></code></pre></div></td></tr></table></figure>
<ol>
<li>打开phase的调试功能</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_PHASE_TRACE<br></code></pre></div></td></tr></table></figure>
<ol>
<li>打开objection的调试功能</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_OBJECTION_TRACE<br></code></pre></div></td></tr></table></figure>
<ol>
<li>打开config_db的调试功能</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_CONFIG_DB_TRACE<br></code></pre></div></td></tr></table></figure>
<ol>
<li>打开resource_db的调试功能</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +UVM_RESOURCE_DB_TRACE<br></code></pre></div></td></tr></table></figure>
<ol>
<li>使用factory机制重载某个实例</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_inst_override=&lt;req_type&gt;,&lt;override_type&gt;,&lt;full_inst_path&gt;<br>//使用示例<br>&lt;sim command&gt; +uvm_set_inst_override=&quot;my_monitor,new_monitor,uvm_test_top.en v.o_agt.mon&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>类型重载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;]<br>//使用示例<br>&lt;sim command&gt; +uvm_set_type_override=&quot;my_monitor,new_monitor&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>类型重载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;]<br>//使用示例<br>&lt;sim command&gt; +uvm_set_type_override=&quot;my_monitor,new_monitor&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>类型重载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;]<br>//使用示例<br>&lt;sim command&gt; +uvm_set_type_override=&quot;my_monitor,new_monitor&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>类型重载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;]<br>//第三个参数replace，只能为0或者1，默认情况下为1<br>//使用示例<br>&lt;sim command&gt; +uvm_set_type_override=&quot;my_monitor,new_monitor&quot;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>在命令行中使用set_config</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&lt;sim command&gt; +uvm_set_config_int=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt;<br>&lt;sim command&gt; +uvm_set_config_string=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt;<br>//使用示例<br>&lt;sim command&gt; +uvm_set_config_int=&quot;uvm_test_top.env.i_agt.drv,pre_num,&#x27;h8&quot;<br></code></pre></div></td></tr></table></figure>
<h3><span id="常用宏汇总">常用宏汇总</span></h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41979380/article/details/121656373">https://blog.csdn.net/weixin_41979380/article/details/121656373</a></p>
<p>宏与运行时的命令行参数不同，它有两种定义方式：</p>
<ul>
<li>一是直接在源文件中中使用<code>`define</code>进行定义，以MACRO为例：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MACRO</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> MACRO 100</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>二是在编译时的命令行添加，以MACRO为例：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">&lt;compile command&gt; +define+MACRO<br><span class="hljs-comment">//或者</span><br>&lt;compile command&gt; +define+MACRO=<span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure>
<hr>
<ol>
<li>扩展寄存器模型中的数据位宽</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_DATA_WIDTH 128</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li>扩展寄存器模型中的地址位宽</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_ADDR_WIDTH 64</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li>自定义字选择（byteenable）位宽</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_REG_BYTENABLE_WIDTH 8</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li>去除OVM中过时的用法，使用纯净的UVM环境</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">define</span> UVM_NO_DEPRECATED</span><br></code></pre></div></td></tr></table></figure>
<p>除上述通用的宏外，<strong>针对不同仿真工具需定义不同的宏</strong>：QUESTA、VCS、INCA分别对应Mentor、Synopsys和Cadence公司的仿真工具。由于UVM的源代码分为两部分（一部分是SV代码，另一部分是C/C++），针对不同的仿真工具，需要在SV与C++编译时分别定义各自的宏</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/categories/IC/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">理论知识</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
                    
                      <a class="hover-with-bg" href="/tags/UVM/">UVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202212041616/IC/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV-tips/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SystemVerilog TIPs</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202211151136/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">HelloWorld | SV实验0~5</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  
  <div id="aplayer" style="width:300px"></div>
  <link defer rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
  <script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js"></script>
  <script defer src="/js/aplayer.js"></script><script src="/js/githubcalendar.js"></script> 
  <script data-pjax src="/js/githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?greensch";
            var git_color =['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'];
            var git_user ="greensch";
            var parent_div_git = document.getElementById('board');
            var git_div_html = '<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px;box-shadow:none;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('board')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:200px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>#github_container > .position-relative > .border{border:0!important}#github-calendar{position: relative;margin-top: -2rem;background-color: var(--board-bg-color);transition: background-color 0.2s ease-in-out;border-radius: 0.5rem;z-index: 3;-webkit-box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);}</style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"left","width":150,"height":400,"vOffset":-18},"mobile":{"show":false,"scale":0.25},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
