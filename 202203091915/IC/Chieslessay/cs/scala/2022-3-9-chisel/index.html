

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="0 Chisel的常见问题（必读）（1）Firrtl中间格式：Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转变成Verilog，语言开发人员开发了一个中间的标准交换格式——Firrtl，它跟Vrilog是同一级别的，两者都比Chisel低一级。编写的Chisel代码首先会经过Firrtl编译器，生成Firrtl代码，也就是一个后缀格式为“.fir”的文件，然">
<meta property="og:type" content="article">
<meta property="og:title" content="Chisel（一）：初步">
<meta property="og:url" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="0 Chisel的常见问题（必读）（1）Firrtl中间格式：Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转变成Verilog，语言开发人员开发了一个中间的标准交换格式——Firrtl，它跟Vrilog是同一级别的，两者都比Chisel低一级。编写的Chisel代码首先会经过Firrtl编译器，生成Firrtl代码，也就是一个后缀格式为“.fir”的文件，然">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/2022-3-9-chisel/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p2.jpg">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p3.jpg">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg">
<meta property="article:published_time" content="2022-03-09T11:15:00.000Z">
<meta property="article:modified_time" content="2022-03-11T11:05:02.269Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="IC">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/2022-3-9-chisel/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
  
  <title>Chisel（一）：初步 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Chisel（一）：初步">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-09 19:15" pubdate>
        2022年3月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Chisel（一）：初步</h1>
            
            <div class="markdown-body">
              <h1 id="0-Chisel的常见问题（必读）"><a href="#0-Chisel的常见问题（必读）" class="headerlink" title="0 Chisel的常见问题（必读）"></a>0 Chisel的常见问题（必读）</h1><p>（1）<strong>Firrtl中间格式：</strong>Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转变成Verilog，语言开发人员开发了一个中间的标准交换格式——Firrtl，它跟Vrilog是同一级别的，两者都比Chisel低一级。编写的Chisel代码首先会经过Firrtl编译器，生成Firrtl代码，也就是一个后缀格式为“.fir”的文件，然后由这个Firrtl文件再去生成对应的Verilog代码。如果读者有兴趣看一看Firrtl的格式，其实与Verilog很接近，只不过是由机器生成的、很死板的代码。Firrtl编译器也并不是只针对Chisel，有兴趣和能力的读者也可以开发针对Java、Python、C++等语言的Firrtl编译器。因为Firrtl只是一种标准的中间媒介，如何从一端到另一端，完全是自定义的。另外，Firrtl也并不仅仅是生成Verilog，同样可以开发工具生成VHDL、SystemVerilog等语言</p>
<p>（2）<u>Chisel与Firrtl双检查：</u>Scala里的语法，在Chisel里也基本能用，比如Scala的基本值类、内建控制结构、函数抽象、柯里化、模式匹配、隐式参数等等。但是读者要记住这些代码不仅要通过Scala编译器的检查，还需要通过Firrtl编译器的检查</p>
<p>（3）<strong>Chisel完全可综合：</strong>Verilog的最初目的是用于电路验证，所以它有很多不可综合的语法。Firrtl在转变成Verilog时，只会采用可综合的语法，因此读者完全不用担心用Chisel写出来的电路不可综合。只要能正确生成Verilog，那就能被综合器生成电路</p>
<p>（4）<strong>Chisel只支持二值逻辑：</strong>Chisel目前<strong>只支持0和1</strong>，<strong>不支持四态逻辑里的x和z</strong>。由于只有芯片对外的IO处才能出现三态门，所以内部设计几乎用不到x和z。而且x和z在设计中会带来危害，忽略掉它们也不影响大多数设计，还简化了模型。当然，<u>如果确实需要，可以通过黑盒语法与外部的Verilog代码互动，也可以在下游工具链里添加四态逻辑</u></p>
<p>（5）<strong>Chisel检查未驱动：</strong>Chisel会对未被驱动的输出型端口和线网进行检测，如果存在，会进行报错。报错选项可以关闭和打开，取决于读者对设计模型的需求。推荐把该选项打开，尽量不要残留无用的声明。</p>
<p>（6）<mark><strong>Chisel需手动导环境包：</strong></mark>Chisel的代码包并不会像Scala的标准库那样被编译器隐式导入，所以每个Chisel文件都应该在开头都需要导包</p>
<ul>
<li>import chisel3._：必选，包含了基本语法</li>
<li>import chisel3.util._：高级语法必选</li>
<li>import chisel3.experimental._：高级语法必选</li>
<li>import chisel3.testers._：高级语法必选</li>
</ul>
<p>（7）<strong>不同层次打包封装：</strong>应该用一个名字有意义的包来打包实现某个功能的文件集。例如，要实现一个自定义的微处理器，则可以把顶层包命名为“mycpu”，进而再划分成“myio”、“mymem”、“mybus”、“myalu”等子包，每个子包里包含相关的源文件。</p>
<p>​        Chisel现在仍在更新中，很可能会添加新功能或删去老功能。因此，本教程介绍的内容在将来并不一定就正确，读者应该持续关注Chisel3的GitHub的发展动向</p>
<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><p>以下环境搭建基于Ubuntu16.04</p>
<h2 id="1-1-Java安装"><a href="#1-1-Java安装" class="headerlink" title="1.1 Java安装"></a>1.1 Java安装</h2><p>根据下面这个博客来的，但在修改环境变量处出现了问题，导致无法进入系统（详情参考本博客《解决Ubuntu修改环境变量后导致登录循环进不去系统的问题》）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41204464/article/details/90314834">https://blog.csdn.net/qq_41204464/article/details/90314834</a></p>
<hr>
<h3 id="（1）下载安装包"><a href="#（1）下载安装包" class="headerlink" title="（1）下载安装包"></a>（1）下载安装包</h3><p>记得下载Linux 64位的 <a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html">官网地址</a></p>
<h3 id="（2）解压并移动"><a href="#（2）解压并移动" class="headerlink" title="（2）解压并移动"></a>（2）解压并移动</h3><p>解压并移动到<code>/usr/lib/jdk</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tar -zxvf ./jdk-8u311-linux-x64.tar.gz<br>mkdir /usr/lib/jdk<br>mv ./jdk1.8.0_311 /usr/lib/jdk/<br></code></pre></div></td></tr></table></figure>
<h3 id="（3）修改环境变量"><a href="#（3）修改环境变量" class="headerlink" title="（3）修改环境变量"></a>（3）修改环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo gedit /etc/profile<br></code></pre></div></td></tr></table></figure>
<p>在文件的<strong>最后</strong>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs make"># JDK,TOMCAT,ORACLE<br>export JAVA_HOME=/home/pu/jdk1.8.0_211<br>export JRE_HOME=$JAVA_HOME/jre<br><br># two sentence belong may crash your env<br># export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib <br># export PATH=$PATH:$JAVA_HOME/bin<br></code></pre></div></td></tr></table></figure>
<h3 id="（4）测试环境变量是否出问题"><a href="#（4）测试环境变量是否出问题" class="headerlink" title="（4）测试环境变量是否出问题"></a>（4）测试环境变量是否出问题</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile <br></code></pre></div></td></tr></table></figure>
<p>如果运行后发现环境变量失效，则修改有问题</p>
<h2 id="1-2-Scala安装"><a href="#1-2-Scala安装" class="headerlink" title="1.2 Scala安装"></a>1.2 Scala安装</h2><ul>
<li><p>随便从官网找一个安装包<a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/all.html，我这里用的rpm安装包，省的我再配置环境变量了">https://www.scala-lang.org/download/all.html，我这里用的rpm安装包，省的我再配置环境变量了</a></p>
</li>
<li><p>安装rpm使用命令：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo rpm  -ivh ./scala-2.11.8.rpm<br></code></pre></div></td></tr></table></figure>
<ul>
<li>安装sbt(官网<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/download.html)：">https://www.scala-sbt.org/download.html)：</a></li>
</ul>
<blockquote>
<p>Scala开发环境，官方名字叫“sbt”，最好选择最新的发布版本的安装，不然你还得蛋疼得安装一个叫<a target="_blank" rel="noopener" href="https://github.com/ucb-bar/firrtl">Firrtl</a> 的软件。这个需要先下载再安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://repo.scala-sbt.org/scalasbt/debian all main&quot;</span> | sudo tee /etc/apt/sources.list.d/sbt.list<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://repo.scala-sbt.org/scalasbt/debian /&quot;</span> | sudo tee /etc/apt/sources.list.d/sbt_old.list<br>curl -sL <span class="hljs-string">&quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot;</span> | sudo apt-key add<br>sudo apt-get update<br>sudo apt-get install sbt<br></code></pre></div></td></tr></table></figure>
<ul>
<li>sbt安装完检查：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sbt<br>sbt -version<br>sbt version <span class="hljs-keyword">in</span> this project: 1.6.2<br>sbt script version: 1.6.2<br></code></pre></div></td></tr></table></figure>
<h2 id="1-3-安装Verilator"><a href="#1-3-安装Verilator" class="headerlink" title="1.3 安装Verilator"></a>1.3 安装Verilator</h2><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install verilator <br><br>verilator -version<br>Verilator 3.904 2017-05-30 rev verilator_3_904 <br></code></pre></div></td></tr></table></figure>
<h2 id="1-4-Chisel安装"><a href="#1-4-Chisel安装" class="headerlink" title="1.4 Chisel安装"></a>1.4 Chisel安装</h2><p>参考官方文档：</p>
<ul>
<li>template：<a target="_blank" rel="noopener" href="https://github.com/freechipsproject/chisel-template">https://github.com/freechipsproject/chisel-template</a></li>
<li>doc：<a target="_blank" rel="noopener" href="https://github.com/chipsalliance/chisel3">https://github.com/chipsalliance/chisel3</a></li>
<li>homepage：<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/">https://www.chisel-lang.org/</a></li>
</ul>
<p>参考指导博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34291505/article/details/87365907">https://blog.csdn.net/qq_34291505/article/details/87365907</a></li>
</ul>
<h3 id="方法一：直接git-clone-template"><a href="#方法一：直接git-clone-template" class="headerlink" title="方法一：直接git clone template"></a>方法一：直接git clone template</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/freechipsproject/chisel-template <br></code></pre></div></td></tr></table></figure>
<h2 id="1-10-第一个工程"><a href="#1-10-第一个工程" class="headerlink" title="1.10 第一个工程"></a>1.10 第一个工程</h2><ul>
<li><p>对于小规模电路，可以直接用Chisel写testbench文件，然后联合Verilator生成C++文件来仿真，输出波形图。该方法会在后续章节介绍。</p>
</li>
<li><p>对于大规模电路，Verilator仿真很吃力，建议还是用生成的Verilog文件在专业EDA工具里仿真。当前Chisel不支持UVM，也没有工具支持Chisel，所以尽量用别的工具做测试。</p>
</li>
</ul>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h1><p>​        读者在学习本章后，<strong>应该理清Chisel数据类型的关系</strong>。</p>
<p>​        <strong>常用的类型就五种</strong>，重点学会这五种即可：</p>
<ul>
<li>UInt</li>
<li>SInt</li>
<li>Bool</li>
<li>Bundle</li>
<li>Vec[T]</li>
</ul>
<p>​        <strong>三种值类</strong>：UInt、SInt和Bool的操作符与Verilog差不多，很快就能理解。</p>
<h2 id="2-1-Chisel的数据类型"><a href="#2-1-Chisel的数据类型" class="headerlink" title="2.1 Chisel的数据类型"></a>2.1 Chisel的数据类型</h2><p>​        Chisel定义了自己的一套数据类型，读者应该跟Scala的九种基本值类区分开来。</p>
<p>​        Scala中数据类型在Chisel用于参数和内建控制结构</p>
<p>​        Chisel自己的数据类型用于构建硬件电路还是得用</p>
<p>​        Chisel定义的数据类型如下图所示，其中<strong>绿色方块是class</strong>，<strong>红色是object</strong>，<strong>蓝色是trait</strong>，<strong>箭头指向的是超类和混入的特质</strong>： </p>
<p><img src="2022-3-9-chisel/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="Chisel的数据类型关系图"></p>
<ul>
<li><p><strong>Data类：所有数据类型都继承自抽象基类Data</strong>，它混入了两个特质HasId和NamedComponent。如果读者查看Chisel3的源代码，就会看到很多参数传递时都用下界表明了是Data的子类。<u>在实际硬件构成里，并不会用到Data</u>，读者也不用关心它的具体实现细节。更多的，应该关注Data类的两大子类：聚合类Aggregate和元素类Element。</p>
</li>
<li><p><strong>Aggregate聚合类：</strong>Aggregate聚合类常用子类是<strong>向量类Vec[T]和包裹类Bundle</strong></p>
<ul>
<li><strong>Vec[T]子类：</strong>用于<strong>包含相同的元素</strong>，元素类型T可以是任意的Data子类。因为Vec[T]混入了特质IndexedSeq[T]，所以向量的元素能从下标0开始索引访问</li>
<li><strong>Bundle子类</strong>：用于<strong>被自定义的类继承，这样自定义的类就能包含任意Data的子类对象</strong>，常用于<strong>协助构造模块的端口</strong>，故而衍生出了一些预定义的端口子类</li>
<li>MixedVec[T]子类：混合向量类是Chisel3.2以上版本添加的语法，它与Vec[T]的不同在于<strong>可以包含不同类型的元素</strong>。</li>
</ul>
</li>
<li><p><strong>Element类：</strong>衍生出了Analog、Bits和Clock三个子类，单例对象DontCare和特质Reset</p>
<ul>
<li><strong>Analog子类：</strong>用于<strong>在黑盒中模拟inout端口</strong>，目前在实际Chisel里并无其他用途</li>
<li><strong>Bits子类：</strong>的两个子类SInt和UInt是最常用的两个数据类型，它们是用补码表示的有符号整数和无符号整数。不仅用来协助定义端口位宽，还用来进行赋值</li>
<li>FixedPoint子类提供的API带有试验性质，而且将来可能会发生改变，所以不常用</li>
<li><strong>Bool子类：</strong>是Chisel自己的布尔类型，<strong>区别于Scala的Boolean</strong>。Bool类是UInt类的子类，因为它可以看成是1bit的UInt，而且它被混入Reset特质，因为复位信号都是用Bool类型的线网或寄存器使能的。此外，Bits类混入了特质ToBoolable，也就是说FixedPoint、SInt和UInt都能转换成多bit的Bool类型</li>
<li><strong>Clock类：</strong>表示时钟，Chisel里的时钟是专门的一个类型，并不像Verilog里那样是1bit的线网。复位类型Reset也是如此</li>
<li><strong>Reset特质</strong>：表示复位，Chisel里的特质是专门的一个特质，并不像Verilog里那样是1bit的线网</li>
<li><strong>DontCare单例对象：</strong>用于赋值给未驱动的端口或线网，防止编译器报错。</li>
</ul>
</li>
</ul>
<h2 id="2-2-能表示数据的字面量"><a href="#2-2-能表示数据的字面量" class="headerlink" title="2.2 能表示数据的字面量"></a>2.2 能表示数据的字面量</h2><p><strong>字面量（literal）</strong>：有直接意义的，能直接表示的固定值</p>
<p><strong>BigInt、Int、Long和String四种类型的Scala字面量来构造UInt和SInt，具体分类两类：</strong></p>
<ul>
<li>数值字面量</li>
<li>字符串字面量</li>
</ul>
<hr>
<p><strong>（1）Chisel具体数的数据类型：</strong>        </p>
<p>​        能够表示具体值的数据类型为<strong>UInt、SInt和Bool</strong>。实际可综合的电路都是若干个bit，所以只能表示整数，这与Verilog是一致的。</p>
<p>​        <strong>要表示浮点数，本质还是用多个bit来构建</strong>，而且要遵循IEEE的浮点标准。</p>
<p><strong>（2）Chisel中的UInt、SInt、Bool：</strong></p>
<ul>
<li>对于UInt，可以构成任意位宽的线网或寄存器</li>
<li>对于SInt，在Chisel里会按补码解读，转换成Verilog后会使用系统函数$signed，这是可综合的</li>
<li>对于Bool，转换成Verilog后就是1bit的线网或寄存器</li>
</ul>
<p><strong>（3）如何用字面量表示数：</strong></p>
<blockquote>
<p>要表示值，则必须有相应的字面量。Chisel定义了一系列隐式类：fromBigIntToLiteral、fromtIntToLiteral、fromtLongToLiteral、fromStringToLiteral、fromBooleanToLiteral。回顾前面讲述的隐式类的内容，也就是会有相应的隐式转换。以隐式类fromtIntToLiteral为例，存在一个同名的隐式转换，把相应的Scala的Int对象转换成一个fromtIntToLiteral的对象。而fromtIntToLiteral类有两个方法U和S，分别构造一个等值的UInt对象和SInt对象。再加上Scala的基本值类都是用字面量构造对象，所以要表示一个UInt对象，可以写成“1.U”的格式，这样编译器会插入隐式转换，变成“fromtIntToLiteral(1).U”，进而构造出字面值为“1”的UInt对象。同理，<strong>也可以构造SInt。还有相同行为的方法asUInt和asSInt。</strong></p>
<p>​        从几个隐式类的名字就可以看出，可以通过BigInt、Int、Long和String四种类型的Scala字面量来构造UInt和SInt。按Scala的语法，其中BigInt、Int、Long三种类型默认是十进制的，但可以加前缀“0x”或“0X”变成十六进制。对于字符串类型的字面量，Chisel编译器默认也是十进制的，但是可以加上首字母“h”、“o”、“b”来分别表示十六进制、八进制和二进制。此外，字符串字面量可以用下划线间隔。</p>
<p>​        可以通过Boolean类型的字面量——true和false——来构造fromBooleanToLiteral类型的对象，然后调用名为B和asBool的方法进一步构造Bool类型的对象</p>
</blockquote>
<p>以上内容总结为：</p>
<ul>
<li>Chisel定义了一系列隐式类，隐式的从<strong>四种Scala字面量到Chisel数据类型的转变</strong><ul>
<li><strong>隐式类：</strong>fromBigIntToLiteral、fromtIntToLiteral、fromtLongToLiteral、fromStringToLiteral、fromBooleanToLiteral<ul>
<li>隐式类中存在相应的隐式转换方法，同名方法、U方法、S方法，分别把字面量转为：同款隐式类、UInt、SInt</li>
<li>如果要表示一个UInt对象可以写成：<code>1.U</code></li>
</ul>
</li>
<li><strong>四种Scala字面量：</strong>BigInt、Int、Long和String，对应的表示方法：<ul>
<li>BigInt、Int、Long：加前缀0x或0X改变进制</li>
<li>String：首字母“h”、“o”、“b”来分别表示十六进制、八进制和二进制，并可以用下划线间隔</li>
</ul>
</li>
<li>完整形式举例<ul>
<li>表示一个UInt对象可以写成<code>1.U</code>的格式，这样编译器会插入隐式转换，变成<code>fromtIntToLiteral(1).U</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Scala的Boolean字面量转变方法：</strong><ul>
<li>可以通过Boolean类型的字面量true、false，来构造fromBooleanToLiteral类型的对象</li>
<li>然后<strong>调用名为B</strong>或<strong>asBool的方法</strong>进一步构造Bool类型的对象</li>
</ul>
</li>
</ul>
<p><strong>一些表示数的例子：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-number">1.</span><span class="hljs-type">U</span>                <span class="hljs-comment">// Int字面值为&quot;1&quot;的UInt对象</span><br><span class="hljs-number">0x1</span>.<span class="hljs-type">U</span>			<span class="hljs-comment">//Int字面值为16进制1的UInt对象</span><br><span class="hljs-number">-8.</span><span class="hljs-type">S</span>               <span class="hljs-comment">// Int字面值为&quot;-8&quot;的SInt对象</span><br><br><span class="hljs-string">&quot;b0101&quot;</span>.<span class="hljs-type">U</span>		<span class="hljs-comment">// String字面值为&quot;5&quot;的UInt对象</span><br><br><span class="hljs-literal">true</span>.<span class="hljs-type">B</span>            <span class="hljs-comment">// Boolean字面值为&quot;true&quot;的Bool对象 </span><br></code></pre></div></td></tr></table></figure>
<p><strong>（4）构造没有字面量的对象</strong></p>
<p>​        UInt、SInt和Bool都不是抽象类，除了可以<strong>通过字面量构造对象</strong>以外，也可以<strong>直接通过apply工厂方法构造没有字面量的对象</strong></p>
<p>​        <strong>有字面量的数据类型</strong>用于赋值、初始化寄存器等操作，而<strong>无字面量的数据类型</strong>则用于声明端口、构造向量等</p>
<h2 id="2-3-数据宽度"><a href="#2-3-数据宽度" class="headerlink" title="2.3 数据宽度"></a>2.3 数据宽度</h2><p><strong>（1）数据的默认宽度：</strong></p>
<p>​        默认情况下，<strong>数据的宽度按字面值取最小</strong>，例如字面值为“8”的UInt对象是4位宽，SInt就是5位宽。但是也可以指定宽度。注意，<strong>Bool类型固定是1位宽</strong>、</p>
<p><strong>（2）宽度类Width、宽度隐式类fromIntToWidth</strong></p>
<p>​        Chisel2里，宽度是由Int类型的参数表示的</p>
<p>​        <strong>Chisel3专门设计了宽度类Width</strong>，还有一个<strong>隐式类fromIntToWidth</strong>（把Int对象转换成fromIntToWidth类型的对象），然后<strong>通过方法W返回一个Width对象</strong>。</p>
<p><strong>（3）如何指定数据宽度：</strong></p>
<p>​        <strong>方法U、asUInt、S和asSInt</strong>都有一个重载的版本，接收一个Width类型的参数，构造指定宽度的SInt和UInt对象</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-number">1.</span><span class="hljs-type">U</span>              <span class="hljs-comment">// 字面值为“1”、宽度为1bit的UInt对象</span><br><br><span class="hljs-number">1.</span><span class="hljs-type">U</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)   <span class="hljs-comment">// 字面值为“1”、宽度为32bit的UInt对象</span><br></code></pre></div></td></tr></table></figure>
<p>​        也可以直接给定：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;ha&quot;</span>, <span class="hljs-number">8</span>) 		<span class="hljs-comment">// hexadecimal 8-bit lit of type UInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;o12&quot;</span>, <span class="hljs-number">6</span>) 		<span class="hljs-comment">// octal 6-bit lit of type UInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;b1010&quot;</span>, <span class="hljs-number">12</span>) 	<span class="hljs-comment">// binary 12-bit lit of type UInt</span><br><span class="hljs-type">SInt</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>) 			<span class="hljs-comment">// signed decimal 7-bit lit of type SInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>) 			<span class="hljs-comment">// unsigned decimal 8-bit lit of type UInt</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（4）UInt、SInt、Bool类中的重载</strong></p>
<p>​        UInt、SInt和Bool都不是抽象类，除了可以<strong>通过字面量构造对象</strong>以外，也可以<strong>直接通过apply工厂方法构造没有字面量的对象</strong></p>
<p>​        UInt和SInt的apply方法有两个版本：</p>
<ul>
<li>一个版本接收Width类型的参数构造指定宽度的对象</li>
<li>另一个则是无参版本构造位宽可自动推断的对象</li>
</ul>
<p>​        有字面量的数据类型用于赋值、初始化寄存器等操作，而无字面量的数据类型则用于声明端口、构造向量等。</p>
<h2 id="2-4-数据类型转换asXXX"><a href="#2-4-数据类型转换asXXX" class="headerlink" title="2.4 数据类型转换asXXX"></a>2.4 数据类型转换asXXX</h2><p>​        UInt、SInt和Bool三个类都包含四个方法：asUInt、asSInt、toBool和toBools：</p>
<ul>
<li>asUInt和asSInt分别把字面值按无符号数和有符号数解释，并且位宽不会变化，要注意转换过程中可能发生符号位和数值的变化。例如，3bit的UInt值“b111”，其字面量是“7”，转换成SInt后字面量就变成了“-1”</li>
<li>toBool会把1bit的“1”转换成Bool类型的true，“0”转换成false</li>
<li>toBools转换成Bool类型的序列Seq[Bool]，当位宽超过1bit</li>
<li>另外，Bool类还有一个方法asClock，把true转换成电压常高的时钟，false转换成电压常低的时钟。Clock类只有一个方法asUInt，转换成对应的0或1</li>
</ul>
<h2 id="2-5-向量Vec-T"><a href="#2-5-向量Vec-T" class="headerlink" title="2.5 向量Vec[T]"></a>2.5 向量Vec[T]</h2><p>​        如果需要一个集合类型的数据，除了可以使用Scala内建的数组、列表、集等数据结构外，还可以使用Chisel专属的Vec[T]。T必须是Data的子类，而且每个元素的类型、位宽必须一样。Vec[T]的伴生对象里有一个apply工厂方法，接收两个参数，第一个是Int类型，表示元素的个数，第二个是元素。它属于可索引的序列，下标从0开始</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myVec = <span class="hljs-type">Wire</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">3</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)))<br><span class="hljs-keyword">val</span> myReg = myVec(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>
<p>​        还有一个工厂方法VecInit[T]，通过接收一个Seq[T]作为参数来构造向量，或者是多个重复参数。不过，这个工厂方法常把有字面值的数据作为参数，用于初始化寄存器组、ROM、RAM等，或者用来构造多个模块。</p>
<p>​        因为Vec[T]也是一种序列，所以它也定义了诸如map、flatMap、zip、foreach、filter、exists、contains等方法。尽管这些方法应该出现在软件里，但是它们也可以简化硬件逻辑的编写，减少手工代码量。</p>
<h2 id="2-6-混合向量MixedVec-T"><a href="#2-6-混合向量MixedVec-T" class="headerlink" title="2.6 混合向量MixedVec[T]"></a>2.6 混合向量MixedVec[T]</h2><p>​        混合向量MixedVec[T]与普通的向量Vec[T]类似，只不过包含的元素可以不全都一样。它的工厂方法是通过重复参数或者序列作为参数来构造的，并且也有一个叫MixedVecInit[T]的单例对象。</p>
<p>​        对于构造Vec[T]和MixedVec[T]的序列，并<strong>不一定要逐个手写，可以通过Scala的函数，比如fill、map、flatMap、to、until等来生成。</strong>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> mixVec = <span class="hljs-type">Wire</span>(<span class="hljs-type">MixedVec</span>((<span class="hljs-number">1</span> to <span class="hljs-number">10</span>) map &#123; i =&gt; <span class="hljs-type">UInt</span>(i.<span class="hljs-type">W</span>) &#125;))<br></code></pre></div></td></tr></table></figure>
<h2 id="2-7-包裹Bundle"><a href="#2-7-包裹Bundle" class="headerlink" title="2.7 包裹Bundle"></a>2.7 包裹Bundle</h2><p>​        <strong>抽象类Bundle很像C语言的结构体(struct)</strong>，用户可以编写一个自定义类来继承自它，然后在自定义的类里包含其它各种Data类型的字段。它可以协助构建线网或寄存器，但是<strong>最常见的用途是用于构建一个模块的端口列表，或者一部分端口</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//直接使用Bundle的方法示例</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>   &#125;)<br>  <br> <span class="hljs-comment">//使用extends Bundle的方法示例</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（2）Bundle和UInt转换</strong></p>
<p>​        <strong>Bundle-&gt;UInt：</strong>Bundle可以和UInt进行相互转换。Bundle类有一个方法asUInt，可以把所含的字段拼接成一个UInt数据，并且前面的字段在高位</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br><br><span class="hljs-keyword">val</span> bundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>bundle.foo := <span class="hljs-number">0xc</span>.<span class="hljs-type">U</span><br>bundle.bar := <span class="hljs-number">0x3</span>.<span class="hljs-type">U</span><br><span class="hljs-keyword">val</span> uint = bundle.asUInt  <span class="hljs-comment">// 12*16 + 3 = 195</span><br></code></pre></div></td></tr></table></figure>
<p>​        <strong>Data-&gt;Bundle：</strong>有一个隐式类fromBitsable，可以把Data类型的对象转化成该类型，然后通过方法fromBits来接收一个Bits类型的参数来给该对象赋值。不过，该方法在Chisel3中已经被标注为过时，不推荐使用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br><br><span class="hljs-keyword">val</span> uint = <span class="hljs-number">0xb4</span>.<span class="hljs-type">U</span><br><span class="hljs-keyword">val</span> bundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>).fromBits(uint)  <span class="hljs-comment">// foo = 11, bar = 4</span><br></code></pre></div></td></tr></table></figure>
<h2 id="2-8-Chisel的内建操作符"><a href="#2-8-Chisel的内建操作符" class="headerlink" title="2.8 Chisel的内建操作符"></a>2.8 Chisel的内建操作符</h2><p>​        有了数据类型，还需要预定义一些相关的操作符进行基本的操作。下表是Chisel内建的操作符：</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:557px;"><caption>
  Chisel的内建操作符
 </caption><thead><tr><th style="text-align:center;vertical-align:middle;width:268px;">操作符</th><th style="text-align:center;vertical-align:middle;width:286px;">释义</th></tr></thead><tbody><tr><th style="text-align:center;vertical-align:middle;width:268px;">位操作符</th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val invertedX = ~x</td><td style="text-align:center;vertical-align:middle;width:286px;">位取反</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hiBits = x &amp; "h_ffff_0000".U</td><td style="text-align:center;vertical-align:middle;width:286px;">位与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val flagsOut = flagsIn | overflow</td><td style="text-align:center;vertical-align:middle;width:286px;">位或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val flagsOut = flagsIn ^ toggle</td><td style="text-align:center;vertical-align:middle;width:286px;">位异或</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>缩减位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt&nbsp; 返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val allSet = x.andR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val anySet = x.orR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val parity = x.xorR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减异或</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>相等性比较符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool </strong>&nbsp;<strong>返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val equ = x === y</td><td style="text-align:center;vertical-align:middle;width:286px;">相等</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val neq = x =/= y</td><td style="text-align:center;vertical-align:middle;width:286px;">不相等</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>移位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val twoToTheX = 1.S &lt;&lt; x</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑左移</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hiBits = 16.U &gt;&gt; x</td><td style="text-align:center;vertical-align:middle;width:286px;">右移(UInt逻辑右移，SInt算术右移)</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>部分位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val xLSB = x(0)</td><td style="text-align:center;vertical-align:middle;width:286px;">抽取1bit，最低位下标0，最高位下标n-1</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val xTopNibble = x(15, 12)</td><td style="text-align:center;vertical-align:middle;width:286px;">抽取多个bit，左边是高位，右边是低位</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val usDebt = Fill(3, "hA".U)</td><td style="text-align:center;vertical-align:middle;width:286px;">拼接一个UInt类型的数据多次(位于util包)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val float = Cat(sign, exponent, mantissa)</td><td style="text-align:center;vertical-align:middle;width:286px;">拼接多个bit，左边的参数是高位(位于util包)</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>逻辑操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sleep = !busy</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑非</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hit = tagMatch &amp;&amp; valid</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val stall = src1busy || src2busy</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val out = Mux(sel, inTrue, inFalse)</td><td style="text-align:center;vertical-align:middle;width:286px;">双输入多路选择器，sel是Bool类型</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>算术操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sum = a + b&nbsp;&nbsp;<em>or</em>&nbsp; val sum = a +% b</td><td style="text-align:center;vertical-align:middle;width:286px;">加法(不进行宽度扩展)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sum = a +&amp; b</td><td style="text-align:center;vertical-align:middle;width:286px;">加法(扩展一位进位位)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val diff = a - b&nbsp;&nbsp;<em>or</em>&nbsp; val diff = a -% b</td><td style="text-align:center;vertical-align:middle;width:286px;">减法(不进行宽度扩展)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val diff = a -&amp; b</td><td style="text-align:center;vertical-align:middle;width:286px;">减法(扩展一位进位位)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val prod = a * b</td><td style="text-align:center;vertical-align:middle;width:286px;">乘法</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val div = a / b</td><td style="text-align:center;vertical-align:middle;width:286px;">除法</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val mod = a % b</td><td style="text-align:center;vertical-align:middle;width:286px;">求余数</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>算术比较符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt </strong>&nbsp;<strong>返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val gt = a &gt; b</td><td style="text-align:center;vertical-align:middle;width:286px;">大于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val gte = a &gt;= b</td><td style="text-align:center;vertical-align:middle;width:286px;">大于等于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val lt = a &lt; b</td><td style="text-align:center;vertical-align:middle;width:286px;">小于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val lte = a &lt;= b</td><td style="text-align:center;vertical-align:middle;width:286px;">小于等于</td></tr></tbody></table>

<p>​        这里要注意的一点是相等性比较的两个符号是<mark>“===”和“=/=”</mark>，因为“==”和“!=”已经被Scala占用，所以Chisel另设了这两个新的操作符。按照优先级的判断准则，<strong>“===”和“=/=”的优先级</strong>以首个字符为“=”来判断，也就是在逻辑操作中，相等性比较的优先级要比与、或、异或都高。</p>
<h2 id="2-9-位宽推断"><a href="#2-9-位宽推断" class="headerlink" title="2.9 位宽推断"></a>2.9 位宽推断</h2><p>​        用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：</p>
<p><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
  Chisel的位宽推断
 </caption><thead><tr><th style="text-align:center;vertical-align:middle;"><strong>操作符</strong></th><th style="text-align:center;vertical-align:middle;">位宽</th></tr></thead><tbody><tr><td style="text-align:center;vertical-align:middle;">z = x + y&nbsp;&nbsp;<em>or</em>&nbsp; z = x +% y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x +&amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y)) + 1</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x - y&nbsp;<em>or</em>&nbsp;z = x -% y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x -&amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y)) + 1</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = min(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Mux(c, x, y)</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = w * y</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + w(y)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &lt;&lt; n</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + maxNum(n)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &gt;&gt; n</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) - minNum(n)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Cat(x, y)</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + w(y)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Fill(n, x)</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) * maxNum(n)</td></tr></tbody></table><br>​        其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算</p>
<p><strong>位宽推测过程：</strong></p>
<p>​        位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。</p>
<p><strong>有关自动截断的问题：</strong></p>
<p>​        当把一个短位宽的信号值或硬件结构赋值给长位宽的硬件结构时，会自动扩展符号位。但是反过来会报错，并不是像Verilog那样把多余的高位截断，这需要注意(注：最新的chisel3版本已经可以像Verilog一样自动把高位截断了)</p>
<h1 id="3-模块与硬件配置"><a href="#3-模块与硬件配置" class="headerlink" title="3 模块与硬件配置"></a>3 模块与硬件配置</h1><p>Chisel在构建硬件的思路上类似Verilog。在Verilog中，是以“模块(module)”为基本单位组成一个完整的独立功能实体，所以Chisel也是按模块划分的，只不过不是用关键字“module”开头来定义模块，而是用一个继承自Module类的自定义class。</p>
<p>在Verilog里，模块内部主要有“线网(wire)”和“四态变量(reg)”两种硬件类型，它们用于描述数字电路的组合逻辑和时序逻辑。在Chisel里，也按这个思路定义了一些硬件类型，包括基本的线网和寄存器，以及一些常用的其它类型。前一章介绍了Chisel的数据类型，这还不够，因为这些数据类型是无法独立工作的。实际的电路应该是由硬件类型的对象构成的，不管是信号的声明，还是用赋值进行信号传递，都是由硬件类型的对象来完成的。数据类型和硬件类型融合在一起，才能构成完整、可运行的组件。比如要声明一个线网，这部分工作由硬件类型来完成；这个线网的位宽是多少、按无符号数还是有符号数解释、是不是向量等等，这些则是由作为参数的数据类型对象来定义的。</p>
<p>本章将介绍Chisel里的常用硬件类型以及如何编写一个基本的模块，对于高级类型，读者可以自行研究。这些类型的语法很简单，都是由定义在单例对象里的apply工厂方法来完成。字面的名字已经把硬件含义表明得很清楚，至于它们的具体实现是什么，读者可以不用关心。</p>
<p>一、Chisel是如何赋值的<br>有了硬件类型后，就可以用赋值操作来进行信号的传递或者电路的连接。只有硬件赋值才有意义，单纯的数据对象进行赋值并不会被编译器转换成实际的电路，因为在Verilog里也是对wire、reg类型的硬件进行赋值。那么，赋值操作需要什么样的操作符来完成呢？</p>
<p>在Chisel里，所有对象都应该由val类型的变量来引用，因为硬件电路的不可变性。因此，一个变量一旦初始化时绑定了一个对象，就不能再发生更改。但是，引用的对象很可能需要被重新赋值。例如，输出端口在定义时使用了“=”与端口变量名进行了绑定，那等到驱动该端口时，就需要通过变量名来进行赋值操作，更新数据。很显然，此时“=”已经不可用了，因为变量在声明的时候不是var类型。即使是var类型，这也只是让变量引用新的对象，而不是直接更新原来的可变对象。</p>
<p>为了解决这个问题，几乎所有的Chisel类都定义了方法“:=”，作为等号赋值的代替。所以首次创建变量时用等号初始化，如果变量引用的对象不能立即确定状态或本身就是可变对象，则在后续更新状态时应该用“:=”。从前面讲的操作符优先级来判断，该操作符以等号结尾，而且不是四种逻辑比较符号之一，所以优先级与等号一致，是最低的。例如：</p>
<p>val x = Wire(UInt(4.W))</p>
<p>val y = Wire(UInt(4.W))</p>
<p>x := “b1010”.U  // 向4bit的线网x赋予了无符号数10</p>
<p>y := ~x  // 把x按位取反，传递给y</p>
<p>二、端口<br>   Ⅰ、定义端口列表<br>定义一个模块前一定要先定义好端口。整个端口列表是由方法“IO<a href="iodef: T">T &lt;: Data</a>”来定义的，通常其参数是一个Bundle类型的对象，而且引用的字段名称必须是“io”。因为端口存在方向，所以还需要方法“Input<a href="source: T">T &lt;: Data</a>”和“Output<a href="source: T">T &lt;: Data</a>”来为每个端口表明具体的方向。注意，“Input<a href="source: T">T &lt;: Data</a>”和“Output<a href="source: T">T &lt;: Data</a>”仅仅是复制它们的参数，所以不能是已经被硬件类型包裹的数据类型。目前Chisel还不支持双向端口inout，只能通过黑盒里的Analog端口来模拟外部Verilog的双向端口。</p>
<p>一旦端口列表定义完成，就可以通过“io.xxx”来使用。输入可以驱动内部其它信号，输出可以被其他信号驱动。可以直接进行赋值操作，布尔类型的端口还能直接作为使能信号。端口不需要再使用其它硬件类型来定义，不过要注意从性质上来说它仍然属于组合逻辑的线网。例如：</p>
<p>class MyIO extends Bundle {<br>   val in = Input(Vec(5, UInt(32.W)))<br>   val out = Output(UInt(32.W))<br>}</p>
<p>……<br>   val io = IO(new MyIO)  // 模块的端口列表<br>……</p>
<p>   Ⅱ、翻转端口列表的方向<br>对于两个相连的模块，可能存在大量同名但方向相反的端口。仅仅为了翻转方向而不得不重写一遍端口显得费时费力，所以Chisel提供了“Flipped<a href="source: T">T &lt;: Data</a>”方法，可以把参数里所有的输入转输出，输出转输入。如果是黑盒里的Analog端口，则仍是双向的。例如：</p>
<p> class MyIO extends Bundle {<br>   val in = Input(Vec(5, UInt(32.W)))<br>   val out = Output(UInt(32.W))<br>}</p>
<p>……<br>   val io = IO(new MyIO)  // in是输入，out是输出<br>……<br>   val io = IO(Flipped(new MyIO))  // out是输入，in是输出</p>
<p>   Ⅲ、整体连接<br>翻转方向的端口列表通常配合整体连接符号“&lt;&gt;”使用。该操作符会把左右两边的端口列表里所有同名的端口进行连接，而且同一级的端口方向必须是输入连输出、输出连输入，父级和子级的端口方向则是输入连输入、输出连输出。注意，方向必须按这个规则匹配，而且不能存在端口名字、数量、类型不同的情况。这样就省去了大量连线的代码。例如：</p>
<p>class MyIO extends Bundle {<br>   val in = Input(Vec(5, UInt(32.W)))<br>   val out = Output(UInt(32.W))<br>}</p>
<p>……<br>   val io = IO(new Bundle {<br>       val x = new MyIO<br>       val y = Flipped(new MyIO)<br>   })</p>
<p>   io.x &lt;&gt; io.y  // 相当于 io.y.in := io.x.in; io.x.out := io.y.out<br>……</p>
<p>三、模块<br>   Ⅰ、定义模块<br>在Chisel里面是用一个自定义的类来定义模块的，这个类有以下三个特点：①继承自Module类。②有一个抽象字段“io”需要实现，该字段必须引用前面所说的端口对象。③在类的主构造器里进行内部电路连线。因为非字段、非方法的内容都属于主构造方法，所以用操作符“:=”进行的赋值、用“&lt;&gt;”进行的连线或一些控制结构等等，都属于主构造方法。从Scala的层面来讲，这些代码在实例化时表示如何构造一个对象；从Chisel的层面来讲，它们就是在声明如何进行模块内部子电路的连接、信号的传递，类似于Verilog的assign和always语句。实际上这些用赋值表示的电路连接在转换成Verilog时，组合逻辑就是大量的assign语句，时序逻辑就是always语句。</p>
<p>还有一点需要注意，这样定义的模块会继承一个字段“clock”，类型是Clock，它表示全局时钟，在整个模块内都可见。对于组合逻辑，是用不上它的，而时序逻辑虽然需要这个时钟，但也不用显式声明。还有一个继承的字段“reset”，类型是Reset，表示全局复位信号，在整个模块内可见。对于需要复位的时序元件，也可以不用显式使用该字段。如果确实需要用到全局时钟和复位，则可以通过它们的字段名称来使用，但要注意类型是否匹配，经常需要“reset.toBool”这样的语句把Reset类型转换成Bool类型用于控制。隐式的全局时钟和复位端口只有在生成Verilog代码时才能看到。</p>
<p>要编写一个双输入多路选择器，其代码如下所示：</p>
<p>// mux2.scala<br>package test</p>
<p>import chisel3._</p>
<p>class Mux2 extends Module {<br>  val io = IO(new Bundle{<br>    val sel = Input(UInt(1.W))<br>    val in0 = Input(UInt(1.W))<br>    val in1 = Input(UInt(1.W))<br>    val out = Output(UInt(1.W))<br>  })</p>
<p>  io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)<br>}<br>在这里，“new Bundle { … }”的写法是声明一个匿名类继承自Bundle，然后实例化匿名类。对于短小、简单的端口列表，可以使用这种简便写法。对于大的公用接口，应该单独写成具名的Bundle子类，方便修改。“io.out := …”其实就是主构造方法的一部分，通过内建操作符和三个输入端口，实现了输出端口的逻辑行为。</p>
<p>   Ⅱ、例化模块<br>要例化一个模块，并不是直接用new生成一个实例对象就完成了，还需要再把实例的对象传递给单例对象Module的apply方法。这种别扭的语法是Scala的语法限制造成的，就像端口需要写成“IO(new Bundle {…})”，无符号数要写成“UInt(n.W)”等等一样。例如，下面的代码通过例化刚才的双输入多路选择器构建四输入多路选择器：</p>
<p>// mux4.scala<br>package test</p>
<p>import chisel3._<br>class Mux4 extends Module {<br>  val io = IO(new Bundle {<br>    val in0 = Input(UInt(1.W))<br>    val in1 = Input(UInt(1.W))<br>    val in2 = Input(UInt(1.W))<br>    val in3 = Input(UInt(1.W))<br>    val sel = Input(UInt(2.W))<br>    val out = Output(UInt(1.W))<br>  })<br>  val m0 = Module(new Mux2)<br>  m0.io.sel := io.sel(0)<br>  m0.io.in0 := io.in0<br>  m0.io.in1 := io.in1<br>  val m1 = Module(new Mux2)<br>  m1.io.sel := io.sel(0)<br>  m1.io.in0 := io.in2<br>  m1.io.in1 := io.in3<br>  val m2 = Module(new Mux2)<br>  m2.io.sel := io.sel(1)<br>  m2.io.in0 := m0.io.out<br>  m2.io.in1 := m1.io.out<br>  io.out := m2.io.out<br>}<br>   Ⅲ、例化多个模块<br>像上个例子中，模块Mux2例化了三次，实际只需要一次性例化三个模块就可以了。对于要多次例化的重复模块，可以利用向量的工厂方法VecInit[T &lt;: Data]。因为该方法接收的参数类型是Data的子类，而模块的字段io正好是Bundle类型，并且实际的电路连线仅仅只需针对模块的端口，所以可以把待例化模块的io字段组成一个序列，或者按重复参数的方式作为参数传递。通常使用序列作为参数，这样更节省代码。生成序列的一种方法是调用单例对象Seq里的方法fill，该方法的一个重载版本有两个单参数列表，第一个接收Int类型的对象，表示序列的元素个数，第二个是传名参数，接收序列的元素。</p>
<p>因为Vec是一种可索引的序列，所以这种方式例化的多个模块类似于“模块数组”，用下标索引第n个模块。另外，因为Vec的元素已经是模块的端口字段io，所以要引用例化模块的某个具体端口时，路径里不用再出现“io”。例如：</p>
<p>// mux4_2.scala<br>package test</p>
<p>import chisel3._<br>class Mux4_2 extends Module {<br>  val io = IO(new Bundle {<br>    val in0 = Input(UInt(1.W))<br>    val in1 = Input(UInt(1.W))<br>    val in2 = Input(UInt(1.W))<br>    val in3 = Input(UInt(1.W))<br>    val sel = Input(UInt(2.W))<br>    val out = Output(UInt(1.W))<br>  })<br>  val m = VecInit(Seq.fill(3)(Module(new Mux2).io))  // 例化了三个Mux2，并且参数是端口字段io<br>  m(0).sel := io.sel(0)  // 模块的端口通过下标索引，并且路径里没有“io”<br>  m(0).in0 := io.in0<br>  m(0).in1 := io.in1<br>  m(1).sel := io.sel(0)<br>  m(1).in0 := io.in2<br>  m(1).in1 := io.in3<br>  m(2).sel := io.sel(1)<br>  m(2).in0 := m(0).out<br>  m(2).in1 := m(1).out<br>  io.out := m(2).out<br>}<br>四、线网<br>Chisel把线网作为电路的节点，通过工厂方法“Wire<a href="t: T">T &lt;: Data</a>”来定义。可以对线网进行赋值，也可以连接到其他电路节点，这是组成组合逻辑的基本硬件类型。例如：</p>
<p>val myNode = Wire(UInt(8.W))</p>
<p>myNode := 0.U </p>
<p>因为Scala作为软件语言是顺序执行的，定义具有覆盖性，所以如果对同一个线网多次赋值，则只有最后一次有效。例如下面的代码与上面的例子是等效的： </p>
<p>val myNode = Wire(UInt(8.W))</p>
<p>myNode := 10.U</p>
<p>myNode := 0.U</p>
<p>五、寄存器<br>寄存器是时序逻辑的基本硬件类型，它们都是由当前时钟域的时钟上升沿触发的。如果模块里没有多时钟域的语句块，那么寄存器都是由隐式的全局时钟来控制。对于有复位信号的寄存器，如果不在多时钟域语句块里，则由隐式的全局复位来控制，并且高有效。目前Chisel所有的复位都是同步复位，异步复位功能还在开发中。如果需要异步复位寄存器，则需要通过黑盒引入。</p>
<p>有五种内建的寄存器，第一种是跟随寄存器“RegNext<a href="next: T">T &lt;: Data</a>”，在每个时钟上升沿，它都会采样一次传入的参数，并且没有复位信号。它的另一个版本的apply工厂方法是“RegNext<a href="next: T, init: T">T &lt;: Data</a>”，也就是由复位信号控制，当复位信号有效时，复位到指定值，否则就跟随。</p>
<p>第二种是复位到指定值的寄存器“RegInit<a href="init: T">T &lt;: Data</a>”，参数需要声明位宽，否则就是默认位宽。可以用内建的when语句进行条件赋值。</p>
<p>第三种是普通的寄存器“Reg<a href="t: T">T &lt;: Data</a>”，它可以在when语句里用全局reset信号进行同步复位(reset信号是Reset类型，要用toBool进行类型转换)，也可以进行条件赋值或无条件跟随。参数同样要指定位宽。</p>
<p>第四种是util包里的带一个使能端的寄存器“RegEnable<a href="next: T, init: T, enable: Bool">T &lt;: Data</a>”，如果不需要复位信号，则第二个参数可以省略给出。</p>
<p>第五种是util包里的移位寄存器“ShiftRegister<a href="in: T, n: Int, resetData: T, en: Bool">T &lt;: Data</a>”，其中第一个参数in是带移位的数据，第二个参数n是需要延迟的周期数，第三个参数resetData是指定的复位值，可以省略，第四个参数en是使能移位的信号，默认为true.B。</p>
<p>假如有如下代码：</p>
<hr>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p2.jpg" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p3.jpg" srcset="/img/loading.gif" lazyload alt="96733090_p3"></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg" srcset="/img/loading.gif" lazyload alt="96733090_p4"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/categories/IC/Chiesl/">Chiesl</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202203092029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%A7%A3%E5%86%B3Ubuntu%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E5%AF%BC%E8%87%B4%E7%99%BB%E5%BD%95%E5%BE%AA%E7%8E%AF%E8%BF%9B%E4%B8%8D%E5%8E%BB%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">解决Ubuntu修改环境变量后导致登录循环进不去系统的问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/">
                        <span class="hidden-mobile">Scala（二）：进阶篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"left","width":250,"height":500,"vOffset":-100},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
