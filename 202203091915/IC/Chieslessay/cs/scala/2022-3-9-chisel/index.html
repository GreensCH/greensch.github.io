

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="推荐阅读官方文档：https:&#x2F;&#x2F;www.chisel-lang.org&#x2F;chisel3&#x2F;docs&#x2F;introduction.html 官方速记手册： 官方github：https:&#x2F;&#x2F;github.com&#x2F;chipsalliance&#x2F;chisel3 0 Chisel的常见问题（必读）（1）Firrtl中间格式：Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转">
<meta property="og:type" content="article">
<meta property="og:title" content="Chisel（一）：初步">
<meta property="og:url" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="推荐阅读官方文档：https:&#x2F;&#x2F;www.chisel-lang.org&#x2F;chisel3&#x2F;docs&#x2F;introduction.html 官方速记手册： 官方github：https:&#x2F;&#x2F;github.com&#x2F;chipsalliance&#x2F;chisel3 0 Chisel的常见问题（必读）（1）Firrtl中间格式：Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/2022-3-9-chisel/image-20220313172534854.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190220235621546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://yoursite.com/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/2022-3-9-chisel/image-20220313224501135.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p2.jpg">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p3.jpg">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg">
<meta property="article:published_time" content="2022-03-09T11:15:00.000Z">
<meta property="article:modified_time" content="2022-03-13T15:45:40.139Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="IC">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
  
  <title>Chisel（一）：初步 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start -->
<link defer rel="stylesheet" href="/css/article_para.css" />
<div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Chisel（一）：初步">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-09 19:15" pubdate>
        2022年3月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      94k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      295 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Chisel（一）：初步</h1>
            
            <div class="markdown-body">
              <p>推荐阅读官方文档：<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/chisel3/docs/introduction.html">https://www.chisel-lang.org/chisel3/docs/introduction.html</a></p>
<p>官方速记手册：</p>
<p>官方github：<a target="_blank" rel="noopener" href="https://github.com/chipsalliance/chisel3">https://github.com/chipsalliance/chisel3</a></p>
<h1 id="0-Chisel的常见问题（必读）"><a href="#0-Chisel的常见问题（必读）" class="headerlink" title="0 Chisel的常见问题（必读）"></a>0 Chisel的常见问题（必读）</h1><p>（1）<strong>Firrtl中间格式：</strong>Chisel是寄宿在Scala里的语言，所以它本质还是Scala。为了从Chisel转变成Verilog，语言开发人员开发了一个中间的标准交换格式——Firrtl，它跟Vrilog是同一级别的，两者都比Chisel低一级。编写的Chisel代码首先会经过Firrtl编译器，生成Firrtl代码，也就是一个后缀格式为“.fir”的文件，然后由这个Firrtl文件再去生成对应的Verilog代码。如果读者有兴趣看一看Firrtl的格式，其实与Verilog很接近，只不过是由机器生成的、很死板的代码。Firrtl编译器也并不是只针对Chisel，有兴趣和能力的读者也可以开发针对Java、Python、C++等语言的Firrtl编译器。因为Firrtl只是一种标准的中间媒介，如何从一端到另一端，完全是自定义的。另外，Firrtl也并不仅仅是生成Verilog，同样可以开发工具生成VHDL、SystemVerilog等语言</p>
<p>（2）<u>Chisel与Firrtl双检查：</u>Scala里的语法，在Chisel里也基本能用，比如Scala的基本值类、内建控制结构、函数抽象、柯里化、模式匹配、隐式参数等等。但是读者要记住这些代码不仅要通过Scala编译器的检查，还需要通过Firrtl编译器的检查</p>
<p>（3）<strong>Chisel完全可综合：</strong>Verilog的最初目的是用于电路验证，所以它有很多不可综合的语法。Firrtl在转变成Verilog时，只会采用可综合的语法，因此读者完全不用担心用Chisel写出来的电路不可综合。只要能正确生成Verilog，那就能被综合器生成电路</p>
<p>（4）<strong>Chisel只支持二值逻辑：</strong>Chisel目前<strong>只支持0和1</strong>，<strong>不支持四态逻辑里的x和z</strong>。由于只有芯片对外的IO处才能出现三态门，所以内部设计几乎用不到x和z。而且x和z在设计中会带来危害，忽略掉它们也不影响大多数设计，还简化了模型。当然，<u>如果确实需要，可以通过黑盒语法与外部的Verilog代码互动，也可以在下游工具链里添加四态逻辑</u></p>
<p>（5）<strong>Chisel检查未驱动：</strong>Chisel会对未被驱动的输出型端口和线网进行检测，如果存在，会进行报错。报错选项可以关闭和打开，取决于读者对设计模型的需求。推荐把该选项打开，尽量不要残留无用的声明。</p>
<p>（6）<mark><strong>Chisel需手动导环境包：</strong></mark>Chisel的代码包并不会像Scala的标准库那样被编译器隐式导入，所以每个Chisel文件都应该在开头都需要导包</p>
<ul>
<li>import chisel3._：必选，包含了基本语法</li>
<li>import chisel3.util._：高级语法必选</li>
<li>import chisel3.experimental._：高级语法必选</li>
<li>import chisel3.testers._：高级语法必选</li>
</ul>
<p>（7）<strong>不同层次打包封装：</strong>应该用一个名字有意义的包来打包实现某个功能的文件集。例如，要实现一个自定义的微处理器，则可以把顶层包命名为“mycpu”，进而再划分成“myio”、“mymem”、“mybus”、“myalu”等子包，每个子包里包含相关的源文件。</p>
<p>Chisel现在仍在更新中，很可能会添加新功能或删去老功能。因此，本教程介绍的内容在将来并不一定就正确，读者应该持续关注Chisel3的GitHub的发展动向</p>
<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><p>以下环境搭建基于Ubuntu16.04</p>
<h2 id="1-1-Java安装"><a href="#1-1-Java安装" class="headerlink" title="1.1 Java安装"></a>1.1 Java安装</h2><p>根据下面这个博客来的，但在修改环境变量处出现了问题，导致无法进入系统（详情参考本博客《解决Ubuntu修改环境变量后导致登录循环进不去系统的问题》）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41204464/article/details/90314834">https://blog.csdn.net/qq_41204464/article/details/90314834</a></p>
<p><strong>下载安装包</strong></p>
<p>​    记得下载Linux64位的<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html">官网地址</a></p>
<p><strong>解压并移动</strong></p>
<p>​    解压并移动到<code>/usr/lib/jdk</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tar -zxvf ./jdk-8u311-linux-x64.tar.gz<br>mkdir /usr/lib/jdk<br>mv ./jdk1.8.0_311 /usr/lib/jdk/<br></code></pre></div></td></tr></table></figure>
<p><strong>修改环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo gedit /etc/profile<br></code></pre></div></td></tr></table></figure>
<p>​    在文件的<strong>最后</strong>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs make"># JDK,TOMCAT,ORACLE<br>export JAVA_HOME=/home/pu/jdk1.8.0_211<br>export JRE_HOME=$JAVA_HOME/jre<br><br># two sentence belong may crash your env<br># export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib <br># export PATH=$PATH:$JAVA_HOME/bin<br></code></pre></div></td></tr></table></figure>
<p><strong>测试环境变量是否出问题</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile <br></code></pre></div></td></tr></table></figure>
<p>​    如果运行后发现环境变量失效，则修改有问题</p>
<h2 id="1-2-Scala安装"><a href="#1-2-Scala安装" class="headerlink" title="1.2 Scala安装"></a>1.2 Scala安装</h2><p>随便从官网找一个安装包<a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/all.html，我这里用的rpm安装包，省的我再配置环境变量了">https://www.scala-lang.org/download/all.html，我这里用的rpm安装包，省的我再配置环境变量了</a></p>
<p><strong>安装rpm</strong>使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo rpm  -ivh ./scala-2.11.8.rpm<br></code></pre></div></td></tr></table></figure>
<p><strong>安装sbt</strong>(官网<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/download.html)：">https://www.scala-sbt.org/download.html)：</a></p>
<blockquote>
<p>Scala开发环境，官方名字叫“sbt”，最好选择最新的发布版本的安装，不然你还得蛋疼得安装一个叫<a target="_blank" rel="noopener" href="https://github.com/ucb-bar/firrtl">Firrtl</a> 的软件。这个需要先下载再安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://repo.scala-sbt.org/scalasbt/debian all main&quot;</span> | sudo tee /etc/apt/sources.list.d/sbt.list<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://repo.scala-sbt.org/scalasbt/debian /&quot;</span> | sudo tee /etc/apt/sources.list.d/sbt_old.list<br>curl -sL <span class="hljs-string">&quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot;</span> | sudo apt-key add<br>sudo apt-get update<br>sudo apt-get install sbt<br></code></pre></div></td></tr></table></figure>
<p><strong>sbt安装完检查：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sbt<br>sbt -version<br>sbt version <span class="hljs-keyword">in</span> this project: 1.6.2<br>sbt script version: 1.6.2<br></code></pre></div></td></tr></table></figure>
<h2 id="1-3-安装Verilator"><a href="#1-3-安装Verilator" class="headerlink" title="1.3 安装Verilator"></a>1.3 安装Verilator</h2><p><strong>执行命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install verilator <br><br>verilator -version<br>Verilator 3.904 2017-05-30 rev verilator_3_904 <br></code></pre></div></td></tr></table></figure>
<h2 id="1-4-Chisel安装"><a href="#1-4-Chisel安装" class="headerlink" title="1.4 Chisel安装"></a>1.4 Chisel安装</h2><p><strong>参考官方文档：</strong></p>
<ul>
<li>template：<a target="_blank" rel="noopener" href="https://github.com/freechipsproject/chisel-template">https://github.com/freechipsproject/chisel-template</a></li>
<li>doc：<a target="_blank" rel="noopener" href="https://github.com/chipsalliance/chisel3">https://github.com/chipsalliance/chisel3</a></li>
<li>homepage：<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/">https://www.chisel-lang.org/</a></li>
</ul>
<p><strong>参考指导博客：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34291505/article/details/87365907">https://blog.csdn.net/qq_34291505/article/details/87365907</a></li>
</ul>
<h3 id="方法一：直接git-clone-template"><a href="#方法一：直接git-clone-template" class="headerlink" title="方法一：直接git clone template"></a>方法一：直接git clone template</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/freechipsproject/chisel-template <br></code></pre></div></td></tr></table></figure>
<h2 id="1-10-第一个工程"><a href="#1-10-第一个工程" class="headerlink" title="1.10 第一个工程"></a>1.10 第一个工程</h2><ul>
<li>对于小规模电路，可以直接用Chisel写testbench文件，然后联合Verilator生成C++文件来仿真，输出波形图。该方法会在后续章节介绍。</li>
<li>对于大规模电路，Verilator仿真很吃力，建议还是用生成的Verilog文件在专业EDA工具里仿真。当前Chisel不支持UVM，也没有工具支持Chisel，所以尽量用别的工具做测试</li>
</ul>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h1><p>读者在学习本章后，<strong>应该理清Chisel数据类型的关系</strong>。</p>
<p><strong>常用的类型就五种</strong>，重点学会这五种即可：</p>
<ul>
<li>UInt</li>
<li>SInt</li>
<li>Bool</li>
<li>Bundle</li>
<li>Vec[T]</li>
</ul>
<p><strong>三种值类</strong>：UInt、SInt和Bool的操作符与Verilog差不多，很快就能理解。</p>
<h2 id="2-1-Chisel的数据类型"><a href="#2-1-Chisel的数据类型" class="headerlink" title="2.1 Chisel的数据类型"></a>2.1 Chisel的数据类型</h2><p>Chisel定义了自己的一套数据类型，读者应该跟Scala的九种基本值类区分开来。</p>
<p>Scala中数据类型在Chisel用于参数和内建控制结构</p>
<p>Chisel自己的数据类型用于构建硬件电路还是得用</p>
<p>Chisel定义的数据类型如下图所示，其中<strong>绿色方块是class</strong>，<strong>红色是object</strong>，<strong>蓝色是trait</strong>，<strong>箭头指向的是超类和混入的特质</strong>： </p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="Chisel的数据类型关系图"></p>
<ul>
<li><p><strong>Data类：所有数据类型都继承自抽象基类Data</strong>，它混入了两个特质HasId和NamedComponent。如果读者查看Chisel3的源代码，就会看到很多参数传递时都用下界表明了是Data的子类。<u>在实际硬件构成里，并不会用到Data</u>，读者也不用关心它的具体实现细节。更多的，应该关注Data类的两大子类：聚合类Aggregate和元素类Element。</p>
</li>
<li><p><strong>Aggregate聚合类：</strong>Aggregate聚合类常用子类是<strong>向量类Vec[T]和包裹类Bundle</strong></p>
<ul>
<li><strong>Vec[T]子类：</strong>用于<strong>包含相同的元素</strong>，元素类型T可以是任意的Data子类。因为Vec[T]混入了特质IndexedSeq[T]，所以向量的元素能从下标0开始索引访问</li>
<li><strong>Bundle子类</strong>：用于<strong>被自定义的类继承，这样自定义的类就能包含任意Data的子类对象</strong>，常用于<strong>协助构造模块的端口</strong>，故而衍生出了一些预定义的端口子类</li>
<li>MixedVec[T]子类：混合向量类是Chisel3.2以上版本添加的语法，它与Vec[T]的不同在于<strong>可以包含不同类型的元素</strong>。</li>
</ul>
</li>
<li><p><strong>Element类：</strong>衍生出了Analog、Bits和Clock三个子类，单例对象DontCare和特质Reset</p>
<ul>
<li><strong>Analog子类：</strong>用于<strong>在黑盒中模拟inout端口</strong>，目前在实际Chisel里并无其他用途</li>
<li><strong>Bits子类：</strong>的两个子类SInt和UInt是最常用的两个数据类型，它们是用补码表示的有符号整数和无符号整数。不仅用来协助定义端口位宽，还用来进行赋值</li>
<li>FixedPoint子类提供的API带有试验性质，而且将来可能会发生改变，所以不常用</li>
<li><strong>Bool子类：</strong>是Chisel自己的布尔类型，<strong>区别于Scala的Boolean</strong>。Bool类是UInt类的子类，因为它可以看成是1bit的UInt，而且它被混入Reset特质，因为复位信号都是用Bool类型的线网或寄存器使能的。此外，Bits类混入了特质ToBoolable，也就是说FixedPoint、SInt和UInt都能转换成多bit的Bool类型</li>
<li><strong>Clock类：</strong>表示时钟，Chisel里的时钟是专门的一个类型，并不像Verilog里那样是1bit的线网。复位类型Reset也是如此</li>
<li><strong>Reset特质</strong>：表示复位，Chisel里的特质是专门的一个特质，并不像Verilog里那样是1bit的线网</li>
<li><strong>DontCare单例对象：</strong>用于赋值给未驱动的端口或线网，防止编译器报错。</li>
</ul>
</li>
</ul>
<h2 id="2-2-能表示数据的字面量"><a href="#2-2-能表示数据的字面量" class="headerlink" title="2.2 能表示数据的字面量"></a>2.2 能表示数据的字面量</h2><p><strong>字面量（literal）</strong>：有直接意义的，能直接表示的固定值</p>
<p><strong>BigInt、Int、Long和String四种类型的Scala字面量来构造UInt和SInt，具体分类两类：</strong></p>
<ul>
<li>数值字面量</li>
<li>字符串字面量</li>
</ul>
<hr>
<p><strong>（1）Chisel具体数的数据类型：</strong>    </p>
<p>能够表示具体值的数据类型为<strong>UInt、SInt和Bool</strong>。实际可综合的电路都是若干个bit，所以只能表示整数，这与Verilog是一致的。</p>
<p><strong>要表示浮点数，本质还是用多个bit来构建</strong>，而且要遵循IEEE的浮点标准。</p>
<p><strong>（2）Chisel中的UInt、SInt、Bool：</strong></p>
<ul>
<li>对于UInt，可以构成任意位宽的线网或寄存器</li>
<li>对于SInt，在Chisel里会按补码解读，转换成Verilog后会使用系统函数$signed，这是可综合的</li>
<li>对于Bool，转换成Verilog后就是1bit的线网或寄存器</li>
</ul>
<p><strong>（3）如何用字面量表示数：</strong></p>
<blockquote>
<p>要表示值，则必须有相应的字面量。Chisel定义了一系列隐式类：fromBigIntToLiteral、fromtIntToLiteral、fromtLongToLiteral、fromStringToLiteral、fromBooleanToLiteral。回顾前面讲述的隐式类的内容，也就是会有相应的隐式转换。以隐式类fromtIntToLiteral为例，存在一个同名的隐式转换，把相应的Scala的Int对象转换成一个fromtIntToLiteral的对象。而fromtIntToLiteral类有两个方法U和S，分别构造一个等值的UInt对象和SInt对象。再加上Scala的基本值类都是用字面量构造对象，所以要表示一个UInt对象，可以写成“1.U”的格式，这样编译器会插入隐式转换，变成“fromtIntToLiteral(1).U”，进而构造出字面值为“1”的UInt对象。同理，<strong>也可以构造SInt。还有相同行为的方法asUInt和asSInt。</strong></p>
<p>​    从几个隐式类的名字就可以看出，可以通过BigInt、Int、Long和String四种类型的Scala字面量来构造UInt和SInt。按Scala的语法，其中BigInt、Int、Long三种类型默认是十进制的，但可以加前缀“0x”或“0X”变成十六进制。对于字符串类型的字面量，Chisel编译器默认也是十进制的，但是可以加上首字母“h”、“o”、“b”来分别表示十六进制、八进制和二进制。此外，字符串字面量可以用下划线间隔。</p>
<p>​    可以通过Boolean类型的字面量——true和false——来构造fromBooleanToLiteral类型的对象，然后调用名为B和asBool的方法进一步构造Bool类型的对象</p>
</blockquote>
<p>以上内容总结为：</p>
<ul>
<li>Chisel定义了一系列隐式类，隐式的从<strong>四种Scala字面量到Chisel数据类型的转变</strong><ul>
<li><strong>隐式类：</strong>fromBigIntToLiteral、fromtIntToLiteral、fromtLongToLiteral、fromStringToLiteral、fromBooleanToLiteral<ul>
<li>隐式类中存在相应的隐式转换方法，同名方法、U方法、S方法，分别把字面量转为：同款隐式类、UInt、SInt</li>
<li>如果要表示一个UInt对象可以写成：<code>1.U</code></li>
</ul>
</li>
<li><strong>四种Scala字面量：</strong>BigInt、Int、Long和String，对应的表示方法：<ul>
<li>BigInt、Int、Long：加前缀0x或0X改变进制</li>
<li>String：首字母“h”、“o”、“b”来分别表示十六进制、八进制和二进制，并可以用下划线间隔</li>
</ul>
</li>
<li>完整形式举例<ul>
<li>表示一个UInt对象可以写成<code>1.U</code>的格式，这样编译器会插入隐式转换，变成<code>fromtIntToLiteral(1).U</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Scala的Boolean字面量转变方法：</strong><ul>
<li>可以通过Boolean类型的字面量true、false，来构造fromBooleanToLiteral类型的对象</li>
<li>然后<strong>调用名为B</strong>或<strong>asBool的方法</strong>进一步构造Bool类型的对象</li>
</ul>
</li>
</ul>
<p><strong>一些表示数的例子：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-number">1.</span><span class="hljs-type">U</span>                <span class="hljs-comment">// Int字面值为&quot;1&quot;的UInt对象</span><br><span class="hljs-number">0x1</span>.<span class="hljs-type">U</span>		<span class="hljs-comment">//Int字面值为16进制1的UInt对象</span><br><span class="hljs-number">-8.</span><span class="hljs-type">S</span>               <span class="hljs-comment">// Int字面值为&quot;-8&quot;的SInt对象</span><br><br><span class="hljs-string">&quot;b0101&quot;</span>.<span class="hljs-type">U</span>	<span class="hljs-comment">// String字面值为&quot;5&quot;的UInt对象</span><br><br><span class="hljs-literal">true</span>.<span class="hljs-type">B</span>            <span class="hljs-comment">// Boolean字面值为&quot;true&quot;的Bool对象 </span><br></code></pre></div></td></tr></table></figure>
<p><strong>（4）构造没有字面量的对象</strong></p>
<p>UInt、SInt和Bool都不是抽象类，除了可以<strong>通过字面量构造对象</strong>以外，也可以<strong>直接通过apply工厂方法构造没有字面量的对象</strong></p>
<p><strong>有字面量的数据类型</strong>用于赋值、初始化寄存器等操作，而<strong>无字面量的数据类型</strong>则用于声明端口、构造向量等</p>
<h2 id="2-3-数据宽度"><a href="#2-3-数据宽度" class="headerlink" title="2.3 数据宽度"></a>2.3 数据宽度</h2><p><strong>（1）数据的默认宽度：</strong></p>
<p>​    默认情况下，<strong>数据的宽度按字面值取最小</strong>，例如字面值为“8”的UInt对象是4位宽，SInt就是5位宽。但是也可以指定宽度。注意，<strong>Bool类型固定是1位宽</strong>、</p>
<p><strong>（2）宽度类Width、宽度隐式类fromIntToWidth</strong></p>
<p>​    Chisel2里，宽度是由Int类型的参数表示的</p>
<p>​    <strong>Chisel3专门设计了宽度类Width</strong>，还有一个<strong>隐式类fromIntToWidth</strong>（把Int对象转换成fromIntToWidth类型的对象），然后<strong>通过方法W返回一个Width对象</strong>。</p>
<p><strong>（3）如何指定数据宽度：</strong></p>
<p><strong>方法U、asUInt、S和asSInt</strong>都有一个重载的版本，接收一个Width类型的参数，构造指定宽度的SInt和UInt对象</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-number">1.</span><span class="hljs-type">U</span>              <span class="hljs-comment">// 字面值为“1”、宽度为1bit的UInt对象</span><br><br><span class="hljs-number">1.</span><span class="hljs-type">U</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)   <span class="hljs-comment">// 字面值为“1”、宽度为32bit的UInt对象</span><br></code></pre></div></td></tr></table></figure>
<p>也可以直接给定：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;ha&quot;</span>, <span class="hljs-number">8</span>) 	<span class="hljs-comment">// hexadecimal 8-bit lit of type UInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;o12&quot;</span>, <span class="hljs-number">6</span>) 	<span class="hljs-comment">// octal 6-bit lit of type UInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-string">&quot;b1010&quot;</span>, <span class="hljs-number">12</span>) 	<span class="hljs-comment">// binary 12-bit lit of type UInt</span><br><span class="hljs-type">SInt</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>) 		<span class="hljs-comment">// signed decimal 7-bit lit of type SInt </span><br><span class="hljs-type">UInt</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>) 		<span class="hljs-comment">// unsigned decimal 8-bit lit of type UInt</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（4）UInt、SInt、Bool类中的重载</strong></p>
<p>UInt、SInt和Bool都不是抽象类，除了可以<strong>通过字面量构造对象</strong>以外，也可以<strong>直接通过apply工厂方法构造没有字面量的对象</strong></p>
<p>UInt和SInt的apply方法有两个版本：</p>
<ul>
<li>一个版本接收Width类型的参数构造指定宽度的对象</li>
<li>另一个则是无参版本构造位宽可自动推断的对象</li>
</ul>
<p>有字面量的数据类型用于赋值、初始化寄存器等操作，而无字面量的数据类型则用于声明端口、构造向量等。</p>
<h2 id="2-4-数据类型转换asXXX"><a href="#2-4-数据类型转换asXXX" class="headerlink" title="2.4 数据类型转换asXXX"></a>2.4 数据类型转换asXXX</h2><p>UInt、SInt和Bool三个类都包含四个方法：asUInt、asSInt、toBool和toBools：</p>
<ul>
<li>asUInt和asSInt分别把字面值按无符号数和有符号数解释，并且位宽不会变化，要注意转换过程中可能发生符号位和数值的变化。例如，3bit的UInt值“b111”，其字面量是“7”，转换成SInt后字面量就变成了“-1”</li>
<li>toBool会把1bit的“1”转换成Bool类型的true，“0”转换成false</li>
<li>toBools转换成Bool类型的序列Seq[Bool]，当位宽超过1bit</li>
<li>另外，Bool类还有一个方法asClock，把true转换成电压常高的时钟，false转换成电压常低的时钟。Clock类只有一个方法asUInt，转换成对应的0或1</li>
</ul>
<h2 id="2-5-向量Vec-T"><a href="#2-5-向量Vec-T" class="headerlink" title="2.5 向量Vec[T]"></a>2.5 向量Vec[T]</h2><p>如果需要一个集合类型的数据，除了可以使用Scala内建的数组、列表、集等数据结构外，还可以使用Chisel专属的Vec[T]。T必须是Data的子类，而且每个元素的类型、位宽为最宽的元素位宽。</p>
<p><strong>两种使用apply工厂创建Vec[T]的方法：</strong></p>
<ul>
<li>Vec(n,type) <ul>
<li>创建的所有类型一样</li>
</ul>
</li>
<li>VecInit(elt0,elts*)<ul>
<li>创建的时候可以用字面量/Seq进行初始化值，比较方便，常用于初始化寄存器组、ROM、RAM、一次性构造多模块</li>
</ul>
</li>
</ul>
<p><strong>使用Vec[T]工厂方法创建向量：</strong></p>
<p>Vec[T]的伴生对象里有一个apply工厂方法，接收两个参数，第一个是Int类型，表示元素的个数，第二个是元素。它属于可索引的序列，下标从0开始</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myVec = <span class="hljs-type">Wire</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">3</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)))<span class="hljs-comment">//Vec(UInt(32.W),UInt(32.W),UInt(32.W))</span><br><span class="hljs-keyword">val</span> myReg = myVec(<span class="hljs-number">0</span>)<span class="hljs-comment">//访问myVec(0)</span><br></code></pre></div></td></tr></table></figure>
<p>创建时也可以用Seq初始化如</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> my_reg = <span class="hljs-type">RegInit</span>(<span class="hljs-type">Vec</span>(<span class="hljs-type">Seq</span>.fill(n)(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))))<br></code></pre></div></td></tr></table></figure>
<p><strong>使用VecInit工厂方法创建向量：</strong></p>
<ul>
<li><p>接收参数为<strong>一个Seq[T]</strong>或者是<strong>多个重复字面量</strong>来构造向量，且常有有<strong>字面值的数据作为参数</strong>，<strong>用于初始化寄存器组、ROM、RAM等，或者用来构造多个模块</strong></p>
</li>
<li><p><img src="2022-3-9-chisel/image-20220313172534854.png" srcset="/img/loading.gif" lazyload alt="image-20220313172534854"><a target="_blank" rel="noopener" href="https://www.chisel-lang.org/api/3.3.3/chisel3/VecInit$.html">官网api解释</a></p>
</li>
</ul>
<p><strong>因为Vec[T]也是一种Seq</strong></p>
<ul>
<li><p>使用VecInit的工厂方法可以把Seq类型转为Vec[T]如上图</p>
</li>
<li><p>Vec[T]定义了诸如map、flatMap、zip、foreach、filter、exists、contains等方法。尽管这些方法应该出现在软件里，但是它们也可以简化硬件逻辑的编写，减少手工代码量。</p>
</li>
</ul>
<h2 id="2-6-混合向量MixedVec-T"><a href="#2-6-混合向量MixedVec-T" class="headerlink" title="2.6 混合向量MixedVec[T]"></a>2.6 混合向量MixedVec[T]</h2><p>混合向量MixedVec[T]与普通的向量Vec[T]类似，只不过包含的元素可以不全都一样。它的工厂方法是通过重复参数或者序列作为参数来构造的，并且也有一个叫MixedVecInit[T]的单例对象。</p>
<p>对于构造Vec[T]和MixedVec[T]的序列，并<strong>不一定要逐个手写，可以通过Scala的函数，比如fill、map、flatMap、to、until等来生成。</strong>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> mixVec = <span class="hljs-type">Wire</span>(<span class="hljs-type">MixedVec</span>((<span class="hljs-number">1</span> to <span class="hljs-number">10</span>) map &#123; i =&gt; <span class="hljs-type">UInt</span>(i.<span class="hljs-type">W</span>) &#125;))<br></code></pre></div></td></tr></table></figure>
<h2 id="2-7-包裹Bundle"><a href="#2-7-包裹Bundle" class="headerlink" title="2.7 包裹Bundle"></a>2.7 包裹Bundle</h2><p><strong>抽象类Bundle很像C语言的结构体(struct)</strong>，用户可以编写一个自定义类来继承自它，然后在自定义的类里包含其它各种Data类型的字段。它可以协助构建线网或寄存器，但是<strong>最常见的用途是用于构建一个模块的端口列表，或者一部分端口</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//new Bundle&#123;...&#125;定义并例化了一个继承于Bundle的匿名子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>   &#125;)<br>  <br> <span class="hljs-comment">//直接定义了一个Bundle的子类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（2）Bundle和UInt转换</strong></p>
<p><strong>Bundle-&gt;UInt：</strong>Bundle可以和UInt进行相互转换。Bundle类有一个方法asUInt，可以把所含的字段拼接成一个UInt数据，并且前面的字段在高位</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br><br><span class="hljs-keyword">val</span> bundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>bundle.foo := <span class="hljs-number">0xc</span>.<span class="hljs-type">U</span><br>bundle.bar := <span class="hljs-number">0x3</span>.<span class="hljs-type">U</span><br><span class="hljs-keyword">val</span> uint = bundle.asUInt  <span class="hljs-comment">// 12*16 + 3 = 195</span><br></code></pre></div></td></tr></table></figure>
<p><strong>Data-&gt;Bundle：</strong>有一个隐式类fromBitsable，可以把Data类型的对象转化成该类型，然后通过方法fromBits来接收一个Bits类型的参数来给该对象赋值。不过，该方法在Chisel3中已经被标注为过时，不推荐使用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 高位</span><br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)  <span class="hljs-comment">// 低位</span><br>&#125;<br><br><span class="hljs-keyword">val</span> uint = <span class="hljs-number">0xb4</span>.<span class="hljs-type">U</span><br><span class="hljs-keyword">val</span> bundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>).fromBits(uint)  <span class="hljs-comment">// foo = 11, bar = 4</span><br></code></pre></div></td></tr></table></figure>
<h2 id="2-8-Chisel的内建操作符"><a href="#2-8-Chisel的内建操作符" class="headerlink" title="2.8 Chisel的内建操作符"></a>2.8 Chisel的内建操作符</h2><p>有了数据类型，还需要预定义一些相关的操作符进行基本的操作。下表是Chisel内建的操作符：</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:557px;"><div style="text-align:center;">Chisel的内建操作符</div><caption>
  Chisel的内建操作符
 </caption><thead><tr><th style="text-align:center;vertical-align:middle;width:268px;">操作符</th><th style="text-align:center;vertical-align:middle;width:286px;">释义</th></tr></thead><tbody><tr><th style="text-align:center;vertical-align:middle;width:268px;">位操作符</th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val invertedX = ~x</td><td style="text-align:center;vertical-align:middle;width:286px;">位取反</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hiBits = x &amp; "h_ffff_0000".U</td><td style="text-align:center;vertical-align:middle;width:286px;">位与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val flagsOut = flagsIn | overflow</td><td style="text-align:center;vertical-align:middle;width:286px;">位或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val flagsOut = flagsIn ^ toggle</td><td style="text-align:center;vertical-align:middle;width:286px;">位异或</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>缩减位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt&nbsp; 返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val allSet = x.andR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val anySet = x.orR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val parity = x.xorR</td><td style="text-align:center;vertical-align:middle;width:286px;">缩减异或</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>相等性比较符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool </strong>&nbsp;<strong>返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val equ = x === y</td><td style="text-align:center;vertical-align:middle;width:286px;">相等</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val neq = x =/= y</td><td style="text-align:center;vertical-align:middle;width:286px;">不相等</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>移位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val twoToTheX = 1.S &lt;&lt; x</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑左移</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hiBits = 16.U &gt;&gt; x</td><td style="text-align:center;vertical-align:middle;width:286px;">右移(UInt逻辑右移，SInt算术右移)</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>部分位操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt, Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val xLSB = x(0)</td><td style="text-align:center;vertical-align:middle;width:286px;">抽取1bit，最低位下标0，最高位下标n-1</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val xTopNibble = x(15, 12)</td><td style="text-align:center;vertical-align:middle;width:286px;">抽取多个bit，左边是高位，右边是低位</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val usDebt = Fill(3, "hA".U)</td><td style="text-align:center;vertical-align:middle;width:286px;">拼接一个UInt类型的数据多次(位于util包)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val float = Cat(sign, exponent, mantissa)</td><td style="text-align:center;vertical-align:middle;width:286px;">拼接多个bit，左边的参数是高位(位于util包)</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>逻辑操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sleep = !busy</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑非</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val hit = tagMatch &amp;&amp; valid</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑与</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val stall = src1busy || src2busy</td><td style="text-align:center;vertical-align:middle;width:286px;">逻辑或</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val out = Mux(sel, inTrue, inFalse)</td><td style="text-align:center;vertical-align:middle;width:286px;">双输入多路选择器，sel是Bool类型</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>算术操作符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sum = a + b&nbsp;&nbsp;<em>or</em>&nbsp; val sum = a +% b</td><td style="text-align:center;vertical-align:middle;width:286px;">加法(不进行宽度扩展)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val sum = a +&amp; b</td><td style="text-align:center;vertical-align:middle;width:286px;">加法(扩展一位进位位)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val diff = a - b&nbsp;&nbsp;<em>or</em>&nbsp; val diff = a -% b</td><td style="text-align:center;vertical-align:middle;width:286px;">减法(不进行宽度扩展)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val diff = a -&amp; b</td><td style="text-align:center;vertical-align:middle;width:286px;">减法(扩展一位进位位)</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val prod = a * b</td><td style="text-align:center;vertical-align:middle;width:286px;">乘法</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val div = a / b</td><td style="text-align:center;vertical-align:middle;width:286px;">除法</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val mod = a % b</td><td style="text-align:center;vertical-align:middle;width:286px;">求余数</td></tr><tr><th style="text-align:center;vertical-align:middle;width:268px;"><strong>算术比较符</strong></th><th style="text-align:center;vertical-align:middle;width:286px;"><strong>作用类型: </strong><strong>SInt, UInt </strong>&nbsp;<strong>返回类型: Bool</strong></th></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val gt = a &gt; b</td><td style="text-align:center;vertical-align:middle;width:286px;">大于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val gte = a &gt;= b</td><td style="text-align:center;vertical-align:middle;width:286px;">大于等于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val lt = a &lt; b</td><td style="text-align:center;vertical-align:middle;width:286px;">小于</td></tr><tr><td style="text-align:center;vertical-align:middle;width:268px;">val lte = a &lt;= b</td><td style="text-align:center;vertical-align:middle;width:286px;">小于等于</td></tr></tbody></table>


<p>这里要注意的一点是相等性比较的两个符号是<mark>“===”和“=/=”</mark>，因为“==”和“!=”已经被Scala占用，所以Chisel另设了这两个新的操作符。按照优先级的判断准则，<strong>“===”和“=/=”的优先级</strong>以首个字符为“=”来判断，也就是在逻辑操作中，相等性比较的优先级要比与、或、异或都高。</p>
<h2 id="2-9-位宽推断"><a href="#2-9-位宽推断" class="headerlink" title="2.9 位宽推断"></a>2.9 位宽推断</h2><p>用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><b><div style="text-align:center;">Chisel的位宽判断</div></b><thead><tr><th style="text-align:center;vertical-align:middle;"><strong>操作符</strong></th><th style="text-align:center;vertical-align:middle;">位宽</th></tr></thead><tbody><tr><td style="text-align:center;vertical-align:middle;">z = x + y&nbsp;&nbsp;<em>or</em>&nbsp; z = x +% y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x +&amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y)) + 1</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x - y&nbsp;<em>or</em>&nbsp;z = x -% y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x -&amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y)) + 1</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &amp; y</td><td style="text-align:center;vertical-align:middle;">w(z) = min(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Mux(c, x, y)</td><td style="text-align:center;vertical-align:middle;">w(z) = max(w(x), w(y))</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = w * y</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + w(y)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &lt;&lt; n</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + maxNum(n)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = x &gt;&gt; n</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) - minNum(n)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Cat(x, y)</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) + w(y)</td></tr><tr><td style="text-align:center;vertical-align:middle;">z = Fill(n, x)</td><td style="text-align:center;vertical-align:middle;">w(z) = w(x) * maxNum(n)</td></tr></tbody></table>

<p>​    其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算</p>
<p><strong>位宽推测过程：</strong></p>
<p>​    位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。</p>
<p><strong>有关自动截断的问题：</strong></p>
<p>​    当把一个短位宽的信号值或硬件结构赋值给长位宽的硬件结构时，会自动扩展符号位。但是反过来会报错，并不是像Verilog那样把多余的高位截断，这需要注意(注：最新的chisel3版本已经可以像Verilog一样自动把高位截断了)</p>
<h1 id="3-硬件类型"><a href="#3-硬件类型" class="headerlink" title="3 硬件类型"></a>3 硬件类型</h1><p>本章将介绍<strong>Chisel里的常用硬件类型、控制语句、如何编写一个基本的模块</strong>，对于高级类型，读者可以自行研究。常用的硬件类型包括：</p>
<ul>
<li>IO</li>
<li>Module</li>
<li>Wire</li>
<li>Reg</li>
</ul>
<p><strong>关于数据类型和硬件类型的关系可参考3.8总结中的内容</strong></p>
<h2 id="3-0-Verilog与Chisel中的硬件类型"><a href="#3-0-Verilog与Chisel中的硬件类型" class="headerlink" title="3.0 Verilog与Chisel中的硬件类型"></a>3.0 Verilog与Chisel中的硬件类型</h2><p>Chisel在构建硬件的思路上类似Verilog。在Verilog中，是以“模块(module)”为基本单位组成一个完整的独立功能实体，所以Chisel也是按模块划分的，只不过不是用关键字“module”开头来定义模块，而是<strong>Chisel定义模块用一个继承自Module类的自定义class</strong></p>
<p><strong>Verilog与Chisel中的硬件类型：</strong></p>
<ul>
<li><p>在Verilog里，模块内部主要有“线网(wire)”和“四态变量(reg)”两种硬件类型，它们用于描述数字电路的组合逻辑和时序逻辑。</p>
</li>
<li><p>在Chisel里，也按这个思路定义了一些硬件类型，<strong>包括基本的线网和寄存器，以及一些常用的其它类型</strong>。前一章介绍了Chisel的数据类型，这还不够，因为这些数据类型是无法独立工作的。实际的电路应该是由硬件类型的对象构成的，不管是信号的声明，还是用赋值进行信号传递，都是由硬件类型的对象来完成的。<strong>数据类型和硬件类型融合在一起，才能构成完整、可运行的组件。</strong>比如要声明一个线网，这部分工作由硬件类型来完成；这个线网的位宽是多少、按无符号数还是有符号数解释、是不是向量等等，这些则是由作为参数的数据类型对象来定义的。</p>
</li>
</ul>
<h2 id="3-1-val与赋值"><a href="#3-1-val与赋值" class="headerlink" title="3.1 val与赋值"></a>3.1 val与赋值</h2><p>有了硬件类型后，就可以用赋值操作来进行信号的传递或者电路的连接。只有硬件赋值才有意义，单纯的数据对象进行赋值并不会被编译器转换成实际的电路，因为在Verilog里也是对wire、reg类型的硬件进行赋值。那么，赋值操作需要什么样的操作符来完成呢？</p>
<p><strong>在Chisel里，所有对象都应该由val类型的变量来引用，因为硬件电路的不可变性</strong>，因此具有以下两种情况：</p>
<ul>
<li><p><strong>硬件电路绑定val后不可变：</strong>一个变量一旦初始化时绑定了一个对象，就不能再发生更改</p>
</li>
<li><p><strong>对引用对象赋值(驱动)时可变：</strong>但引用的对象，很可能需要被重新赋值。例如，输出端口在定义时使用了“=”与端口变量名进行了绑定，那等到驱动该端口时，就需要通过变量名来进行赋值操作，更新数据。很显然，此时“=”已经不可用了，因为变量在声明的时候不是var类型。即使是var类型，这也只是让变量引用新的对象，而不是直接更新原来的可变对象。</p>
</li>
</ul>
<p><strong>如何对引用对象赋值：</strong></p>
<p>​    为了解决这个问题，<strong>几乎所有的Chisel类都定义了方法<code>:=</code></strong>，<strong>作为等号赋值的代替</strong>。所以首次创建变量时用等号初始化，如果变量引用的对象不能立即确定状态或本身就是可变对象，则在后续更新状态时应该用“:=”。从前面讲的操作符优先级来判断，该操作符以等号结尾，而且不是四种逻辑比较符号之一，所以优先级与等号一致，是最低的。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> x = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br><br><span class="hljs-keyword">val</span> y = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br><br>x := <span class="hljs-string">&quot;b1010&quot;</span>.<span class="hljs-type">U</span>  <span class="hljs-comment">// 驱动4bit的线网x为无符号数10</span><br><br>y := ~x  <span class="hljs-comment">// 驱动线网y为x的按位取反</span><br></code></pre></div></td></tr></table></figure>
<h2 id="3-2-端口、自定义接口、模块接口"><a href="#3-2-端口、自定义接口、模块接口" class="headerlink" title="3.2 端口、自定义接口、模块接口"></a>3.2 端口、自定义接口、模块接口</h2><p><strong>定义：</strong></p>
<ul>
<li>端口：任何为其成员分配了方向的<strong>数据对象</strong></li>
<li>自定义端口列表：Bundle的子类</li>
<li>模块接口：Module中的io字段，指向一个IO实例实例</li>
</ul>
<p><strong>各种类型实现概览：</strong></p>
<ul>
<li><p><strong>端口</strong>/有方向的数据对象：端口类的原始声明为<code>Input[T &lt;: Data](source: T)</code>和<code>Output[T &lt;: Data](source: T)</code>。<strong>注意</strong>，端口复制源数据对象的参数，不能是已经被硬件类型包裹的数据类型。目前Chisel还<strong>不支持双向端口inout</strong>，只能通过黑盒里的Analog端口来模拟外部Verilog的双向端口。</p>
</li>
<li><p><strong>自定义端口列表</strong>/Bundle子类：自定义类，<strong>父类</strong>或<strong>超类(自定义接口的子类)</strong>是Bundle，内部嵌入了分配方向的数据对象</p>
</li>
<li><p><strong>模块接口</strong>/io字段：指向一个IO实例，IO类的原始声明为<code>IO[T &lt;: Data](iodef: T)</code></p>
</li>
</ul>
<h3 id="3-2-1-如何声明一个自定义的端口列表"><a href="#3-2-1-如何声明一个自定义的端口列表" class="headerlink" title="3.2.1 如何声明一个自定义的端口列表"></a>3.2.1 如何声明一个自定义的端口列表</h3><h4 id="（1）定义Bundle的子类"><a href="#（1）定义Bundle的子类" class="headerlink" title="（1）定义Bundle的子类"></a>（1）定义Bundle的子类</h4><p>Bundle类作为<strong>父类</strong>，定义子类完成</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//一个声明端口的例子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoupled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> ready = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> data = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> valid = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>也可以是Bundle作为<strong>超类</strong>，扩展子类</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br><span class="hljs-keyword">val</span> data = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>))<br><span class="hljs-keyword">val</span> valid = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>&#125;<br><span class="hljs-comment">//我们可以通过使用bundle继承添加奇偶校验位来扩展SimpleLink</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleLink</span> </span>&#123;<br><span class="hljs-keyword">val</span> parity = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="（2）端口列表的嵌套"><a href="#（2）端口列表的嵌套" class="headerlink" title="（2）端口列表的嵌套"></a>（2）端口列表的嵌套</h4><p><strong>端口列表嵌套单个端口列表：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-comment">//在一个新的 FilterIO 包中嵌套两个 pliks 来定义一个过滤器接口:</span><br>  <span class="hljs-keyword">val</span> x = <span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span>)<span class="hljs-comment">//反转的PLink实例</span><br>  <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span><span class="hljs-comment">//PLink实例</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>端口列表嵌套端口列表向量<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/chisel3/docs/explanations/interfaces-and-connections.html">Bundle Vec</a>：</strong></p>
<p>通过Vec构造函数，在端口列表中，嵌套端口列表向量形成了更丰富的层次结构接口。</p>
<p>为了创建一个被Uint输入选择的有多组向量输入输出的mux，我们使用了Vec构造方法(For example, in order to create a crossbar with a vector of inputs, producing a vector of outputs, and selected by a UInt input, we utilize the Vec constructor:)</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util.log2Ceil<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrossbarIo</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> in = <span class="hljs-type">Vec</span>(n, <span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span>))<br>  <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(log2Ceil(n).<span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> out = <span class="hljs-type">Vec</span>(n, <span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span>)<br>  <span class="hljs-comment">// Vec 以 size 作为第一个参数，以返回端口的块作为第二个参数。</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="3-2-2-如何定义端口"><a href="#3-2-2-如何定义端口" class="headerlink" title="3.2.2 如何定义端口"></a>3.2.2 如何定义端口</h3><p><strong>如何定义端口：</strong>使用两个构造函数，参数是数据类型</p>
<ul>
<li><code>Input[T &lt;: Data](source: T)</code></li>
<li><code>Output[T &lt;: Data](source: T)</code></li>
</ul>
<p><strong>两种定义端口的示例：</strong></p>
<ul>
<li><strong>声明时指定方向</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoupled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br><span class="hljs-keyword">val</span> ready = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br><span class="hljs-keyword">val</span> data = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br><span class="hljs-keyword">val</span> valid = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>实例化时指定方向</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScaleIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFloat</span>().asInput<br>    <span class="hljs-keyword">val</span> scale = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFloat</span>().asInput<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFloat</span>().asOutput<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    <code>asInput</code>和<code>asOutput</code>方法强制<strong>数据对象的所有模块</strong>指向所请求的方向</p>
<p><strong>端口的特性：</strong></p>
<ul>
<li>驱动特性：<strong>端口输入可以驱动内部其它信号，输出可以被其他信号驱动</strong>。</li>
<li>赋值特性：<strong>端口可以直接进行赋值操作</strong>，布尔类型的端口还能直接作为使能信号。</li>
<li>硬件类型：<strong>端口不需要再使用其它硬件类型来定义</strong>，不过要注意从性质上来说它仍然属于组合逻辑的线网</li>
</ul>
<h3 id="3-2-3-模块接口"><a href="#3-2-3-模块接口" class="headerlink" title="3.2.3 模块接口"></a>3.2.3 模块接口</h3><p><strong>定义：</strong>模块接口是模块中固定字段io</p>
<p><strong>固定字段io：</strong></p>
<ul>
<li><strong>io名称固定</strong>，是Module类的内部成员</li>
<li>io指向了一个自定义接口实例，实例由<strong>方法<code>IO[T &lt;: Data](iodef: T)</code>生成</strong></li>
</ul>
<p><strong>通过io调用端口：</strong>一旦模块接口定义完成，就可以通过<code>io.端口x</code>使用</p>
<p><strong>模块接口示例：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//声明一个端口类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">5</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)))<br>   <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>&#125;<br><br>......<br> <span class="hljs-comment">// 模块的端口列表</span><br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyIO</span>) <br>......<br></code></pre></div></td></tr></table></figure>
<h3 id="3-2-4-翻转端口列表的方向"><a href="#3-2-4-翻转端口列表的方向" class="headerlink" title="3.2.4 翻转端口列表的方向"></a>3.2.4 翻转<u>端口列表</u>的方向</h3><ul>
<li>方法“<code>Flipped[T &lt;: Data](source: T)</code>方法</li>
<li>对于两个相连的模块，可能存在大量同名但方向相反的端口。仅仅为了翻转方向而不得不重写一遍端口显得费时费力，所以Chisel提供了“<code>Flipped[T &lt;: Data](source: T)</code>方法，可以把参数里所有的输入转输出，输出转输入。如果是黑盒里的Analog端口，则仍是双向的。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">5</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)))<br>   <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>&#125;<br><br>......<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyIO</span>)  <span class="hljs-comment">// in是输入，out是输出</span><br>......<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyIO</span>))  <span class="hljs-comment">// out是输入，in是输出</span><br></code></pre></div></td></tr></table></figure>
<h3 id="3-2-5-端口的两种连接方式"><a href="#3-2-5-端口的两种连接方式" class="headerlink" title="3.2.5 端口的两种连接方式"></a>3.2.5 端口的两种连接方式</h3><p>一旦我们定义了接口，我们就可以通过如下操作符进行连接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.chisel-lang.org/api/latest/chisel3/Data.html#:="><code>MonoConnect</code></a>操作符 ( <code>:=</code>) </li>
<li><a target="_blank" rel="noopener" href="https://www.chisel-lang.org/api/latest/chisel3/Data.html#&lt;"><code>BiConnect</code></a>操作符 ( <code>&lt;&gt;</code>) </li>
</ul>
<p><strong>（1）<code>MonoConnect.connect</code>, 或<code>:=</code>, 按元素执行单向连接。</strong></p>
<p>请注意，这不是可交换的。在调用这个函数之前，已经确定了一个显式的source和sink</p>
<p>连接操作将在左数据中递归(使用右数据)。如果通过左侧的移动不能与右侧的移动相匹配，则将引发异常。右侧允许有额外的字段。Vec内部元素必须仍然是完全相同的大小</p>
<p><strong>:=的左值与右值：</strong></p>
<ul>
<li><p>左值必须是可写的，因此其中之一必须保持：</p>
<ul>
<li><p>是内部可写节点（<code>Reg</code>或<code>Wire</code>）</p>
</li>
<li><p>是当前模块的输出</p>
</li>
<li><p>是当前模块的子模块的输入</p>
</li>
</ul>
</li>
<li><p>右值必须是可读的，因此其中之一必须保持：</p>
<ul>
<li><p>是内部可读节点 ( <code>Reg</code>, <code>Wire</code>, <code>Op</code>)</p>
</li>
<li><p>是字面的</p>
</li>
<li><p>是当前模块的端口还是当前模块的子模块</p>
</li>
</ul>
</li>
</ul>
<p><strong>（2）<code>BiConnect.connect</code>, 或<code>&lt;&gt;</code>, 按元素执行双向连接</strong></p>
<p>请注意，参数是左和右（不是源和接收器），因此目的是使操作具有可交换性。连接操作将递归左下<code>Data</code>（右<code>Data</code>）。如果左侧的移动无法在右侧匹配，或者右侧有额外的字段，则会引发异常</p>
<p><strong>biconnect<code>&lt;&gt;</code>运算符的用法：</strong></p>
<ul>
<li>将两个模块组合成一个过滤器块，如下所示：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> valid = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleLink</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> parity = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> x = <span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span>)<br>  <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br>  <span class="hljs-keyword">val</span> f1 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Filter</span>)<br>  <span class="hljs-keyword">val</span> f2 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Filter</span>)<br>  f1.io.x &lt;&gt; io.x<br>  f1.io.y &lt;&gt; f2.io.x<br>  f2.io.y &lt;&gt; io.y<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>连接同名的子端口时</strong>，对Bundle 的 Scala 类型不需要匹配。如果任一侧缺少一个命名信号，Chisel 将给出错误，如下例所示：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReallyAFilterIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> x = <span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span>)<br>  <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">new</span> <span class="hljs-type">PLink</span><br>  <span class="hljs-keyword">val</span> z = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bool</span>())<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io1 = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br>  <span class="hljs-keyword">val</span> io2 = <span class="hljs-type">IO</span>(<span class="hljs-type">Flipped</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">NotReallyAFilterIO</span>))<br><br>  io1 &lt;&gt; io2<br>&#125;<br><br><span class="hljs-comment">//执行</span><br><span class="hljs-type">ChiselStage</span>.emitVerilog(<span class="hljs-keyword">new</span> <span class="hljs-type">Block2</span>)<br><span class="hljs-comment">//执行后发生错误，错误提示如下：</span><br><span class="hljs-comment">// chisel3.internal.ChiselException: Connection between left (Block2.io1: IO[FilterIO]) ...</span><br></code></pre></div></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ul>
<li>双向连接只能与<strong>定向元素</strong>（如 IO）一起使用，例如不支持连接两条线，因为 Chisel 不一定能自动确定方向。例如，在此处放置两条临时电线并将它们连接起来是行不通的，即使可以从端点知道方向：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockWithTemporaryWires</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br>  <span class="hljs-keyword">val</span> f1 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Filter</span>)<br>  <span class="hljs-keyword">val</span> f2 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Filter</span>)<br>  f1.io.x &lt;&gt; io.x<br> <span class="hljs-keyword">val</span> tmp1 = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br> <span class="hljs-keyword">val</span> tmp2 = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterIO</span>)<br>  f1.io.y &lt;&gt; tmp1<br>  tmp1 &lt;&gt; tmp2<br>  tmp2 &lt;&gt; f2.io.x<br>  f2.io.y &lt;&gt; io.y<br>&#125;<br><br><span class="hljs-comment">//执行</span><br><span class="hljs-type">ChiselStage</span>.emitVerilog(<span class="hljs-keyword">new</span> <span class="hljs-type">BlockWithTemporaryWires</span>)<br><span class="hljs-comment">//执行后发生错误，错误结果提示：</span><br><span class="hljs-comment">// chisel3.internal.ChiselException: Connection between left (Filter.io.y: IO[PLink]) ...</span><br></code></pre></div></td></tr></table></figure>
<p>有关更多详细信息和信息，请参阅<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/chisel3/docs/explanations/connection-operators.md">深入了解连接运算符</a></p>
<p><strong>注意：当使用<code>Chisel._</code>(兼容模式) 而不是 时<code>chisel3._</code>，<code>:=</code>运算符以类似于 的双向方式工作<code>&lt;&gt;</code>，但不完全相同。</strong></p>
<h2 id="3-3-模块"><a href="#3-3-模块" class="headerlink" title="3.3 模块"></a>3.3 模块</h2><h3 id="3-3-1-模块的特性"><a href="#3-3-1-模块的特性" class="headerlink" title="3.3.1 模块的特性"></a>3.3.1 模块的特性</h3><p>在Chisel里面是用一个自定义的类来定义模块的，这个类有以下三个特点：</p>
<ul>
<li><p><strong>继承自Module类</strong>。</p>
</li>
<li><p>有一个<strong>抽象字段<code>io</code>需要实现</strong>，该字段必须引用前面所说的端口对象。</p>
</li>
<li><p>在类的<strong>主构造器里进行内部电路连线</strong>。因为非字段、非方法的内容都属于主构造方法，<strong>所以用操作符“:=”进行的赋值、用“&lt;&gt;”进行的连线或一些控制结构等等</strong>，都属于主构造方法。</p>
<ul>
<li><blockquote>
<p>从Scala的层面来讲，这些代码在实例化时表示如何构造一个对象；</p>
<p>从Chisel的层面来讲，它们就是在声明如何进行模块内部子电路的连接、信号的传递，类似于Verilog的assign和always语句。实际上这些用赋值表示的电路连接在转换成Verilog时，组合逻辑就是大量的assign语句，时序逻辑就是always语句</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>自定义类所继承Module类的两个字段clock、reset：</strong></p>
<ul>
<li>clock类型是Clock，它表示<strong>全局时钟</strong>，在整个模块内都可见。对于组合逻辑，是用不上它的，而时序逻辑虽然需要这个时钟，但也不用显式声明。</li>
<li>reset类型是Reset，表示<strong>全局复位信号</strong>，在整个模块内可见。对于需要复位的时序元件，也可以不用显式使用该字段。如果确实需要用到全局时钟和复位，则可以通过它们的字段名称来使用，但要注意类型是否匹配，经常需要“reset.toBool”这样的语句把Reset类型转换成Bool类型用于控制。隐式的全局时钟和复位端口只有在生成Verilog代码时才能看到。</li>
</ul>
<p><strong>要编写一个双输入多路选择器，其代码如下所示：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// mux2.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mux2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>&#123;<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in0 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>  io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在这里，“new Bundle { … }”的写法是声明一个匿名类继承自Bundle，然后实例化匿名类。对于短小、简单的端口列表，可以使用这种简便写法。对于大的公用接口，应该单独写成具名的Bundle子类，方便修改。“io.out := …”其实就是主构造方法的一部分，通过内建操作符和三个输入端口，实现了输出端口的逻辑行为</p>
</blockquote>
<h3 id="3-3-2-例化模块"><a href="#3-3-2-例化模块" class="headerlink" title="3.3.2 例化模块"></a>3.3.2 例化模块</h3><p><strong>例化模块包括两个步骤：</strong></p>
<ul>
<li>用new生成一个实例对象就完成了<ul>
<li><code>new 自定义模块类</code></li>
</ul>
</li>
<li><strong>还需要再把实例的对象传递给单例对象Module的apply方法</strong><ul>
<li><code>Module(自定义模块对象实例)</code></li>
</ul>
</li>
</ul>
<p>​    这种别扭的语法是Scala的语法限制造成的，就像端口需要写成<code>IO(new Bundle &#123;...&#125;)</code>，无符号数要写成<code>UInt(n.W)</code>等等一样。</p>
<p>例如，下面的代码通过例化刚才的双输入多路选择器构建四输入多路选择器：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// mux4.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mux4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in0 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in2 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in3 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  <span class="hljs-keyword">val</span> m0 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Mux2</span>)<br>  m0.io.sel := io.sel(<span class="hljs-number">0</span>)<br>  m0.io.in0 := io.in0<br>  m0.io.in1 := io.in1<br>  <span class="hljs-keyword">val</span> m1 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Mux2</span>)<br>  m1.io.sel := io.sel(<span class="hljs-number">0</span>)<br>  m1.io.in0 := io.in2<br>  m1.io.in1 := io.in3<br>  <span class="hljs-keyword">val</span> m2 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Mux2</span>)<br>  m2.io.sel := io.sel(<span class="hljs-number">1</span>)<br>  m2.io.in0 := m0.io.out<br>  m2.io.in1 := m1.io.out<br>  io.out := m2.io.out<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="3-3-3-一次性例化多个模块"><a href="#3-3-3-一次性例化多个模块" class="headerlink" title="3.3.3 一次性例化多个模块"></a>3.3.3 一次性例化多个模块</h3><p>像上个例子中，模块Mux2例化了三次，实际只需要一次性例化三个模块就可以了</p>
<p><strong>例化多个模块的原理</strong>：</p>
<ul>
<li>通过向量的工厂方法<a target="_blank" rel="noopener" href="https://www.chisel-lang.org/api/3.3.3/chisel3/VecInit$.html"><code>VecInit[T &lt;: Data]</code></a>进行多个模块接口的例化</li>
<li><code>VecInit</code>的apply方法的参数<ul>
<li>使用序列作为参数（用的多）<ul>
<li>使用单例对象Seq里的方法fill进行构造，把多个模块接口整合到序列中</li>
</ul>
</li>
<li>使用重复参数（用的少）</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于要多次例化的重复模块，可以利用向量的工厂方法VecInit[T &lt;: Data]。因为该方法接收的参数类型是Data的子类，而模块的字段io正好是Bundle类型，并且实际的电路连线仅仅只需针对模块的端口，所以可以把待例化模块的io字段组成一个序列，或者按重复参数的方式作为参数传递。</p>
<p>通常使用序列作为参数，这样更节省代码。生成序列的一种方法是调用单例对象Seq里的方法fill，该方法的一个重载版本有两个单参数列表，第一个接收Int类型的对象，表示序列的元素个数，第二个是传名参数，接收序列的元素。</p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><strong>Vec元素是模块接口字段，因此无需经过io引用，并且可直接通过下表索引</strong></li>
</ul>
<blockquote>
<p>因为Vec是一种可索引的序列，所以这种方式例化的多个模块类似于“模块数组”，用下标索引第n个模块。</p>
<p>因为Vec的元素已经是模块的端口字段io，所以要引用例化模块的某个具体端口时，路径里不用再出现“io”。</p>
</blockquote>
<p><strong>示例代码如下：</strong>的:::</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// mux4_2.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mux4_2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br><span class="hljs-comment">//io绑定接口实例</span><br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in0 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in2 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in3 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><span class="hljs-comment">//从Module构造出Seq，再由序列构造为向量,并把向量每一个元素(这里是指模块实例)做例化</span><br>  <span class="hljs-keyword">val</span> m = <span class="hljs-type">VecInit</span>(<span class="hljs-type">Seq</span>.fill(<span class="hljs-number">3</span>)(<span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Mux2</span>).io))  <span class="hljs-comment">// 例化了三个Mux2，并且参数是端口字段io</span><br>  m(<span class="hljs-number">0</span>).sel := io.sel(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 模块的端口通过下标索引，并且路径里没有“io”</span><br>  m(<span class="hljs-number">0</span>).in0 := io.in0<br>  m(<span class="hljs-number">0</span>).in1 := io.in1<br>  m(<span class="hljs-number">1</span>).sel := io.sel(<span class="hljs-number">0</span>)<br>  m(<span class="hljs-number">1</span>).in0 := io.in2<br>  m(<span class="hljs-number">1</span>).in1 := io.in3<br>  m(<span class="hljs-number">2</span>).sel := io.sel(<span class="hljs-number">1</span>)<br>  m(<span class="hljs-number">2</span>).in0 := m(<span class="hljs-number">0</span>).out<br>  m(<span class="hljs-number">2</span>).in1 := m(<span class="hljs-number">1</span>).out<br>  io.out := m(<span class="hljs-number">2</span>).out<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="3-4-线网"><a href="#3-4-线网" class="headerlink" title="3.4 线网"></a>3.4 线网</h2><p><strong>定义线网的方法：</strong>Chisel把线网作为电路的节点，通过工厂方法来定义</p>
<ul>
<li><code>Wire[T &lt;: Data](t: T)</code></li>
</ul>
<p><strong>线网的赋值、连接：</strong></p>
<ul>
<li>可以对线网进行赋值，也可以连接到其他电路节点，这是组成组合逻辑的基本硬件类型。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myNode = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>myNode := <span class="hljs-number">0.</span><span class="hljs-type">U</span> <br></code></pre></div></td></tr></table></figure>
<ul>
<li>对线网的多次驱动是可覆盖的： </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myNode = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>myNode := <span class="hljs-number">10.</span><span class="hljs-type">U</span><br>myNode := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br><span class="hljs-comment">//最终myNode表现为0,10被覆盖</span><br></code></pre></div></td></tr></table></figure>
<h2 id="3-5-寄存器"><a href="#3-5-寄存器" class="headerlink" title="3.5 寄存器"></a>3.5 寄存器</h2><p><strong>寄存器特性：</strong></p>
<ul>
<li>寄存器是时序逻辑的基本硬件类型，它们都是由当前时钟域的时钟上升沿触发的。</li>
<li>如果模块里没有多时钟域的语句块，那么寄存器都是由隐式的全局时钟来控制。对于有复位信号的寄存器，如果不在多时钟域语句块里，则由隐式的全局复位来控制，并且高有效。</li>
<li>目前Chisel所有的复位都是同步复位，异步复位功能还在开发中。如果需要异步复位寄存器，则需要通过黑盒引入。</li>
</ul>
<p><strong>五种内建的寄存器：</strong>init复位、next输入、t位宽、enable是能</p>
<ul>
<li><strong>跟随寄存器</strong><code>RegNext[T &lt;: Data](next: T)</code>和<code>RegNext[T &lt;: Data](next: T, init: T)</code><ul>
<li>在每个时钟上升沿，它都会采样一次传入的参数，并且没有复位信号。它的另一个版本的apply工厂方法是<code>RegNext[T &lt;: Data](next: T, init: T)</code>，也就是由复位信号控制，当复位信号有效时，复位到指定值，否则就跟随。</li>
</ul>
</li>
<li><strong>复位到指定值的寄存器</strong><code>RegInit[T &lt;: Data](init: T)</code><ul>
<li>参数需要声明位宽，否则就是默认位宽。可以用内建的when语句进行条件赋值。</li>
</ul>
</li>
<li><strong>普通的寄存器</strong><code>Reg[T &lt;: Data](t: T)</code><ul>
<li>它可以在when语句里用全局reset信号进行同步复位(reset信号是Reset类型，要用toBool进行类型转换)，也可以进行条件赋值或无条件跟随。参数同样要指定位宽。</li>
</ul>
</li>
<li>util包里的带一个<strong>使能端的寄存</strong>器<code>RegEnable[T &lt;: Data](next: T, init: T, enable: Bool)</code><ul>
<li>如果不需要复位信号，则第二个参数可以省略给出。</li>
</ul>
</li>
<li>util包里的<strong>移位寄存器</strong><code>ShiftRegister[T &lt;: Data](in: T, n: Int, resetData: T, en: Bool)</code><ul>
<li>其中第一个参数in是带移位的数据，第二个参数n是需要延迟的周期数，第三个参数resetData是指定的复位值，可以省略，第四个参数en是使能移位的信号，默认为true.B。</li>
</ul>
</li>
</ul>
<p><strong>假如有如下代码：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// reg.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">REG</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  <span class="hljs-keyword">val</span> reg0 = <span class="hljs-type">RegNext</span>(io.a)<br>  <span class="hljs-keyword">val</span> reg1 = <span class="hljs-type">RegNext</span>(io.a, <span class="hljs-number">0.</span><span class="hljs-type">U</span>)<br>  <span class="hljs-keyword">val</span> reg2 = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> reg3 = <span class="hljs-type">Reg</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> reg4 = <span class="hljs-type">Reg</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> reg5 = <span class="hljs-type">RegEnable</span>(io.a + <span class="hljs-number">1.</span><span class="hljs-type">U</span>, <span class="hljs-number">0.</span><span class="hljs-type">U</span>, io.en)<br>  <span class="hljs-keyword">val</span> reg6 = <span class="hljs-type">RegEnable</span>(io.a - <span class="hljs-number">1.</span><span class="hljs-type">U</span>, io.en)<br>  <span class="hljs-keyword">val</span> reg7 = <span class="hljs-type">ShiftRegister</span>(io.a, <span class="hljs-number">3</span>, <span class="hljs-number">0.</span><span class="hljs-type">U</span>, io.en)<br>  <span class="hljs-keyword">val</span> reg8 = <span class="hljs-type">ShiftRegister</span>(io.a, <span class="hljs-number">3</span>, io.en)<br>  <br>  reg2 := io.a.andR<br>  reg3 := io.a.orR<br>  when(reset.toBool) &#123;<br>    reg4 := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .otherwise &#123;<br>    reg4 := <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>  &#125;<br>    <span class="hljs-comment">//regx(n) n表示寄存器位数</span><br>  io.c := reg0(<span class="hljs-number">0</span>) &amp; reg1(<span class="hljs-number">0</span>) &amp; reg2(<span class="hljs-number">0</span>) &amp; reg3(<span class="hljs-number">0</span>) &amp; reg4(<span class="hljs-number">0</span>) &amp; reg5(<span class="hljs-number">0</span>) &amp; reg6(<span class="hljs-number">0</span>) &amp; reg7(<span class="hljs-number">0</span>) &amp; reg8(<span class="hljs-number">0</span>)<br>&#125; <br></code></pre></div></td></tr></table></figure>
<p><strong>对应生成的主要Verilog代码为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// REG.v</span><br><span class="hljs-keyword">module</span> REG(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_a,<br>  <span class="hljs-keyword">input</span>        io_en,<br>  <span class="hljs-keyword">output</span>       io_c<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg2; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg3; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg4; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg5; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_2; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_3; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_4; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg6; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_5; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_6; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg7; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_7; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_8; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg8; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_9; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_10; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_11; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>GEN_8; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_13; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_14; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_15; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_16; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_17; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_18; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_19; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_20; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_21; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_22; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_23; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_24; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_25; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_26; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_27; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_28; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_1 = io_a + <span class="hljs-number">8&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_2 = io_a - <span class="hljs-number">8&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_3 = <span class="hljs-built_in">$unsigned</span>(<span class="hljs-number">_</span>T_2); <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_4 = <span class="hljs-number">_</span>T_3[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_9 = ~ io_a; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_10 = <span class="hljs-number">_</span>T_9 == <span class="hljs-number">8&#x27;h0</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_11 = io_a != <span class="hljs-number">8&#x27;h0</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>GEN_8 = reset ? <span class="hljs-number">1&#x27;h0</span> : <span class="hljs-number">1&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_13 = reg0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_14 = reg1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_15 = <span class="hljs-number">_</span>T_13 &amp; <span class="hljs-number">_</span>T_14; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_16 = reg2[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_17 = <span class="hljs-number">_</span>T_15 &amp; <span class="hljs-number">_</span>T_16; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_18 = reg3[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_19 = <span class="hljs-number">_</span>T_17 &amp; <span class="hljs-number">_</span>T_18; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_20 = reg4[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_21 = <span class="hljs-number">_</span>T_19 &amp; <span class="hljs-number">_</span>T_20; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_22 = reg5[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_23 = <span class="hljs-number">_</span>T_21 &amp; <span class="hljs-number">_</span>T_22; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_24 = reg6[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_25 = <span class="hljs-number">_</span>T_23 &amp; <span class="hljs-number">_</span>T_24; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_26 = reg7[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_27 = <span class="hljs-number">_</span>T_25 &amp; <span class="hljs-number">_</span>T_26; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_28 = reg8[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> io_c = <span class="hljs-number">_</span>T_27 &amp; <span class="hljs-number">_</span>T_28; <br> <br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    reg0 &lt;= io_a;<br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg1 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg2 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg2 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_10&#125;;<br>    <span class="hljs-keyword">end</span><br>    reg3 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_11&#125;;<br>    reg4 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>GEN_8&#125;;<br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg5 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg5 &lt;= <span class="hljs-number">_</span>T_1;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg6 &lt;= <span class="hljs-number">_</span>T_4;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_5 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_5 &lt;= io_a;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_6 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_6 &lt;= <span class="hljs-number">_</span>T_5;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg7 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg7 &lt;= <span class="hljs-number">_</span>T_6;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_7 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_8 &lt;= <span class="hljs-number">_</span>T_7;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg8 &lt;= <span class="hljs-number">_</span>T_8;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="3-6-寄存器组"><a href="#3-6-寄存器组" class="headerlink" title="3.6 寄存器组"></a>3.6 寄存器组</h2><p>五种内建寄存器的工厂方法，它们的参数可以是任何Data的子类型。如果<strong>把子类型Vec[T]作为参数传递进去（vec[T]可通过VecInit创建），就会生成多个位宽相同、行为相同、名字前缀相同的寄存器</strong>。同样，<strong>寄存器组在Chisel代码里可以通过下标索引</strong></p>
<p><strong>假如有如下代码：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// reg2.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">REG2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br> <br>  <span class="hljs-keyword">val</span> reg0 = <span class="hljs-type">RegNext</span>(<span class="hljs-type">VecInit</span>(io.a, io.a))<br>  <span class="hljs-keyword">val</span> reg1 = <span class="hljs-type">RegNext</span>(<span class="hljs-type">VecInit</span>(io.a, io.a), <span class="hljs-type">VecInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>, <span class="hljs-number">0.</span><span class="hljs-type">U</span>))<br>  <span class="hljs-keyword">val</span> reg2 = <span class="hljs-type">RegInit</span>(<span class="hljs-type">VecInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>), <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)))<br>  <span class="hljs-keyword">val</span> reg3 = <span class="hljs-type">Reg</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)))<br>  <span class="hljs-keyword">val</span> reg4 = <span class="hljs-type">Reg</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)))<br>  <span class="hljs-keyword">val</span> reg5 = <span class="hljs-type">RegEnable</span>(<span class="hljs-type">VecInit</span>(io.a + <span class="hljs-number">1.</span><span class="hljs-type">U</span>, io.a + <span class="hljs-number">1.</span><span class="hljs-type">U</span>), <span class="hljs-type">VecInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>), <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)), io.en)<br>  <span class="hljs-keyword">val</span> reg6 = <span class="hljs-type">RegEnable</span>(<span class="hljs-type">VecInit</span>(io.a - <span class="hljs-number">1.</span><span class="hljs-type">U</span>, io.a - <span class="hljs-number">1.</span><span class="hljs-type">U</span>), io.en)<br>  <span class="hljs-keyword">val</span> reg7 = <span class="hljs-type">ShiftRegister</span>(<span class="hljs-type">VecInit</span>(io.a, io.a), <span class="hljs-number">3</span>, <span class="hljs-type">VecInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>), <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)), io.en)<br>  <span class="hljs-keyword">val</span> reg8 = <span class="hljs-type">ShiftRegister</span>(<span class="hljs-type">VecInit</span>(io.a, io.a), <span class="hljs-number">3</span>, io.en)<br>  <br>  reg2(<span class="hljs-number">0</span>) := io.a.andR<br>  reg2(<span class="hljs-number">1</span>) := io.a.andR<br>  reg3(<span class="hljs-number">0</span>) := io.a.orR<br>  reg3(<span class="hljs-number">1</span>) := io.a.orR<br>  when(reset.toBool) &#123;<br>    reg4(<span class="hljs-number">0</span>) := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>    reg4(<span class="hljs-number">1</span>) := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .otherwise &#123;<br>    reg4(<span class="hljs-number">0</span>) := <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>    reg4(<span class="hljs-number">1</span>) := <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>  &#125;<br>  io.c := reg0(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg1(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg2(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg3(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg4(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg5(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg6(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg7(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp; reg8(<span class="hljs-number">0</span>)(<span class="hljs-number">0</span>) &amp;<br>          reg0(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg1(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg2(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg3(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg4(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg5(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg6(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg7(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) &amp; reg8(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>对应的主要Verilog代码为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// REG2.v</span><br><span class="hljs-keyword">module</span> REG2(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_a,<br>  <span class="hljs-keyword">input</span>        io_en,<br>  <span class="hljs-keyword">output</span>       io_c<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg0_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg0_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg1_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg1_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg2_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg2_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg3_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg3_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg4_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg4_1; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_5; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg5_0;   <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg5_1; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_10; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_11; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_12; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg6_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg6_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_19_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_19_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_20_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_20_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg7_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg7_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_22_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_22_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_23_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_23_1; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg8_0; <br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg8_1; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_24; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_25; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_28; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>GEN_16; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_31; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_32; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_33; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_34; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_35; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_36; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_37; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_38; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_39; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_40; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_41; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_42; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_43; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_44; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_45; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_46; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_47; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_48; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_49; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_50; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_51; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_52; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_53; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_54; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_55; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_56; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_57; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_58; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_59; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_60; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_61; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_62; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_63; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_64; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_5 = io_a + <span class="hljs-number">8&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_10 = io_a - <span class="hljs-number">8&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_11 = <span class="hljs-built_in">$unsigned</span>(<span class="hljs-number">_</span>T_10); <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_12 = <span class="hljs-number">_</span>T_11[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_24 = ~ io_a; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_25 = <span class="hljs-number">_</span>T_24 == <span class="hljs-number">8&#x27;h0</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_28 = io_a != <span class="hljs-number">8&#x27;h0</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>GEN_16 = reset ? <span class="hljs-number">1&#x27;h0</span> : <span class="hljs-number">1&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_31 = reg0_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_32 = reg1_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_33 = <span class="hljs-number">_</span>T_31 &amp; <span class="hljs-number">_</span>T_32; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_34 = reg2_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_35 = <span class="hljs-number">_</span>T_33 &amp; <span class="hljs-number">_</span>T_34; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_36 = reg3_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_37 = <span class="hljs-number">_</span>T_35 &amp; <span class="hljs-number">_</span>T_36; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_38 = reg4_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_39 = <span class="hljs-number">_</span>T_37 &amp; <span class="hljs-number">_</span>T_38; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_40 = reg5_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_41 = <span class="hljs-number">_</span>T_39 &amp; <span class="hljs-number">_</span>T_40; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_42 = reg6_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_43 = <span class="hljs-number">_</span>T_41 &amp; <span class="hljs-number">_</span>T_42; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_44 = reg7_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_45 = <span class="hljs-number">_</span>T_43 &amp; <span class="hljs-number">_</span>T_44; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_46 = reg8_0[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_47 = <span class="hljs-number">_</span>T_45 &amp; <span class="hljs-number">_</span>T_46; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_48 = reg0_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_49 = <span class="hljs-number">_</span>T_47 &amp; <span class="hljs-number">_</span>T_48; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_50 = reg1_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_51 = <span class="hljs-number">_</span>T_49 &amp; <span class="hljs-number">_</span>T_50; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_52 = reg2_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_53 = <span class="hljs-number">_</span>T_51 &amp; <span class="hljs-number">_</span>T_52; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_54 = reg3_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_55 = <span class="hljs-number">_</span>T_53 &amp; <span class="hljs-number">_</span>T_54; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_56 = reg4_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_57 = <span class="hljs-number">_</span>T_55 &amp; <span class="hljs-number">_</span>T_56; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_58 = reg5_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_59 = <span class="hljs-number">_</span>T_57 &amp; <span class="hljs-number">_</span>T_58; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_60 = reg6_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_61 = <span class="hljs-number">_</span>T_59 &amp; <span class="hljs-number">_</span>T_60; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_62 = reg7_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_63 = <span class="hljs-number">_</span>T_61 &amp; <span class="hljs-number">_</span>T_62; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_64 = reg8_1[<span class="hljs-number">0</span>]; <br>  <span class="hljs-keyword">assign</span> io_c = <span class="hljs-number">_</span>T_63 &amp; <span class="hljs-number">_</span>T_64; <br>  <br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    reg0_0 &lt;= io_a;<br>    reg0_1 &lt;= io_a;<br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg1_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg1_0 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg1_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg1_1 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg2_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg2_0 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_25&#125;;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg2_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      reg2_1 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_25&#125;;<br>    <span class="hljs-keyword">end</span><br>    reg3_0 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_28&#125;;<br>    reg3_1 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>T_28&#125;;<br>    reg4_0 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>GEN_16&#125;;<br>    reg4_1 &lt;= &#123;&#123;<span class="hljs-number">7&#x27;d0</span>&#125;, <span class="hljs-number">_</span>GEN_16&#125;;<br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg5_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg5_0 &lt;= <span class="hljs-number">_</span>T_5;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg5_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg5_1 &lt;= <span class="hljs-number">_</span>T_5;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg6_0 &lt;= <span class="hljs-number">_</span>T_12;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg6_1 &lt;= <span class="hljs-number">_</span>T_12;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_19_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_19_0 &lt;= io_a;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_19_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_19_1 &lt;= io_a;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_20_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_20_0 &lt;= <span class="hljs-number">_</span>T_19_0;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_20_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-number">_</span>T_20_1 &lt;= <span class="hljs-number">_</span>T_19_1;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg7_0 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg7_0 &lt;= <span class="hljs-number">_</span>T_20_0;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      reg7_1 &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        reg7_1 &lt;= <span class="hljs-number">_</span>T_20_1;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_22_0 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_22_1 &lt;= io_a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_23_0 &lt;= <span class="hljs-number">_</span>T_22_0;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_23_1 &lt;= <span class="hljs-number">_</span>T_22_1;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg8_0 &lt;= <span class="hljs-number">_</span>T_23_0;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>      reg8_1 &lt;= <span class="hljs-number">_</span>T_23_1;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="3-7-用when给电路赋值-if-else-if-else"><a href="#3-7-用when给电路赋值-if-else-if-else" class="headerlink" title="3.7 用when给电路赋值(if else if else)"></a>3.7 用when给电路赋值(if else if else)</h2><p>在Verilog里，可以使用“if…else if…else”这样的条件选择语句来方便地构建电路的逻辑。由于Scala已经占用了“if…else if…else”语法，所以相应的<strong>Chisel控制结构改成了when语句</strong>，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs chisel">when (condition 1) &#123; definition 1 &#125;<br>.elsewhen (condition 2) &#123; definition 2 &#125;<br>...<br>.elsewhen (condition N) &#123; definition N &#125;<br>.otherwise &#123; default behavior &#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>特别注意：</strong></p>
<ul>
<li><p><code>.elsewhen</code>和<code>.otherwise</code>的开头有两个句点</p>
</li>
<li><p>所有的判断条件都是返回Bool类型的传名参数，不要和Scala的Boolean类型混淆</p>
<ul>
<li><strong>不存在Boolean和Bool之间的相互转换</strong></li>
<li>对于<strong>UInt、SInt和Reset类型，可以用方法toBool转换成Bool类型来作为判断条件</strong></li>
</ul>
</li>
<li><p><strong>when语句不仅可以给线网赋值，还可以给寄存器赋值</strong>，但是要注意构建组合逻辑时不能缺失“.otherwise”分支</p>
</li>
</ul>
<p><strong>使用情况：</strong></p>
<ul>
<li>通常，<strong>when用于</strong>给带使能信号的<strong>寄存器</strong>更新数据，<strong>组合逻辑不常用</strong><ul>
<li>对于有复位信号的寄存器，<strong>推荐使用<code>RegInit</code>来声明</strong>，这样生成的Verilog会自动根据当前的时钟域来同步复位，<strong>尽量不要在when语句里用<code>reset.toBool</code>作为复位条件</strong></li>
</ul>
</li>
</ul>
<p><strong>unless结构：</strong></p>
<ul>
<li>除了when结构，util包里还有一个与之对偶的结构<code>unless</code>，<strong>如果unless的判定条件为false.B则一直执行，否则不执行：</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util._<br><br>unless (condition) &#123; definition &#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="3-8-总结：数据类型与硬件类型的区别"><a href="#3-8-总结：数据类型与硬件类型的区别" class="headerlink" title="3.8 总结：数据类型与硬件类型的区别"></a>3.8 总结：数据类型与硬件类型的区别</h2><p>前一章介绍了Chisel的数据类型，其中常用的就五种：UInt、SInt、Bool、Bundle和Vec[T]。本章介绍了硬件类型，最基本的是IO、Wire和Reg三种，还有指明端口方向的Input、Output和Flipped。Module是沿袭了Verilog用模块构建电路的规则，不仅让熟悉Verilog/VHDL的工程师方便理解，也便于从Chisel转化成Verilog代码。</p>
<p>数据类型必须配合硬件类型才能使用，它不能独立存在，因为编译器只会把硬件类型生成对应的Verilog代码。从语法规则上来讲，这两种类型也有很大的区别，编译器会对数据类型和硬件类型加以区分。尽管从Scala的角度来看，硬件类型对应的工厂方法仅仅是“封装”了一遍作为入参的数据类型，其返回结果没变，比如Wire的工厂方法定义为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Data</span>](t: <span class="hljs-type">T</span>)(<span class="hljs-keyword">implicit</span> sourceInfo: <span class="hljs-type">SourceInfo</span>, compileOptions: <span class="hljs-type">CompileOptions</span>): <span class="hljs-type">T</span><br></code></pre></div></td></tr></table></figure>
<p>可以看到，入参t的类型与返回结果的类型是一样的，但是还有配置编译器的隐式参数，很可能区别就源自这里。</p>
<p>但是从Chisel编译器的角度来看，这两者就是不一样。换句话说，硬件类型就好像在数据类型上“包裹了一层外衣(英文原文用单词binding来形容)”。比如，线网“Wire(UInt(8.W))”就像给数据类型“UInt(8.W)”包上了一个“Wire( )”。所以，在编写Chisel时，要注意哪些地方是数据类型，哪些地方又是硬件类型。这时，静态语言的优势便体现出来了，因为编译器会帮助程序员检查类型是否匹配。如果在需要数据类型的地方出现了硬件类型、在需要硬件类型的地方出现了数据类型，那么就会引发错误。程序员只需要按照错误信息去修改相应的代码，而不需要人工逐个检查。</p>
<p>例如，在前面介绍寄存器组的时候，示例代码里的一句是这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> reg0 = <span class="hljs-type">RegNext</span>(<span class="hljs-type">VecInit</span>(io.a, io.a)) <br></code></pre></div></td></tr></table></figure>
<p>读者可能会好奇为什么不写成如下形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> reg0 = <span class="hljs-type">RegNext</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, io.a)) <br></code></pre></div></td></tr></table></figure>
<p>如果改成这样，那么编译器就会发出如下错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">[error] chisel3.core.<span class="hljs-type">Binding</span>$<span class="hljs-type">ExpectedChiselTypeException</span>: vec <span class="hljs-class"><span class="hljs-keyword">type</span> &#x27;<span class="hljs-title">chisel3</span>.<span class="hljs-title">core</span>.<span class="hljs-title">UInt@6147b2fd</span>&#x27; <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">a</span> <span class="hljs-title">Chisel</span> <span class="hljs-title">type</span>, <span class="hljs-title">not</span> <span class="hljs-title">hardware</span> </span><br></code></pre></div></td></tr></table></figure>
<p>这是因为方法Vec期望第二个参数是数据类型，这样它才能推断出返回的Vec[T]是数据类型。但实际的“io.a”是经过Input封装过的硬件类型，导致Vec[T]变成了硬件类型，所以发生了类型匹配错误。错误信息里也明确指示了，“Chisel type”指的就是数据类型，“hardware”指的就是硬件类型，而vec的类型应该是“Chisel type”，不应该变成硬件。</p>
<p>Chisel提供了一个用户API——chiselTypeOf<a href="target: T">T &lt;: Data</a>: T，其作用就是把硬件类型的“封皮”去掉，变成纯粹的数据类型。因此，读者可能会期望如下代码成功：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> reg0 = <span class="hljs-type">RegNext</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, chiselTypeOf(io.a)))  <br></code></pre></div></td></tr></table></figure>
<p>但是编译器仍然发出了错误信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">[error] chisel3.core.<span class="hljs-type">Binding</span>$<span class="hljs-type">ExpectedHardwareException</span>: reg next <span class="hljs-symbol">&#x27;Vec</span>(chisel3.core.<span class="hljs-type">UInt</span>@<span class="hljs-number">65</span>b0972a, chisel3.core.<span class="hljs-type">UInt</span>@<span class="hljs-number">25155</span>aa4)&#x27; must be hardware, not a bare <span class="hljs-type">Chisel</span> <span class="hljs-keyword">type</span>. <span class="hljs-type">Perhaps</span> you forgot to wrap it in <span class="hljs-type">Wire</span>(_) or <span class="hljs-type">IO</span>(_)? <br></code></pre></div></td></tr></table></figure>
<p>只不过，这次是RegNext出错了。chiselTypeOf确实把硬件类型变成了数据类型，所以Vec[T]的检查通过了。但RegNext是实打实的硬件——寄存器，它也需要根据入参来推断返回结果的类型，所以传入一个数据类型Vec[T]就引发了错误。错误信息还额外提示程序员，是否忘记了用Wire(<em>)或IO(</em>)来包裹裸露的数据类型。甚至是带有字面量的数据类型，比如“0.U(8.W)”这样的对象，也被当作是硬件类型。</p>
<p>综合考虑这两种错误，只有写成“val reg0 = RegNext(VecInit(io.a, io.a))”合适，因为VecInit专门接收硬件类型的参数来构造硬件向量，给VecInit传入数据类型反而会报错，尽管它的返回类型也是Vec[T]。另外，Reg(_)的参数是数据类型，不是硬件类型，所以示例代码中它的参数是Vec，而别的参数都是VecInit。</p>
<p>有了基本的数据类型和硬件类型后，就已经可以编写绝大多数组合逻辑与时序逻辑电路。下一章将介绍Chisel库里定义的常用原语，有了这些原语就能更快速地构建电路，而不需要只用这些基本类型来搭积木。</p>
<h1 id="4-常用的硬件原语"><a href="#4-常用的硬件原语" class="headerlink" title="4 常用的硬件原语"></a>4 常用的硬件原语</h1><p>前两章介绍了基本的数据类型和硬件类型，已经足够编写基本的小规模电路。至于要如何生成Verilog，会在后续章节讲解。如果要编写大型电路，当然也可以一砖一瓦地搭建，但是费时费力，完全体现不出软件语言的优势。Chisel在语言库里定义了很多常用的硬件原语，读者可以直接导入相应的包来使用。让编译器多干活，让程序员少费力，本章介绍的常用原语有：</p>
<ul>
<li>多路选择器</li>
<li>ROM</li>
<li>RAM</li>
<li>带写掩膜的RAM</li>
<li>从文件读取到RAM</li>
<li>计数器</li>
<li>16位线性反馈移位寄存器</li>
<li>状态机（不是原语）</li>
</ul>
<p>本章介绍了Chisel内建的常用原语，还有更多原语可以使用，比如Bundle衍生的几种端口类，读者可以通过查询API或源码来进一步了解。</p>
<h2 id="4-1-多路选择器"><a href="#4-1-多路选择器" class="headerlink" title="4.1 多路选择器"></a>4.1 多路选择器</h2><p>因为多路选择器是一个很常用的电路模块，所以<strong>Chisel内建了几种多路选择器</strong>：</p>
<ul>
<li><p><strong>二输入多路选择器(Mux)，形式为</strong><code>Mux(sel, in1, in2)</code>：sel是Bool类型，in1和in2的类型相同，都是Data的任意子类型。当sel为true.B时，返回in1，否则返回in2</p>
<ul>
<li>因为Mux仅仅是把一个输入返回，所以Mux可以内嵌Mux，构成<strong>n输入多路选择器(嵌套Mux)</strong>，类似于嵌套的三元操作符。其<strong>形式为</strong><code>Mux(c1, a, Mux(c2, b, Mux(..., default)))</code></li>
</ul>
</li>
<li><p><strong>n输入多路选择器的简便写法(MuxCase)</strong>，MuxCase在<u>chisel3.util</u>包里，形式为<code>MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...))</code>，它的展开与嵌套的Mux是一样的：第一个参数是默认情况下返回的结果，第二个参数是一个数组，数组的元素是对偶<code>(成立条件，被选择的输入)</code></p>
</li>
<li><strong>查找表(MuxLookup)</strong>，第三种是MuxCase的变体也在<u>chisel3.uti</u>l包里，它相当于把MuxCase的成立条件依次换成从0开始的索引值像一个查找表，其<strong>形式为</strong><code>MuxLookup(idx, default, Array(0.U -&gt; a, 1.U -&gt; b, ...))</code>。它的展开相当于<code>MuxCase(default, Array((idx === 0.U) -&gt; a, (idx === 1.U) -&gt; b, ...))</code></li>
<li><strong>独热码多路选择器(Mux1H)</strong>：第四种是<u>chisel3.util</u>包里的，它的选择信号是一个独热码。如果零个或多个选择信号有效，则行为未定义。<strong>其形式如下</strong>：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> hotValue = <span class="hljs-type">Mux1H</span>(<span class="hljs-type">Seq</span>(<br>    io.selector(<span class="hljs-number">0</span>) -&gt; <span class="hljs-number">2.</span><span class="hljs-type">U</span>,<br>    io.selector(<span class="hljs-number">1</span>) -&gt; <span class="hljs-number">4.</span><span class="hljs-type">U</span>,<br>    io.selector(<span class="hljs-number">2</span>) -&gt; <span class="hljs-number">8.</span><span class="hljs-type">U</span>,<br>    io.selector(<span class="hljs-number">4</span>) -&gt; <span class="hljs-number">11.</span><span class="hljs-type">U</span><br>))<br></code></pre></div></td></tr></table></figure>
<p><strong>Chisel与Verilog带来的思考：</strong></p>
<ul>
<li><strong>内建的多路选择器会转换成Verilog的三元操作符<code>? :</code></strong>，这对于构建组合逻辑而言是完全足够的，而且更推荐这种做法，</li>
<li><p><strong>when语句常用于给寄存器赋值</strong>，而很少用来给线网赋值</p>
</li>
<li><p><strong>always的缺点与为什么要使用assign：</strong>读者可能习惯用always语句块来编写电路，但这存在一些问题：</p>
<ul>
<li>always既可以综合出时序逻辑又能综合出组合逻辑，导致<strong>reg变量存在二义性</strong>，常常使得新手误解reg就是寄存器</li>
<li>if…else if…else不能<strong>传播控制变量的未知态x</strong>(某些EDA工具可以)，使得仿真阶段无法发现一些错误，但是assign语句会在控制变量为x时也输出x</li>
<li>工业级的Verilog，都是用assign语句来构建电路。<strong>时序逻辑也是通过例化触发器模块来完成的</strong>，相应的端口都是由assign来驱动，而且<strong>触发器会使用SystemVerilog的断言来寻找always语句里的x和z</strong>。<strong>整个设计应该尽量避免使用always语句。</strong> </li>
</ul>
</li>
</ul>
<h2 id="4-2-ROM"><a href="#4-2-ROM" class="headerlink" title="4.2 ROM"></a>4.2 ROM</h2><p>可以<strong>用VecInit</strong>的工厂方法来<strong>创建一个只读存储器</strong>：</p>
<ul>
<li><p><strong>VecInit的两种形式</strong>（前面提到过）：</p>
<ul>
<li><code>VecInit[T &lt;: Data](elt0: T, elts: T*)</code>：elt0和elts类型/字面量保持一致即可</li>
<li><code>VecInit[T &lt;: Data](elts: Seq[T])</code>：从seq序列中创建</li>
</ul>
</li>
<li><p><strong>参数</strong>就是ROM里的常量数值，<strong>对应的Verilog代码就是给读取ROM的线网或寄存器赋予常量值</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// rom.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ROM</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  <span class="hljs-keyword">val</span> rom = <span class="hljs-type">VecInit</span>(<span class="hljs-number">1.</span><span class="hljs-type">U</span>, <span class="hljs-number">2.</span><span class="hljs-type">U</span>, <span class="hljs-number">3.</span><span class="hljs-type">U</span>, <span class="hljs-number">4.</span><span class="hljs-type">U</span>)<br><br>  io.out := rom(io.sel)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>对应的Verilog为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// ROM.v</span><br><span class="hljs-keyword">module</span> ROM(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] io_sel,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_out<br>);<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>GEN_1; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>GEN_2; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>GEN_3; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>GEN_1 = <span class="hljs-number">2&#x27;h1</span> == io_sel ? <span class="hljs-number">3&#x27;h2</span> : <span class="hljs-number">3&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>GEN_2 = <span class="hljs-number">2&#x27;h2</span> == io_sel ? <span class="hljs-number">3&#x27;h3</span> : <span class="hljs-number">_</span>GEN_1; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>GEN_3 = <span class="hljs-number">2&#x27;h3</span> == io_sel ? <span class="hljs-number">3&#x27;h4</span> : <span class="hljs-number">_</span>GEN_2; <br>  <span class="hljs-keyword">assign</span> io_out = &#123;&#123;<span class="hljs-number">5&#x27;d0</span>&#125;, <span class="hljs-number">_</span>GEN_3&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p><strong>Vec[T]索引需要注意的内容：</strong></p>
<p>在这个例子里需要提的一点是，<strong>Vec[T]类的apply方法不仅可以接收Int类型的索引值，另一个重载版本还能接收UInt类型的索引值</strong>。所以对于承担地址、计数器等<strong>功能的部件，可以直接作为由Vec[T]构造的元素的索引参数</strong>，比如这个例子中根据sel端口的值来选择相应地址的ROM值。</p>
<h2 id="4-3-RAM"><a href="#4-3-RAM" class="headerlink" title="4.3 RAM"></a>4.3 RAM</h2><p><strong>Chisel支持两种类型的RAM：</strong></p>
<ul>
<li><p>第一种RAM是同步(时序)写，异步(组合逻辑)读，通过工厂方法<code>Mem[T &lt;: Data](size: Int, t: T)</code>来构建。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> asyncMem = <span class="hljs-type">Mem</span>(<span class="hljs-number">16</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)) <br></code></pre></div></td></tr></table></figure>
<p><u>由于现代的FPGA和ASIC技术已经不再支持异步读RAM</u>，所以<strong>这种RAM会被综合成寄存器阵列</strong></p>
</li>
<li><p>第二种RAM则是同步(时序)读、写，通过工厂方法<code>SyncReadMem[T &lt;: Data](size: Int, t: T)</code>来构建，<strong>这种RAM会被综合成实际的SRAM</strong>。在Verilog代码上，<strong>这两种RAM都是由reg类型的变量来表示的</strong>，区别在于<strong>第二种RAM的读地址会被地址寄存器寄存一次</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> syncMem = <span class="hljs-type">SyncReadMem</span>(<span class="hljs-number">16</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p><strong>写RAM的语法是：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">when(wr_en) &#123;<br>     mem.write(address, dataIn) <br>     out := <span class="hljs-type">DontCare</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>其中DontCare告诉Chisel的未连接线网检测机制，写入RAM时读端口的行为无需关心</strong>(说人话就是out悬空的时候的一种表达方式)</li>
</ul>
<p><strong>读RAM的语法是：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">out := mem.read(address, rd_en)<br></code></pre></div></td></tr></table></figure>
<p><strong>读、写使能信号都可以省略</strong></p>
<p><strong>综合器综合出的SRAM可能是寄存器阵列：</strong></p>
<p>​    要综合出实际的SRAM，读者最好了解自己的综合器是如何推断的，按照综合器的推断规则来编写模块的端口定义、时钟域划分、读写使能的行为等等，否则就可能综合出寄存器阵列而不是SRAM。以Vivado 2018.3为例，下面的单端口SRAM代码经过综合后会映射到FPGA上实际的BRAM资源，而不是寄存器：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// ram.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinglePortRAM</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> addr = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">10.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> dataIn = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> we = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> dataOut = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br>  <span class="hljs-keyword">val</span> syncRAM = <span class="hljs-type">SyncReadMem</span>(<span class="hljs-number">1024</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <br>  when(io.en) &#123;<br>      when(io.we) &#123;<br>          syncRAM.write(io.addr, io.dataIn)<span class="hljs-comment">//写RAM</span><br>          io.dataOut := <span class="hljs-type">DontCare</span><span class="hljs-comment">//输出悬空</span><br>      &#125; .otherwise &#123;<br>          io.dataOut := syncRAM.read(io.addr)<span class="hljs-comment">//读RAM到输出</span><br>      &#125;<br>  &#125; .otherwise &#123;<br>       io.dataOut := <span class="hljs-type">DontCare</span><span class="hljs-comment">//输出悬空</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    下面是Vivado综合后的部分截图，可以看到确实变成了实际的BRAM：</p>
<p><img src="https://img-blog.csdnimg.cn/20190220235621546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="Vivado综合出来的单端口BRAM"></p>
<p><strong>双端BRAM的Verilog-&gt;Chisel-&gt;Verilog后无法识别出SRAM：</strong></p>
<p>​    Vivado的BRAM最多支持真·双端口，按照对应的Verilog模板逆向编写Chisel，然后用编译器把Chisel转换成Verilog。但此时编译器生成的Verilog代码并不能被Vivado的综合器识别出来。</p>
<p>​    <strong>原因在于</strong>SyncReadMem生成的Verilog代码是<strong>用一级寄存器保存输入的读地址，然后用读地址寄存器去异步读取RAM的数据</strong>，而Vivado的综合器识别不出这种模式的RAM。读者必须<strong>手动修改成用一级寄存器保存异步读取的数据而不是读地址，然后把读数据寄存器的内容用assign语句赋值给读数据端口</strong>，这样才能被识别成真·双端口BRAM。尚不清楚其它综合器是否有这个问题。经过咨询SiFive的工作人员，对方答复因为当前转换的代码把延迟放在地址一侧，所以流水线的节拍设计也是根据这个来的。考虑到贸然修改SyncReadMem的行为，可能会潜在地影响其它用户对流水线的设计，故而没有修改计划。如果确实需要自定义的、对综合器友好的Verilog代码，可以使用黑盒功能替代，或者给Firrtl编译器传入参数，改用自定义脚本来编译Chisel。</p>
<h2 id="4-4-带写掩模的RAM"><a href="#4-4-带写掩模的RAM" class="headerlink" title="4.4 带写掩模的RAM"></a>4.4 带写掩模的RAM</h2><p><strong>写掩膜：</strong></p>
<p>​    RAM通常都具备按字节写入的功能，比如数据写入端口的位宽是32bit，那么就应该有32b(4bit)的写掩模信号，只有当写掩模比特有效时，对应的字节才会写入。Chisel也具备构建带写掩模的RAM的功能</p>
<p><strong>Chisel中的实现：</strong></p>
<ul>
<li><p>当构建RAM的数据类型为Vec[T]时，就会推断出该RAM具有写掩模</p>
<ul>
<li>```<br>val ram = SyncReadMem(size, Vec(Num, Type(Width)))<figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><br>+ 需要定义一个Se<span class="hljs-string">q[Bool]</span>类型的**写掩模信号**，**序列的元素个数为数据写入端口的位宽除以字节宽度**<br><br>  + <span class="hljs-string">``</span><span class="hljs-string">`scal</span><br><span class="hljs-string">     val mask = Wire(Vec(DataWidth/ByteWitdth, Bool()))</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>write方法有一个重载版本，就是第三个参数是接收写掩模信号的。当下标为0的写掩模比特是true.B时，最低的那个字节会被写入，依次类推</p>
<ul>
<li>```scala<br>val dataIn_temp = Wire(和定义ram时的Type(Width)一样)<br>ram.write(addr, dataIn_temp, mask)<figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><br>是一个带写掩模的单端口<span class="hljs-type">RAM</span>：<br><br>```scala<br>// maskram.scala<br><span class="hljs-title">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">MaskRAM</span> extends <span class="hljs-type">Module</span> &#123;</span><br><span class="hljs-class">  val io = <span class="hljs-type">IO</span>(<span class="hljs-title">new</span> <span class="hljs-type">Bundle</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-title">val</span> <span class="hljs-title">addr</span> = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(10.<span class="hljs-type">W</span>))</span><br><span class="hljs-class">    val dataIn = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(32.<span class="hljs-type">W</span>))</span><br><span class="hljs-class">    val en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())</span><br><span class="hljs-class">    val we = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(4.<span class="hljs-type">W</span>))</span><br><span class="hljs-class">    val dataOut = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(32.<span class="hljs-type">W</span>))  </span><br><span class="hljs-class">  &#125;)</span><br><span class="hljs-class">  val dataIn_temp = <span class="hljs-type">Wire</span>(<span class="hljs-type">Vec</span>(4, <span class="hljs-type">UInt</span>(8.<span class="hljs-type">W</span>)))</span><br><span class="hljs-class">  val dataOut_temp = <span class="hljs-type">Wire</span>(<span class="hljs-type">Vec</span>(4, <span class="hljs-type">UInt</span>(8.<span class="hljs-type">W</span>)))</span><br><span class="hljs-class">  val mask = <span class="hljs-type">Wire</span>(<span class="hljs-type">Vec</span>(4, <span class="hljs-type">Bool</span>()))</span><br><span class="hljs-class">  val syncRAM = <span class="hljs-type">SyncReadMem</span>(1024, <span class="hljs-type">Vec</span>(4, <span class="hljs-type">UInt</span>(8.<span class="hljs-type">W</span>)))//</span><br><span class="hljs-class">    </span><br><span class="hljs-class">  when(<span class="hljs-title">io</span>.<span class="hljs-title">en</span>) &#123;</span><br><span class="hljs-class">    syncRAM.write(<span class="hljs-title">io</span>.<span class="hljs-title">addr</span>, <span class="hljs-title">dataIn_temp</span>, <span class="hljs-title">mask</span>)</span><br><span class="hljs-class">    dataOut_temp := syncRAM.read(<span class="hljs-title">io</span>.<span class="hljs-title">addr</span>)//读<span class="hljs-type">RAM</span>到输出</span><br><span class="hljs-class">  &#125; .otherwise &#123;</span><br><span class="hljs-class">    dataOut_temp := <span class="hljs-type">DontCare</span>//输出悬空</span><br><span class="hljs-class">  &#125; </span><br><span class="hljs-class">  for(<span class="hljs-title">i</span> &lt;- 0 <span class="hljs-title">until</span> 4) &#123;</span><br><span class="hljs-class">    dataIn_temp(<span class="hljs-title">i</span>) := io.dataIn(8*<span class="hljs-title">i</span>+7, 8*<span class="hljs-title">i</span>)</span><br><span class="hljs-class">    mask(<span class="hljs-title">i</span>) := io.we(<span class="hljs-title">i</span>).toBool</span><br><span class="hljs-class">    io.dataOut := <span class="hljs-type">Cat</span>(<span class="hljs-title">dataOut_temp</span>(3), dataOut_temp(2), dataOut_temp(1), dataOut_temp(0))</span><br><span class="hljs-class">  &#125;</span><br><span class="hljs-class">&#125;</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>为什么读写端口和写掩膜要定义成一个Uint：</strong></p>
<p>​    读、写端口和写掩模可以不用定义成一个UInt，也可以是Vec[UInt]，这样定义只是为了<strong>让模块对外只有一个读端口、一个写端口和一个写掩模端口</strong></p>
<p><strong>使用Vec[T]数据类型定义RAM的效果：</strong></p>
<p>​    注意，编译器会把Vec[T]的元素逐个展开，而不是合并成压缩数组的形式。也正是如此，上述代码对应的Verilog中，把RAM主体定义成了<code>reg [7:0] syncRAM_0 [0:1023]</code>、<code>reg [7:0] syncRAM_1 [0:1023]</code>、<code>reg [7:0] syncRAM_2 [0:1023]</code>和<code>reg [7:0] syncRAM_3 [0:1023]</code>，而不是一个<code>reg [31:0] syncRAM [0:1023]</code>。这样，Vivado综合出来的电路是四小块BRAM，而不是一大块BRAM</p>
<h2 id="4-5-从文件读取数据到RAM"><a href="#4-5-从文件读取数据到RAM" class="headerlink" title="4.5 从文件读取数据到RAM"></a>4.5 从文件读取数据到RAM</h2><p>在experimental包里有一个单例对象loadMemoryFromFile，它的apply方法可以在Chisel层面上从txt文件读取数据到RAM里。</p>
<p><strong>导入方式：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util.experimental.loadMemoryFromFile<br></code></pre></div></td></tr></table></figure>
<p><strong>其定义如下所示：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Data</span>](memory: <span class="hljs-type">MemBase</span>[<span class="hljs-type">T</span>], fileName: <span class="hljs-type">String</span>, hexOrBinary: <span class="hljs-type">FileType</span> = <span class="hljs-type">MemoryLoadFileType</span>.<span class="hljs-type">Hex</span>): <span class="hljs-type">Unit</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>第一个参数是MemBase[T]类型的，也就是Mem[T]和SyncReadMem[T]的超类，该参数接收一个自定义的RAM对象</li>
<li>第二个参数是文件的名字及路径，用字符串表示</li>
<li>第三个参数表示读取的方式为十六进制或二进制，默认是MemoryLoadFileType.Hex，也可以改成MemoryLoadFileType.Binary。<strong>注意，没有十进制和八进制</strong></li>
</ul>
<p><strong>本质是Verilog的readmemh/b</strong></p>
<p>​    该方法其实就是调用Verilog的系统函数<code>$readmemh”和“$readmemb</code></p>
<p><strong>文件路径：</strong></p>
<p>​    该方法其实就是调用Verilog的系统函数<code>$readmemh”和“$readmemb</code>所以要注意文件路径的书写和数据的格式都要按照Verilog的要求书写。<strong>最好把数据文件放在resources文件夹里</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// loadmem.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util.experimental.loadMemoryFromFile<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadMem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> address = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">3.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> value   = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  <span class="hljs-keyword">val</span> memory = <span class="hljs-type">Mem</span>(<span class="hljs-number">8</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>)) <span class="hljs-comment">//定义了一个asyncMem</span><br>  io.value := memory.read(io.address)<br>  loadMemoryFromFile(memory, <span class="hljs-string">&quot;~/chisel-workspace/chisel-template/mem.txt&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>那么就会得到两个Verilog文件：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// LoadMem.v</span><br><span class="hljs-keyword">module</span> LoadMem(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] io_address,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_value<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] memory [<span class="hljs-number">0</span>:<span class="hljs-number">7</span>]; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] memory__T_data; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] memory__T_addr; <br>  <span class="hljs-keyword">assign</span> memory__T_addr = io_address;<br>  <span class="hljs-keyword">assign</span> memory__T_data = memory[memory__T_addr]; <br>  <span class="hljs-keyword">assign</span> io_value = memory__T_data;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// LoadMem.LoadMem.memory.v</span><br><span class="hljs-keyword">module</span> BindsTo_0_LoadMem(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] io_address,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_value<br>);<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  <span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;~/chisel-workspace/chisel-template/mem.txt&quot;</span>, LoadMem<span class="hljs-variable">.memory</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>在用Verilator仿真时，它会识别这个Chisel代码，从文件读取数据</strong></p>
<h2 id="4-6-计数器"><a href="#4-6-计数器" class="headerlink" title="4.6 计数器"></a>4.6 计数器</h2><p>计数器也是一个常用的硬件电路。Chisel在util包里定义了一个自增计数器原语Counter</p>
<p><strong>导入方式：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util._<br></code></pre></div></td></tr></table></figure>
<p><strong>Counter工厂方法接收两个参数的版本：</strong></p>
<ul>
<li>第一个参数是Bool类型的<strong>使能信号</strong>，为true.B时计数器从0开始每个时钟上升沿加1自增，为false.B时则计数器保持不变</li>
<li>第二个参数需要一个Int类型的<strong>具体正数</strong></li>
<li>当计数到该值时归零。该方法<strong>返回一个二元组</strong>，其第一个元素是计数器的计数值，第二个元素是判断计数值是否等于期望值的结果。</li>
</ul>
<p><strong>Counter工厂方法接收一个参数的重载版本没有使能信号</strong></p>
<p><strong>有如下示例代码：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// counter.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> valid = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())  <br>  &#125;)<br><br>  <span class="hljs-keyword">val</span> (a, b) = <span class="hljs-type">Counter</span>(io.en, <span class="hljs-number">233</span>)<br>  io.out := a<br>  io.valid := b<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>它生成的主要Verilog代码为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// MyCounter.v</span><br><span class="hljs-keyword">module</span> MyCounter(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>        io_en,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_out,<br>  <span class="hljs-keyword">output</span>       io_valid<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] value; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T; <br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_2; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T = value == <span class="hljs-number">8&#x27;he8</span>; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_2 = value + <span class="hljs-number">8&#x27;h1</span>; <br>  <span class="hljs-keyword">assign</span> io_out = value; <br>  <span class="hljs-keyword">assign</span> io_valid = io_en &amp; <span class="hljs-number">_</span>T; <br><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      value &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (io_en) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T) <span class="hljs-keyword">begin</span><br>          value &lt;= <span class="hljs-number">8&#x27;h0</span>;<br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>          value &lt;= <span class="hljs-number">_</span>T_2;<br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-7-16位线性反馈移位寄存器"><a href="#4-7-16位线性反馈移位寄存器" class="headerlink" title="4.7 16位线性反馈移位寄存器"></a>4.7 16位线性反馈移位寄存器</h2><p>如果要<strong>产生伪随机数</strong>，可以使用util包里的16位线性反馈移位寄存器原语<strong>LFSR16</strong></p>
<p><strong>导入方式：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util._<br></code></pre></div></td></tr></table></figure>
<p><strong>其定义如下所示：</strong></p>
<ul>
<li>LFSR16接收一个Bool类型的使能信号，用于控制寄存器是否移位，缺省值为true.B</li>
<li>返回一个UInt(16.W)类型的结果</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// lfsr.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFSR</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> en = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  io.out := <span class="hljs-type">LFSR16</span>(io.en)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>它生成的主要Verilog代码为：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// LFSR.v</span><br>module <span class="hljs-type">LFSR</span>(<br>  input         clock,<br>  input         reset,<br>  input         io_en,<br>  output [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] io_out<br>);<br>  reg [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] _T;<br>  wire  _T_1; <br>  wire  _T_2; <br>  wire  _T_3; <br>  wire  _T_4; <br>  wire  _T_5; <br>  wire  _T_6; <br>  wire  _T_7; <br>  wire [<span class="hljs-number">14</span>:<span class="hljs-number">0</span>] _T_8; <br>  wire [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] _T_9; <br>  assign _T_1 = _T[<span class="hljs-number">0</span>]; <br>  assign _T_2 = _T[<span class="hljs-number">2</span>]; <br>  assign _T_3 = _T_1 ^ _T_2; <br>  assign _T_4 = _T[<span class="hljs-number">3</span>]; <br>  assign _T_5 = _T_3 ^ _T_4; <br>  assign _T_6 = _T[<span class="hljs-number">5</span>]; <br>  assign _T_7 = _T_5 ^ _T_6; <br>  assign _T_8 = _T[<span class="hljs-number">15</span>:<span class="hljs-number">1</span>]; <br>  assign _T_9 = &#123;_T_7,_T_8&#125;; <br>  assign io_out = _T; <br><br>  always @(posedge clock) begin<br>    <span class="hljs-keyword">if</span> (reset) begin<br>      _T &lt;= <span class="hljs-number">16</span><span class="hljs-symbol">&#x27;h1</span>;<br>    end <span class="hljs-keyword">else</span> begin<br>      <span class="hljs-keyword">if</span> (io_en) begin<br>        _T &lt;= _T_9;<br>      end<br>    end<br>  end<br>endmodule<br></code></pre></div></td></tr></table></figure>
<h2 id="4-8-用于初始化状态位的不重复枚举"><a href="#4-8-用于初始化状态位的不重复枚举" class="headerlink" title="4.8 用于初始化状态位的不重复枚举"></a>4.8 用于初始化状态位的不重复枚举</h2><p>状态机也是常用电路，但是<strong>Chisel没有直接构建状态机的原语</strong></p>
<p><strong>不过，util包里定义了一个Enum特质及其伴生对象</strong></p>
<p><strong>导入方式：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3.util._<br></code></pre></div></td></tr></table></figure>
<p><strong>伴生对象里的apply方法定义如下：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>]<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>根据参数n返回对应元素数的List[UInt]，每个元素都是不同的</strong>，所以可以作为枚举值来使用</li>
<li>最好把枚举状态的变量名也组成一个列表，然后用列表的模式匹配来进行赋值。有了枚举值后，可以通过<code>switch…is…is</code>语句来使用。其中，switch里是相应的状态寄存器，而每个is分支的后面则是枚举值及相应的定义</li>
</ul>
<p><strong>例如检测持续时间超过两个时钟周期的高电平：</strong></p>
<p>​    <strong>注意，枚举状态名的首字母要小写，这样Scala的编译器才能识别成变量模式匹配</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// fsm.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetectTwoOnes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>  &#125;)<br><span class="hljs-comment">//sNone :: sOne1 :: sTwo1s :: Nil等价于List(sNone, sOne1, sTwo1s)</span><br><span class="hljs-comment">//下面语句的主要作用使用过Enum的伴生对象的apply方法对上面三个val赋初值</span><br>  <span class="hljs-keyword">val</span> sNone :: sOne1 :: sTwo1s :: <span class="hljs-type">Nil</span> = <span class="hljs-type">Enum</span>(<span class="hljs-number">3</span>) <br>  <span class="hljs-keyword">val</span> state = <span class="hljs-type">RegInit</span>(sNone)<br><br>  io.out := (state === sTwo1s)<br><br>  switch (state) &#123;<br>    is (sNone) &#123;<br>      when (io.in) &#123;<br>        state := sOne1<br>      &#125;<br>    &#125;<br>    is (sOne1) &#123;<br>      when (io.in) &#123;<br>        state := sTwo1s<br>      &#125; .otherwise &#123;<br>        state := sNone<br>      &#125;<br>    &#125;<br>    is (sTwo1s) &#123;<br>      when (!io.in) &#123;<br>        state := sNone<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>它生成的Verilog为：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// DetectTwoOnes.v</span><br><span class="hljs-keyword">module</span> DetectTwoOnes(<br>  <span class="hljs-keyword">input</span>   clock,<br>  <span class="hljs-keyword">input</span>   reset,<br>  <span class="hljs-keyword">input</span>   io_in,<br>  <span class="hljs-keyword">output</span>  io_out<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_1; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_2; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_3; <br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_4; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_1 = <span class="hljs-number">2&#x27;h0</span> == state; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_2 = <span class="hljs-number">2&#x27;h1</span> == state; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_3 = <span class="hljs-number">2&#x27;h2</span> == state; <br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_4 = io_in == <span class="hljs-number">1&#x27;h0</span>; <br>  <span class="hljs-keyword">assign</span> io_out = state == <span class="hljs-number">2&#x27;h2</span>;<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      state &lt;= <span class="hljs-number">2&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T_1) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (io_in) <span class="hljs-keyword">begin</span><br>          state &lt;= <span class="hljs-number">2&#x27;h1</span>;<br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T_2) <span class="hljs-keyword">begin</span><br>          <span class="hljs-keyword">if</span> (io_in) <span class="hljs-keyword">begin</span><br>            state &lt;= <span class="hljs-number">2&#x27;h2</span>;<br>          <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            state &lt;= <span class="hljs-number">2&#x27;h0</span>;<br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T_3) <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T_4) <span class="hljs-keyword">begin</span><br>              state &lt;= <span class="hljs-number">2&#x27;h0</span>;<br>            <span class="hljs-keyword">end</span><br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h1 id="5-生成Verilog与基本测试"><a href="#5-生成Verilog与基本测试" class="headerlink" title="5 生成Verilog与基本测试"></a>5 生成Verilog与基本测试</h1><p>经过前三章的内容，读者已经了解了如何使用Chisel构建一个基本的模块。本章的内容就是在此基础上，把一个Chisel模块编译成Verilog代码，并进一步使用Verilator做一些简单的测试。</p>
<h2 id="5-1-生成Verilog"><a href="#5-1-生成Verilog" class="headerlink" title="5.1 生成Verilog"></a>5.1 生成Verilog</h2><p>前面介绍Scala的内容里说过，Scala程序的入口是主函数。所以，生成Verilog的程序自然是在主函数里例化待编译的模块，然后运行这个主函数。例化待编译模块需要特殊的方法调用。chisel3包里有一个单例对象Driver，它包含一个方法execute，该方法接收两个参数，第一个参数是命令行传入的实参即字符串数组args，第二个是返回待编译模块的对象的无参函数。运行这个execute方法，就能得到Verilog代码。</p>
<p>假设在src/main/scala文件夹下有一个全加器的Chisel设计代码，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// fulladder.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullAdder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> cin = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> cout = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br>  io.s := io.a ^ io.b ^ io.cin<br>  io.cout := (io.a &amp; io.b) | ((io.a | io.b) &amp; io.cin)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接着，读者需要在src/test/scala文件夹下编写对应的主函数文件，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// fullAdderGen.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FullAdderGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">FullAdder</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在这个主函数里，只有一个execute函数的调用，第一个参数固定是“args”，第二个参数则是无参的函数字面量“() =&gt; new FullAdder”。因为Chisel的模块本质上还是Scala的class，所以只需用new构造一个对象作为返回结果即可。主函数里可以包括多个execute函数，也可以包含其它代码。还有一点要注意的是，建议把设计文件和主函数放在一个包里，比如这里的“package test”，这样省去了编写路径的麻烦。<br>要运行这个主函数，需要在build.sbt文件所在的路径下打开终端，然后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$ sbt <span class="hljs-string">&#x27;test:runMain test.FullAdderGen&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>注意，sbt后面有空格，再后面的内容都是被单引号对或双引号对包起来。其中，test:runMain是让sbt执行主函数的命令，而test.FullAdderGen就是要执行的那个主函数。</p>
<p>如果设计文件没有错误，那么最后就会看到“[success] Total time: 6 s, completed Feb 22, 2019 4:45:31 PM”这样的信息。此时，终端的路径下就会生成三个文件：FullAdder.anno.json、FullAdder.fir和FullAdder.v。</p>
<p>第一个文件用于记录传递给Firrtl编译器的Scala注解，读者可以不用关心。第二个后缀为“.fir”的文件就是对应的Firrtl代码，第三个自然是对应的Verilog文件。</p>
<p>首先查看最关心的Verilog文件，内容如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// FullAdder.v</span><br>module <span class="hljs-type">FullAdder</span>(<br>  input   clock,<br>  input   reset,<br>  input   io_a,<br>  input   io_b,<br>  input   io_cin,<br>  output  io_s,<br>  output  io_cout<br>);<br>  wire  _T; <span class="hljs-comment">// @[fulladder.scala 14:16]</span><br>  wire  _T_2; <span class="hljs-comment">// @[fulladder.scala 15:20]</span><br>  wire  _T_3; <span class="hljs-comment">// @[fulladder.scala 15:37]</span><br>  wire  _T_4; <span class="hljs-comment">// @[fulladder.scala 15:45]</span><br>  assign _T = io_a ^ io_b; <span class="hljs-comment">// @[fulladder.scala 14:16]</span><br>  assign _T_2 = io_a &amp; io_b; <span class="hljs-comment">// @[fulladder.scala 15:20]</span><br>  assign _T_3 = io_a | io_b; <span class="hljs-comment">// @[fulladder.scala 15:37]</span><br>  assign _T_4 = _T_3 &amp; io_cin; <span class="hljs-comment">// @[fulladder.scala 15:45]</span><br>  assign io_s = _T ^ io_cin; <span class="hljs-comment">// @[fulladder.scala 14:8]</span><br>  assign io_cout = _T_2 | _T_4; <span class="hljs-comment">// @[fulladder.scala 15:11]</span><br>endmodule<br></code></pre></div></td></tr></table></figure>
<p>可以看到，代码逻辑与想要表达的意思完全一致，而且对应的代码都用注释标明了来自于Chisel源文件的哪里。但由于这是通过语法分析的脚本代码得到的，所以看上去显得很笨拙、僵硬，生成了大量无用的中间变量声明。对于下游的综合器而言是一个负担，可能会影响综合器的优化。而且在进行仿真时，要理解这些中间变量也很麻烦。对后端人员来说，这也是让人头疼的问题。</p>
<p>接着再看一看Firrtl代码，内容如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// FullAdder.fir</span><br>;buildInfoPackage: chisel3, version: <span class="hljs-number">3.2</span>-<span class="hljs-type">SNAPSHOT</span>, scalaVersion: <span class="hljs-number">2.12</span><span class="hljs-number">.6</span>, sbtVersion: <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><br>circuit <span class="hljs-type">FullAdder</span> : <br>  module <span class="hljs-type">FullAdder</span> : <br>    input clock : <span class="hljs-type">Clock</span><br>    input reset : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;<br>    output io : &#123;flip a : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;, flip b : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;, flip cin : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;, s : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;, cout : <span class="hljs-type">UInt</span>&lt;<span class="hljs-number">1</span>&gt;&#125;<br>    <br>    node _T = xor(io.a, io.b) @[fulladder.scala <span class="hljs-number">14</span>:<span class="hljs-number">16</span>]<br>    node _T_1 = xor(_T, io.cin) @[fulladder.scala <span class="hljs-number">14</span>:<span class="hljs-number">23</span>]<br>    io.s &lt;= _T_1 @[fulladder.scala <span class="hljs-number">14</span>:<span class="hljs-number">8</span>]<br>    node _T_2 = and(io.a, io.b) @[fulladder.scala <span class="hljs-number">15</span>:<span class="hljs-number">20</span>]<br>    node _T_3 = or(io.a, io.b) @[fulladder.scala <span class="hljs-number">15</span>:<span class="hljs-number">37</span>]<br>    node _T_4 = and(_T_3, io.cin) @[fulladder.scala <span class="hljs-number">15</span>:<span class="hljs-number">45</span>]<br>    node _T_5 = or(_T_2, _T_4) @[fulladder.scala <span class="hljs-number">15</span>:<span class="hljs-number">28</span>]<br>    io.cout &lt;= _T_5 @[fulladder.scala <span class="hljs-number">15</span>:<span class="hljs-number">11</span>]  <br></code></pre></div></td></tr></table></figure>
<p>可以看到，Firrtl代码与它生成的Verilog代码非常接近。这种代码风格虽然不方便人工阅读，但是适合语法分析脚本使用</p>
<h2 id="5-2-在命令里增加参数"><a href="#5-2-在命令里增加参数" class="headerlink" title="5.2 在命令里增加参数"></a>5.2 在命令里增加参数</h2><h3 id="5-2-1-给Firrtl传递参数"><a href="#5-2-1-给Firrtl传递参数" class="headerlink" title="5.2.1 给Firrtl传递参数"></a>5.2.1 给Firrtl传递参数</h3><p>在运行主函数时，可以在刚才的命令后面继续增加可选的参数。例如，增加参数“—help”查看帮助菜单，运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$ sbt <span class="hljs-string">&#x27;test:runMain test.FullAdderGen --help&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>可以得到如下帮助信息： </p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">common options<br>  -tn, --top-name &lt;top-level-circuit-name&gt;<br>                           This options defines the top level circuit, defaults to dut when possible<br>  -td, --target-dir &lt;target-directory&gt;<br>                           This options defines a work directory <span class="hljs-keyword">for</span> intermediate files, default is .<br>  -ll, --log-level &lt;Error|Warn|Info|Debug|Trace&gt;<br>                           This options defines a work directory <span class="hljs-keyword">for</span> intermediate files, default is .<br>  -cll, --class-log-level &lt;FullClassName:[Error|Warn|Info|Debug|Trace]&gt;[,...]<br>                           This options defines a work directory <span class="hljs-keyword">for</span> intermediate files, default is .<br>  -ltf, --log-to-file      default logs to stdout, this flags writes to topName.log or firrtl.log <span class="hljs-keyword">if</span> no topName<br>  -lcn, --log-class-names  shows class names and <span class="hljs-built_in">log</span> level <span class="hljs-keyword">in</span> logging output, useful <span class="hljs-keyword">for</span> target --class-log-level<br>  --<span class="hljs-built_in">help</span>                   prints this usage text<br>  &lt;arg&gt;...                 optional unbounded args<br>chisel3 options<br>  -chnrf, --no-run-firrtl  Stop after chisel emits chirrtl file<br>firrtl options<br>  -i, --input-file &lt;firrtl-source&gt;<br>                           use this to override the default input file name , default is empty<br>  -o, --output-file &lt;output&gt;<br>                           use this to override the default output file name, default is empty<br>  -faf, --annotation-file &lt;input-anno-file&gt;<br>                           Used to specify annotation files (can appear multiple <span class="hljs-built_in">times</span>)<br>  -foaf, --output-annotation-file &lt;output-anno-file&gt;<br>                           use this to <span class="hljs-built_in">set</span> the annotation output file<br>  -X, --compiler &lt;high|middle|low|verilog|sverilog&gt;<br>                           compiler to use, default is verilog<br> --info-mode &lt;ignore|use|gen|append&gt;<br>                           specifies the <span class="hljs-built_in">source</span> info handling, default is append<br>  -fct, --custom-transforms &lt;package&gt;.&lt;class&gt;<br>                           runs these custom transforms during compilation.<br>  -fil, --inline &lt;circuit&gt;[.&lt;module&gt;[.&lt;instance&gt;]][,..],<br>                           Inline one or more module (comma separated, no spaces) module looks like <span class="hljs-string">&quot;MyModule&quot;</span> or <span class="hljs-string">&quot;MyModule.myinstance</span><br><span class="hljs-string">  -firw, --infer-rw        Enable readwrite port inference for the target circuit</span><br><span class="hljs-string">  -frsq, --repl-seq-mem -c:&lt;circuit&gt;:-i:&lt;filename&gt;:-o:&lt;filename&gt;</span><br><span class="hljs-string">                           Replace sequential memories with blackboxes + configuration file</span><br><span class="hljs-string">  -clks, --list-clocks -c:&lt;circuit&gt;:-m:&lt;module&gt;:-o:&lt;filename&gt;</span><br><span class="hljs-string">                           List which signal drives each clock of every descendent of specified module</span><br><span class="hljs-string">  -fsm, --split-modules    Emit each module to its own file in the target directory.</span><br><span class="hljs-string">  --no-check-comb-loops    Do NOT check for combinational loops (not recommended)</span><br><span class="hljs-string">  --no-dce                 Do NOT run dead code elimination </span><br></code></pre></div></td></tr></table></figure>
<p>例如，最常用的是参数“-td”，可以在后面指定一个文件夹，这样之前生成的三个文件就在该文件夹里，而不是在当前路径下。其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$ sbt <span class="hljs-string">&#x27;test:runMain test.FullAdderGen -td ./generated/fulladder&#x27;</span> <br></code></pre></div></td></tr></table></figure>
<h3 id="5-2-2-给主函数传递参数"><a href="#5-2-2-给主函数传递参数" class="headerlink" title="5.2.2 给主函数传递参数"></a>5.2.2 给主函数传递参数</h3><p>Scala的类可以接收参数，自然Chisel的模块也可以接收参数。假设要构建一个n位的加法器，具体位宽不确定，根据需要而定。那么，就可以把端口位宽参数化，例化时传入想要的参数即可。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// adder.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-keyword">import</span> chisel3._<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adder</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(n.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(n.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(n.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> cout = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br> <br>  io.s := (io.a +&amp; io.b)(n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)<br>  io.cout := (io.a +&amp; io.b)(n)<br>&#125;<br> <br><span class="hljs-comment">// adderGen.scala</span><br><span class="hljs-keyword">package</span> test<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AdderGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">Adder</span>(args(<span class="hljs-number">0</span>).toInt))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在这里，模块Adder的主构造方法接收一个Int类型的参数n，然后用n去定义端口位宽。主函数在例化这个模块时，就要给出相应的参数。前面的帮助菜单里显示，在运行sbt命令时，可以传入若干个独立的参数。和运行Scala的主函数一样，这些命令行的参数也可以由字符串数组args通过下标来索引。从要运行的主函数后面开始，后面的内容都是按空格划分、从下标0开始的args的元素。比如例子中的主函数期望第一个参数即args(0)是一个数字字符串，这样就能通过方法toInt转换成Adder所需的参数。</p>
<p>​        执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$  sbt <span class="hljs-string">&#x27;test:runMain test.AdderGen 8 -td ./generated/adder&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>可以在相应的文件夹下得到如下Verilog代码，其中位宽的确是8位的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Adder.v</span><br>module <span class="hljs-type">Adder</span>(<br>  input        clock,<br>  input        reset,<br>  input  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_a,<br>  input  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_b,<br>  output [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] io_s,<br>  output       io_cout<br>);<br>  wire [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] _T; <br>  assign _T = io_a + io_b; <br>  assign io_s = _T[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]; <br>  assign io_cout = _T[<span class="hljs-number">8</span>];<br>endmodule<br></code></pre></div></td></tr></table></figure>
<h2 id="5-3-编写简单的测试"><a href="#5-3-编写简单的测试" class="headerlink" title="5.3 编写简单的测试"></a>5.3 编写简单的测试</h2><p>Chisel的测试有两种，第一种是利用Scala的测试来验证Chisel级别的代码逻辑有没有错误。因为这部分内容比较复杂，而且笔者目前也没有深入学习有关Scala测试的内容，所以这部分内容可有读者自行选择研究。第二种是利用Chisel库里的peek和poke函数，给模块的端口加激励、查看信号值，并交由下游的Verilator来仿真、产生波形。这种方式比较简单，类似于Verilog的testbench，适合小型电路的验证。对于超大型的系统级电路，最好还是生成Verilog，交由成熟的EDA工具，用UVM进行验证。</p>
<p>要编写一个简单的testbench，首先也是定义一个类，这个类的主构造方法接收一个参数，参数类型就是待测模块的类名。因为模块也是一个类，从Scala的角度来看，一个类就是定义了一种类型。其次，这个类继承自PeekPokeTester类，并且把接收的待测模块也传递给此超类。最后，测试类内部有四种方法可用：①“poke(端口，激励值)”方法给相应的端口添加想要的激励值，激励值是Int类型的；②“peek(端口)”方法返回相应的端口的当前值；③“expect(端口，期望值)”方法会对第一个参数(端口)使用peek方法，然后与Int类型的期望值进行对比，如果两者不相等则出错；④“step(n)”方法则让仿真前进n个时钟周期。</p>
<p>因为测试模块只用于仿真，无需转成Verilog，所以类似for、do…while、to、until、map等Scala高级语法都可以使用，帮助测试代码更加简洁有效。</p>
<p>如下所示是一个对前一例中的8位加法器的testbench：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// addertest.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> scala.util._<br><span class="hljs-keyword">import</span> chisel3.iotesters._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdderTest</span>(<span class="hljs-params">c: <span class="hljs-type">Adder</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PeekPokeTester</span>(<span class="hljs-params">c</span>) </span>&#123;<br>  <span class="hljs-keyword">val</span> randNum = <span class="hljs-keyword">new</span> <span class="hljs-type">Random</span><br>  <span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">0</span> until <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-keyword">val</span> a = randNum.nextInt(<span class="hljs-number">256</span>)<br>    <span class="hljs-keyword">val</span> b = randNum.nextInt(<span class="hljs-number">256</span>)<br>    poke(c.io.a, a)<br>    poke(c.io.b, b)<br>    step(<span class="hljs-number">1</span>)<br>    expect(c.io.s, (a + b) &amp; <span class="hljs-number">0xff</span>)<br>    expect(c.io.cout, ((a + b) &amp; <span class="hljs-number">0x100</span>) &gt;&gt; <span class="hljs-number">8</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>其中，第一个包scala.util里包含了Scala生成伪随机数的类Random，第二个包chisel3.iotesters包含了测试类PeekPokeTester。</p>
<h2 id="5-4-运行测试"><a href="#5-4-运行测试" class="headerlink" title="5.4 运行测试"></a>5.4 运行测试</h2><p>要运行测试，自然也是通过主函数，但是这次是使用iotesters包里的execute方法。该方法与前面生成Verilog的方法类似，仅仅是多了一个参数列表，多出的第二个参数列表接收一个返回测试类的对象的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// addertest.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AdderTestGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.iotesters.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">Adder</span>(<span class="hljs-number">8</span>))(c =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">AdderTest</span>(c))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$  sbt <span class="hljs-string">&#x27;test:runMain test.AdderTestGen -td ./generated/addertest --backend-name verilator&#x27;</span> <br></code></pre></div></td></tr></table></figure>
<p>执行成功后，就能在相应文件夹里看到一个新生成的文件夹，里面是仿真生成的文件。其中，“Adder.vcd”文件就是波形文件，使用GTKWave软件打开就能查看，将相应的端口拖拽到右侧就能显示波形。</p>
<p>如果只想在终端查看仿真运行的信息，则执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">esperanto@ubuntu:~/chisel-template$  sbt <span class="hljs-string">&#x27;test:runMain test.AdderTestGen -td ./generated/addertest --is-verbose&#x27;</span> <br></code></pre></div></td></tr></table></figure>
<p>那么终端就会显示如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[info] [0.002] SEED 1550906002475<br>[info] [0.005]   POKE io_a &lt;- 184<br>[info] [0.006]   POKE io_b &lt;- 142<br>[info] [0.006] STEP 0 -&gt; 1<br>[info] [0.007] EXPECT AT 1   io_s got 70 expected 70 PASS<br>[info] [0.008] EXPECT AT 1   io_cout got 1 expected 1 PASS<br>[info] [0.008]   POKE io_a &lt;- 114<br>[info] [0.009]   POKE io_b &lt;- 231<br>[info] [0.009] STEP 1 -&gt; 2<br>[info] [0.009] EXPECT AT 2   io_s got 89 expected 89 PASS<br>[info] [0.009] EXPECT AT 2   io_cout got 1 expected 1 PASS<br>[info] [0.010]   POKE io_a &lt;- 183<br>[info] [0.010]   POKE io_b &lt;- 168<br>[info] [0.010] STEP 2 -&gt; 3<br>[info] [0.011] EXPECT AT 3   io_s got 95 expected 95 PASS<br>[info] [0.011] EXPECT AT 3   io_cout got 1 expected 1 PASS<br>[info] [0.012]   POKE io_a &lt;- 223<br>[info] [0.012]   POKE io_b &lt;- 106<br>[info] [0.012] STEP 3 -&gt; 4<br>[info] [0.012] EXPECT AT 4   io_s got 73 expected 73 PASS<br>[info] [0.013] EXPECT AT 4   io_cout got 1 expected 1 PASS<br>[info] [0.013]   POKE io_a &lt;- 12<br>[info] [0.013]   POKE io_b &lt;- 182<br>[info] [0.013] STEP 4 -&gt; 5<br>[info] [0.014] EXPECT AT 5   io_s got 194 expected 194 PASS<br>[info] [0.014] EXPECT AT 5   io_cout got 0 expected 0 PASS<br>[info] [0.014]   POKE io_a &lt;- 52<br>[info] [0.014]   POKE io_b &lt;- 41<br>[info] [0.015] STEP 5 -&gt; 6<br>[info] [0.015] EXPECT AT 6   io_s got 93 expected 93 PASS<br>[info] [0.016] EXPECT AT 6   io_cout got 0 expected 0 PASS<br>[info] [0.016]   POKE io_a &lt;- 187<br>[info] [0.017]   POKE io_b &lt;- 60<br>[info] [0.017] STEP 6 -&gt; 7<br>[info] [0.017] EXPECT AT 7   io_s got 247 expected 247 PASS<br>[info] [0.018] EXPECT AT 7   io_cout got 0 expected 0 PASS<br>[info] [0.018]   POKE io_a &lt;- 218<br>[info] [0.019]   POKE io_b &lt;- 203<br>[info] [0.019] STEP 7 -&gt; 8<br>[info] [0.019] EXPECT AT 8   io_s got 165 expected 165 PASS<br>[info] [0.020] EXPECT AT 8   io_cout got 1 expected 1 PASS<br>[info] [0.020]   POKE io_a &lt;- 123<br>[info] [0.021]   POKE io_b &lt;- 115<br>[info] [0.021] STEP 8 -&gt; 9<br>[info] [0.021] EXPECT AT 9   io_s got 238 expected 238 PASS<br>[info] [0.022] EXPECT AT 9   io_cout got 0 expected 0 PASS<br>[info] [0.022]   POKE io_a &lt;- 17<br>[info] [0.022]   POKE io_b &lt;- 197<br>[info] [0.023] STEP 9 -&gt; 10<br>[info] [0.023] EXPECT AT 10   io_s got 214 expected 214 PASS<br>[info] [0.024] EXPECT AT 10   io_cout got 0 expected 0 PASS<br><span class="hljs-built_in">test</span> Adder Success: 20 tests passed <span class="hljs-keyword">in</span> 15 cycles <span class="hljs-keyword">in</span> 0.047415 seconds 316.36 Hz<br>[info] [0.025] RAN 10 CYCLES PASSED<br>[success] Total time: 7 s, completed Feb 23, 2019 3:13:26 PM <br></code></pre></div></td></tr></table></figure>
<h2 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h2><p>本章介绍了从Chisel转换成Verilog、测试设计的基本方法。因为Chisel还在更新中，这些方法也是从Chisel2里保留下来的。将来也许会有更便捷的方式，读者可以留意</p>
<h1 id="6-黑盒"><a href="#6-黑盒" class="headerlink" title="6 黑盒"></a>6 黑盒</h1><p>因为Chisel的功能相对Verilog来说还不完善，所以设计人员在当前版本下无法实现的功能，就需要用Verilog来实现。在这种情况下，可以使用Chisel的BlackBox功能，它的作用就是向Chisel代码提供了用Verilog设计的电路的接口，使得Chisel层面的代码可以通过模块的端口来进行交互。</p>
<h2 id="6-1-例化黑盒"><a href="#6-1-例化黑盒" class="headerlink" title="6.1 例化黑盒"></a>6.1 例化黑盒</h2><p>如果读者尝试在Chisel的模块里例化另一个模块，然后生成Verilog代码，就会发现端口名字里多了“io_”这样的字眼。很显然，这是因为Chisel要求模块的端口都是由字段“io”来引用的，语法分析脚本在生成Verilog代码时会保留这个端口名前缀。</p>
<p>假设有一个外部的Verilog模块，它的端口列表声明如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Dut ( <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>: <span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> reset, <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>: <span class="hljs-number">0</span>] b );<br></code></pre></div></td></tr></table></figure>
<p>按照Verilog的语法，它的例化代码应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs veriilog">Dut u0 ( .a(u0_a), .clk(u0_clk), .reset(u0_reset), .b(u0_b) ); <br></code></pre></div></td></tr></table></figure>
<p>其中，例化时的名字和连接的线网名是可以任意的，但是模块名“Dut”和端口名“.a”、“.clk”、“.reset”、 “.b”是固定的。</p>
<p>倘若把这个Verilog模块声明成普通的Chisel模块，然后直接例化使用，那么例化的Verilog代码就会变成：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">Dut u0 ( <span class="hljs-variable">.io_a</span>(io_u0_a), <span class="hljs-variable">.io_clk</span>(io_u0_clk), <span class="hljs-variable">.io_reset</span>(io_u0_reset), <span class="hljs-variable">.io_b</span>(io_u0_b) );<br></code></pre></div></td></tr></table></figure>
<p>也就是说，本来应该是“.a”，变成了“.io_a”。当然，这样做首先在Chisel层面上就不会成功，因为Chisel的编译器不允许模块内部连线为空，不能只有端口声明而没有内部连线的模块。</p>
<p>如果定义Dut类时，不是继承自Module，而是继承自BlackBox，则允许只有端口定义，也只需要端口定义。此外，在别的模块里例化黑盒时，编译器不会给黑盒的端口名加上“io_”，连接的线网名变成引用黑盒的变量名与黑盒端口名的组合。例如： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// blackbox.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> clk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseDut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> toDut_a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> toDut_b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  <span class="hljs-keyword">val</span> u0 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Dut</span>)<br><br>  u0.io.a := io.toDut_a<br>  u0.io.clk := clock<br>  u0.io.reset := reset<br>  io.toDut_b := u0.io.b<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UseDutTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">UseDut</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它对应生成的Verilog代码为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// UseDut.v</span><br><span class="hljs-keyword">module</span> UseDut(<br>  <span class="hljs-keyword">input</span>         clock,<br>  <span class="hljs-keyword">input</span>         reset,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] io_toDut_a,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  io_toDut_b<br>);<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] u0_a; <span class="hljs-comment">// @[blackbox.scala 20:18]</span><br>  <span class="hljs-keyword">wire</span>  u0_clk; <span class="hljs-comment">// @[blackbox.scala 20:18]</span><br>  <span class="hljs-keyword">wire</span>  u0_reset; <span class="hljs-comment">// @[blackbox.scala 20:18]</span><br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] u0_b; <span class="hljs-comment">// @[blackbox.scala 20:18]</span><br>  Dut u0 ( <span class="hljs-comment">// @[blackbox.scala 20:18]</span><br>    <span class="hljs-variable">.a</span>(u0_a),<br>    <span class="hljs-variable">.clk</span>(u0_clk),<br>    <span class="hljs-variable">.reset</span>(u0_reset),<br>    <span class="hljs-variable">.b</span>(u0_b)<br>  );<br>  <span class="hljs-keyword">assign</span> io_toDut_b = u0_b; <span class="hljs-comment">// @[blackbox.scala 25:14]</span><br>  <span class="hljs-keyword">assign</span> u0_a = io_toDut_a; <span class="hljs-comment">// @[blackbox.scala 22:11]</span><br>  <span class="hljs-keyword">assign</span> u0_clk = clock; <span class="hljs-comment">// @[blackbox.scala 23:13]</span><br>  <span class="hljs-keyword">assign</span> u0_reset = reset; <span class="hljs-comment">// @[blackbox.scala 24:15]</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>可以看到，例化黑盒生成的Verilog代码，完全符合Verilog例化模块的语法规则。通过黑盒导入Verilog模块的端口列表给Chisel模块使用，然后把Chisel代码转换成Verilog，把它与导入的Verilog一同传递给EDA工具使用。</p>
<p>BlackBox的构造方法可以接收一个Map[String, Param]类型的参数，这会使得例化外部的Verilog模块时具有配置模块的“#(参数配置)”。映射的键固定是字符串类型，它对应Verilog里声明的参数名；映射的值对应传入的配置参数，可以是字符串，也可以是整数和浮点数。虽然值的类型是Param，这是一个Chisel的印章类，但是单例对象chisel3.experimental里定义了相应的隐式转换，可以把BigInt、Int、Long、Double和String转换成对应的Param类型。例如把上例修改成： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">...<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span>(<span class="hljs-params"><span class="hljs-type">Map</span>(&quot;<span class="hljs-type">DATA_WIDTH</span>&quot; -&gt; 32,</span></span><br><span class="hljs-params"><span class="hljs-class">                               &quot;<span class="hljs-type">MODE</span>&quot; -&gt; &quot;<span class="hljs-type">Sequential</span>&quot;,</span></span><br><span class="hljs-params"><span class="hljs-class">                               &quot;<span class="hljs-type">RESET</span>&quot; -&gt; &quot;<span class="hljs-type">Asynchronous</span>&quot;</span>)) </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> clk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>对应的Verilog就变成了：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">...<br>  <span class="hljs-type">Dut</span> #(.<span class="hljs-type">DATA_WIDTH</span>(<span class="hljs-number">32</span>), .<span class="hljs-type">MODE</span>(<span class="hljs-string">&quot;Sequential&quot;</span>), .<span class="hljs-type">RESET</span>(<span class="hljs-string">&quot;Asynchronous&quot;</span>)) u0 ( <span class="hljs-comment">// @[blackbox.scala 23:18]</span><br>    .a(u0_a),<br>    .clk(u0_clk),<br>    .reset(u0_reset),<br>    .b(u0_b)<br>  );<br>...<br></code></pre></div></td></tr></table></figure>
<p>通过这种方式，借助Verilog把Chisel的功能暂时补齐了。比如UCB发布的Rocket-Chip，就是用黑盒导入异步寄存器，供内部代码使用。</p>
<h2 id="6-2-复制Verilog文件"><a href="#6-2-复制Verilog文件" class="headerlink" title="6.2 复制Verilog文件"></a>6.2 复制Verilog文件</h2><p>chisel3.util包里有一个特质HasBlackBoxResource，如果在黑盒类里混入这个特质，并且在src/main/resources文件夹里有对应的Verilog源文件，那么在Chisel转换成Verilog时，就会把Verilog文件一起复制到目标文件夹。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">...<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> <span class="hljs-keyword">with</span> <span class="hljs-title">HasBlackBoxResource</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> clk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  setResource(<span class="hljs-string">&quot;/dut.v&quot;</span>)<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>注意，相比一般的黑盒，除了端口列表的声明，还多了一个特质里的setResource方法的调用。方法的入参是Verilog文件的相对地址，即相对src/main/resources的地址。</p>
<h2 id="6-3-内联Verilog文件"><a href="#6-3-内联Verilog文件" class="headerlink" title="6.3 内联Verilog文件"></a>6.3 内联Verilog文件</h2><p>chisel3.util包里还有有一个特质HasBlackBoxInline，混入该特质的黑盒类可以把Verilog代码直接内嵌进去。内嵌的方式是调用特质里的方法“setInline(blackBoxName: String, blackBoxInline: String)”，类似于setResource的用法。这样，目标文件夹里就会生成一个单独的Verilog文件，复制内嵌的代码。该方法适合小型Verilog设计。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">...<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> <span class="hljs-keyword">with</span> <span class="hljs-title">HasBlackBoxInline</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> clk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  setInline(<span class="hljs-string">&quot;dut.v&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            |module dut(input [31:0] a,</span><br><span class="hljs-string">            |           input clk,</span><br><span class="hljs-string">            |           input reset,</span><br><span class="hljs-string">            |           output [3:0] b);</span><br><span class="hljs-string">            |  </span><br><span class="hljs-string">            |  reg [3:0] b_temp;</span><br><span class="hljs-string">            |</span><br><span class="hljs-string">            |  always @ (posedge clk, negedge reset)</span><br><span class="hljs-string">            |    if(!reset)</span><br><span class="hljs-string">            |      b_temp &lt;= &#x27;b0;</span><br><span class="hljs-string">            |    else if(a == &#x27;b0)</span><br><span class="hljs-string">            |      b_temp &lt;= b_temp + 1&#x27;b1</span><br><span class="hljs-string">            |</span><br><span class="hljs-string">            |  assign b = b_temp;</span><br><span class="hljs-string">            |endmodule</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>.stripMargin)<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>字符串中的“ | ”表示文件的边界，比如Scala的解释器在换行后的开头就是一根竖线，方法stripMargin用于消除竖线左侧的空格。</p>
<p>调用这个黑盒的模块在转换成Verilog后，目标文件夹里会生成一个“dut.v”文件，内容就是内嵌的Verilog代码。</p>
<h2 id="6-4-inout端口"><a href="#6-4-inout端口" class="headerlink" title="6.4 inout端口"></a>6.4 inout端口</h2><p>Chisel目前只支持在黑盒中引入Verilog的inout端口。Bundle中使用 “Analog(位宽)”声明Analog类型的端口，经过编译后变成Verilog的inout端口。模块里的端口可以声明成Analog类型，但只能用于与黑盒连接，不能在Chisel代码中进行读写。因为是双向端口，所以不需要用Input或Output指明方向，但是可以用Flipped来翻转，也就不会影响整个Bundle的翻转。使用前，要先用“chisel3.experimental._”进行导入。</p>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// inout.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InoutIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> a = <span class="hljs-type">Analog</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> c = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">16.</span><span class="hljs-type">W</span>))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InoutPort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> <span class="hljs-keyword">with</span> <span class="hljs-title">HasBlackBoxInline</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InoutIO</span>)<br><br>  setInline(<span class="hljs-string">&quot;InoutPort.v&quot;</span>,<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    |module InoutPort( inout [15:0] a,</span><br><span class="hljs-string">    |                  input [15:0] b,</span><br><span class="hljs-string">    |                  input        sel,</span><br><span class="hljs-string">    |                  output [15:0] c);</span><br><span class="hljs-string">    |  assign a = sel ? &#x27;bz : b;</span><br><span class="hljs-string">    |  assign c = sel ? a : &#x27;bz;</span><br><span class="hljs-string">    |endmodule</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.stripMargin)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeInout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InoutIO</span>)<br><br>  <span class="hljs-keyword">val</span> m = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InoutPort</span>)<br><br>  m.io &lt;&gt; io<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">InoutGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">MakeInout</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对应的Verilog为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// MakeInout.v</span><br><span class="hljs-keyword">module</span> MakeInout(<br>  <span class="hljs-keyword">input</span>         clock,<br>  <span class="hljs-keyword">input</span>         reset,<br>  <span class="hljs-keyword">inout</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] io_a,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] io_b,<br>  <span class="hljs-keyword">input</span>         io_sel,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] io_c<br>);<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] m_b; <span class="hljs-comment">// @[inout.scala 32:17]</span><br>  <span class="hljs-keyword">wire</span>  m_sel; <span class="hljs-comment">// @[inout.scala 32:17]</span><br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] m_c; <span class="hljs-comment">// @[inout.scala 32:17]</span><br>  InoutPort m ( <span class="hljs-comment">// @[inout.scala 32:17]</span><br>    <span class="hljs-variable">.a</span>(io_a),<br>    <span class="hljs-variable">.b</span>(m_b),<br>    <span class="hljs-variable">.sel</span>(m_sel),<br>    <span class="hljs-variable">.c</span>(m_c)<br>  );<br>  <span class="hljs-keyword">assign</span> io_c = m_c; <span class="hljs-comment">// @[inout.scala 34:8]</span><br>  <span class="hljs-keyword">assign</span> m_b = io_b; <span class="hljs-comment">// @[inout.scala 34:8]</span><br>  <span class="hljs-keyword">assign</span> m_sel = io_sel; <span class="hljs-comment">// @[inout.scala 34:8]</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>本章介绍了三种黑盒的用法，其目的在于通过外部的Verilog文件来补充Chisel还没有的功能。除此之外，由于还没有EDA工具直接支持Chisel，比如在开发FPGA项目时，要例化Xilinx或Altera的IP，就需要用到黑盒。</p>
<h1 id="第二十二章-Chisel基础——多时钟域设计"><a href="#第二十二章-Chisel基础——多时钟域设计" class="headerlink" title="第二十二章 Chisel基础——多时钟域设计"></a>第二十二章 Chisel基础——多时钟域设计</h1><p>在数字电路中免不了用到多时钟域设计，尤其是设计异步FIFO这样的同步元件。在Verilog里，多时钟域的设计很简单，只需声明多个时钟端口，然后不同的always语句块根据需要选择不同的时钟作为敏感变量即可。在Chisel里，则相对复杂一些，因为这与Scala的变量作用域相关，而且时序元件在编译时都是自动地隐式跟随当前时钟域。本章将介绍多时钟域设计的语法，这其实很简单。</p>
<h2 id="7-1-没有隐式端口的模块"><a href="#7-1-没有隐式端口的模块" class="headerlink" title="7.1 没有隐式端口的模块"></a>7.1 没有隐式端口的模块</h2><p>继承自Module的模块类会获得隐式的全局时钟与同步复位信号，即使在设计中用不上它们也没关系。如果读者确实不喜欢这两个隐式端口，则可以选择继承自RawModule，这样在转换成Verilog时就没有隐式端口。它是单例对象chisel3.experimental里定义的类型，也就是UserModule类的别名。</p>
<p>这样的模块一般用于纯组合逻辑。在类内顶层不能出现使用时钟的相关操作，比如定义寄存器，否则会报错没有隐式端口。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// module.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RawModule</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>  io.c := io.a &amp; io.b<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ModuleGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它生成的Verilog代码为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// MyModule.v</span><br><span class="hljs-keyword">module</span> MyModule(<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_a,<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_b,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_c<br>);<br>  <span class="hljs-keyword">assign</span> io_c = io_a &amp; io_b; <span class="hljs-comment">// @[module.scala 13:8]</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>RawModule也可以包含时序逻辑，但要使用多时钟域语法。</p>
<h2 id="7-2-定义一个时钟域和复位域"><a href="#7-2-定义一个时钟域和复位域" class="headerlink" title="7.2 定义一个时钟域和复位域"></a>7.2 定义一个时钟域和复位域</h2><p>chisel3.core包里有一个单例对象withClockAndReset，其apply方法定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">T</span>](clock: <span class="hljs-type">Clock</span>, reset: <span class="hljs-type">Reset</span>)(block: ⇒ <span class="hljs-type">T</span>): <span class="hljs-type">T</span><br></code></pre></div></td></tr></table></figure>
<p>该方法的作用就是创建一个新的时钟和复位域，作用范围仅限于它的传名参数的内部。新的时钟和复位信号就是第一个参数列表的两个参数。注意，在编写代码时不能写成<code>import chisel3.core._</code>，这会扰乱<code>import chisel3._</code>的导入内容。正确做法是用<code>import chisel3.experimental._</code>导入<code>experimental</code>对象，它里面用同名字段引用了单例对象<code>chisel3.core.withClockAndReset</code>，这样就不需要再导入<code>core</code>包。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiClockModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;undefined<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;undefined<br>       <span class="hljs-keyword">val</span> clockB = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>       <span class="hljs-keyword">val</span> resetB = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>       <span class="hljs-keyword">val</span> stuff = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>   &#125;)<br>   <span class="hljs-comment">// 这个寄存器跟随当前模块的隐式全局时钟clock</span><br>   <span class="hljs-keyword">val</span> regClock1 = <span class="hljs-type">RegNext</span>(io.stuff)<br><br>   withClockAndReset(io.clockB, io.resetB) &#123;undefined<br>       <span class="hljs-comment">// 在该花括号内，所有时序元件都跟随时钟io.clockB</span><br>       <span class="hljs-comment">// 所有寄存器的复位信号都是io.resetB</span><br><br>       <span class="hljs-comment">// 这个寄存器跟随io.clockB</span><br>       <span class="hljs-keyword">val</span> regClockB = <span class="hljs-type">RegNext</span>(io.stuff)<br>       <span class="hljs-comment">// 还可以例化其它模块</span><br>       <span class="hljs-keyword">val</span> m = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ChildModule</span>)<br>    &#125;<br><br>   <span class="hljs-comment">// 这个寄存器跟随当前模块的隐式全局时钟clock</span><br>   <span class="hljs-keyword">val</span> regClock2 = <span class="hljs-type">RegNext</span>(io.stuff)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因为第二个参数列表只有一个传名参数，所以可以把圆括号写成花括号，这样还有自动的分号推断。再加上传名参数的特性，尽管需要一个无参函数，但是可以省略书写“() =&gt;”。所以，</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">withClockAndReset(io.clockB, io.resetB) &#123;undefined<br>    sentence1<br>    sentence2<br>    ...<br>    sentenceN<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>实际上相当于：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">withClockAndReset(io.clockB, io.resetB)( () =&gt; (sentence1; sentence2; ...; sentenceN) )<br></code></pre></div></td></tr></table></figure>
<p>这结合了Scala的柯里化、传名参数和单参数列表的语法特性，让DSL语言的自定义方法看上去就跟内建的while、for、if等结构一样自然，所以Scala很适合构建DSL语言。</p>
<p>读者再仔细看一看apply方法的定义，它的第二个参数是一个函数，同时该函数的返回结果也是整个apply方法的返回结果。也就是说，独立时钟域的定义里，最后一个表达式的结果会被当作函数的返回结果。可以用一个变量来引用这个返回结果，这样在独立时钟域的定义外也能使用。例如引用最后返回的模块：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiClockModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;undefined<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;undefined<br>       <span class="hljs-keyword">val</span> clockB = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>       <span class="hljs-keyword">val</span> resetB = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>       <span class="hljs-keyword">val</span> stuff = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>   &#125;)<br><br>   <span class="hljs-keyword">val</span> clockB_child = withClockAndReset(io.clockB, io.resetB) &#123;undefined<br>       <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ChildModule</span>)<br>    &#125;<br><br>   clockB_child.io.in := io.stuff  <br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>如果传名参数全都是定义，最后没有表达式用于返回，那么apply的返回结果类型自然就是Unit。此时，外部不能访问独立时钟域里的任何内容。例如把上个例子改成如下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiClockModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;undefined<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;undefined<br>       <span class="hljs-keyword">val</span> clockB = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>       <span class="hljs-keyword">val</span> resetB = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>       <span class="hljs-keyword">val</span> stuff = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>   &#125;)<br><br>   <span class="hljs-keyword">val</span> clockB_child = withClockAndReset(io.clockB, io.resetB) &#123;undefined<br>       <span class="hljs-keyword">val</span> m = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ChildModule</span>)<br>    &#125;<br><br>   clockB_child.m.io.in := io.stuff  <br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>现在，被例化的模块不是作为返回结果，而是变成了变量m的引用对象，故而传名参数是只有定义、没有有用的返回值的空函数。如果编译这个模块，就会得到“没有相关成员”的错误信息： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">[error] /home/esperanto/chisel-template/src/main/scala/module.scala:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>: value m is not a member of <span class="hljs-type">Unit</span><br>[error]   clockB_child.m.io.in := io.stuff<br>[error]                ^ <br></code></pre></div></td></tr></table></figure>
<p>如果独立时钟域有多个变量要与外部交互，则应该在模块内部的顶层定义全局的线网，让所有时钟域都能访问。</p>
<p>除了单例对象withClockAndReset，还有单例对象withClock和withReset，分别用于构建只有独立时钟和只有独立复位信号的作用域，三者的语法是一样的。</p>
<h2 id="7-3-使用时钟负沿和低有效的复位信号"><a href="#7-3-使用时钟负沿和低有效的复位信号" class="headerlink" title="7.3 使用时钟负沿和低有效的复位信号"></a>7.3 使用时钟负沿和低有效的复位信号</h2><p>默认情况下，声明的时序元件都是以时钟的正沿和高有效的复位信号作为敏感变量，但是在多时钟域的语法里，可以改变其行为。复位信号比较简单，只需要加上取反符号或逻辑非符号。时钟信号稍微麻烦一些，需要先用asUInt方法把Clock类型转换成UInt类型，再用toBool转换成Bool类型，此时可以加上取反符号或逻辑非符号，最后再用asClock变回Clock类型。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// negclkrst.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NegativeClkRst</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RawModule</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> myClk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> myRst = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>  withClockAndReset((~io.myClk.asUInt.toBool).asClock, ~io.myRst) &#123;<br>    <span class="hljs-keyword">val</span> temp = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    temp := io.in<br>    io.out := temp<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NegClkRstGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">NegativeClkRst</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它生成的Verilog主要是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// NegativeClkRst.v</span><br><span class="hljs-keyword">module</span> NegativeClkRst(<br>  <span class="hljs-keyword">input</span>  [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_in,<br>  <span class="hljs-keyword">input</span>        io_myClk,<br>  <span class="hljs-keyword">input</span>        io_myRst,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_out<br>);<br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T; <span class="hljs-comment">// @[negclkrst.scala 14:32]</span><br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_2; <span class="hljs-comment">// @[negclkrst.scala 14:22]</span><br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_3; <span class="hljs-comment">// @[negclkrst.scala 14:47]</span><br>  <span class="hljs-keyword">wire</span>  <span class="hljs-number">_</span>T_4; <span class="hljs-comment">// @[negclkrst.scala 14:56]</span><br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_5; <span class="hljs-comment">// @[negclkrst.scala 15:23]</span><br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T = <span class="hljs-built_in">$unsigned</span>(io_myClk); <span class="hljs-comment">// @[negclkrst.scala 14:32]</span><br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_2 = ~ <span class="hljs-number">_</span>T; <span class="hljs-comment">// @[negclkrst.scala 14:22]</span><br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_3 = <span class="hljs-number">_</span>T_2; <span class="hljs-comment">// @[negclkrst.scala 14:47]</span><br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_4 = ~ io_myRst; <span class="hljs-comment">// @[negclkrst.scala 14:56]</span><br>  <span class="hljs-keyword">assign</span> io_out = <span class="hljs-number">_</span>T_5; <span class="hljs-comment">// @[negclkrst.scala 17:12]</span><br><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> <span class="hljs-number">_</span>T_3) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">_</span>T_4) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_5 &lt;= <span class="hljs-number">4&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T_5 &lt;= io_in;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="7-4-示例：异步FIFO"><a href="#7-4-示例：异步FIFO" class="headerlink" title="7.4 示例：异步FIFO"></a>7.4 示例：异步FIFO</h2><p>在跨时钟域设计中，经常需要使用异步FIFO来同步不同时钟域的数据传输。下面是笔者自己编写的一个异步FIFO例子，数据位宽和深度都是参数化的，读、写地址指针的交互采用格雷码和两级寄存器采样，以便改善亚稳态。通过在Vivado 2018.3里综合后，可以得到以BRAM为存储器的FIFO。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// FIFO.scala</span><br><span class="hljs-keyword">package</span> fifo<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIFO</span>(<span class="hljs-params">width: <span class="hljs-type">Int</span>, depth: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">RawModule</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-comment">// write-domain</span><br>    <span class="hljs-keyword">val</span> dataIn = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(width.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> writeEn = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> writeClk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> full = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-comment">// read-domain</span><br>    <span class="hljs-keyword">val</span> dataOut = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(width.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> readEn = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> readClk = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> empty = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-comment">// reset</span><br>    <span class="hljs-keyword">val</span> systemRst = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  &#125;)<br>  <span class="hljs-keyword">val</span> ram = <span class="hljs-type">SyncReadMem</span>(<span class="hljs-number">1</span> &lt;&lt; depth, <span class="hljs-type">UInt</span>(width.<span class="hljs-type">W</span>))   <span class="hljs-comment">// 2^depth</span><br>  <span class="hljs-keyword">val</span> writeToReadPtr = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))  <span class="hljs-comment">// to read clock domain</span><br>  <span class="hljs-keyword">val</span> readToWritePtr = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))  <span class="hljs-comment">// to write clock domain</span><br>  <span class="hljs-comment">// write clock domain</span><br>  withClockAndReset(io.writeClk, io.systemRst) &#123;<br>    <span class="hljs-keyword">val</span> binaryWritePtr = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> binaryWritePtrNext = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> grayWritePtr = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> grayWritePtrNext = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> isFull = <span class="hljs-type">RegInit</span>(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>)<br>    <span class="hljs-keyword">val</span> fullValue = <span class="hljs-type">Wire</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> grayReadPtrDelay0 = <span class="hljs-type">RegNext</span>(readToWritePtr)<br>    <span class="hljs-keyword">val</span> grayReadPtrDelay1 = <span class="hljs-type">RegNext</span>(grayReadPtrDelay0)<br>    binaryWritePtrNext := binaryWritePtr + (io.writeEn &amp;&amp; !isFull).asUInt<br>    binaryWritePtr := binaryWritePtrNext<br>    grayWritePtrNext := (binaryWritePtrNext &gt;&gt; <span class="hljs-number">1</span>) ^ binaryWritePtrNext<br>    grayWritePtr := grayWritePtrNext<br>    writeToReadPtr := grayWritePtr<br>    fullValue := (grayWritePtrNext === <span class="hljs-type">Cat</span>(~grayReadPtrDelay1(depth, depth - <span class="hljs-number">1</span>), grayReadPtrDelay1(depth - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))<br>    isFull := fullValue<br>    when(io.writeEn &amp;&amp; !isFull) &#123;<br>      ram.write(binaryWritePtr(depth - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), io.dataIn)<br>    &#125;<br>    io.full := isFull    <br>  &#125;<br>  <span class="hljs-comment">// read clock domain</span><br>  withClockAndReset(io.readClk, io.systemRst) &#123;<br>    <span class="hljs-keyword">val</span> binaryReadPtr = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> binaryReadPtrNext = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> grayReadPtr = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> grayReadPtrNext = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>((depth + <span class="hljs-number">1</span>).<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> isEmpty = <span class="hljs-type">RegInit</span>(<span class="hljs-literal">true</span>.<span class="hljs-type">B</span>)<br>    <span class="hljs-keyword">val</span> emptyValue = <span class="hljs-type">Wire</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> grayWritePtrDelay0 = <span class="hljs-type">RegNext</span>(writeToReadPtr)<br>    <span class="hljs-keyword">val</span> grayWritePtrDelay1 = <span class="hljs-type">RegNext</span>(grayWritePtrDelay0)<br>    binaryReadPtrNext := binaryReadPtr + (io.readEn &amp;&amp; !isEmpty).asUInt<br>    binaryReadPtr := binaryReadPtrNext<br>    grayReadPtrNext := (binaryReadPtrNext &gt;&gt; <span class="hljs-number">1</span>) ^ binaryReadPtrNext<br>    grayReadPtr := grayReadPtrNext<br>    readToWritePtr := grayReadPtr<br>    emptyValue := (grayReadPtrNext === grayWritePtrDelay1)<br>    isEmpty := emptyValue<br>    io.dataOut := ram.read(binaryReadPtr(depth - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), io.readEn &amp;&amp; !isEmpty)<br>    io.empty := isEmpty<br>  &#125;  <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FIFOGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">FIFO</span>(args(<span class="hljs-number">0</span>).toInt, args(<span class="hljs-number">1</span>).toInt))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><p>本章介绍了如何用Chisel设计多时钟域电路，重点是学会apply方法的使用，以及对第二个参数列表的理解。要注意独立时钟域里只有最后的表达式能被作为返回值给变量引用，并被外部访问，其它的定义都是对外不可见的。</p>
<h1 id="8-函数的应用"><a href="#8-函数的应用" class="headerlink" title="8 函数的应用"></a>8 函数的应用</h1><p>函数是编程语言的常用语法，即使是Verilog这样的硬件描述语言，也会用函数来构建组合逻辑。对于Chisel这样的高级语言，函数的使用更加方便，还能节省不少代码量。不管是用户自己写的函数、Chisel语言库里的函数还是Scala标准库里的函数，都能帮助用户节省构建电路的时间。</p>
<h2 id="8-1-用函数抽象组合逻辑"><a href="#8-1-用函数抽象组合逻辑" class="headerlink" title="8.1 用函数抽象组合逻辑"></a>8.1 用函数抽象组合逻辑</h2><p>与Verilog一样，对于频繁使用的组合逻辑电路，可以定义成Scala的函数形式，然后通过函数调用的方式来使用它。这些函数既可以定义在某个单例对象里，供多个模块重复使用，也可以直接定义在电路模块里。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// function.scala</span><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFunc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out1 = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> out2 = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>())<br>  &#125;)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clb</span></span>(a: <span class="hljs-type">UInt</span>, b: <span class="hljs-type">UInt</span>, c: <span class="hljs-type">UInt</span>, d: <span class="hljs-type">UInt</span>): <span class="hljs-type">UInt</span> =<br>    (a &amp; b) | (~c &amp; d)<br>  io.out1 := clb(io.in(<span class="hljs-number">0</span>), io.in(<span class="hljs-number">1</span>), io.in(<span class="hljs-number">2</span>), io.in(<span class="hljs-number">3</span>))<br>  io.out2 := clb(io.in(<span class="hljs-number">0</span>), io.in(<span class="hljs-number">2</span>), io.in(<span class="hljs-number">3</span>), io.in(<span class="hljs-number">1</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="8-2-用工厂方法简化模块的例化"><a href="#8-2-用工厂方法简化模块的例化" class="headerlink" title="8.2 用工厂方法简化模块的例化"></a>8.2 用工厂方法简化模块的例化</h2><p>在Scala里，往往在类的伴生对象里定义一个工厂方法，来简化类的实例化。同样，Chisel的模块也是Scala的类，也可以在其伴生对象里定义工厂方法来简化例化、连线模块。例如用双输入多路选择器构建四输入多路选择器：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// mux4.scala</span><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mux2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in0 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Mux2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(sel: <span class="hljs-type">UInt</span>, in0: <span class="hljs-type">UInt</span>, in1: <span class="hljs-type">UInt</span>) = &#123;<br>    <span class="hljs-keyword">val</span> m = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Mux2</span>)<br>    m.io.in0 := in0<br>    m.io.in1 := in1<br>    m.io.sel := sel<br>    m.io.out<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mux4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in0 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in2 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> in3 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  io.out := <span class="hljs-type">Mux2</span>(io.sel(<span class="hljs-number">1</span>),<br>                 <span class="hljs-type">Mux2</span>(io.sel(<span class="hljs-number">0</span>), io.in0, io.in1),<br>                 <span class="hljs-type">Mux2</span>(io.sel(<span class="hljs-number">0</span>), io.in2, io.in3))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="8-3-用Scala的函数简化代码"><a href="#8-3-用Scala的函数简化代码" class="headerlink" title="8.3 用Scala的函数简化代码"></a>8.3 用Scala的函数简化代码</h2><p>Scala的函数也能在Chisel里使用，只要能通过Firrtl编译器的检查。比如在生成长的序列上，利用Scala的函数就能减少大量的代码。假设要构建一个译码器，在Verilog里需要写条case语句，当n很大时就会使代码显得冗长而枯燥。利用Scala的for、yield组合可以产生相应的判断条件与输出结果的序列，再用zip函数将两个序列组成一个对偶序列，再把对偶序列作为MuxCase的参数，就能用几行代码构造出任意位数的译码器。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// decoder.scala</span><br><span class="hljs-keyword">package</span> decoder<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoder</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">RawModule</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> sel = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(n.<span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>((<span class="hljs-number">1</span> &lt;&lt; n).<span class="hljs-type">W</span>))  <br>  &#125;)<br><br>  <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">0</span> until (<span class="hljs-number">1</span> &lt;&lt; n)) <span class="hljs-keyword">yield</span> io.sel === i.<span class="hljs-type">U</span><br>  <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">0</span> until (<span class="hljs-number">1</span> &lt;&lt; n)) <span class="hljs-keyword">yield</span> <span class="hljs-number">1.</span><span class="hljs-type">U</span> &lt;&lt; i<br>  io.out := <span class="hljs-type">MuxCase</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>, x zip y)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DecoderGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">Decoder</span>(args(<span class="hljs-number">0</span>).toInt))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>只需要输入参数n，就能立即生成对应的n位译码器。</p>
<h2 id="8-4-Chisel的打印函数"><a href="#8-4-Chisel的打印函数" class="headerlink" title="8.4 Chisel的打印函数"></a>8.4 Chisel的打印函数</h2><p>Chisel提供了一个“ printf ”函数来打印信息，用于电路调试。它有Scala和C两种风格。当用Verilator生成波形时，每个时钟周期都会在屏幕上显示一次。如果在when语句块里，只有条件成立时才运行。隐式的全局复位信号也不会触发。</p>
<p>printf函数只能在Chisel的模块里使用，并且会转换成Verilog的系统函数“$fwrite”，包含在宏定义块“ <code>ifndef SYNTHESIS......</code>endif ”里。通过Verilog的宏定义，可以取消这部分不可综合的代码。因为后导入的chisel3包覆盖了Scala的标准包，所以Scala里的printf函数要写成“Predef.printf”的完整路径形式。</p>
<h3 id="8-4-1-Scala风格"><a href="#8-4-1-Scala风格" class="headerlink" title="8.4.1 Scala风格"></a>8.4.1 Scala风格</h3><p>该风格类似于Scala的字符串插值器。Chisel自定义了一个p插值器，该插值器可以对字符串内的一些自定义表达式进行求值、Chiel类型转化成字符串类型等。</p>
<p><strong>① 简单格式</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myUInt = <span class="hljs-number">33.</span><span class="hljs-type">U</span><br><span class="hljs-comment">// 显示Chisel自定义的类型的数据</span><br>printf(<span class="hljs-string">p&quot;myUInt = <span class="hljs-subst">$myUInt</span>&quot;</span>) <span class="hljs-comment">// myUInt = 33</span><br><span class="hljs-comment">// 显示成十六进制</span><br>printf(<span class="hljs-string">p&quot;myUInt = 0x<span class="hljs-subst">$&#123;Hexadecimal(myUInt)&#125;</span>&quot;</span>) <span class="hljs-comment">// myUInt = 0x21</span><br><span class="hljs-comment">// 显示成二进制</span><br>printf(<span class="hljs-string">p&quot;myUInt = <span class="hljs-subst">$&#123;Binary(myUInt)&#125;</span>&quot;</span>) <span class="hljs-comment">// myUInt = 100001</span><br><span class="hljs-comment">// 显示成字符(ASCⅡ码)</span><br>printf(<span class="hljs-string">p&quot;myUInt = <span class="hljs-subst">$&#123;Character(myUInt)&#125;</span>&quot;</span>) <span class="hljs-comment">// myUInt = !</span><br></code></pre></div></td></tr></table></figure>
<p><strong>② 聚合数据类型</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myVec = <span class="hljs-type">Vec</span>(<span class="hljs-number">5.</span><span class="hljs-type">U</span>, <span class="hljs-number">10.</span><span class="hljs-type">U</span>, <span class="hljs-number">13.</span><span class="hljs-type">U</span>)<br>printf(<span class="hljs-string">p&quot;myVec = <span class="hljs-subst">$myVec</span>&quot;</span>) <span class="hljs-comment">// myVec = Vec(5, 10, 13)</span><br><br><span class="hljs-keyword">val</span> myBundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>()<br>    <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>()<br>&#125;)<br>myBundle.foo := <span class="hljs-number">3.</span><span class="hljs-type">U</span><br>myBundle.bar := <span class="hljs-number">11.</span><span class="hljs-type">U</span><br>printf(<span class="hljs-string">p&quot;myBundle = <span class="hljs-subst">$myBundle</span>&quot;</span>) <span class="hljs-comment">// myBundle = Bundle(a -&gt; 3, b -&gt; 11)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>③ 自定义打印信息</strong></p>
<p>对于自定义的Bundle类型，可以重写toPrintable方法来定制打印内容。当自定义的Bundle配合其他硬件类型例如Wire构成具体的硬件，并且被赋值后，可以用p插值器来求值该硬件，此时就会调用重写的toPrintable方法。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> valid = <span class="hljs-type">Bool</span>()<br>  <span class="hljs-keyword">val</span> addr = <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> length = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">UInt</span>(<span class="hljs-number">64.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toPrintable</span></span>: <span class="hljs-type">Printable</span> = &#123;<br>      <span class="hljs-keyword">val</span> char = <span class="hljs-type">Mux</span>(valid, &#x27;v&#x27;.<span class="hljs-type">U</span>, &#x27;-&#x27;.<span class="hljs-type">U</span>)<br>      <span class="hljs-string">p&quot;Message:\n&quot;</span> +<br>      <span class="hljs-string">p&quot;  valid  : <span class="hljs-subst">$&#123;Character(char)&#125;</span>\n&quot;</span> +<br>      <span class="hljs-string">p&quot;  addr   : 0x<span class="hljs-subst">$&#123;Hexadecimal(addr)&#125;</span>\n&quot;</span> +<br>      <span class="hljs-string">p&quot;  length : <span class="hljs-subst">$length</span>\n&quot;</span> +<br>      <span class="hljs-string">p&quot;  data   : 0x<span class="hljs-subst">$&#123;Hexadecimal(data)&#125;</span>\n&quot;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> myMessage = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Message</span>)<br>myMessage.valid := <span class="hljs-literal">true</span>.<span class="hljs-type">B</span><br>myMessage.addr := <span class="hljs-string">&quot;h1234&quot;</span>.<span class="hljs-type">U</span><br>myMessage.length := <span class="hljs-number">10.</span><span class="hljs-type">U</span><br>myMessage.data := <span class="hljs-string">&quot;hdeadbeef&quot;</span>.<span class="hljs-type">U</span><br><br>printf(<span class="hljs-string">p&quot;<span class="hljs-subst">$myMessage</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p>注意，重写的toPrintable方法的返回类型固定是Printable，这是因为p插值器的返回类型就是Printable，并且Printable类里定义了一个方法“+”用于将多个字符串拼接起来。在最后一个语句里，p插值器会求值myMessage，这就会调用Message类的toPrintable方法。因此，最终的打印信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Message:<br>     valid  : v<br>     addr   : 0x00001234<br>     length : 10<br>     data   : 0x00000000deadbeef<br></code></pre></div></td></tr></table></figure>
<h3 id="8-4-2-C风格"><a href="#8-4-2-C风格" class="headerlink" title="8.4.2 C风格"></a>8.4.2 C风格</h3><p>Chisel的printf也支持C的部分格式控制符和转义字符。如下所示：</p>
<p><img src="2022-3-9-chisel/image-20220313224501135.png" srcset="/img/loading.gif" lazyload alt="image-20220313224501135"></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myUInt = <span class="hljs-number">32.</span><span class="hljs-type">U</span><br>printf(<span class="hljs-string">&quot;myUInt = %d&quot;</span>, myUInt) <span class="hljs-comment">// myUInt = 32</span><br></code></pre></div></td></tr></table></figure>
<h2 id="8-5-Chisel的对数函数"><a href="#8-5-Chisel的对数函数" class="headerlink" title="8.5 Chisel的对数函数"></a>8.5 Chisel的对数函数</h2><p>在二进制运算里，求以2为底的对数也是常用的运算。</p>
<p>chisel3.util包里有一个单例对象Log2，它的一个apply方法接收一个Bits类型的参数，计算并返回该参数值以2为底的幂次。返回类型是UInt类型，并且是向下截断的。另一个apply的重载版本可以接受第二个Int类型的参数，用于指定返回结果的位宽。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Log2</span>(<span class="hljs-number">8.</span><span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于3.U</span><br><br><span class="hljs-type">Log2</span>(<span class="hljs-number">13.</span><span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于3.U(向下截断)</span><br><br><span class="hljs-type">Log2</span>(myUIntWire)  <span class="hljs-comment">// 动态求值 </span><br></code></pre></div></td></tr></table></figure>
<p>chisel3.util包里还有四个单例对象：log2Ceil、log2Floor、log2Up和log2Down，它们的apply方法的参数都是Int和BigInt类型，返回结果都是Int类型。log2Ceil是把结果向上舍入，log2Floor则向下舍入。log2Up和log2Down不仅分别把结果向上、向下舍入，而且结果最小为1。</p>
<p>单例对象isPow2的apply方法接收Int和BigInt类型的参数，判断该整数是不是2的n次幂，返回Boolean类型的结果。</p>
<h2 id="8-6-与硬件相关的函数"><a href="#8-6-与硬件相关的函数" class="headerlink" title="8.6 与硬件相关的函数"></a>8.6 与硬件相关的函数</h2><h3 id="8-6-1-位旋转"><a href="#8-6-1-位旋转" class="headerlink" title="8.6.1 位旋转"></a>8.6.1 位旋转</h3><p>chisel3.util包里还有一些常用的操作硬件的函数，比如单例对象Reverse的apply方法可以把一个UInt类型的对象进行旋转，返回一个对应的UInt值。在转换成Verilog时，都是通过拼接完成的组合逻辑。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Reverse</span>(<span class="hljs-string">&quot;b1101&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于&quot;b1011&quot;.U</span><br><br><span class="hljs-type">Reverse</span>(<span class="hljs-string">&quot;b1101&quot;</span>.<span class="hljs-type">U</span>(<span class="hljs-number">8.</span><span class="hljs-type">W</span>))  <span class="hljs-comment">// 等于&quot;b10110000&quot;.U</span><br><br><span class="hljs-type">Reverse</span>(myUIntWire)  <span class="hljs-comment">// 动态旋转</span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-6-2-位拼接"><a href="#8-6-2-位拼接" class="headerlink" title="8.6.2 位拼接"></a>8.6.2 位拼接</h3><p>单例对象Cat有两个apply方法，分别接收一个Bits类型的序列和Bits类型的重复参数，将它们拼接成一个UInt数。前面的参数在高位。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Cat</span>(<span class="hljs-string">&quot;b101&quot;</span>.<span class="hljs-type">U</span>, <span class="hljs-string">&quot;b11&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于&quot;b10111&quot;.U</span><br><br><span class="hljs-type">Cat</span>(myUIntWire0, myUIntWire1)  <span class="hljs-comment">// 动态拼接</span><br><br><span class="hljs-type">Cat</span>(<span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;b101&quot;</span>.<span class="hljs-type">U</span>, <span class="hljs-string">&quot;b11&quot;</span>.<span class="hljs-type">U</span>))  <span class="hljs-comment">// 等于&quot;b10111&quot;.U</span><br><br><span class="hljs-type">Cat</span>(mySeqOfBits)  <span class="hljs-comment">// 动态拼接 </span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-6-3-1计数器"><a href="#8-6-3-1计数器" class="headerlink" title="8.6.3 1计数器"></a>8.6.3 1计数器</h3><p>单例对象PopCount有两个apply方法，分别接收一个Bits类型的参数和Bool类型的序列，计算参数里“1”或“true.B”的个数，返回对应的UInt值。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">PopCount</span>(<span class="hljs-type">Seq</span>(<span class="hljs-literal">true</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">false</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">true</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">true</span>.<span class="hljs-type">B</span>))  <span class="hljs-comment">// 等于3.U</span><br><br><span class="hljs-type">PopCount</span>(<span class="hljs-type">Seq</span>(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">false</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">true</span>.<span class="hljs-type">B</span>, <span class="hljs-literal">false</span>.<span class="hljs-type">B</span>))  <span class="hljs-comment">// 等于1.U</span><br><br><span class="hljs-type">PopCount</span>(<span class="hljs-string">&quot;b1011&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于3.U</span><br><br><span class="hljs-type">PopCount</span>(<span class="hljs-string">&quot;b0010&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于1.U</span><br><br><span class="hljs-type">PopCount</span>(myUIntWire)  <span class="hljs-comment">// 动态计数</span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-6-4-独热码转换器"><a href="#8-6-4-独热码转换器" class="headerlink" title="8.6.4 独热码转换器"></a>8.6.4 独热码转换器</h3><p>单例对象OHToUInt的apply方法可以接收一个Bits类型或Bool序列类型的独热码参数，计算独热码里的“1”在第几位(从0开始)，返回对应的UInt值。如果不是独热码，则行为不确定。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">OHToUInt</span>(<span class="hljs-string">&quot;b1000&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于3.U</span><br><br><span class="hljs-type">OHToUInt</span>(<span class="hljs-string">&quot;b1000_0000&quot;</span>.<span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于7.U </span><br></code></pre></div></td></tr></table></figure>
<p>还有一个行为相反的单例对象UIntToOH，它的apply方法是根据输入的UInt类型参数，返回对应位置的独热码，独热码也是UInt类型。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">UIntToOH</span>(<span class="hljs-number">3.</span><span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于&quot;b1000&quot;.U</span><br><br><span class="hljs-type">UIntToOH</span>(<span class="hljs-number">7.</span><span class="hljs-type">U</span>)  <span class="hljs-comment">// 等于&quot;b1000_0000&quot;.U</span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-6-5-无关位"><a href="#8-6-5-无关位" class="headerlink" title="8.6.5 无关位"></a>8.6.5 无关位</h3><p>Verilog里可以用问号表示无关位，那么用case语句进行比较时就不会关心这些位。Chisel里有对应的BitPat类，可以指定无关位。在其伴生对象里，一个apply方法可以接收一个字符串来构造BitPat对象，字符串里用问号表示无关位。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-string">&quot;b10101&quot;</span>.<span class="hljs-type">U</span> === <span class="hljs-type">BitPat</span>(<span class="hljs-string">&quot;b101??&quot;</span>) <span class="hljs-comment">// 等于true.B</span><br><br><span class="hljs-string">&quot;b10111&quot;</span>.<span class="hljs-type">U</span> === <span class="hljs-type">BitPat</span>(<span class="hljs-string">&quot;b101??&quot;</span>) <span class="hljs-comment">// 等于true.B</span><br><br><span class="hljs-string">&quot;b10001&quot;</span>.<span class="hljs-type">U</span> === <span class="hljs-type">BitPat</span>(<span class="hljs-string">&quot;b101??&quot;</span>) <span class="hljs-comment">// 等于false.B </span><br></code></pre></div></td></tr></table></figure>
<p>另一个apply方法则用UInt类型的参数来构造BitPat对象，UInt参数必须是字面量。这允许把UInt类型用在期望BitPat的地方，当用BitPat定义接口又并非所有情况要用到无关位时，该方法就很有用。</p>
<p>另外，bitPatToUInt方法可以把一个BitPat对象转换成UInt对象，但是BitPat对象不能包含无关位</p>
<p>dontCare方法接收一个Int类型的参数，构造等值位宽的全部无关位。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myDontCare = <span class="hljs-type">BitPat</span>.dontCare(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 等于BitPat(&quot;b????&quot;) </span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-6-6-查找表"><a href="#8-6-6-查找表" class="headerlink" title="8.6.6 查找表"></a>8.6.6 查找表</h3><p>BitPat通常配合两种查找表使用。一种是单例对象Lookup，其apply方法定义为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Bits</span>](addr: <span class="hljs-type">UInt</span>, <span class="hljs-keyword">default</span>: <span class="hljs-type">T</span>, mapping: <span class="hljs-type">Seq</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">T</span>)]): <span class="hljs-type">T</span> <br></code></pre></div></td></tr></table></figure>
<p>addr会与每个BitPat进行比较，如果相等，就返回对应的值，否则就返回default。</p>
<p>第二种是单例对象ListLookup，它的apply方法与上面的类似，区别在于返回结果是一个T类型的列表：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">defapply[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Data</span>](addr: <span class="hljs-type">UInt</span>, <span class="hljs-keyword">default</span>: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>], mapping: <span class="hljs-type">Array</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">List</span>[<span class="hljs-type">T</span>])]): <span class="hljs-type">List</span>[<span class="hljs-type">T</span>] <br></code></pre></div></td></tr></table></figure>
<p>这两种查找表的常用场景是构造CPU的控制器，因为CPU指令里有很多无关位，所以根据输入的指令(即addr)与预先定义好的带无关位的指令进行匹配，就能得到相应的控制信号。</p>
<h2 id="8-7-总结"><a href="#8-7-总结" class="headerlink" title="8.7 总结"></a>8.7 总结</h2><p>在编写代码时，虽然是构造硬件，但是语言特性和编译器允许读者灵活使用高级函数。要做到熟能生巧，就应该多阅读、多练习。</p>
<h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9 其他"></a>9 其他</h1><p>本章讲解的内容比较繁杂，没有一个统一的中心思想。这些问题与实际编程没有太大关系，但是读者需要稍微留意。</p>
<h2 id="9-1-动态命名模块"><a href="#9-1-动态命名模块" class="headerlink" title="9.1 动态命名模块"></a>9.1 动态命名模块</h2><p>Chisel可以动态定义模块的名字，也就是转成Verilog时的模块名不使用定义的类名，而是使用重写的desiredName方法的返回字符串。模块和黑盒都适用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> <span class="hljs-type">I</span> = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> <span class="hljs-type">O</span> = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>   &#125;)<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">desiredName</span> </span>= <span class="hljs-string">&quot;Tea&quot;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;&#125;)<br>   <span class="hljs-keyword">val</span> drink = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Coffee</span>)<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">desiredName</span> </span>= <span class="hljs-string">&quot;SodiumMonochloride&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对应的Verilog为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> SodiumMonochloride(<br>     <span class="hljs-keyword">input</span>   clock,<br>     <span class="hljs-keyword">input</span>   reset<br>);<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] drink_O;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] drink_I;<br>     Tea drink (<br>         <span class="hljs-variable">.O</span>(drink_O),<br>         <span class="hljs-variable">.I</span>(drink_I)<br>     );<br>     <span class="hljs-keyword">assign</span> drink_I = <span class="hljs-number">32&#x27;h0</span>;<br><span class="hljs-keyword">endmodule</span> <br></code></pre></div></td></tr></table></figure>
<h2 id="9-2-动态修改端口"><a href="#9-2-动态修改端口" class="headerlink" title="9.2 动态修改端口"></a>9.2 动态修改端口</h2><p>Chisel通过引入Scala的Boolean参数、可选值以及if语句可以创建出可选的端口，在例化该模块时可以通过控制Boolean入参来生成不同的端口。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleWithOptionalIOs</span>(<span class="hljs-params">flag: <span class="hljs-type">Boolean</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">12.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">12.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> out2 = <span class="hljs-keyword">if</span> (flag) <span class="hljs-type">Some</span>(<span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">12.</span><span class="hljs-type">W</span>))) <span class="hljs-keyword">else</span> <span class="hljs-type">None</span><br>  &#125;)<br><br>   io.out := io.in<br>   <span class="hljs-keyword">if</span>(flag) &#123;<br>     io.out2.get := io.in<br>   &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>注意，端口应该包装成可选值，这样不需要端口时就能用对象None代替，编译出来的Verilog就不会生成这个端口。在给可选端口赋值时，应该先用可选值的get方法把端口解放出来。这里也体现了可选值语法的便利性。</p>
<h2 id="9-3-生成正确的块内信号名"><a href="#9-3-生成正确的块内信号名" class="headerlink" title="9.3 生成正确的块内信号名"></a>9.3 生成正确的块内信号名</h2><p>一般情况下，在when、withClockAndReset等语句块里定义的信号(线网和寄存器)，转换成Verilog时不会生成正确的变量名。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// name.scala</span><br><span class="hljs-keyword">package</span> test<br><br><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>  when (io.a) &#123;<br>    <span class="hljs-keyword">val</span> innerReg = <span class="hljs-type">RegInit</span>(<span class="hljs-number">5.</span><span class="hljs-type">U</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>))<br>    innerReg := innerReg + <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>    io.b := innerReg<br>  &#125; .otherwise &#123;<br>    io.b := <span class="hljs-number">10.</span><span class="hljs-type">U</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NameGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">TestMod</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它对应生成的Verilog为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TestMod.v</span><br><span class="hljs-keyword">module</span> TestMod(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>        io_a,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_b<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_2;<br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_2 = <span class="hljs-number">_</span>T + <span class="hljs-number">4&#x27;h1</span>;<br>  <span class="hljs-keyword">assign</span> io_b = io_a ? <span class="hljs-number">_</span>T : <span class="hljs-number">4&#x27;ha</span>;<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T &lt;= <span class="hljs-number">4&#x27;h5</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-number">_</span>T &lt;= <span class="hljs-number">_</span>T_2;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<p>注意看，when语句块里声明的寄存器innerReg，被命名成了“_T”。</p>
<p>如果想让名字正确，则需要在build.sbt文件里加上：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">addCompilerPlugin(<span class="hljs-string">&quot;org.scalamacros&quot;</span> % <span class="hljs-string">&quot;paradise&quot;</span> % <span class="hljs-string">&quot;2.1.0&quot;</span> cross <span class="hljs-type">CrossVersion</span>.full) <br></code></pre></div></td></tr></table></figure>
<p>同时，设计代码里需要加上传递给Firrtl的注解：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">...<br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.experimental.chiselName<br><br><span class="hljs-meta">@chiselName</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>...<br></code></pre></div></td></tr></table></figure>
<p>这样，对应的Verilog文件就有了正确的寄存器名字：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TestMod.v</span><br><span class="hljs-keyword">module</span> TestMod(<br>  <span class="hljs-keyword">input</span>        clock,<br>  <span class="hljs-keyword">input</span>        reset,<br>  <span class="hljs-keyword">input</span>        io_a,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] io_b<br>);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] innerReg;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-number">_</span>T_1;<br>  <span class="hljs-keyword">assign</span> <span class="hljs-number">_</span>T_1 = innerReg + <span class="hljs-number">4&#x27;h1</span>;<br>  <span class="hljs-keyword">assign</span> io_b = io_a ? innerReg : <span class="hljs-number">4&#x27;ha</span>;<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>      innerReg &lt;= <span class="hljs-number">4&#x27;h5</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      innerReg &lt;= <span class="hljs-number">_</span>T_1;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>
<h2 id="9-4-拆包一个值-给拼接变量赋值"><a href="#9-4-拆包一个值-给拼接变量赋值" class="headerlink" title="9.4 拆包一个值(给拼接变量赋值)"></a>9.4 拆包一个值(给拼接变量赋值)</h2><p>在Verilog中，左侧的赋值对象可以是一个拼接起多个变量的值，例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] b;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] c;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] z = [...];<br><span class="hljs-keyword">assign</span> &#123;a, b, c&#125; = z;<br></code></pre></div></td></tr></table></figure>
<p>在Chisel里不能直接这么赋值。最简单的做法是先定义一个a、b、c组成的Bundle，高位定义在前面，然后创建线网z。线网z可以被直接赋值，被赋值后，z再调用方法asTypeOf。该方法接收一个Data类型的参数，可以把调用对象强制转换成参数的类型并返回，在这里也就是把a、b、c组成的Bundle作为参数。注意，返回结果是一个新对象，并没有直接修改调用对象z。强制转换必须保证不会出错。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> a = <span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> b = <span class="hljs-type">UInt</span>(<span class="hljs-number">4.</span><span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> c = <span class="hljs-type">UInt</span>(<span class="hljs-number">3.</span><span class="hljs-type">W</span>)<br>&#125;<br><br><span class="hljs-keyword">val</span> z = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">9.</span><span class="hljs-type">W</span>))<br>z := ...<br><span class="hljs-keyword">val</span> unpacked = z.asTypeOf(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>unpacked.a<br>unpacked.b<br>unpacked.c<br></code></pre></div></td></tr></table></figure>
<h2 id="9-5-子字赋值"><a href="#9-5-子字赋值" class="headerlink" title="9.5 子字赋值"></a>9.5 子字赋值</h2><p>在Verilog中，可以直接给向量的某几位赋值。同样，Chisel受限于Scala，不支持直接给Bits类型的某几位赋值。子字赋值的可行办法是先调用Bits类型的toBools方法。该方法根据调用对象的0、1排列返回一个相应的Seq[Bool]类型的结果，并且低位在序列里的下标更小，比如第0位的下标就是0、第n位的下标就是n。然后用这个Seq[Bool]对象配合VecInit构成一个向量，此时就可以给单个比特赋值。注意，必须都是Bool类型，要注意赋值前是否需要类型转换。子字赋值完成后，Bool向量再调用asUInt、asSInt方法转换回来。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">10.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> bit = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">10.</span><span class="hljs-type">W</span>))<br>   &#125;)<br>   <span class="hljs-keyword">val</span> bools = <span class="hljs-type">VecInit</span>(io.in.toBools)<br>   bools(<span class="hljs-number">0</span>) := io.bit<br>   io.out := bools.asUInt<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="9-6-参数化的Bundle"><a href="#9-6-参数化的Bundle" class="headerlink" title="9.6 参数化的Bundle"></a>9.6 参数化的Bundle</h2><p>因为Chisel是基于Scala和JVM的，所以当一个Bundle类的对象用于创建线网、IO等操作时，它并不是把自己作为参数，而是交出自己的一个复制对象，也就是说编译器需要知道如何来创建当前Bundle对象的复制对象。Chisel提供了一个内部的API函数cloneType，任何继承自Data的Chisel对象，要复制自身时，都是由cloneType负责返回该对象的复制对象。它对应的用户API则是chiselTypeOf。</p>
<p>当自定义的Bundle的主构造方法没有参数时，Chisel会自动推断出如何构造Bundle对象的复制，原因很简单，因为构造一个新的复制对象不需要任何参数，仅仅使用关键字new就行了。但是，如果自定义的Bundle带有参数列表，那么Chisel就无法推断了，因为传递进去的参数可以是任意的，并不一定就是完全地复制。此时需要用户自己重写Bundle类的cloneType方法，其形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cloneType</span> </span>= (<span class="hljs-keyword">new</span> <span class="hljs-type">CustomBundle</span>(arguments)).asInstanceOf[<span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>]<br></code></pre></div></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBundle</span>(<span class="hljs-params">a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> foo = <span class="hljs-type">UInt</span>(a.<span class="hljs-type">W</span>)<br>   <span class="hljs-keyword">val</span> bar = <span class="hljs-type">UInt</span>(b.<span class="hljs-type">W</span>)<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cloneType</span> </span>= (<span class="hljs-keyword">new</span> <span class="hljs-type">ExampleBundle</span>(a, b)).asInstanceOf[<span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>]<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBundleModule</span>(<span class="hljs-params">btype: <span class="hljs-type">ExampleBundle</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(chiselTypeOf(btype))<br>   &#125;)<br>   io.out := io.b.foo + io.b.bar<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Top</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>   <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>       <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>       <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">17.</span><span class="hljs-type">W</span>))<br>   &#125;)<br>   <span class="hljs-keyword">val</span> x = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ExampleBundle</span>(<span class="hljs-number">31</span>, <span class="hljs-number">17</span>))<br>   x := <span class="hljs-type">DontCare</span><br>   <span class="hljs-keyword">val</span> m = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ExampleBundleModule</span>(x))<br>   m.io.b.foo := io.in<br>   m.io.b.bar := io.in<br>   io.out := m.io.out<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>例子中的ExampleBundle有两个参数，编译器无法在复制它的对象时推断出这两个参数是什么，所以重写的cloneType方法需要用户手动将两个参数传入，而且用asInstanceOf[this.type]保证返回对象的类型与this对象是一样的。</p>
<p>如果没有这个重写的cloneType的方法，编译器会提示把ExampleBundle的参数变成固定的和可获取的，以便cloneType方法能被自动推断，即非参数化Bundle不需要重写该方法。此外，变量x必须要用Wire包住ExampleBundle的对象，否则x在传递给ExampleBundleModule时，编译器会提示应该传入一个硬件而不是裸露的Chisel类型，并询问是否遗漏了Wire(<em>)或IO(</em>)。与之相反，“Input(chiselTypeOf(btype))”中的chiselTypeOf方法也必不可少，因为此时传入的btype是一个硬件，编译器会提示Input的参数应该是Chisel类型而不是硬件，需要使用方法chiselTypeOf解除包住ExampleBundle对象的Wire。</p>
<p>这个例子中，cloneType在构造复制对象时，仅仅是传递了对应的参数，这就会构造一个一模一样的新对象。为了进一步说明cloneType的作用，再来看一个“别扭”的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBundle</span>(<span class="hljs-params">a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> <span class="hljs-type">A</span> = <span class="hljs-type">UInt</span>(a.<span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> <span class="hljs-type">B</span> = <span class="hljs-type">UInt</span>(b.<span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cloneType</span> </span>= (<span class="hljs-keyword">new</span> <span class="hljs-type">TestBundle</span>(<span class="hljs-number">5</span>*b, a+<span class="hljs-number">1</span>)).asInstanceOf[<span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>]<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">10.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> y = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">TestBundle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br>  &#125;)<br><br>  io.out.<span class="hljs-type">A</span> := io.x<br>  io.out.<span class="hljs-type">B</span> := io.y<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p>这里，cloneType在构造复制对象前，先把形参a、b做了一些算术操作，再传递给TestBundle的主构造方法使用。按常规思路，代码“Output(new TestBundle(10, 5))”应该构造两个输出端口：10bit的A和5bit的B。但实际生成的Verilog如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">module <span class="hljs-type">TestModule</span>(<br>  input         clock,<br>  input         reset,<br>  input  [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]  io_x,<br>  input  [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  io_y,<br>  output [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] io_out_A,<br>  output [<span class="hljs-number">10</span>:<span class="hljs-number">0</span>] io_out_B<br>);<br>  assign io_out_A = &#123;&#123;<span class="hljs-number">15</span><span class="hljs-symbol">&#x27;d0</span>&#125;, io_x&#125;;<br>  assign io_out_B = &#123;&#123;<span class="hljs-number">6</span><span class="hljs-symbol">&#x27;d0</span>&#125;, io_y&#125;;<br>endmodule <br></code></pre></div></td></tr></table></figure>
<p>也就是说，“Output(new TestBundle(10, 5))”的真正形式应该是“Output((new TestBundle(10, 5)).cloneType)”，即Output的真正参数是对象TestBundle(10, 5)的cloneType方法构造出来的对象。而cloneType方法是用实参“5 * 5(b)”和“10(a) + 1”来分别赋予形参a和b，因此得出A的实际位宽是25bit，B的实际位宽是11bit。 </p>
<h2 id="9-7-Chisel泛型"><a href="#9-7-Chisel泛型" class="headerlink" title="9.7 Chisel泛型"></a>9.7 Chisel泛型</h2><p>Chisel本质上还是Scala，所以Chisel的泛型就是使用Scala的泛型语法，这使得电路参数化更加方便。无论是Chisel的函数还是模块，都可以用类型参数和上、下界来泛化。在例化模块时，传入不同类型的参数，就可能会产生不同的电路，而无需编写额外的代码，当然前提是逻辑、类型必须正确。</p>
<p>要熟练使用泛型比较麻烦，所需素材很多，这里就不再介绍。读者可以通过阅读Chisel的源码来学习它是如何进行泛型的。</p>
<h2 id="9-8-未驱动的线网"><a href="#9-8-未驱动的线网" class="headerlink" title="9.8 未驱动的线网"></a>9.8 未驱动的线网</h2><p>Chisel的Invalidate API支持检测未驱动的输出型IO以及定义不完整的Wire定义，在编译成firrtl时会产生“not fully initialized”错误。换句话说，就是组合逻辑的真值表不完整，不能综合出完整的电路。如果确实需要不被驱动的线网，则可以赋给一个DontCare对象，这会告诉Firrtl编译器，该线网故意不被驱动。转换成的Verilog会赋予该信号全0值，甚至把逻辑全部优化掉，所以谨慎使用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> outs = <span class="hljs-type">Output</span>(<span class="hljs-type">Vec</span>(<span class="hljs-number">10</span>, <span class="hljs-type">Bool</span>()))<br>&#125;)<br>io.outs &lt;&gt; <span class="hljs-type">DontCare</span> <br></code></pre></div></td></tr></table></figure>
<p>检查机制是由CompileOptions.explicitInvalidate控制的，如果把它设置成true就是严格模式(执行检查)，设置成false就是不严格模式(不执行检查)。开关方法有两种，第一种是定义一个抽象的模块类，由抽象类设置，其余模块都继承自这个抽象类。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 严格</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExplicitInvalidateModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span>(<span class="hljs-params"></span>)(<span class="hljs-params">chisel3.core.<span class="hljs-type">ExplicitCompileOptions</span>.<span class="hljs-type">NotStrict</span>.copy(explicitInvalidate = true</span>))</span><br><br><span class="hljs-comment">// 不严格</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImplicitInvalidateModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span>(<span class="hljs-params"></span>)(<span class="hljs-params">chisel3.core.<span class="hljs-type">ExplicitCompileOptions</span>.<span class="hljs-type">Strict</span>.copy(explicitInvalidate = false</span>))</span><br></code></pre></div></td></tr></table></figure>
<p> 第二种方法是在每个模块里重写compileOptions字段，由该字段设置编译选项。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 严格</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> compileOptions = chisel3.core.<span class="hljs-type">ExplicitCompileOptions</span>.<span class="hljs-type">NotStrict</span>.copy(explicitInvalidate = <span class="hljs-literal">true</span>)<br>  ...<br>&#125; <br><br><span class="hljs-comment">// 不严格</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> compileOptions = chisel3.core.<span class="hljs-type">ExplicitCompileOptions</span>.<span class="hljs-type">Strict</span>.copy(explicitInvalidate = <span class="hljs-literal">false</span>)<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="9-9-总结"><a href="#9-9-总结" class="headerlink" title="9.9 总结"></a>9.9 总结</h2><p>本章内容是编写Chisel时的常见问题汇总。最常出现的错误就是“not fully initialized”，读者应该根据提示信息查看设计中是否有情况没覆盖全的组合逻辑。</p>
<h1 id="10-隐式参数的应用"><a href="#10-隐式参数的应用" class="headerlink" title="10 隐式参数的应用"></a>10 隐式参数的应用</h1><p>第二十五章 Chisel进阶——隐式参数的应用</p>
<p>_iChthyosaur</p>
<p>于 2019-02-25 21:55:14 发布</p>
<p>7346<br> 收藏 12<br>文章标签： Scala Chisel RISC-V<br>版权<br>用Chisel编写的CPU，比如Rocket-Chip、RISCV-Mini等，都有一个特点，就是可以用一个配置文件来裁剪电路。这利用了Scala的模式匹配、样例类、偏函数、可选值、隐式定义等语法。本章内容就是来为读者详细解释它的工作机制。</p>
<p>一、相关定义<br>要理解隐式参数是如何配置电路的，应该先了解与配置相关的定义。在阅读代码之前，为了能快速读懂、深入理解，读者最好复习一下模式匹配和隐式定义两章的内容。</p>
<p>下面是来自于开源处理器RISCV-Mini的代码：</p>
<p>// Config.scala<br>// See LICENSE.SiFive for license details.</p>
<p>package freechips.rocketchip.config</p>
<p>abstract class Field[T] private (val default: Option[T])<br>{<br>  def this() = this(None)<br>  def this(default: T) = this(Some(default))<br>}</p>
<p>abstract class View {<br>  final def apply<a href="pname: Field[T]">T</a>: T = apply(pname, this)<br>  final def apply<a href="pname: Field[T], site: View">T</a>: T = {<br>    val out = find(pname, site)<br>    require (out.isDefined, s”Key ${pname} is not defined in Parameters”)<br>    out.get<br>  }</p>
<p>  final def lift<a href="pname: Field[T]">T</a>: Option[T] = lift(pname, this)<br>  final def lift<a href="pname: Field[T], site: View">T</a>: Option[T] = find(pname, site).map(_.asInstanceOf[T])</p>
<p>  protected[config] def find<a href="pname: Field[T], site: View">T</a>: Option[T]<br>}</p>
<p>abstract class Parameters extends View {<br>  final def ++ (x: Parameters): Parameters =<br>    new ChainParameters(this, x)</p>
<p>  final def alter(f: (View, View, View) =&gt; PartialFunction[Any,Any]): Parameters =<br>    Parameters(f) ++ this</p>
<p>  final def alterPartial(f: PartialFunction[Any,Any]): Parameters =<br>    Parameters((<em>,</em>,_) =&gt; f) ++ this</p>
<p>  final def alterMap(m: Map[Any,Any]): Parameters =<br>    new MapParameters(m) ++ this</p>
<p>  protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a>: Option[T]<br>  protected[config] def find<a href="pname: Field[T], site: View">T</a> = chain(site, new TerminalView, pname)<br>}</p>
<p>object Parameters {<br>  def empty: Parameters = new EmptyParameters<br>  def apply(f: (View, View, View) =&gt; PartialFunction[Any,Any]): Parameters = new PartialParameters(f)<br>}</p>
<p>class Config(p: Parameters) extends Parameters {<br>  def this(f: (View, View, View) =&gt; PartialFunction[Any,Any]) = this(Parameters(f))</p>
<p>  protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = p.chain(site, tail, pname)<br>  override def toString = this.getClass.getSimpleName<br>  def toInstance = this<br>}</p>
<p>// Internal implementation:</p>
<p>private class TerminalView extends View {<br>  def find<a href="pname: Field[T], site: View">T</a>: Option[T] = pname.default<br>}</p>
<p>private class ChainView(head: Parameters, tail: View) extends View {<br>  def find<a href="pname: Field[T], site: View">T</a> = head.chain(site, tail, pname)<br>}</p>
<p>private class ChainParameters(x: Parameters, y: Parameters) extends Parameters {<br>  def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = x.chain(site, new ChainView(y, tail), pname)<br>}</p>
<p>private class EmptyParameters extends Parameters {<br>  def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = tail.find(pname, site)<br>}</p>
<p>private class PartialParameters(f: (View, View, View) =&gt; PartialFunction[Any,Any]) extends Parameters {<br>  protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = {<br>    val g = f(site, this, tail)<br>    if (g.isDefinedAt(pname)) Some(g.apply(pname).asInstanceOf[T]) else tail.find(pname, site)<br>  }<br>}</p>
<p>private class MapParameters(map: Map[Any, Any]) extends Parameters {<br>  protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = {<br>    val g = map.get(pname)<br>    if (g.isDefined) Some(g.get.asInstanceOf[T]) else tail.find(pname, site)<br>  }<br>}<br>二、Field[T]类<br>位置：6-10行<br>抽象类Field[T]是一个类型构造器，它需要根据类型参数T来生成不同的类型。而T取决于传入的参数——可选值default：Option[T]的类型。例如，如果传入一个Some(10)，那么所有的T都可以确定为Int。</p>
<p>Field[T]只有一个公有val字段，即主构造方法的参数default：Option[T]。此外，主构造方法是私有的，外部只能访问两个公有的辅助构造方法“def this()”和“def this(default: T)”。第一个辅助构造方法不接收参数，所以会构造一个可选值字段是None的对象；第二个辅助构造方法接受一个T类型的参数，然后把参数打包成可选值Some(default): Option[T]，并把它赋给对象的可选值字段。</p>
<p>事实上，Field[T]是抽象的，我们并不能通过“new Field(参数)”来构造一个对象，所以它只能用于继承给子类、子对象或子特质。之所以定义抽象类Field[T]，是为了后面构造出它的样例子对象，并把这些样例对象用于偏函数。例如，构造一个“case object isInt extends Field[Int]”，然后把样例对象isInt用于偏函数“case isInt =&gt; …”。</p>
<p>为什么要把isInt构造成Field[Int]类型，而不是直接的Int类型呢？首先，我们想要偏函数的参数是一个常量，这样才能构成常量模式的模式匹配，一个常量模式控制一条配置选项。所以，要么定义一个样例对象，要么定义一个普通的Int对象比如1。这里我们选择定义样例对象，因为不仅会有Int类型，还可能有其他的自定义类型，它们可能是抽象的，无法直接创建实例对象。而且，用一个普通的Int对象来做模式匹配，会显得不那么独一无二。为了方便统一，全部构造成Field[T]类型的样例对象。例如，“case object isA extends Field[A]”、“case object isB extends Field[B]”等等。</p>
<p>其次，为什么要引入Field[Int]而不是“case object isInt extends Int”呢？因为Scala的基本类型Int、Float、Double、Boolean等都是final修饰的抽象类，不能被继承。</p>
<p>三、View类<br>位置：12-24行<br>我们只需要关心抽象类View的两个apply方法。其中第一个apply方法只是调用了第二个apply方法，重点在第二个apply方法。第二个apply方法调用了View的find方法，而find方法是抽象的，目前只知道它的返回结果是一个可选值。View的子类应该实现这个find方法，并且find方法会影响apply方法。如果不同的子类实现了不同行为的find方法，那么apply方法可能也会有不同的行为。</p>
<p>我们可以大致推测一下，参数pname的类型是Field[T]，那么很有可能是一个样例对象。而find方法应该就是在参数site里面找到是否包含pname，如果包含就返回一个可选值，否则就返回None。根据require函数可以印证这一点：如果site里面没有pname，那么结果out就是None，out.isDefined就是false，require函数产生异常，并输出字符串“Key ${pname} is not defined in Parameters”，即找不到pname；反之，out.isDefined就是true，require函数通过，不会输出字符串，并执行后面的out.get，即把可选值解开并返回。</p>
<p>四、Parameters类及伴生对象<br>位置：26-46行<br>抽象类Parameters是View的子类，它的确实现了find方法，但是又引入了抽象的chain方法，所以我们只需要关心Parameters的子类是如何实现chain方法的。另外四个方法不是重点，但是大致可以推测出来是在把两个Parameters类的对象拼接起来。</p>
<p>此外，出现了新的类TerminalView(位置58-60行)。TerminalView类也是View的子类，它也实现了find方法，只不过是直接返回pname的可选值字段。可以做如下推测：Parameters类的find方法给chain方法传递了三个参数——site、一个TerminalView实例对象和pname，它既可以在site里寻找是否包含pname，也可以用TerminalView的find方法直接返回pname。</p>
<p>Parameters类的伴生对象里定义了一个apply工厂方法，该方法构造了一个PartialParameters对象(位置74-79行)。</p>
<p>首先，PartialParameters类是Parameters的子类，所以工厂方法的返回类型可以是Parameters但实际返回结果是一个子类对象。</p>
<p>其次，工厂方法的入参f是一个理解难点。f的类型是一个函数，这个函数有三个View类型的入参，然后返回一个偏函数，即f是一个返回偏函数的函数。根据偏函数的介绍内容，我们可以推测出f返回的偏函数应该是一系列的case语句，用于模式匹配。</p>
<p>接着，前面说过，我们只需要关心Parameters的子类是如何实现chain方法的，而子类PartialParameters则实现了chain方法的一个版本。这个chain方法首先把PartialParameters的构造参数f返回的偏函数用g来引用，也就是说，g现在就是那个偏函数。至于f的三个入参site、this和tail则不是重点。然后，g.isDefinedAt(pname)表示在偏函数的可行域里寻找是否包含pname，如果有的话，则执行相应的case语句；否则，就用参数tail的find方法。结合代码定义，参数tail其实就是TerminalView的实例对象，它的find方法就是直接返回pname的可选值字段。这与推测内容相吻合。</p>
<p>五、Config类<br>位置：48-54行<br>首先，Config类也是Parameters的子类。它可以通过主构造方法接收一个Parameters类型的实例对象来构造一个Config类型的实例对象，或者通过辅助构造方法接收一个函数f来间接构造一个Config类型的实例对象。观察这个辅助构造方法，它其实先调用了Parameters的工厂方法，也就是利用函数f先构造了一个PartialParameters类型的对象(是Parameters的子类型)，再用这个PartialParameters类型的对象去运行主构造方法。</p>
<p>其次，我们仍然需要知道chain方法是如何实现的。这里，Config的chain方法是由构造时的参数p: Parameters决定的。如果一个Config的对象是用辅助构造方法和函数f构造的，那么参数p就是一个PartialParameters的对象，构造出来的Config对象的chain方法实际上运行的是PartialParameters的chain方法。</p>
<p>六、MiniConfig类<br>前面讲解的内容相当于类库里预先定义好的内容。要配置自定义的电路，还需要一个自定义的类。比如，处理器RISCV-Mini就定义了下面的MiniConfig类：</p>
<p>// See LICENSE for license details.</p>
<p>package mini</p>
<p>import chisel3.Module<br>import freechips.rocketchip.config.{Parameters, Config}<br>import junctions._</p>
<p>class MiniConfig extends Config((site, here, up) =&gt; {<br>    // Core<br>    case XLEN =&gt; 32<br>    case Trace =&gt; true<br>    case BuildALU    =&gt; (p: Parameters) =&gt; Module(new ALUArea()(p))<br>    case BuildImmGen =&gt; (p: Parameters) =&gt; Module(new ImmGenWire()(p))<br>    case BuildBrCond =&gt; (p: Parameters) =&gt; Module(new BrCondArea()(p))<br>    // Cache<br>    case NWays =&gt; 1 // TODO: set-associative<br>    case NSets =&gt; 256<br>    case CacheBlockBytes =&gt; 4 * (here(XLEN) &gt;&gt; 3) // 4 x 32 bits = 16B<br>    // NastiIO<br>    case NastiKey =&gt; new NastiParameters(<br>      idBits   = 5,<br>      dataBits = 64,<br>      addrBits = here(XLEN))<br>  }<br>)<br>MiniConfig类是Config的子类，其实它没有添加任何定义，只是给超类Config传递了所需要的构造参数。第五点讲了，Config有两种构造方法，这里是用了给定函数f的方法。那么函数f是什么呢？函数f的类型是“(View, View, View) =&gt; PartialFunction[Any,Any]”，这里给出的三个View类型入参是site、here和up。我们目前只知道site、here和up是View类型的对象，具体是什么，还无法确定，也无需关心。重点在于返回的偏函数是什么。偏函数是用花括号包起来的9个case语句，这呼应了我们前面讲过的用case语句组构造偏函数。我们可以推测case后面的XLEN、Trace等，就是一系列的Filed[T]类型的样例对象，也就是第二点推测的。</p>
<p>那么如何利用MiniConfig类呢？我们可以推测这个类包含了riscv-mini核全部的配置信息，然后看看处理器RISCV-Mini的顶层文件是如何描述的：</p>
<p>val params = (new MiniConfig).toInstance<br>val chirrtl = firrtl.Parser.parse(chisel3.Driver.emit(() =&gt; new Tile(params)))</p>
<p>这里，也就是直接构造了一个MiniConfig的实例，并把它传递给了需要它的顶层模块Tile。</p>
<p>七、MiniConfig的运行原理<br>我们来看Tile模块的定义：</p>
<p>class Tile(tileParams: Parameters) extends Module with TileBase {<br>  implicit val p = tileParams<br>  val io     = IO(new TileIO)<br>  val core   = Module(new Core)<br>  val icache = Module(new Cache)<br>  val dcache = Module(new Cache)<br>  val arb    = Module(new MemArbiter)</p>
<p>  io.host &lt;&gt; core.io.host<br>  core.io.icache &lt;&gt; icache.io.cpu<br>  core.io.dcache &lt;&gt; dcache.io.cpu<br>  arb.io.icache &lt;&gt; icache.io.nasti<br>  arb.io.dcache &lt;&gt; dcache.io.nasti<br>  io.nasti &lt;&gt; arb.io.nasti<br>}</p>
<p>首先，Tile模块需要一个Parameters类型的参数，我们给了一个MiniConfig的实例，而MiniConfig继承自Config，Config继承自Parameters，所以这是合法的。</p>
<p>然后，Tile模块把入参赋给了隐式变量p。参考隐式定义的内容，这个隐式变量会被编译器传递给当前层次所有未显式给出的隐式参数。查看其他代码的定义，也就是后面实例化的TileIO、Core、Cache和MemArbiter需要隐式参数。由于没有显式给出隐式参数，那么它们都会接收这个隐式变量p，即MiniConfig实例。</p>
<p>以Core模块为例：</p>
<p>class Core(implicit val p: Parameters) extends Module with CoreParams {<br>  val io = IO(new CoreIO)<br>  val dpath = Module(new Datapath)<br>  val ctrl  = Module(new Control)</p>
<p>  io.host &lt;&gt; dpath.io.host<br>  dpath.io.icache &lt;&gt; io.icache<br>  dpath.io.dcache &lt;&gt; io.dcache<br>  dpath.io.ctrl &lt;&gt; ctrl.io<br>} </p>
<p>可以看到，Core模块确实需要接收一个隐式的Parameters类型的参数。</p>
<p>再来看Core混入的特质CoreParams：</p>
<p> abstract trait CoreParams {<br>     implicit val p: Parameters<br>     val xlen = p(XLEN)<br>}</p>
<p>这个特质有未实现的抽象成员，即隐式参数p。抽象成员需要子类给出具体的实现，这里也就是Core模块接收的MiniConfig实例。</p>
<p>那么“val xlen = p(XLEN)”意味着什么呢？我们知道，p是一个MiniConfig的实例对象，它继承了超类View的apply方法。查看apply的定义，也就是调用了：</p>
<p>final def apply<a href="pname: Field[T]">T</a>: T = apply(pname, this)</p>
<p>和 </p>
<p>final def apply<a href="pname: Field[T], site: View">T</a>: T = {<br>  val out = find(pname, site)<br>  require (out.isDefined, s”Key ${pname} is not defined in Parameters”)<br>  out.get<br>}</p>
<p>而XLEN被定义为：</p>
<p>case object XLEN extends Field[Int] </p>
<p>前面推测了XLEN是Field[T]类型的样例对象。现在看到定义，确实如此。</p>
<p>即“val xlen = p(XLEN)”相当于“val xlen = p.apply(XLEN, p)”。这里的this也就是把对象p自己传入。紧接着，apply方法需要调用find方法，即“val out = find(XLEN, p)”。而MiniConfig继承了Parameters的find和chain方法，也就是：</p>
<p>protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a>: Option[T]<br>protected[config] def find<a href="pname: Field[T], site: View">T</a> = chain(site, new TerminalView, pname) </p>
<p>而chain方法继承自Config类：</p>
<p>protected[config] def chain<a href="site: View, tail: View, pname: Field[T]">T</a> = p.chain(site, tail, pname) </p>
<p>注意这里的p是用MiniConfig传递给超类的函数f构造的PartialParameters对象，不是MiniConfig对象自己。即：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">“<span class="hljs-keyword">val</span> out = (<span class="hljs-keyword">new</span> <span class="hljs-type">PartialParameters</span>((site, here, up) =&gt; &#123;…&#125;)).chain(p, <span class="hljs-keyword">new</span> <span class="hljs-type">TerminalView</span>, <span class="hljs-type">XLEN</span>)”。<br></code></pre></div></td></tr></table></figure>
<p>再来看PartialParameters类的chain方法的具体行为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span>[config] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chain</span></span>[<span class="hljs-type">T</span>](site: <span class="hljs-type">View</span>, tail: <span class="hljs-type">View</span>, pname: <span class="hljs-type">Field</span>[<span class="hljs-type">T</span>]) = &#123;<br>   <span class="hljs-keyword">val</span> g = f(site, <span class="hljs-keyword">this</span>, tail)<br>   <span class="hljs-keyword">if</span> (g.isDefinedAt(pname)) <span class="hljs-type">Some</span>(g.apply(pname).asInstanceOf[<span class="hljs-type">T</span>]) <span class="hljs-keyword">else</span> tail.find(pname, site)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>注意，这里的f就是PartialParameters的构造参数，也就是MiniConfig传递给超类Config的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(site, here, up) =&gt; &#123;<br>    <span class="hljs-comment">// Core</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">XLEN</span> =&gt; <span class="hljs-number">32</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Trace</span> =&gt; <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">BuildALU</span>    =&gt; (p: <span class="hljs-type">Parameters</span>) =&gt; <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ALUArea</span>()(p))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">BuildImmGen</span> =&gt; (p: <span class="hljs-type">Parameters</span>) =&gt; <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ImmGenWire</span>()(p))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">BuildBrCond</span> =&gt; (p: <span class="hljs-type">Parameters</span>) =&gt; <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BrCondArea</span>()(p))<br>    <span class="hljs-comment">// Cache</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">NWays</span> =&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> set-associative</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">NSets</span> =&gt; <span class="hljs-number">256</span> <br>    <span class="hljs-keyword">case</span> <span class="hljs-type">CacheBlockBytes</span> =&gt; <span class="hljs-number">4</span> * (here(<span class="hljs-type">XLEN</span>) &gt;&gt; <span class="hljs-number">3</span>) <span class="hljs-comment">// 4 x 32 bits = 16B</span><br>    <span class="hljs-comment">// NastiIO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">NastiKey</span> =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">NastiParameters</span>(<br>        idBits   = <span class="hljs-number">5</span>,<br>        dataBits = <span class="hljs-number">64</span>,<br>        addrBits = here(<span class="hljs-type">XLEN</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>至此，我们就可以确定site = p(MiniConfig对象自己)，here = new PartialParameters((site, here, up) =&gt; {…})(注意这里的this应该是chain的调用对象)，up = new TerminalView。</p>
<p>而g就是由花括号里的9个case语句组成的偏函数。那么g.isDefinedAt(XLEN)就是true，最终chain返回的结果就是“Some(g.apply(XLEN).asInstanceOf[Int])”即可选值Some(32)，注意XLEN是Field[Int]类型的，确定了T是Int。</p>
<p>得到了“val out = Some(32)”后，apply方法的require就能通过，同时返回结果“out.get”即32。最终，“val xlen = p(XLEN)”相当于“val xlen = 32”。也就是说，在混入特质CoreParams的地方，如果有一个隐式Parameters变量是MiniConfig的对象，就会得到一个名为“xlen”的val字段，它的值是32。</p>
<p>关于“here(XLEN)”，因为here已经确定是由f构成的PartialParameters对象，那么套用前述过程，其实也是返回32。</p>
<p>假设偏函数的可行域内没有XLEN，那么chain就会执行“(new TerminalView).find(XLEN, p)”，也就是返回XLEN.default。因为XLEN在定义时没给超类Filed[Int]传递参数，所以会调用Filed[T]的第一个辅助构造函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-type">None</span>) <br></code></pre></div></td></tr></table></figure>
<p>导致XLEN.default = None。这使得“val out = None”，apply方法的require产生异常报错，并打印信息“Key XLEN is not defined in Parameters”。注意字符串插值会把${pname}求值成XLEN。</p>
<p>再来看Core模块里的CoreIO：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreBundle</span>(<span class="hljs-params">implicit val p: <span class="hljs-type">Parameters</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> <span class="hljs-keyword">with</span> <span class="hljs-title">CoreParams</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostIO</span>(<span class="hljs-params">implicit p: <span class="hljs-type">Parameters</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">CoreBundle</span>(<span class="hljs-params"></span>)(<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-keyword">val</span> fromhost = <span class="hljs-type">Flipped</span>(<span class="hljs-type">Valid</span>(<span class="hljs-type">UInt</span>(xlen.<span class="hljs-type">W</span>)))<br>  <span class="hljs-keyword">val</span> tohost   = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(xlen.<span class="hljs-type">W</span>))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreIO</span>(<span class="hljs-params">implicit p: <span class="hljs-type">Parameters</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">CoreBundle</span>(<span class="hljs-params"></span>)(<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-keyword">val</span> host = <span class="hljs-keyword">new</span> <span class="hljs-type">HostIO</span><br>  <span class="hljs-keyword">val</span> icache = <span class="hljs-type">Flipped</span>((<span class="hljs-keyword">new</span> <span class="hljs-type">CacheIO</span>))<br>  <span class="hljs-keyword">val</span> dcache = <span class="hljs-type">Flipped</span>((<span class="hljs-keyword">new</span> <span class="hljs-type">CacheIO</span>))<br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>抽象类CoreBundle混入了特质CoreParams，并接收HostIO传来的隐式参数——MiniConfig的对象(HostIO来自于CoreIO ，CoreIO来自于Core，Core来自于Tile)，所以HostIO有了字段“val xlen = 32”，它定义的端口位宽也就是32位的了。 </p>
<p>对于偏函数其他的case语句，原理一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Trace</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Boolean</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">BuildALU</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Parameters</span> =&gt; <span class="hljs-type">ALU</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">BuildImmGen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Parameters</span> =&gt; <span class="hljs-type">ImmGen</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">BuildBrCond</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Parameters</span> =&gt; <span class="hljs-type">BrCond</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NWays</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Int</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NSets</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Int</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CacheBlockBytes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">Int</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NastiKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Field</span>[<span class="hljs-type">NastiParameters</span>]</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NastiParameters</span>(<span class="hljs-params">dataBits: <span class="hljs-type">Int</span>, addrBits: <span class="hljs-type">Int</span>, idBits: <span class="hljs-type">Int</span></span>)</span><br><br><span class="hljs-keyword">if</span> (p(<span class="hljs-type">Trace</span>)) &#123;<br>    printf(<span class="hljs-string">&quot;PC: %x, INST: %x, REG[%d] &lt;- %x\n&quot;</span>, ew_pc, ew_inst,<br>      <span class="hljs-type">Mux</span>(regFile.io.wen, wb_rd_addr, <span class="hljs-number">0.</span><span class="hljs-type">U</span>),<br>      <span class="hljs-type">Mux</span>(regFile.io.wen, regFile.io.wdata, <span class="hljs-number">0.</span><span class="hljs-type">U</span>))<br>  &#125; <br><br><span class="hljs-keyword">val</span> alu     = p(<span class="hljs-type">BuildALU</span>)(p)<br><span class="hljs-keyword">val</span> immGen  = p(<span class="hljs-type">BuildImmGen</span>)(p)<br><span class="hljs-keyword">val</span> brCond  = p(<span class="hljs-type">BuildBrCond</span>)(p) <br><br><span class="hljs-keyword">val</span> nWays  = p(<span class="hljs-type">NWays</span>) <span class="hljs-comment">// Not used...</span><br><span class="hljs-keyword">val</span> nSets  = p(<span class="hljs-type">NSets</span>)<br><span class="hljs-keyword">val</span> bBytes = p(<span class="hljs-type">CacheBlockBytes</span>) <br><br><span class="hljs-keyword">val</span> nastiExternal = p(<span class="hljs-type">NastiKey</span>)<br><span class="hljs-keyword">val</span> nastiXDataBits = nastiExternal.dataBits<br><span class="hljs-keyword">val</span> nastiWStrobeBits = nastiXDataBits / <span class="hljs-number">8</span><br><span class="hljs-keyword">val</span> nastiXAddrBits = nastiExternal.addrBits<br><span class="hljs-keyword">val</span> nastiWIdBits = nastiExternal.idBits<br><span class="hljs-keyword">val</span> nastiRIdBits = nastiExternal.idBits<br>...... <br></code></pre></div></td></tr></table></figure>
<h2 id="10-8-总结：如何自定义参数"><a href="#10-8-总结：如何自定义参数" class="headerlink" title="10.8 总结：如何自定义参数"></a>10.8 总结：如何自定义参数</h2><p>首先要导入第一点给出的文件，其次是像定义MiniConfig那样定义自己的参数类，然后实例化参数类，并用隐式参数传递给相应的模块。模块在定义时，记得要留好隐式参数列表。</p>
<p>如果当前作用域有隐式的参数类对象，那么用“val xxx = p(XXX)”参数化的字段就能根据隐式对象求得具体的值。改变隐式对象的内容，就能动态地定义像位宽这样的关键字段。这样裁剪设计时，只需要修改自定义参数类的偏函数，而不需要每个地方都去更改。</p>
<h2 id="10-9-后记"><a href="#10-9-后记" class="headerlink" title="10.9 后记"></a>10.9 后记</h2><p>Chisel系列的博客暂时更新完毕，如若后续有大版本发布，语言改动较大，再来及时更新。</p>
<hr>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p2.jpg" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p3.jpg" srcset="/img/loading.gif" lazyload alt="96733090_p3"></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg" srcset="/img/loading.gif" lazyload alt="96733090_p4"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/categories/IC/Chiesl/">Chiesl</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202203092029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%A7%A3%E5%86%B3Ubuntu%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E5%AF%BC%E8%87%B4%E7%99%BB%E5%BD%95%E5%BE%AA%E7%8E%AF%E8%BF%9B%E4%B8%8D%E5%8E%BB%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">解决Ubuntu修改环境变量后导致登录循环进不去系统的问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/">
                        <span class="hidden-mobile">Scala（二）：进阶篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  
  <div id="aplayer" style="width:300px"></div>
  <link defer rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
  <script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js"></script>
  <script defer src="/js/aplayer.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"left","width":250,"height":500,"vOffset":-18},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
