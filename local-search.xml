<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo框架下的博客多主机写作方案</title>
    <link href="/202201111602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%9A%E4%B8%BB%E6%9C%BA%E5%86%99%E4%BD%9C%E6%96%B9%E6%A1%88/"/>
    <url>/202201111602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%9A%E4%B8%BB%E6%9C%BA%E5%86%99%E4%BD%9C%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo框架下的博客多主机写作方案"><a href="#hexo框架下的博客多主机写作方案" class="headerlink" title="hexo框架下的博客多主机写作方案"></a>hexo框架下的博客多主机写作方案</h2><p>参考链接：<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1 安装Git"></a>1 安装Git</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程</p><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git</p><h2 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2 安装nodejs"></a>2 安装nodejs</h2><p>安装nodejs，因为之前用的nodejs是<a href="https://nodejs.org/dist/v12.16.1/">v12.16.1/</a>版本的，所以下载也是，通过这个官方镜像网站进行访问<a href="https://npmmirror.com/mirrors/node/">Node.js Mirror (npmmirror.com)</a></p><p>或者是通过中文官网找到合适的下载路径<a href="http://nodejs.cn/download/">下载 | Node.js 中文网 (nodejs.cn)</a></p><p>下载时选择.msi文件的安装包进行安装</p><h2 id="3-安装hexo-博客文件夹下"><a href="#3-安装hexo-博客文件夹下" class="headerlink" title="3 安装hexo(博客文件夹下)"></a>3 安装hexo(博客文件夹下)</h2><h3 id="本地目录的创建-克隆："><a href="#本地目录的创建-克隆：" class="headerlink" title="本地目录的创建/克隆："></a>本地目录的创建/克隆：</h3><p>前面git和nodejs安装好后，就可以安装hexo了</p><p>首先，你需要一个博客的本地目录/将远程工程克隆到本地用来安装hexo：</p><ul><li><p>你需要先把之前本地blog push到github上，在这里就只需要进行<code>git clone</code>就可以，<a href="https://github.com/GreensCH/blog-code.git">本博客git clone地址（需要权限）</a></p></li><li><p>你也可以创建一个文件夹blog，然后<code>cd</code>到这个文件夹下</p><hr></li></ul><h3 id="hexo的安装："><a href="#hexo的安装：" class="headerlink" title="hexo的安装："></a>hexo的安装：</h3><p>再者进行hexo的安装</p><ul><li>使用<a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供的命令进行安装<ul><li><code>npm install hexo-cli -g</code></li><li>如果安装中出现问题，输入返回提示中的命令<code>$ rm -rf node_modules &amp;&amp; npm install --force</code>即可</li></ul></li></ul><h2 id="4-SSH添加到github"><a href="#4-SSH添加到github" class="headerlink" title="4 SSH添加到github"></a>4 SSH添加到github</h2><h3 id="创建SSH："><a href="#创建SSH：" class="headerlink" title="创建SSH："></a>创建SSH：</h3><ul><li>回到你的git bash中，输入以下命令（这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户）</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li>可以用以下两条，检查一下你有没有输对</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config user.name<br>git config user.email<br></code></pre></div></td></tr></table></figure><ul><li>然后用下方命令创建SSH，一路回车</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></div></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><hr><h3 id="公钥添加到github上："><a href="#公钥添加到github上：" class="headerlink" title="公钥添加到github上："></a>公钥添加到github上：</h3><blockquote><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/3194ad0a9d04d94c09485122932968f3.png" alt="img"></p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><hr><h3 id="查看是否成功："><a href="#查看是否成功：" class="headerlink" title="查看是否成功："></a>查看是否成功：</h3><ul><li><p>在gitbash中，查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="5-修改live2d的本地目录地址，或者将文件移动到此地址"><a href="#5-修改live2d的本地目录地址，或者将文件移动到此地址" class="headerlink" title="5 修改live2d的本地目录地址，或者将文件移动到此地址"></a>5 修改live2d的本地目录地址，或者将文件移动到此地址</h2>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(个人用)游戏快捷键</title>
    <link href="/202201051602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/%E7%BA%A2%E8%AD%A63%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/202201051602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/%E7%BA%A2%E8%AD%A63%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>部队位置预览：同时按住左右两个按键，可用于集中部队</p><p>平视视角：极高画质下，滚轮拉到底</p><p>恢复视角：点击滚轮</p><p>维修：C</p><p>卖出：Z</p><p>滚到某一类型单位：TAB</p><p>回滚到某一类型单位：shift+TAB</p><p>选择某一类型单位： F1，2，3，4（用于替换单击）如右图<img src="C:\Users\常桂林\AppData\Roaming\Typora\typora-user-images\image-20220108203153584.png" alt="image-20220108203153584"></p><p><strong>同时安装多个建筑：</strong>利用上述F123456配合切换的ER切换建造单位进行建造（即对应位置F1~F9，ER相互切换的点）</p><p><strong>连续造五个单位：</strong>shift+单机</p><p>一次性清空所有建造单位：shift+右键</p><p>路径点模式：alt</p><p>*计划模式（先不动的路径点模式）：ctrl+z</p><p>*编屏/跳转地图书签：ctrl+JKL/JKL…</p><p>选中全体作战单位：Q</p><p>选中当前画面相同的单位：W</p><p>选中所有相同的单位：WW</p><p>加入原有选择：shift</p><p><strong>补充编队（两种方法）：</strong></p><ul><li>不断WW选中再重新ctrl编队</li><li>方法二（两部）：<ul><li>选中：shift+编队名</li><li>编队：ctrl+编队名</li></ul></li></ul><p>显示血条：shift+space</p><p>*设置集结点：ctrl+R</p><p>跳转到下一个支援单位(支援单位指的是基地车、矿车、工兵)：N</p><p><strong>查看前一个事件(事件指的是副官说的内容)</strong>：space</p><p>一键散兵：X</p><hr><h2 id="补充实用内容"><a href="#补充实用内容" class="headerlink" title="补充实用内容"></a>补充实用内容</h2><p>路径点模式配合F：</p><ul><li>设置路径点</li><li>手动点击特殊技能而不是直接按F</li></ul><p><strong>四连F：</strong></p><ul><li>选中</li><li>F+1</li><li>F+2</li><li>….F345567</li></ul><p><strong>如何攻击：</strong></p><ul><li>选中</li><li>按A</li><li>鼠标左右预览过去，而不是直接右键（所有单位同步过去）</li></ul><hr><h2 id="不实用内容"><a href="#不实用内容" class="headerlink" title="不实用内容"></a>不实用内容</h2><p>全局聊天：enter</p><p>友军聊天：backspace</p><p>语音聊天/切换全局和团队语音：V/ctrl+V</p><p>加信标（只能同时存在三个）：B</p><p>删除信标：delete</p><p>在小地图上画画：B</p><p>csgo的无线电：M</p><p>放录像快进：.</p><p>快速保存：shift+S</p><p>快速载入：shift+l</p><p>关闭血条：end</p><p>截图：F12</p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/202201031521/uncategorizedessay/ic/sv%E5%AD%A6%E4%B9%A0/TCL07-%E8%BF%87%E7%A8%8B/"/>
    <url>/202201031521/uncategorizedessay/ic/sv%E5%AD%A6%E4%B9%A0/TCL07-%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>Tcl分为：</p><ul><li>内建(Build-in)过程（如power()、exp()等）</li><li>用户自定义过程</li></ul><p>``proc 参数一 {参数二} {参数三}</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Tcl"><span class="hljs-keyword">proc</span><span class="hljs-title"> func</span> &#123;ref1 ref2&#125;&#123;<br>tcl_sentence<br>&#125;<br></code></pre></div></td></tr></table></figure><p>proc只是一个普通的Tcl命令而不是特殊的语法声明，因此pro的参数处理方法和其他Tcl命令相同</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/202201031413/uncategorizedessay/ic/sv%E5%AD%A6%E4%B9%A0/TCL06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/202201031413/uncategorizedessay/ic/sv%E5%AD%A6%E4%B9%A0/TCL06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="1-语法重点"><a href="#1-语法重点" class="headerlink" title="1 语法重点"></a>1 语法重点</h2><ul><li><p>各种控制语句包括：if,switch,while,for,foreach(在列表和数组中提到),source</p></li><li><p>控制语句内部执行的脚本实际上是本语句的一个参数（本质上执行了一条语句）</p></li><li><p>有关大括号{}和换行符的</p><ul><li><p>Tcl解释器认为换行符是前一个命令的分隔符，除非换行符在花括号或者双引号之内（参考if语句的参数二）</p></li><li><p>```tcl</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>+ 有关大括号&#123;&#125;和双引号的<br><br>+ 表达式真假：<br><br>  + 真：非0、<span class="hljs-literal">yes</span>、<span class="hljs-literal">true</span><br>  + 假：0、<span class="hljs-literal">no</span>、<span class="hljs-literal">false</span><br><br><br><span class="hljs-comment">## 2 各种控制语句</span><br><br><span class="hljs-comment">### 2.1 if 语句</span><br><br><span class="hljs-comment">### 标准if</span><br><br>标准语句：<br><br>``<span class="hljs-keyword">if</span>&#123;参数一&#125;&#123;参数二&#125;``：第一个参数是一个表达式，第二个参数是待执行的TCL脚本<br><br>```tcl<br><span class="hljs-builtin-name">set</span> x 1<br><span class="hljs-keyword">if</span>&#123;<span class="hljs-variable">$x</span>&gt;0&#125;&#123;<br><span class="hljs-builtin-name">set</span> x -<span class="hljs-variable">$x</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>错误语句（类C）：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> x <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>&#123;<span class="hljs-variable">$x</span>&gt;<span class="hljs-number">0</span>&#125;<br>&#123;<br><span class="hljs-keyword">set</span> x -<span class="hljs-variable">$x</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>错误原因查看上一节有关大括号和双引号内容</li></ul><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>标准语句：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><p>错误语句（类C）：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;<br>&#123;<br>脚本一<br>&#125; <br>else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><ul><li>错误原因查看上一节有关大括号和双引号内容</li></ul><h3 id="if-elseif-else"><a href="#if-elseif-else" class="headerlink" title="if-elseif-else"></a>if-elseif-else</h3><p>标准语句：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; elseif &#123;<br>脚本二<br>&#125; else &#123;<br>脚本三<br>&#125;<br>脚本四<br></code></pre></div></td></tr></table></figure><p>有时候switch比if-elseif-else更高效</p><h2 id="2-2-switch"><a href="#2-2-switch" class="headerlink" title="2.2 switch"></a>2.2 switch</h2><h3 id="标准语句："><a href="#标准语句：" class="headerlink" title="标准语句："></a>标准语句：</h3><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><h3 id="匹配模式参数"><a href="#匹配模式参数" class="headerlink" title="匹配模式参数"></a>匹配模式参数</h3><h2 id="2-3-while"><a href="#2-3-while" class="headerlink" title="2.3 while"></a>2.3 while</h2><h2 id="2-4-for"><a href="#2-4-for" class="headerlink" title="2.4 for"></a>2.4 for</h2><h2 id="2-5-source"><a href="#2-5-source" class="headerlink" title="2.5 source"></a>2.5 source</h2><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶7：Item_Sequence_Sequencer_Driver</title>
    <link href="/202111302244/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B67%EF%BC%9AItem_Sequence_Sequencer_Driver/"/>
    <url>/202111302244/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B67%EF%BC%9AItem_Sequence_Sequencer_Driver/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>Item， Sequence， Sequencer， Driver介绍</li><li>Item， Sequence， Sequencer， Driver两两之间的关系与常见操作</li><li>如何构建一个测试序列(sequence)</li></ul><p>背景：</p><p>小白第一年可能不会直接写验证环境，而是写一些seq和test</p><p>对于小白来讲第一年工作基本就两件事：</p><ul><li>（第一年）构建seq，使用这些宏</li><li>（第一年）定义功能覆盖率，对他们进行收敛</li></ul><p>第二年创建环境：</p><ul><li>（第二年）创建环境，你可以把实验代码照搬过工作中去修改</li></ul><h1 id="1-新手上路"><a href="#1-新手上路" class="headerlink" title="1 新手上路"></a>1 新手上路</h1><h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><h3 id="run-phase"><a href="#run-phase" class="headerlink" title="run_phase"></a>run_phase</h3><ul><li><p>到我们的run_phase了</p></li><li><p>driver,monitor,checker,reference_model的run_phase都是些forever，和sv里面的run任务相同，它们不会停下来，sv里面只有generator会停下来</p></li><li><p>这节课我们会讲，在run_phase我们的激励怎么一步一步把item通过sqr发送到dri一侧</p></li></ul><h2 id="1-2-四个核心词介绍"><a href="#1-2-四个核心词介绍" class="headerlink" title="1.2 四个核心词介绍"></a>1.2 四个核心词介绍</h2><p><strong>本章主要讲四个核心词的作用、分类以及之间的互动关系</strong></p><ul><li>sequence item</li><li>sequence</li><li>sequencer</li><li>driver</li></ul><h3 id="1-2-1-trans驱动作用"><a href="#1-2-1-trans驱动作用" class="headerlink" title="1.2.1 trans驱动作用"></a>1.2.1 trans驱动作用</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201105614128.png" alt="image-20211201105614128"></p><p>整个事物的驱动力就是transaction的传送</p><h3 id="1-2-2-四者关系打比方"><a href="#1-2-2-四者关系打比方" class="headerlink" title="1.2.2 四者关系打比方"></a>1.2.2 四者关系打比方</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201113557243.png" alt="image-20211201113557243"></p><pre><code class=" mermaid">graph TBsequence --&gt; 道路sequence_item --&gt; 货车sequencer --&gt; 目的地关卡driver --&gt; 目的_进行扫描与分解</code></pre><p>通路结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201133536311.png" alt="image-20211201133536311"></p><ul><li>sqr到driver是通过req与rsp</li></ul><h3 id="1-2-3-sequencer-item"><a href="#1-2-3-sequencer-item" class="headerlink" title="1.2.3 sequencer item"></a>1.2.3 sequencer item</h3><p>sequence item是driver与DUT每一次互动的最小颗粒度</p><p>sequence item是一个类</p><ul><li>内部可定义成员方法或变量，成员变量应考虑是否需要随机化</li></ul><h3 id="1-2-4-driver：一个例子"><a href="#1-2-4-driver：一个例子" class="headerlink" title="1.2.4 driver：一个例子"></a>1.2.4 driver：一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201134705399-16383376267321.png" alt="image-20211201134705399"></p><p><strong>一个例子</strong>：假设DUT是slave端，driver扮演master访问DUT寄存器</p><ul><li>item定义的数据信息包括：地址、命令码、数据和状态值（访问是否成功，V1V2的MCDF不涉及状态码，UVM实战会完善）</li><li>driver任务：<ul><li>driver取得后通过时序方式在initerface一侧发起激励至DUT<ul><li>这种时序需要保持几个时钟（按照总线做寄存去访问的习惯）</li></ul></li></ul></li></ul><h3 id="1-2-5-sequence-的层次化"><a href="#1-2-5-sequence-的层次化" class="headerlink" title="1.2.5 sequence 的层次化"></a>1.2.5 sequence 的层次化</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201135832487.png" alt="image-20211201135832487"></p><p>sequence内部包括item可以包括sequence，从而sequence一层一层实现层次化</p><h3 id="1-2-6-sequencer"><a href="#1-2-6-sequencer" class="headerlink" title="1.2.6 sequencer"></a>1.2.6 sequencer</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141140565.png" alt="image-20211201141140565"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141204261.png" alt="image-20211201141204261"></p><ul><li>sequencer是sequence与driver之间的桥梁，使用TLM进行通信，通信参数为sequence_item类</li><li>sequencer的相关控制方法都在uvm_sequence里面</li></ul><h3 id="1-2-7-driver"><a href="#1-2-7-driver" class="headerlink" title="1.2.7 driver"></a>1.2.7 driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141253909.png" alt="image-20211201141253909"></p><p>driver特点：</p><ul><li>永远喂不饱，forever驱动</li><li>不会修改item值</li></ul><h3 id="1-2-8-sequence的互动"><a href="#1-2-8-sequence的互动" class="headerlink" title="1.2.8 sequence的互动"></a>1.2.8 sequence的互动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201133503968.png" alt="image-20211201133503968"></p><h2 id="1-3-继承关系"><a href="#1-3-继承关系" class="headerlink" title="1.3 继承关系"></a>1.3 继承关系</h2><h3 id="1-3-1-uvm-sequence是obj"><a href="#1-3-1-uvm-sequence是obj" class="headerlink" title="1.3.1 uvm_sequence是obj"></a>1.3.1 uvm_sequence是obj</h3><p>uvm_sequence_item和uvm_sequence都继承于uvm_object，不同于comp只在build_phase里创建和配置，obj可以在任何时候穿几件</p><p>uvm_sequence与uvm_comp继承树</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141531814.png" alt="image-20211201141531814"></p><h3 id="1-3-2-提示：sequence继承obj而带来的特点"><a href="#1-3-2-提示：sequence继承obj而带来的特点" class="headerlink" title="1.3.2 提示：sequence继承obj而带来的特点"></a>1.3.2 提示：sequence继承obj而带来的特点</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141627603.png" alt="image-20211201141627603"></p><p>（1）你无法预测run阶段什么时候会创建sequence并挂在到sqr上，也无法通过phase机制识别sequence 的运行阶段</p><p>（2）obj独立于build阶段外，所以可以动态挂在</p><p>（3）seq无法在顶层配置的时候按照层次关系直接进行配置</p><p>（4）seq必须挂载到sqr，并依赖于sqr的结构关系来间接获取顶层配置信息</p><h3 id="1-3-3-提示"><a href="#1-3-3-提示" class="headerlink" title="1.3.3 提示"></a>1.3.3 提示</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201170827558.png" alt="image-20211201170827558"></p><p>（1）新手：将时序控制的权力给seq，即seq产生item，seq交给driver</p><p>（2）明确职责的情况：seq应该只负责生成item</p><p>（3）item生成和传送并不代表最终的接口时序，决定接口时序的是sqr和dri。进而引申出一个问题，为什么要有sqr在seq和dri之间</p><ul><li>sqr既是关卡也是路由</li><li>sqr是一个组件，可以通过TLM端口传送item</li><li>sqr有仲裁机制，处理多个并行seq</li></ul><h2 id="1-4-总结：数据传送机制"><a href="#1-4-总结：数据传送机制" class="headerlink" title="1.4 总结：数据传送机制"></a>1.4 总结：数据传送机制</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201172240003.png" alt="image-20211201172240003"></p><p>（1）数据传送机制是get模式（关于put和ge模式参考TLM）</p><ul><li>sv里面是generator产生item，stimulator/driver去get</li><li>uvm也是get模式，driver是initiator，是get模式</li></ul><p>如图：</p><p>通信模式</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174511162.png" alt="image-20211201174511162"></p><p>数据传输方向：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174541927.png" alt="image-20211201174541927"></p><p>（2）为什么是get模式：</p><ul><li>效率较高：seq产生item可以直接到达sqr，穿过sqr到达dri即可结束传输；put还需要收到返回值才可以发起下一次的传输</li><li>seq的仲裁特性：仲裁特性更符合设计思维：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174819011.png" alt="image-20211201174819011"></li></ul></li></ul><h1 id="2-Sequence和Item"><a href="#2-Sequence和Item" class="headerlink" title="2 Sequence和Item"></a>2 Sequence和Item</h1><h2 id="2-1-概述（引入）"><a href="#2-1-概述（引入）" class="headerlink" title="2.1 概述（引入）"></a>2.1 概述（引入）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201175018828.png" alt="image-20211201175018828"></p><p>（3）</p><ul><li><p>seq指的是：uvm_sequence类</p></li><li><p>item指的是：uvm_sequence_item类</p></li></ul><p>（4）环境中至少有一个seq，不能仅仅一个item就可以想当然的发送到sqr</p><h2 id="2-2-sequence-item-介绍"><a href="#2-2-sequence-item-介绍" class="headerlink" title="2.2 sequence item 介绍"></a>2.2 sequence item 介绍</h2><p>item继承于uvm_object，具备obj核心方法：<code>copy()</code>，<code>clone()</code>，<code>compare()</code>，<code>record()</code></p><p>item内部数据成员可分为以下几类：</p><ul><li>控制类：如总线协议上的读写类型、数据长度、传送模式</li><li>负载类：一般指数据总线上的数据包</li><li>配置类：用来控制driver的驱动行为，例如命令driver的发送间隔或者有无错误插入<ul><li>config_db只能配置一次driver</li><li>item控制</li></ul></li><li>调试类：用来标记一些额外信息方便调试，例如该对象的<strong>实例序号</strong>、创建时间、被driver解析的时间始末等</li></ul><h2 id="2-3-item的简单例子"><a href="#2-3-item的简单例子" class="headerlink" title="2.3 item的简单例子"></a>2.3 item的简单例子</h2><p>sqr没有接dri与seq，仅仅看item是怎么回事</p><h3 id="item定义"><a href="#item定义" class="headerlink" title="item定义"></a>item定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225256849.png" alt="image-20211201225256849"></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225400298.png" alt="image-20211201225400298"></p><p>这里用new创建obj，复习一下create的好处：</p><ul><li>override</li><li>建立层次化关系</li><li>comp不可以new？</li></ul><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225558954.png" alt="image-20211201225558954"></p><p>t1没有随机化，t2随机化了</p><h2 id="2-4-item使用特点"><a href="#2-4-item使用特点" class="headerlink" title="2.4 item使用特点"></a>2.4 item使用特点</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225617852.png" alt="image-20211201225617852"></p><p>（1）数据成员为rand形</p><p>（2）使用`uvm_field_xxx宏进行数据成员声明，便于域自动化</p><p>（3）seq的body()很重要，和run类似</p><p>（4）item生命周期：始于seq的body()，穿越sqr，最终到达dri并被笑话</p><ul><li>item要善用copy()，clone()等数据方法</li></ul><h2 id="2-5-item与seq的关系"><a href="#2-5-item与seq的关系" class="headerlink" title="2.5 item与seq的关系"></a>2.5 item与seq的关系</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225939333.png" alt="image-20211201225939333"> </p><p>（1）seq控制item实例的随机化，因此内部应预留可供外部随机化的变量，通过层级传递进seq进而控制item，控制item的内容有</p><ul><li>item内部随机变量</li><li>item之间的组织和时序控制</li></ul><h2 id="2-6-三类常见的seq定义方式："><a href="#2-6-三类常见的seq定义方式：" class="headerlink" title="2.6 三类常见的seq定义方式："></a>2.6 三类常见的seq定义方式：</h2><ul><li><p>扁平类（flat sequence）：最简单的，只组织最小颗粒度即item</p></li><li><p>层次类（hierarchical sequence）：更高层seq包括底层seq</p></li><li>虚拟类（virtual sequence）：工作后经常用的，控制整个测试场景中不同的seq</li></ul><h2 id="2-7-三类seq定义：Flat-Sequence-介绍"><a href="#2-7-三类seq定义：Flat-Sequence-介绍" class="headerlink" title="2.7 三类seq定义：Flat Sequence 介绍"></a>2.7 三类seq定义：Flat Sequence 介绍</h2><h3 id="2-7-1-介绍"><a href="#2-7-1-介绍" class="headerlink" title="2.7.1 介绍"></a>2.7.1 介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230645731.png" alt="image-20211201230645731"></p><h3 id="2-7-2-代码示例一"><a href="#2-7-2-代码示例一" class="headerlink" title="2.7.2 代码示例一"></a>2.7.2 代码示例一</h3><h4 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230925611.png" alt="image-20211201230925611"></p><ul><li>body就像组件中的run一样，因为obj不参与phase，定义了body你不需要手动运行就和你不需要手动run一样</li><li>数据的随机化：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231059436.png" alt="image-20211201231059436"></li></ul></li></ul><h4 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230854209.png" alt="image-20211201230854209"></p><p>这里为什么手动执行body()，因为这不是个完整的代码，完整的应该是由挂载到的sqr自动运行</p><h4 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231331801.png" alt="image-20211201231331801"></p><p>（1）暂时没有用seq宏</p><p>（4）示例一颗粒度较小没有使用item</p><h3 id="2-7-3-代码示例二：加大颗粒度（使用item）"><a href="#2-7-3-代码示例二：加大颗粒度（使用item）" class="headerlink" title="2.7.3 代码示例二：加大颗粒度（使用item）"></a>2.7.3 代码示例二：加大颗粒度（使用item）</h3><h4 id="trans"><a href="#trans" class="headerlink" title="trans"></a>trans</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231554790.png" alt="image-20211201231554790"></p><h4 id="seq更多的去做一些控制的任务"><a href="#seq更多的去做一些控制的任务" class="headerlink" title="seq更多的去做一些控制的任务"></a>seq更多的去做一些控制的任务</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231846970.png" alt="image-20211201231846970"></p><ul><li><p>seq更加简洁</p></li><li><p>多的去做一些控制的任务，粒度由trans控制</p></li><li><p>只需要例化一个trans实例</p></li></ul><h4 id="test没有什么大的变化"><a href="#test没有什么大的变化" class="headerlink" title="test没有什么大的变化"></a>test没有什么大的变化</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232126539.png" alt="image-20211201232126539"></p><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232239563.png" alt="image-20211201232239563"></p><h3 id="2-7-4-如何去定义一个item，粒度多少合适？"><a href="#2-7-4-如何去定义一个item，粒度多少合适？" class="headerlink" title="2.7.4 如何去定义一个item，粒度多少合适？"></a>2.7.4 如何去定义一个item，粒度多少合适？</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232253752.png" alt="image-20211201232253752"></p><p>简单来讲：seq里面包含多个item</p><h2 id="2-8-三类seq定义：Hierarchical-Sequence-介绍"><a href="#2-8-三类seq定义：Hierarchical-Sequence-介绍" class="headerlink" title="2.8 三类seq定义：Hierarchical Sequence 介绍"></a>2.8 三类seq定义：Hierarchical Sequence 介绍</h2><h3 id="2-8-1-介绍"><a href="#2-8-1-介绍" class="headerlink" title="2.8.1 介绍"></a>2.8.1 介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232405666.png" alt="image-20211201232405666"></p><ul><li>嵌套seq好处是可以创建更丰富的激励场景</li><li>hierarchical seq可以嵌套：hierarchical seq，flat seq，item</li></ul><h3 id="2-8-2-代码示例：trans与flatseq基于2-7-3"><a href="#2-8-2-代码示例：trans与flatseq基于2-7-3" class="headerlink" title="2.8.2 代码示例：trans与flatseq基于2.7.3"></a>2.8.2 代码示例：trans与flatseq基于2.7.3</h3><h4 id="hier-seq"><a href="#hier-seq" class="headerlink" title="hier_seq"></a>hier_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232553633.png" alt="image-20211201232553633"></p><p>宏做了三件事：</p><ul><li>创建了seq和item</li><li>完成了随机化</li><li>传送到sqr上</li></ul><h3 id="2-8-3-示例总结"><a href="#2-8-3-示例总结" class="headerlink" title="2.8.3 示例总结"></a>2.8.3 示例总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232800181.png" alt="image-20211201232800181"></p><p>（1）示例代码宏的三个作用</p><p>（3）示例中既有串行的激励关系，也有并行的激励关系</p><p>更复杂的场景中可以加入seq/item之间的时序关系：</p><ul><li>事件同步</li><li>一定的延迟关系</li></ul><h1 id="3-Sequencer和Driver"><a href="#3-Sequencer和Driver" class="headerlink" title="3 Sequencer和Driver"></a>3 Sequencer和Driver</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-数据传输概述"><a href="#3-1-1-数据传输概述" class="headerlink" title="3.1.1 数据传输概述"></a>3.1.1 数据传输概述</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202164914967.png" alt="image-20211202164914967"></p><hr><ul><li><p>seq与dri是组件，组件之间的通信依赖于TLM端口</p></li><li><p>数据传送机制是get模式（关于put和ge模式参考TLM）</p><ul><li><p>sv里面是generator产生item，stimulator/driver去get</p></li><li><p>uvm也是get模式，driver是initiator，是get模式</p></li></ul></li></ul><hr><p>seq与dri的端口结构图：双向的数据传输</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202164857361.png" alt="image-20211202164857361"></p><h3 id="3-1-2-端口"><a href="#3-1-2-端口" class="headerlink" title="3.1.2 端口"></a>3.1.2 端口</h3><p><strong>（1）端口：</strong></p><p>UVM<strong>专门提供</strong>便于item传输的<strong>端口</strong>，供seq与driv使用：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm seq_item pull_port <span class="hljs-variable">#(type REQ=int, type RSP=REQ)</span><br>uvm_seq_item_pull_export <span class="hljs-variable">#(type REQ=int, type RSP=REQ)</span><br>uvm_seq_item_pull_imp <span class="hljs-variable">#(type REQ=int, type RSP=REQ, type imp=int)</span><br></code></pre></div></td></tr></table></figure><p><strong>（2）端口分类：</strong></p><p>由于<strong>driver</strong>是请求发起端，所以在driver一侧例化了下面<strong>两种</strong>端口，<strong>一般我们只会使用其中一种</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_seq_item_pull_port <span class="hljs-variable">#(REP, RSP)</span> seq_item_port<span class="hljs-comment">//一般只使用这个，这个端口既可以get req又可以put rsp</span><br>uvm_analysis_port <span class="hljs-variable">#(RSP)</span> rsp_port<span class="hljs-comment">//广播模式端口，一段对多段，专门广播rsp，一般Monitor会用</span><br></code></pre></div></td></tr></table></figure><p>而<strong>sequencer</strong>一侧则为请求的响应端，在sequencer一侧例化了 对应的两种端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_seq_item_pull_imp <span class="hljs-variable">#(REQ, RSP, this_type)</span> seq_item_export<span class="hljs-comment">//名字export实际上是imp</span><br>uvm_analysis_export <span class="hljs-variable">#(RSP)</span> rsp_export<br></code></pre></div></td></tr></table></figure><ul><li>为什么是export实际上是imp？：<ul><li>因为sqr里面有fifo，对外显示的是export但已经是最后一个组件了，对内还需要连接</li><li>如图所示：<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202165831924.png" alt="image-20211202165831924"></li><li>补充sqr只有rsp的fifo没有req的fifo</li></ul></li></ul><p>回忆三种port</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202165649765.png" alt="image-20211202165649765"></p><h3 id="3-1-3-端口的连接"><a href="#3-1-3-端口的连接" class="headerlink" title="3.1.3 端口的连接"></a>3.1.3 端口的连接</h3><p>dri与sqr的端口成对组合，一共两对，进行连接：</p><ul><li>第一对：<ul><li><code>uvm_seq_item_pull_port #(REP, RSP) seq_item_port</code></li><li><code>uvm_seq_item_pull_imp #(REQ, RSP, this_type) seq_item_export</code></li></ul></li><li>第二对：<ul><li><code>uvm_analysis_port #(RSP) rsp_port</code></li><li><code>uvm_analysis_export #(RSP) rsp_export</code></li></ul></li></ul><p>两组端口都可以实现rsp发送，但方式不一样</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202170821975.png" alt="image-20211202170821975"></p><p>（1）<strong>通常使用第一对就够了</strong>，即：<code>driver::seq_item_port.connect(sequencer::seq_item_export)</code></p><h3 id="3-1-4-第一对端口的方法-需要反复听"><a href="#3-1-4-第一对端口的方法-需要反复听" class="headerlink" title="3.1.4 第一对端口的方法(需要反复听)"></a>3.1.4 第一对端口的方法(需要反复听)</h3><p>在driver一侧，通过seq_item_port调用这一种类型的TLM端口的方法：</p><ul><li>task get_next_item(output REQ req_arg)：采取blocking的方式等待从sequence获 取下一个item<ul><li><strong>常用</strong>，blocking即阻塞的方式</li></ul></li><li>task try_next_item(output REQ req_arg):采取nonblocking的方式从sequencer获 取item,如果立即返回的结果req_arg为null,则表示sequence还没有准备好<ul><li>nonblocking即非阻塞</li></ul></li><li>function void item_done(input RSP rsp_arg=null)：用来<strong>通知sequence</strong>当前的 sequence item已经消化完毕，可以选播性地传递RSP参数，返回状态值<ul><li><strong>不可缺少</strong>，完成一个完整的握手</li></ul></li><li>task wait_for_sequences()：等待当前的sequence直到产生下一个有效的item <ul><li>用的较少</li></ul></li><li>function bit has_do_available():如果当前的sequence准备好而且可以获取下一个有 效的item,则返向1,否则返回0</li><li><p>function void put_response(input RSP rsp_arg)：采取nonblocking方式发送 response,如果丽］返回1,否则返回0</p></li><li><p>也可以用传统的：</p><ul><li><p>task get(output REQ req_arg):采用get方式获取item</p></li><li><p>task peek(output REQ req_arg):采用peek方式获取item</p></li><li><p>task put(input RSP rsp_arg)：采取blocking方式将response发送回sequence</p></li><li><p>为什么有这三个port？</p><ul><li>uvm seq_item pull_port,uvm seq_item pull_export,uvm seq_item pull_imp这三个port继承于之前的tlm_port，这些port保留下来</li></ul></li></ul></li></ul><p>经常成对出现的方法：</p><ul><li>get_next_item与item_done</li></ul><p>put rsp独立出现</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202171759071.png" alt="image-20211202171759071"></p><h3 id="3-1-5-sqr与dri参数类的REQ与RSP的类型参数"><a href="#3-1-5-sqr与dri参数类的REQ与RSP的类型参数" class="headerlink" title="3.1.5 sqr与dri参数类的REQ与RSP的类型参数"></a>3.1.5 sqr与dri参数类的REQ与RSP的类型参数</h3><h4 id="参数类声明原型："><a href="#参数类声明原型：" class="headerlink" title="参数类声明原型："></a>参数类声明原型：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202180517844-16384395186521.png" alt="image-20211202180517844"></p><p>参数类内部的类型一致，缺省值为uvm_sequence_item，即自定义的Item的父类类型</p><hr><h4 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202182723182.png" alt="image-20211202182723182"></p><p>（1）如上所说缺省时拿到的是父类类型，需要动态进行类型转换</p><p>（2）类型参数为自定义类时不用在意</p><hr><h4 id="类型保持一致的作用："><a href="#类型保持一致的作用：" class="headerlink" title="类型保持一致的作用："></a>类型保持一致的作用：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202182940197.png" alt="image-20211202182940197"></p><p>把rsp反馈到sqr的四种方法：</p><ul><li>put(rsp)//put rsp</li><li>put()//put方法</li><li>rsp_port::write(RSP)//rsp_port进行write写入</li><li>item_done</li></ul><p>这四种方法最终都会写入到一个fifo里面</p><h2 id="3-2-事务传递实例"><a href="#3-2-事务传递实例" class="headerlink" title="3.2 事务传递实例"></a>3.2 事务传递实例</h2><h3 id="（1）item-trans-和-flat-seq"><a href="#（1）item-trans-和-flat-seq" class="headerlink" title="（1）item(trans) 和 flat_seq"></a>（1）item(trans) 和 flat_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183241815.png" alt="image-20211202183241815"></p><p>flat_seq：</p><ul><li>body<ul><li>调用seq里面的函数create_item创建了一个item，创建时参数包括item的类型，被挂载到的sqr, （补充：用new也能）</li><li>父类句柄转换：<code>void`($cast(req, tmp))</code>，记住这种类型转换的方法（补充：如果只做randomize可以把子类也随机了，但这里要调用子类内的成员变量所以需要转换类型）</li></ul></li></ul><p>补充内容：</p><ul><li>为什么item也被挂载到sqr上<ul><li>实际上seq与Item都挂载到sqr上</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184105335.png" alt="image-20211202184105335"></li><li><strong>而自己定义的sqr又是uvm_sequence的成员变量</strong></li></ul></li><li>一个完成的传输：<ul><li>seq收到item_done才算结束，这里使用get_response(tmp)</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184636538.png" alt="image-20211202184636538"></li></ul></li></ul><h3 id="（2）sqr：最简单的一个"><a href="#（2）sqr：最简单的一个" class="headerlink" title="（2）sqr：最简单的一个"></a>（2）sqr：最简单的一个</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184922242.png" alt="image-20211202184922242"></p><p>继承于uvm_sequencer</p><p><strong>只要进行一个注册就ok，最简单的一个</strong>，更多的握手关系在seq和dri一侧，sqr做路由作用</p><h3 id="（3）driver"><a href="#（3）driver" class="headerlink" title="（3）driver"></a>（3）driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183323782.png" alt="image-20211202183323782"></p><ul><li><p>关于REQ是哪来的，你忘了自己是个参数类了吗？这不是参数类的类型参数值吗？</p><ul><li>这里没有进行参数指明，所以直接用默认了，就是没有下图红字部分<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202204354109.png" alt="image-20211202204354109"></li></ul></li></ul></li><li><p>run_phase</p><ul><li><p>通过port拿到item：seq_item_port.get_next_item(tmp)</p></li><li><p>item父类转子类</p></li><li><p>子类克隆方法（返回父类句柄）</p></li><li><p>克隆的对象的父类句柄转子类</p></li><li><p>req的id交给rsp的id：rsp.set_sequence_id(req.get_sequence_id())</p><ul><li><p>seq_id是什么时候产生的？item经过sqr时被打上</p></li><li><p>seq_id有什么用？用于识别不同seq</p></li><li><p>为什么要手动set？id没有进行域的自动化，克隆的时候不会复制id，克隆只关心数据部分而id不是数据部分</p></li><li><p>传输结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202185848489.png" alt="image-20211202185848489"></p></li></ul></li><li><p>item_done(rsp句柄)，让seq结束</p><ul><li>即便没有rsp句柄（即没有rsp消息）也是一个完整的数据传输过程</li><li>如果没有rsp句柄，seq能否等到？<ul><li>finish_item可以等到，因为等到的item_done</li><li>get_response(tmp)会卡住，因为fifo为空没有数据<ul><li><strong>因此get_response一定要成对不然会卡住</strong></li></ul></li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202190641416.png" alt="image-20211202190641416"></li></ul></li></ul></li></ul></li></ul><h3 id="（4）env"><a href="#（4）env" class="headerlink" title="（4）env"></a>（4）env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183249715.png" alt="image-20211202183249715"></p><ul><li><p>成员区域</p><ul><li>对sqr和drv进行例化</li></ul></li><li><p>build</p><ul><li>对sqr和drv进行创建</li></ul></li><li><p>connect</p><ul><li>对第一个端口类进行连接，这就够了</li></ul></li></ul><h3 id="（5）test"><a href="#（5）test" class="headerlink" title="（5）test"></a>（5）test</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183254693.png" alt="image-20211202183254693"></p><p>build：</p><ul><li>sqr的创建</li></ul><p>run_phase控制各个run_phase：</p><ul><li><p>挂起objection防止退出</p></li><li><p>例化flat_seq</p><ul><li>flat是Obj是在运行过程中动态产生的所以不在build里面例化</li></ul></li><li><p>flat_sep挂载到sqr上</p></li><li>结束挂起结束运行</li></ul><h3 id="（6）输出结果"><a href="#（6）输出结果" class="headerlink" title="（6）输出结果"></a>（6）输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202190839895.png" alt="image-20211202190839895"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202201323144.png" alt="image-20211202201323144">     </p><h2 id="3-3-【重要】各个模块的动作总结"><a href="#3-3-【重要】各个模块的动作总结" class="headerlink" title="3.3 【重要】各个模块的动作总结"></a>3.3 【重要】各个模块的动作总结</h2><h3 id="flat-seq："><a href="#flat-seq：" class="headerlink" title="flat_seq："></a>flat_seq：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202203103945.png" alt="image-20211202203103945"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">create_item()<br>start_item()<br>randomize()<br>finish_item()<br>*get_response()<br></code></pre></div></td></tr></table></figure><h3 id="driver以及之后的逻辑："><a href="#driver以及之后的逻辑：" class="headerlink" title="driver以及之后的逻辑："></a>driver以及之后的逻辑：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202204659663.png" alt="image-20211202204659663"></p><h3 id="高层次端口的连接（env和test）"><a href="#高层次端口的连接（env和test）" class="headerlink" title="高层次端口的连接（env和test）"></a>高层次端口的连接（env和test）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202205103247.png" alt="image-20211202205103247"></p><p>（1）env端口连接，使用一种端口进行成对连接就行</p><p>（2）</p><ul><li><p>记得在test中挂起objection防止提前退出</p></li><li><p>挂载seq到sqr使用uvm_sequence::<strong>start</strong>(SEQUENCER)完成</p></li></ul><h2 id="3-4-【重要】通信时序"><a href="#3-4-【重要】通信时序" class="headerlink" title="3.4 【重要】通信时序"></a>3.4 【重要】通信时序</h2><h3 id="3-4-1-通信时序"><a href="#3-4-1-通信时序" class="headerlink" title="3.4.1 通信时序"></a>3.4.1 通信时序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210435732.png" alt="image-20211202210435732"></p><h3 id="3-4-2-seq与sqr的细节补充"><a href="#3-4-2-seq与sqr的细节补充" class="headerlink" title="3.4.2 seq与sqr的细节补充"></a>3.4.2 seq与sqr的细节补充</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210329060.png" alt="image-20211202210329060"></p><p>（1）seq起点是create</p><p>（2）sqr的仲裁机制根据dri的get_next_item来的</p><p>（3）sqr在获取item之前item应该完成随机化</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210714053.png" alt="image-20211202210714053"></p><h3 id="3-4-3-握手建议、类型问题"><a href="#3-4-3-握手建议、类型问题" class="headerlink" title="3.4.3 握手建议、类型问题"></a>3.4.3 握手建议、类型问题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210749419.png" alt="image-20211202210749419"></p><ul><li><p>主要讲克隆和ID一部分的内容，可以参考3.2driver的run_phase</p></li><li><p>以及rep和rsp使用一个item所带来的危害</p></li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210904018.png" alt="image-20211202210904018"></p><ul><li><p>seq与driver类型完全保持一致</p></li><li><p>如何修改底层的sequence item类型？override</p></li></ul><h1 id="4-Sequencer和Sequence：初步"><a href="#4-Sequencer和Sequence：初步" class="headerlink" title="4 Sequencer和Sequence：初步"></a>4 Sequencer和Sequence：初步</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-主要学习内容"><a href="#4-1-1-主要学习内容" class="headerlink" title="4.1.1 主要学习内容"></a>4.1.1 主要学习内容</h3><p>主要讲几种常见的仲裁方式，一般可能用不太到</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202220542862.png" alt="image-20211202220542862"></p><h3 id="4-1-2-sequence宏概述：区分两种挂载seq到sqr方式"><a href="#4-1-2-sequence宏概述：区分两种挂载seq到sqr方式" class="headerlink" title="4.1.2 sequence宏概述：区分两种挂载seq到sqr方式"></a>4.1.2 sequence宏概述：区分两种挂载seq到sqr方式</h3><ul><li>start()<ul><li>在test对top_seq挂载（参考第三章），在top_sep对child_sep和item挂载，在child_sep对item挂载</li></ul></li><li>`uvm_do<ul><li>一种宏：参考第五章</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221445893.png" alt="image-20211202221445893"></p><h2 id="4-2-sequence和item发送示例"><a href="#4-2-sequence和item发送示例" class="headerlink" title="4.2 sequence和item发送示例"></a>4.2 sequence和item发送示例</h2><h3 id="bus-trans"><a href="#bus-trans" class="headerlink" title="bus_trans"></a>bus_trans</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221650621.png" alt="image-20211202221650621"></p><h3 id="child-seq"><a href="#child-seq" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221712682.png" alt="image-20211202221712682"></p><h3 id="top-seq"><a href="#top-seq" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222244292.png" alt="image-20211202222244292"></p><p>包含child_seq与item</p><h3 id="sqr"><a href="#sqr" class="headerlink" title="sqr"></a>sqr</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222302835.png" alt="image-20211202222302835"></p><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222337508.png" alt="image-20211202222337508"></p><p>driver里面get的全是最小颗粒度item，seq在sqr处被拆解</p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222453646.png" alt="image-20211202222453646"></p><h3 id="test与输出结果"><a href="#test与输出结果" class="headerlink" title="test与输出结果"></a>test与输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222607612.png" alt="image-20211202222607612"></p><h2 id="4-3-示例总结：两种挂载方式"><a href="#4-3-示例总结：两种挂载方式" class="headerlink" title="4.3 示例总结：两种挂载方式"></a>4.3 示例总结：两种挂载方式</h2><p>两种挂载方式，分别把seq和item挂载到sqr上</p><h3 id="4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上"><a href="#4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上" class="headerlink" title="4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上"></a>4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222550069.png" alt="image-20211202222550069"></p><p>top_seq中的uvm_sequence::start()</p><ul><li>start内部参数解释<ul><li>uvm_sequencer_base sequencer：<ul><li>挂载到的sqr实例句柄</li></ul></li><li>uvm_sequence_base parent_sequence：<ul><li>上层对象句柄，示例中top_seq调用该方法时代入”this”代表child_seq的上层对象为自己</li><li>这样做的好处是保持子对象优先级一致，进而对仲裁有帮助仲裁表现一致</li></ul></li><li>int this_priority：<ul><li>优先级，默认值-1，此时实际优先级为100</li></ul></li><li>call_pre_post：<ul><li>建议使用默认值<ul><li>补充：body的pre和post回调函数不建议实现</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-2-把item挂载到sqr上"><a href="#4-3-2-把item挂载到sqr上" class="headerlink" title="4.3.2 把item挂载到sqr上"></a>4.3.2 把item挂载到sqr上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202223931132.png" alt="image-20211202223931132"></p><p>第二个参数不需要特别关心，往往知道挂载哪个item就够了</p><h3 id="4-3-3-item创建发送过程"><a href="#4-3-3-item创建发送过程" class="headerlink" title="4.3.3 item创建发送过程"></a>4.3.3 item创建发送过程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202224727373.png" alt="image-20211202224727373"></p><p>pre_do()，mid_do()，post_do()：不建议实现，会变复杂</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225013595.png" alt="image-20211202225013595"></p><h3 id="4-3-4-seq-item的start-挂载内部逻辑"><a href="#4-3-4-seq-item的start-挂载内部逻辑" class="headerlink" title="4.3.4 seq/item的start()挂载内部逻辑"></a>4.3.4 seq/item的start()挂载内部逻辑</h3><h4 id="sequence挂载到sequencer"><a href="#sequence挂载到sequencer" class="headerlink" title="sequence挂载到sequencer"></a>sequence挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225207310.png" alt="image-20211202225207310"></p><p>为什么可以不关心：有时候call_pre_post=1时这些post和pre都不会执行</p><h4 id="item挂载到sequencer"><a href="#item挂载到sequencer" class="headerlink" title="item挂载到sequencer"></a>item挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225413186.png" alt="image-20211202225413186"></p><p>start_item立即返回，因为只有一个sqr进行仲裁可以立刻返回结果</p><h1 id="5-Sequencer和Sequence：更简单的创建挂载传输方式：宏"><a href="#5-Sequencer和Sequence：更简单的创建挂载传输方式：宏" class="headerlink" title="5 Sequencer和Sequence：更简单的创建挂载传输方式：宏"></a>5 Sequencer和Sequence：更简单的创建挂载传输方式：宏</h1><p>图中宏省略了`</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225658481.png" alt="图中宏省略了`"></p><p><strong>这些宏封装了好多方法函数，x表示包括，空表示不包括</strong></p><p><strong>Item：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程，但直接randomiztion</li><li>`uvm_do_with：做一个带constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>body为空，因为item没有</li></ul></li></ul><p><strong>Sequence：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程<br>+ </li><li>`uvm_do_with：做一个constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>没有做sync和post-sync<ul><li>因为sync和post-sync需要在body里面拿到优先级，`uvm_do本身不会拿到优先级，只有在seq_body里面，只有在发送item时候才会拿到（即每次发送一个item的时候都会申请一次优先级）</li></ul></li></ul></li></ul><h3 id="宏的调用位置"><a href="#宏的调用位置" class="headerlink" title="宏的调用位置"></a>宏的调用位置</h3><ul><li>这些宏调用的都是 sequence方法，因此只有sequence才可以调用这些宏</li></ul><h3 id="宏带来的怠惰"><a href="#宏带来的怠惰" class="headerlink" title="宏带来的怠惰"></a>宏带来的怠惰</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203115317909.png" alt="image-20211203115317909"></p><h2 id="5-2-其他的宏"><a href="#5-2-其他的宏" class="headerlink" title="5.2 其他的宏"></a>5.2 其他的宏</h2><ul><li>将优先级作为参数传递的<strong><code>`uvm_do_pri/`uvm_do_on_prio</code></strong>等宏<ul><li>并行发送多个seq时，伴随优先级发送</li><li>形参优先级，默认为100</li><li>`uvm_do_on：这个on是什么意思，表示把这个特定的seq挂载到某一个sqr上面<ul><li>对于item来说，使用`uvm_do则会被同样挂载到seq挂载到的sqr上</li><li>`uvm_do_on则可以进行指定</li></ul></li></ul></li><li>专门针对seq的<strong><code>`uvm_create_seq/`uvm_do_seq/`uvm_do_seq_with</code></strong>等宏</li></ul><h2 id="5-3-序列宏的示例"><a href="#5-3-序列宏的示例" class="headerlink" title="5.3 序列宏的示例"></a>5.3 序列宏的示例</h2><h3 id="child-seq-1"><a href="#child-seq-1" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135350051.png" alt="image-20211203135350051"></p><p>怎样利用宏发送的：</p><ul><li>`uvm_create(req)：创建item</li><li>`uvm_rand_send_with：添加constraint</li></ul><p>上述宏可以合并为：</p><ul><li>`uvm_do_with</li></ul><h3 id="top-seq-1"><a href="#top-seq-1" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135410573.png" alt="image-20211203135410573"></p><ul><li>`uvm_do：这里发送了child_seq</li><li>`uvm_do_with：这里发送了item</li></ul><h2 id="5-4-序列宏的建议"><a href="#5-4-序列宏的建议" class="headerlink" title="5.4 序列宏的建议"></a>5.4 序列宏的建议</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135746376.png" alt="image-20211203135746376"></p><p>（1）不管seq在哪个层次，都应在test结束前执行完毕</p><p>（2）可以用fork_join完成seq发送。而不建议用fork_join_any和fork_join_none，可能会导致seq没结束就立即退出，使得后台仍然有一些seq像挂载到sqr上面；进一步如果你针对fork调用disable可能会所锁sqr，因为你来不及释放seq线程权限。</p><ul><li>补充：你在代码中使用fork_join_any和fork_join_none一定要使用同步，如此处假如你使用了fork_join_any和fork_join_none你应该完成即便fork退出seq运行在后台时，仍然能与后台运行的seq进行同步，使得所有seq结束以后才进行后续的操作</li></ul><p>（3）fork_join其中一个seq线程无法结束时，考虑在合适时间点使用disbale</p><h1 id="5-Sequencer和Sequence：仲裁特性"><a href="#5-Sequencer和Sequence：仲裁特性" class="headerlink" title="5 Sequencer和Sequence：仲裁特性"></a>5 Sequencer和Sequence：仲裁特性</h1><h2 id="5-1-Sequencer和Sequence的仲裁特性"><a href="#5-1-Sequencer和Sequence的仲裁特性" class="headerlink" title="5.1 Sequencer和Sequence的仲裁特性"></a>5.1 Sequencer和Sequence的仲裁特性</h2><h3 id="5-1-1-仲裁特性介绍"><a href="#5-1-1-仲裁特性介绍" class="headerlink" title="5.1.1 仲裁特性介绍"></a>5.1.1 仲裁特性介绍</h3><p>仲裁场景结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141411994.png" alt="仲裁场景结构图"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141403633.png" alt="image-20211203141403633"></p><p>（1）<strong>sqr已经内建了仲裁机制，只需要在top_seq设置仲裁的模式就足够</strong></p><p>（2）</p><p>如何设置：uvm_sequencer::set_arbitration(UVM_SEQ_ARB_TYPE val)</p><p>模式介绍：</p><ul><li>UVM_SEQ_ARB_FIFO：默认模式，竞争优先</li><li>UVM_SEQ_ARB_WEIGHTED：优先级模式</li><li>UVM_SEQ_ARB_RANDOM：随机模式</li><li>UVM_SEQ_ARB_STRICT_FIFO：按照优先和抵达顺序授权</li><li>UVM_SEQ_ARB_STRICT_RANDOM：最高优先级并随机授权</li><li>UVM_SEQ_ARB_USER：自定义仲裁，很少用</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143759204.png" alt="image-20211203143759204"></p><h3 id="5-1-2-Sequencer的仲裁示例"><a href="#5-1-2-Sequencer的仲裁示例" class="headerlink" title="5.1.2 Sequencer的仲裁示例"></a>5.1.2 Sequencer的仲裁示例</h3><h4 id="item和child-seq"><a href="#item和child-seq" class="headerlink" title="item和child_seq"></a>item和child_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143948761.png" alt="image-20211203143948761"></p><h4 id="top-seq和sqr"><a href="#top-seq和sqr" class="headerlink" title="top_seq和sqr"></a>top_seq和sqr</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203144103956.png" alt="image-20211203144103956"></p><p>top_seq：</p><ul><li>body：<ul><li>设置优先级模式</li><li>fork_join进行调度：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145448313.png" alt="image-20211203145448313"></li><li>三个同一时间申请的，seq1和seq2优先级更高</li><li>base是constraint</li><li>此时赋予了优先级之后child_seq中的`uvm_do_with就可以进行挂在了，因为它们等待的就是这个顶层的优先级，使用wait_for_guant等待授权</li></ul></li></ul></li></ul><h4 id="driver-1"><a href="#driver-1" class="headerlink" title="driver"></a>driver</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145759397.png" alt="image-20211203145759397"></p><p>没有太多新意</p><h3 id="env-1"><a href="#env-1" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145816089.png" alt="image-20211203145816089"></p><h3 id="test和输出结果"><a href="#test和输出结果" class="headerlink" title="test和输出结果"></a>test和输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145834402.png" alt="image-20211203145834402"></p><p>test：</p><ul><li>为什么test里面不用宏：因为用不了只能在seq里面用</li></ul><p>为什么是seq1seq2seq1seq2seq3seq3，而且还是0时刻？：</p><ul><li>发送item没有耗时</li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150048046.png" alt="image-20211203150048046"></p><h2 id="5-2-Sequencer的锁定机制介绍"><a href="#5-2-Sequencer的锁定机制介绍" class="headerlink" title="5.2 Sequencer的锁定机制介绍"></a>5.2 Sequencer的锁定机制介绍</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150933463.png" alt="image-20211203150933463"></p><p>（1）锁定机制</p><p>什么是锁定机制：seq拿到权限后进行锁定，</p><p>什么是锁定：seq拿到一个item后锁定下来，后续item都可以拿到</p><p>（2）两种锁定方式：两个函数都可以</p><ul><li>lock()与unlock<ul><li>一定记得unlock</li></ul></li><li>grab()与ungrab()<ul><li>优先级比lock高，下一次授权周期可以无条件获取授权</li></ul></li></ul><h3 id="5-2-2-Sequencer的锁定示例"><a href="#5-2-2-Sequencer的锁定示例" class="headerlink" title="5.2.2 Sequencer的锁定示例"></a>5.2.2 Sequencer的锁定示例</h3><h4 id="item、child-seq、lock-seq"><a href="#item、child-seq、lock-seq" class="headerlink" title="item、child_seq、lock_seq"></a>item、child_seq、lock_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155333757.png" alt="image-20211203155333757"></p><p>child_seq：内部重复发送两次，间隔10ns，参考之前一节的示例</p><p>lock_seq：</p><ul><li><p>先等了10ns，试图达到等待授权把sqr锁住</p></li><li><p>m_sequencer.lock(this);</p><ul><li>什么时候才能lock住：下一次等待授权的时候，即大家都在等待的时候</li></ul></li><li>重复发送三次</li></ul><h3 id="grab-seq"><a href="#grab-seq" class="headerlink" title="grab_seq"></a>grab_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155557543.png" alt="image-20211203155557543"></p><p>grab_seq：</p><ul><li><p>等了20ns</p></li><li><p>m_sequencer.grab(this);</p><ul><li>什么时候才能锁住：只要重新做仲裁就能锁住</li></ul></li><li>重复发送三次</li></ul><h4 id="top-seq-2"><a href="#top-seq-2" class="headerlink" title="top_seq"></a>top_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155814989.png" alt="image-20211203155814989"></p><p>seq1,seq2,seq3</p><p>lock_seq：优先级为300</p><p>grab_seq：没有优先级</p><h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160141887-16385185030091.png" alt="image-20211203160141887"></p><hr><p>注释版：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160157368-16385185184612.png" alt="image-20211203160157368"></p><h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>10ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送（发送完等待10纳秒，重新排队伍）</li><li>lock_seq开始要权限</li></ul><p>10ns-20ns：</p><ul><li>seq发送</li></ul><p>20ns：</p><ul><li>seq1,2,3,lock都开始等待（lock因为优先级低所以也要等待）</li></ul><p>20ns-40ns：</p><ul><li>被lock锁住</li></ul><p>40ns：</p><ul><li>grabs拿到权限（实际上20nsgrab就开始试图拿权限，但被lock控制，只能等到重新仲裁，届时即可直接锁住无需）</li></ul><p>40ns-70ns：</p><ul><li>被grabs锁住</li></ul><p>70ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送</li></ul><h4 id="结果补充"><a href="#结果补充" class="headerlink" title="结果补充"></a>结果补充</h4><p>seq优先级如果使用默认，不给定，则默认100</p><p>即直接：</p><ul><li><code>`uvm_do_pri_with(seq)</code></li><li><code>`uvm_do_pri_with(lock)</code></li><li><code>`uvm_do_pri_with(grab)</code></li></ul><h3 id="5-2-3-结论"><a href="#5-2-3-结论" class="headerlink" title="5.2.3 结论"></a>5.2.3 结论</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203161407082.png" alt="image-20211203161407082"></p><p>无论是lock或者grab都是在重新仲裁时才能锁住</p><h1 id="6-Sequence的层次化"><a href="#6-Sequence的层次化" class="headerlink" title="6 Sequence的层次化"></a>6 Sequence的层次化</h1><p>对于小白我们可能更关心如何让你的sequence层次化，如何理解别人写的层次化的sequence，以及把它们作为更顶层的sequence如何一层一层的调用</p><h2 id="6-1-概述：水平复用和垂直复用"><a href="#6-1-概述：水平复用和垂直复用" class="headerlink" title="6.1 概述：水平复用和垂直复用"></a>6.1 概述：水平复用和垂直复用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203162021806.png" alt="image-20211203162021806"></p><ul><li>hierarchical sequence：层次序列，seq都挂载在一个sqr上</li><li>virtual sequence：seq可挂载在多个sqr上</li><li>layering sequence</li></ul><h2 id="6-2-Hierarchical-Sequence层次序列"><a href="#6-2-Hierarchical-Sequence层次序列" class="headerlink" title="6.2 Hierarchical Sequence层次序列"></a>6.2 Hierarchical Sequence层次序列</h2><h3 id="6-2-1-Hierarchical-Sequence介绍"><a href="#6-2-1-Hierarchical-Sequence介绍" class="headerlink" title="6.2.1 Hierarchical Sequence介绍"></a>6.2.1 Hierarchical Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203170532752.png" alt="image-20211203170532752"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203173213812.png" alt="image-20211203173213812"></p><h3 id="6-2-2-Hierarchical-Sequence代码示例"><a href="#6-2-2-Hierarchical-Sequence代码示例" class="headerlink" title="6.2.2 Hierarchical Sequence代码示例"></a>6.2.2 Hierarchical Sequence代码示例</h3><p><strong>cmd 和 item</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215113852.png" alt="image-20211203215113852"></p><p><strong>clk_rst_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215132273.png" alt="image-20211203215132273"></p><p><strong>reg_test_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215159086.png" alt="image-20211203215159086"></p><p><strong>top_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215246475.png" alt="image-20211203215246475"></p><p><strong>reg_master_sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215319193.png" alt="image-20211203215319193"></p><p><strong>driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215348378.png" alt="image-20211203215348378"></p><p><strong>agent</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215406423.png" alt="image-20211203215406423"></p><ul><li>例化与连接</li></ul><h3 id="6-2-3-示例解析"><a href="#6-2-3-示例解析" class="headerlink" title="6.2.3 示例解析"></a>6.2.3 示例解析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215450672.png" alt="image-20211203215450672"></p><h3 id="6-2-4-总结"><a href="#6-2-4-总结" class="headerlink" title="6.2.4 总结"></a>6.2.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215501808-16385397031013.png" alt="image-20211203215501808"></p><h2 id="6-3-Virtual-Sequence"><a href="#6-3-Virtual-Sequence" class="headerlink" title="6.3 Virtual Sequence"></a>6.3 Virtual Sequence</h2><h3 id="6-3-1-Virtual-Sequence介绍"><a href="#6-3-1-Virtual-Sequence介绍" class="headerlink" title="6.3.1 Virtual Sequence介绍"></a>6.3.1 Virtual Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215818498.png" alt="image-20211203215818498"></p><hr><p>把所有子系统的sqr都放在virtual_sequencer里面</p><ul><li>virtual_sequencer包含着很多实例句柄</li><li>它就像一个路由一样，找到他就能找到各个子系统的sqr</li><li>起到一个统筹的作用</li><li>virtual sequencer往往与virtual sequence有联系的</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215944706.png" alt="image-20211203215944706"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220636658.png" alt="image-20211203220636658"></p><p>virtual sequencer就是个简单的路由器，包含句柄而已，没有任何item经过，也不需要与driver连接</p><h3 id="6-3-2-Virtual-Sequence示例"><a href="#6-3-2-Virtual-Sequence示例" class="headerlink" title="6.3.2 Virtual Sequence示例"></a>6.3.2 Virtual Sequence示例</h3><p><strong>vritual sequencer结构图</strong>：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220753318.png" alt="vritual sequencer结构图"></p><p><strong>【重要】有关挂载</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203222842906.png" alt="image-20211203222842906"></p><p>mcdf_normal_seq(virtual sequence)要挂载到virutal sequencer</p><p>其他的seq间接的通过virutal sequencer挂载到不同的sqr上面，挂载的目的地不一样所以用uvm_do_on</p><hr><p><strong>virtual sequence</strong></p><p>定义了一个sequence：实际上就是我们的virtual sequence</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220826070.png" alt="image-20211203220826070"></p><p>包括了好多seq句柄</p><p>sqr与vsqr区别：</p><ul><li>用了很多`uvm<em>do</em><strong>on</strong></li><li>有别于Hierarchical Sequence使用的`uvm_do</li></ul><p>子</p><p>p_sequencer和m_sequencer的区别：</p><ul><li>m_sequencer：是父类句柄，类型是uvm_sequencer</li><li>p_sequencer：是子类句柄，类型是`uvm_declare_p_sequencer(mcdf_virtual_sequencer)<ul><li>自定义出来的，不是与定义好的，定义语句就来源于`uvm_declare_p_sequencer(mcdf_virtual_sequencer)</li><li>定义语句完成了两个步骤：<ul><li>mcdf_virtual_sequencer p_sequencer;</li><li>$cast(p_sequencer, m_sequencer);//把父类句柄转为子类句柄</li></ul></li><li>为什么一定要子类句柄：<ul><li>因为父类的访问不到这些子系统sqr句柄</li><li>通过这个子类句柄p_sequencer我们可以访问到vsqr里面所有成员变量</li></ul></li></ul></li></ul><p><strong>子一级的sqr，agent，和virutal sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223410467.png" alt="image-20211203223410467"></p><p>virutal sequencer 包含各个句柄就完事了</p><p><strong>mcdf_env</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223436428.png" alt="image-20211203223436428"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223450033-16385420908084.png" alt="image-20211203223450033"></p><p>千万不要忘了再connect里进行句柄传递，避免悬空</p><p><strong>test</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223457604.png" alt="image-20211203223457604"></p><h3 id="6-3-3-示例解析"><a href="#6-3-3-示例解析" class="headerlink" title="6.3.3 示例解析"></a>6.3.3 示例解析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224423125.png" alt="image-20211203224423125"></p><h3 id="6-3-4-总结"><a href="#6-3-4-总结" class="headerlink" title="6.3.4 总结"></a>6.3.4 总结</h3><p>中心化协调</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224508271.png" alt="image-20211203224508271"></p><h3 id="6-3-5-Virutal-Sequencer建议"><a href="#6-3-5-Virutal-Sequencer建议" class="headerlink" title="6.3.5 Virutal Sequencer建议"></a>6.3.5 Virutal Sequencer建议</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224612008.png" alt="image-20211203224612008"></p><ul><li>vseq与普通seq区分</li><li>vsqr同底层负责传输对象的sqr区分</li><li>vseq中使用`uvm_declare_p_sqr来创建p_sequencer变量方便之后索引</li><li>顶层环境中创建vsqr并完成内部各个sqr句柄与底层sqr实例连接</li></ul><h2 id="6-4-Layering-Sequence：层次化"><a href="#6-4-Layering-Sequence：层次化" class="headerlink" title="6.4 Layering Sequence：层次化"></a>6.4 Layering Sequence：层次化</h2><h3 id="6-4-1-Layering-Sequence介绍"><a href="#6-4-1-Layering-Sequence介绍" class="headerlink" title="6.4.1 Layering Sequence介绍"></a>6.4.1 Layering Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224824934.png" alt="image-20211203224824934"></p><ul><li><p>普通协议，构建协议总线时通过：sequencer item包含与约束关系</p></li><li><p>复杂协议，网络传输协议，需要更深层次一层一层解析，通过：若干个抽象层次去做</p></li></ul><p><strong>由高抽象级到低抽象级（传输层&gt;&gt;链路层&gt;&gt;物理层）</strong>的构建，我们称为<strong>Layering Sequence</strong></p><p>接下来学习，一定考虑三个层次：高抽象级的item，低抽象级的item，中间做转化的sequence</p><p>Layering Sequence层次结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p>寄存器模型下的item传递结构图与layering sequence具体作用内容：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225425767.png" alt="寄存器模型下的item传递结构图"></p><ul><li>对寄存器的reg.write()和reg.read()指令，通过寄存器模型的Adaption Layer转化层次，进而转化为总线的一个item。即把reg_item转为bug_item</li><li>得出layering sequence包括三者：高抽象级的item，低抽象级的item，中间做转化的sequence</li><li>高抽象级的item与低抽象级的item没有直接的继承关系所以需要做一个映射</li><li>高抽象级不包括具体的数据，只有类似命令、长度、idle等信息</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204114418582.png" alt="image-20211204114418582"></p><h3 id="6-4-2-Layering-Sequence代码示例"><a href="#6-4-2-Layering-Sequence代码示例" class="headerlink" title="6.4.2 Layering Sequence代码示例"></a>6.4.2 Layering Sequence代码示例</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p><strong>cmd和bus_trans(item)</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204114905038.png" alt="image-20211204114905038"></p><p>比较底层</p><p><strong>packet_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115007333.png" alt="image-20211204115007333"></p><p><strong>layer_trans(item)</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115027913.png" alt="image-20211204115027913"></p><p>比较抽象：</p><ul><li>没有任何与数据有关的传输内用，只有cmd，len，idle</li><li>与底层的bus_trans没有任何继承关系所以要做一个映射</li></ul><p><strong>adapter_seq：转化层</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115443718.png" alt="image-20211204115443718"></p><ul><li>p_sequencer通过`ucm_declare获得，通过p_sqr拿到up_sqr更上层的layersqr句柄</li><li><p>拿到子类句柄void($cast(trans,req))</p></li><li><p>转化为一个底层个seq，把高抽象级的长度转化为低抽象级的pkt_seq，`uvm_do挂载到了phy_driver上</p></li><li>做一个握手，告诉高层，我已经把高抽象层的trans消化掉了</li></ul><p><strong>top_seq , layering_sqr , phy_sqr</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204121723508.png" alt="image-20211204121723508"></p><p>layering_sqr , phy_sqr定义不讲了</p><p>phy_sqr里面有个句柄up_sqr，需要顶层把相关实例传递进来</p><p>top_seq：连续发送了两个layer_trans</p><p><strong>phy_driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204121949423-16385915953441.png" alt="image-20211204121949423"></p><p><strong>phy_agent</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122004651.png" alt="image-20211204122004651"></p><p>包含phy_drv和phy_sqr的例化与连接</p><p><strong>test，重点在这里，查看连接关系</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122057373.png" alt="image-20211204122057373"></p><ul><li>例化了layer_sqr与phy_agt<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122201923.png" alt="image-20211204122201923"></li></ul></li><li>sqr句柄的传递，layer_seq/top_seq，adapter_seq，phy_seq的挂载<ul><li>up_sqr句柄的传递<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122317592.png" alt="image-20211204122317592"></li></ul></li><li>adapter_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122352177.png" alt="image-20211204122352177"></li></ul></li><li>top_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122458395.png" alt="image-20211204122458395"></li></ul></li><li>phy_seq的挂载实际上不是个挂载而是产生的过程，在adapter_seq用uvm_do出来好多pkg_seq，这些pkg_seq时加上就属于phy到drv的seq</li></ul></li><li>为什么用fork_join_none<ul><li>用fork_join_none直接挂载上去就可以了</li><li>用fork_join不行，这个start会自动帮我们执行body()，adapter.body()是个forever会卡在这里</li></ul></li></ul><h3 id="6-4-3-如何实现sequencer-layer协议转换的方法："><a href="#6-4-3-如何实现sequencer-layer协议转换的方法：" class="headerlink" title="6.4.3 如何实现sequencer layer协议转换的方法："></a>6.4.3 如何实现sequencer layer协议转换的方法：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123212588.png" alt="image-20211204123212588"></p><p>（1）layer_trans,bus_trans完全两个不同的抽象级</p><p>（2）需要adapter_seq完成从获取layer_trans再去生成phy_trans和seq，再从physqr发送出去</p><p>（2）fork_join_none</p><p>（4）至于多少个层次取决于</p><h3 id="6-4-4-总结"><a href="#6-4-4-总结" class="headerlink" title="6.4.4 总结"></a>6.4.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123514922.png" alt="image-20211204123514922"></p><p>（2）只有高抽象级到低抽象级，低到高需要有回路，通过response_item实现，两者的思想实际上一样</p><p>（3）也可以不通过高到低的回路，而是外部通过monitor采集response trans最终实现返回，避开adapter</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶5(了解)：TLM2与同步通信元件.md</title>
    <link href="/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%20(copy)/"/>
    <url>/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%20(copy)/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>TLM2通信</li><li>同步通信元件</li></ul><p>TLM2.0与UVM入门进阶5的双向通信都作为了解</p><h1 id="1-TLM2-0通信（了解）"><a href="#1-TLM2-0通信（了解）" class="headerlink" title="1 TLM2.0通信（了解）"></a>1 TLM2.0通信（了解）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-由TLM1-0到TLM2-0"><a href="#1-1-1-由TLM1-0到TLM2-0" class="headerlink" title="1.1.1 由TLM1.0到TLM2.0"></a>1.1.1 由TLM1.0到TLM2.0</h3><ul><li>TLM1.0用UVM各个组件之间连接</li><li>TLM2.0用于与SystemC进行连接</li></ul><p>目前TLM开源包也是基于TLM2.0，且TLM2.0早于UVM成立的标准</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204050389.png" alt="image-20211129204050389"></p><h3 id="1-1-2-对比、主要内容"><a href="#1-1-2-对比、主要内容" class="headerlink" title="1.1.2 对比、主要内容"></a>1.1.2 对比、主要内容</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204417791.png" alt="image-20211129204417791"></p><p><strong>什么时候用到</strong>TLM2.0，uvm与systemc做继承，把systemc作为reference model的时候</p><ul><li>因为systemc是纯设计模型，没有时间概念 </li></ul><p>纯验证环境中不需要TLM2.0</p><h2 id="1-2-接口实现"><a href="#1-2-接口实现" class="headerlink" title="1.2 接口实现"></a>1.2 接口实现</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205403805.png" alt=""></p><hr><h3 id="1-2-1-传输方法"><a href="#1-2-1-传输方法" class="headerlink" title="1.2.1 传输方法"></a>1.2.1 传输方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205432385.png" alt="image-20211129205432385"></p><p>两种方法：</p><ul><li>_fw：forward拿过来一个req</li><li>_bw：backward拿过来一个rsp</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205521092.png" alt="image-20211129205521092"></p><h3 id="1-2-2-传输端口：端口类socket"><a href="#1-2-2-传输端口：端口类socket" class="headerlink" title="1.2.2 传输端口：端口类socket"></a>1.2.2 传输端口：端口类socket</h3><p>socket由port,export和imp组合而成</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205557115.png" alt="image-20211129205557115"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205653551.png" alt="image-20211129205653551"></p><h3 id="1-2-3-端口类socket继承于uvm-port-base"><a href="#1-2-3-端口类socket继承于uvm-port-base" class="headerlink" title="1.2.3 端口类socket继承于uvm_port_base"></a>1.2.3 端口类socket继承于uvm_port_base</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205707575.png" alt="image-20211129205707575"></p><h2 id="1-3-传输数据"><a href="#1-3-传输数据" class="headerlink" title="1.3 传输数据"></a>1.3 传输数据</h2><h3 id="1-3-1-传输数据类型uvm-tlm-generic-payload"><a href="#1-3-1-传输数据类型uvm-tlm-generic-payload" class="headerlink" title="1.3.1 传输数据类型uvm_tlm_generic_payload"></a>1.3.1 传输数据类型uvm_tlm_generic_payload</h3><p>严格使用uvm_tlm_generic_payload类进行数据传输</p><p>这样才能与systemc无缝连接</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205747604-16381906688471.png" alt="image-20211129205747604"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205825619.png" alt="image-20211129205825619"></p><h3 id="1-3-2-uvm-tlm-generic-payload内部变量"><a href="#1-3-2-uvm-tlm-generic-payload内部变量" class="headerlink" title="1.3.2 uvm_tlm_generic_payload内部变量"></a>1.3.2 uvm_tlm_generic_payload内部变量</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205855177.png" alt="image-20211129205855177"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205938411.png" alt="image-20211129205938411"></p><h3 id="1-3-3-其他数据类型：两种解决方法"><a href="#1-3-3-其他数据类型：两种解决方法" class="headerlink" title="1.3.3 其他数据类型：两种解决方法"></a>1.3.3 其他数据类型：两种解决方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210001509.png" alt="image-20211129210001509"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210352251.png" alt="image-20211129210352251"></p><h2 id="1-4-时间标记"><a href="#1-4-时间标记" class="headerlink" title="1.4 时间标记"></a>1.4 时间标记</h2><h3 id="1-4-1-uvm-tlm-tim"><a href="#1-4-1-uvm-tlm-tim" class="headerlink" title="1.4.1 uvm_tlm_tim"></a>1.4.1 uvm_tlm_tim</h3><p>原则上systemc可以自己创建一些时钟，当我们很少这样做，因为会大幅度降低仿真效率</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210411249.png" alt="image-20211129210411249"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210541718.png" alt="image-20211129210541718"></p><h2 id="1-5-通信代码示例"><a href="#1-5-通信代码示例" class="headerlink" title="1.5 通信代码示例"></a>1.5 通信代码示例</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210558006.png" alt="image-20211129210558006"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210851775.png" alt="image-20211129210851775"></p><ul><li>数据类型固定所以不需要再指定数据传输类型</li><li>自始至终rsq与rsp都是一个对象</li></ul><p>顶层代码：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211419275.png" alt="image-20211129211419275"></p><h2 id="1-6-通信代码示例（有标注版）"><a href="#1-6-通信代码示例（有标注版）" class="headerlink" title="1.6 通信代码示例（有标注版）"></a>1.6 通信代码示例（有标注版）</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210811424.png" alt="image-20211129210811424"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211211453.png" alt="image-20211129211211453"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211507182.png" alt="image-20211129211507182"></p><h1 id="2-同步通信元件"><a href="#2-同步通信元件" class="headerlink" title="2 同步通信元件"></a>2 同步通信元件</h1>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶6：同步通信元件（解决组件同步与进程同步）</title>
    <link href="/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B66%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%85%83%E4%BB%B6/"/>
    <url>/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B66%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%85%83%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>同步通信元件</li><li>第一组类：uvm_event、uvm_event_pool、uvm_event_callback</li><li>第二组类：uvm_barrier, uvm_barrier_pool</li></ul><h1 id="1-同步通信元件"><a href="#1-同步通信元件" class="headerlink" title="1 同步通信元件"></a>1 同步通信元件</h1><p>SV的同步通信元件：event, semaphore, mailbox</p><p>UVM的线程同步，不局限于同一对象中，而针对不同组件之间的同步问题</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129213636303.png" alt="image-20211129213636303"></p><p><strong>同步类</strong>(保证了封闭性)：</p><ul><li>uvm_event, uvm_event_pool和uvm_event_callback</li><li>uvm_barrier, uvm_barrier_pool</li></ul><hr><p>补充：</p><p>不推荐句柄的形式进行同步：</p><ul><li>什么是句柄的形式？</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130100921108.png" alt="image-20211130100921108"></p><p>c2拿到了c1中例化的event1句柄</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130101116086.png" alt="image-20211130101116086"></p><p>两组类指的是这两组：</p><p>第一组：uvm_event, uvm_event_pool和uvm_event_callback</p><p>第二组：uvm_barrier, uvm_barrier_pool</p><p>uvm_callback具有回调特点的同时还能有丰富特性供<strong>层次化调用</strong></p><h1 id="2-第一组类：uvm-event、uvm-event-pool、uvm-event-callback"><a href="#2-第一组类：uvm-event、uvm-event-pool、uvm-event-callback" class="headerlink" title="2 第一组类：uvm_event、uvm_event_pool、uvm_event_callback"></a>2 第一组类：uvm_event、uvm_event_pool、uvm_event_callback</h1><p>学习内容：第一组类：</p><ul><li>uvm_event</li><li>uvm_event_pool</li><li>uvm_event_callback</li></ul><p>uvm_event解决问题（详细参考2.5节总结）</p><ul><li>obj与comp的同步</li><li>comp之间的同步</li><li>seq与dri之间的同步</li><li>seq之间的同步</li></ul><h2 id="2-1-对比与注意"><a href="#2-1-对比与注意" class="headerlink" title="2.1 对比与注意"></a>2.1 对比与注意</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130101432927-16382384751551.png" alt="image-20211130101432927"></p><ul><li>有post/pre trigger回调</li><li>trigger时能传入数据</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130165629774.png" alt="image-20211130165629774"></p><h2 id="2-2-uvm-event介绍"><a href="#2-2-uvm-event介绍" class="headerlink" title="2.2 uvm_event介绍"></a>2.2 uvm_event介绍</h2><p>不同组件共享一个名称相同的uvm_event，这个uvm_event创建、存放、例化、管理在uvm_pool这一个资源池中，uvm_pool是继承于uvm_object_string_pool#(T)一个参数类</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130154308227.png" alt="image-20211130154308227"></p><hr><p>关于uvm_object_string_pool #(T)：</p><p>T pool [stirng] —&gt;uvm_event pool [“event_name”]</p><h2 id="2-3-部分总结-详细参考2-1"><a href="#2-3-部分总结-详细参考2-1" class="headerlink" title="2.3 部分总结(详细参考2.1)"></a>2.3 部分总结(详细参考2.1)</h2><p>(1) <strong>uvm_event_pool不需要例化，就在后台一直工作</strong></p><p>(2) 如何在组件中拿到/创建event：</p><ul><li><p>声明一个uvm_event句柄e1</p></li><li><p><code>e1.uvm_event_pool::get_gobal(&quot;event_name&quot;);</code>//创建或得到了一个event句柄</p></li><li><p>真正的创建其实时在uvm_event_pool自动完成的</p></li></ul><p>(3) 如何触发、被触发、重复触发：</p><ul><li>与SV不同</li><li>trigger()触发，同时可以传入数据</li><li>wait_trigger()/wait_trigger_data等待</li><li>重复触发之前一定要reset</li></ul><p>(4) 如何增加回调函数：</p><ul><li>创建一个回调类uvm_callback（按照组件创建的方式）</li><li>在类里面实现：pre_trigger,post_trigger两种方法<ul><li>pre_trigger()有返回值，返回1时表明uvm_event不会被trigger同时不会执行post_trigger()，否则反之</li></ul></li><li>最后在event被例化处使用add_callback添加回调函数</li></ul><p>(5) 获取等待某个事件的进程数：</p><ul><li>get_num_waiters()</li></ul><p>(6) 查看uvm_event状态（即查看是否已被触发）或者说是<strong>电平触发</strong></p><ul><li>wait_ptrigger()与wait_ptrigger_data()</li></ul><p>(7) 补充：wait_trigger与wait_ptrigger</p><ul><li>wait_trigger边沿触发：同SV中的@</li><li>wait_ptrigger电平触发</li></ul><h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><h4 id="（1）transaction-amp-uvm-callback"><a href="#（1）transaction-amp-uvm-callback" class="headerlink" title="（1）transaction&amp;uvm_callback"></a>（1）transaction&amp;uvm_callback</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130155117660.png" alt="image-20211130155117660"></p><ul><li><p>定义了一个transaction类型edata</p></li><li><p>定义ecb继承于uvm_event_callback注册肯定跑不掉</p></li><li>回调函数的定义与实现<ul><li>回调函数只能是<strong>pre_trigger，post_trigger</strong></li><li>形参data解释：触发时可以<strong>传入某些数据</strong></li></ul></li></ul><h4 id="（2）comp1对event1由全局pool进行的例化"><a href="#（2）comp1对event1由全局pool进行的例化" class="headerlink" title="（2）comp1对event1由全局pool进行的例化"></a>（2）comp1对event1由全局pool进行的例化</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130163328262.png" alt="image-20211130163328262"></p><p>通过全局Pool进行例化</p><p><code>e1=uvm_event_pool::get_gobal(&quot;e1&quot;);</code></p><ul><li>event pool里面有e1：直接拿到一个句柄</li><li>event pool里面没有e1：帮助创建一个名字是e1的句柄</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130163631552.png" alt="image-20211130163631552"></p><hr><p>task run_phase()中的要点：</p><ul><li>edata d = new()</li><li><strong>e1.trigger(d);//把数据传入triggered</strong></li><li>把callback与event1做个关联<ul><li><code>e1.add_callback(cb)</code></li></ul></li></ul><h4 id="（3）comp2-amp-env"><a href="#（3）comp2-amp-env" class="headerlink" title="（3）comp2&amp;env"></a>（3）comp2&amp;env</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130164226422.png" alt="image-20211130164226422"></p><p><code>e1.wait_triiger_data(tmp)</code>：等待被触发同时等待一个数据过来</p><ul><li>tmp默认obj类型</li></ul><p>void`($cast(d, tmp))：tmp进行父类转子类的转化</p><p><code>e1.wait_triiger()</code>：直接等待被触发</p><h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130155105004.png" alt="image-20211130155105004"></p><h2 id="2-5-应用场景总结"><a href="#2-5-应用场景总结" class="headerlink" title="2.5 应用场景总结"></a>2.5 应用场景总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130170353117.png" alt="image-20211130170353117"></p><ul><li>uvm_event的使用场景</li><li>uvm_event的使用场景</li><li>uvm_event什么时候使用到<ul><li>obj与comp的同步</li><li>comp之间的同步</li><li>seq与dri之间的同步</li><li>seq之间的同步</li></ul></li></ul><h2 id="3-第二组类：uvm-barrier-uvm-barrier-pool"><a href="#3-第二组类：uvm-barrier-uvm-barrier-pool" class="headerlink" title="3 第二组类：uvm_barrier, uvm_barrier_pool"></a>3 第二组类：uvm_barrier, uvm_barrier_pool</h2><p>学习内容：第二组类：</p><ul><li>uvm_barrier</li><li>uvm_barrier_pool </li></ul><h2 id="3-1-进程同步与uvm-barrier-amp-uvm-barrier-pool"><a href="#3-1-进程同步与uvm-barrier-amp-uvm-barrier-pool" class="headerlink" title="3.1 进程同步与uvm_barrier&amp;uvm_barrier_pool"></a>3.1 进程同步与uvm_barrier&amp;uvm_barrier_pool</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130171903482.png" alt="image-20211130171903482"></p><p>P1：SV中多线程的同步</p><p>P2：UVM的组件独立，SV方法收到作用域限制</p><p>P3：uvm_barrier解决多个组件同步协调，uvm_barrier_pool全局管理uvm_barrier</p><p>P4：继承关系同uvm_event_pool</p><h2 id="3-2-uvm-barrier-pool-amp-uvm-event-pool继承于uvm-object-string-pool"><a href="#3-2-uvm-barrier-pool-amp-uvm-event-pool继承于uvm-object-string-pool" class="headerlink" title="3.2 uvm_barrier_pool&amp;uvm_event_pool继承于uvm_object_string_pool"></a>3.2 uvm_barrier_pool&amp;uvm_event_pool继承于uvm_object_string_pool</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130172416691.png" alt="image-20211130172416691"></p><h2 id="3-3-阈值"><a href="#3-3-阈值" class="headerlink" title="3.3 阈值"></a>3.3 阈值</h2><p>可设置阈值threshold</p><p>等待线程<strong>不少于</strong>阈值时触发全体线程中的等待</p><h3 id="3-4-部分总结"><a href="#3-4-部分总结" class="headerlink" title="3.4 部分总结"></a>3.4 部分总结</h3><ul><li>wait_for()进行等待</li><li>set_threshold()设置触发阈值</li></ul><h2 id="3-5-代码示例"><a href="#3-5-代码示例" class="headerlink" title="3.5 代码示例"></a>3.5 代码示例</h2><h3 id="（1）comp1-amp-comp2及其获得b句柄"><a href="#（1）comp1-amp-comp2及其获得b句柄" class="headerlink" title="（1）comp1&amp;comp2及其获得b句柄"></a>（1）comp1&amp;comp2及其获得b句柄</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173016211.png" alt="image-20211130173016211"></p><ul><li>b.wait_for()</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173010530.png" alt="image-20211130173010530"></p><h3 id="（2）env"><a href="#（2）env" class="headerlink" title="（2）env"></a>（2）env</h3><p>env1做了一个裁判员</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173104269.png" alt="image-20211130173104269"></p><h3 id="（3）结果与总结"><a href="#（3）结果与总结" class="headerlink" title="（3）结果与总结"></a>（3）结果与总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173252341.png" alt="image-20211130173252341"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173336364.png" alt="image-20211130173336364"></p><h2 id="4-正式进入uvm-callback"><a href="#4-正式进入uvm-callback" class="headerlink" title="4 正式进入uvm_callback"></a>4 正式进入uvm_callback</h2><p>之前都是稍微提到组件或obj的回调方法，以及uvm_event_callback，今天我们正式分析uvm_callback机制</p><h3 id="4-1-回调的作用"><a href="#4-1-回调的作用" class="headerlink" title="4.1 回调的作用"></a>4.1 回调的作用</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130211756901.png" alt="image-20211130211756901"></p><p>第一段，<strong>回调的好处</strong></p><ul><li>另一种同步方式</li><li>方便里类的封装复用</li></ul><p>第二三四段，<strong>如何实现封闭的包扩展新方法</strong></p><ul><li>类的继承</li><li>uvm覆盖机制</li><li>callback，无需继承何添加新方法，只需要后期定义</li></ul><h3 id="4-2-之前学习过什么uvm-callback？"><a href="#4-2-之前学习过什么uvm-callback？" class="headerlink" title="4.2 之前学习过什么uvm_callback？"></a>4.2 之前学习过什么uvm_callback？</h3><ul><li><p>学过uvm_event_callback</p></li><li><p>学过uvm_object提供了一些callback方法供用户们定义：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">copy () /do_copy () <br>print () /do_print () <br>compare()/do_compare() <br>pack () /do_pack ()<br>unpack() /do_unpack () <br>record()/do_record()<br></code></pre></div></td></tr></table></figure><p>默认情况下，这些回调函数do_xxx是定义为空的</p><p>如果用户执行了uvm_object::copy()函数，那么在该函数执行末尾会自动执行 uvm_object::do_copy()</p><p>do_copy()是copy，的回调函数，uvm_object会在copy()的执行尾端勾住(hook) callback 函数即do_copy()</p><p>如果用户自定义了这些回调函数，就可以在对应函数执行结束后再执行扩展后的回调方法</p><p>通过这个新添加的类，使得函数回调有了顺序和继承性</p><p>关于顺序和继承性的实现，UVM是通过两个相关类uvm_callback_iter和uvm_callbacks #(T, CB)来实现的</p><p>如何定义这些callback类：<br>UVM是通过两个相关类uvm_callback_iter和uvm_callbacks #(T, CB)来实现的</p><ul><li><code>uvm_callback_iter</code></li><li><code>uvm_callbacks #(T, CB)</code></li></ul><h2 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h2><h3 id="（1）trans数据类以及callback定义"><a href="#（1）trans数据类以及callback定义" class="headerlink" title="（1）trans数据类以及callback定义"></a>（1）trans数据类以及callback定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215505263.png" alt="image-20211130215505263"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215542955.png" alt="image-20211130215542955"></p><ul><li>trans数据类<ul><li>obj注册</li></ul></li><li>定义cb1<ul><li>obj注册</li><li>虚函数，名称随便起</li></ul></li><li>定义cb2继承于cb1<ul><li>override do_trans</li></ul></li></ul><p><strong>你可以在callback里面定义任何你想定义的函数名称</strong>：这里我们定义了do_trans函数</p><h3 id="（2）comp1定义"><a href="#（2）comp1定义" class="headerlink" title="（2）comp1定义"></a>（2）comp1定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130213618156.png" alt="image-20211130213618156"></p><ul><li>定义comp1<ul><li>注册(关联)comp1与cb1两个类的关系，方便之后检查(其实也可以不写，类型不同时无法提醒警告，参考4.4节)<ul><li><code>uvm_register_cb(comp1, cb1)</code></li></ul></li><li>run_phase中插入callback<ul><li>插入callbacks：<code>uvm_do_callback(comp1, cb1, do_trans(d))</code><ul><li>参数解释：我在comp1里面调用cb1类型的callback，callback方法名为do_trans(d)，d为传入参数</li></ul></li></ul></li></ul></li></ul><h3 id="（3）env与输出结果"><a href="#（3）env与输出结果" class="headerlink" title="（3）env与输出结果"></a>（3）env与输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215608187.png" alt="image-20211130215608187"></p><ul><li>构造函数<ul><li>例化comp1,cb1,cb2</li></ul></li><li>build_phase<ul><li>添加callbacks进行绑定：<code>uvm_callbacks # (comp1)::add(组件实例句柄, callback实例句柄1)</code><ul><li>实现callback与comp1进行绑定</li></ul></li><li>添加callbacks进行绑定：<code>uvm_callbacks # (comp1)::add(组件实例句柄, callback实例句柄2)</code><ul><li>实现callback与comp1进行绑定</li><li>cb2没有注册为什么添加到m_cb2到c1可以？：因为cb2继承cb1，<strong>一旦发生继承关系你不需要再进行绑定</strong></li></ul></li></ul></li></ul><p>comp1的run_phase最终执行顺序：</p><ul><li>run_phase原来部分程序</li><li>cb1.do_trans(d)</li><li>cb2.do_trans(d)</li></ul><hr><h3 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h3><p>①注册你的callback</p><p>②绑定以及插入callback</p><p>③添加callback</p><h2 id="4-4-总结：结对子"><a href="#4-4-总结：结对子" class="headerlink" title="4.4 总结：结对子"></a>4.4 总结：结对子</h2><p>UVMcallback与SVcallback没区别，建议使用UVMcallback，更为标准化</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130220008552.png" alt="image-20211130220008552"></p><h3 id="部分函数总结"><a href="#部分函数总结" class="headerlink" title="部分函数总结"></a>部分函数总结</h3><ul><li>组件创建时注册：<code>uvm_register_cb(组件类名, callback类名)</code></li><li><p>组件对应位置插入：<code>uvm_do_callback(组件类名, callback类名, callback内回调方法名(回调传入数据参数))</code></p></li><li><p>环境中添加：<code>uvm_callbacks # (组件类名)::add(组件实例句柄, callback实例句柄)</code></p></li><li><p>控制回调函数的层次（了解）：<code>`uvm_do_callbacks_exit_on(T,CB,METHOD,VAL)</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶5：TLM通信_单向双向多向_通信管道_TLM2.0</title>
    <link href="/202111271641/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/"/>
    <url>/202111271641/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li><p>TLM通信</p><ul><li>单向通信</li><li>双向通信</li><li>多向通信</li><li>通信管道</li></ul></li><li><p>TLM2.0</p></li></ul><p>双向通信（使用较少）与TLM2.0（与SystemC通信），都作为<strong>了解</strong></p><h1 id="1-TLM通信"><a href="#1-TLM通信" class="headerlink" title="1 TLM通信"></a>1 TLM通信</h1><p>transaction level module</p><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>不用端口也是ok的（如实验2）但使用端口可以降低耦合度，有利于更长远的维护</p><h3 id="1-1-1-系统原型与芯片验证"><a href="#1-1-1-系统原型与芯片验证" class="headerlink" title="1.1.1 系统原型与芯片验证"></a>1.1.1 系统原型与芯片验证</h3><p>芯片开发流程中，两个地方对项目的助推起到关键作用：</p><ul><li>系统原型</li><li>芯片验证</li></ul><p>系统原型：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127173613007-16381918085062.png" alt="image-20211127173613007"></p><p>芯片验证：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127173627851-16381918085094.png" alt="image-20211127173627851"></p><p>实际上sv在组件间发送的数据都是trans，把硬件发送的数据抽象到一个数据包中，模拟硬件内部多个周期的数据传输</p><p>两者中的TLM与其作用：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174154049-16381918085096.png" alt="image-20211127174154049"></p><p>TLM是一个标准，而不一种特定语言：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174214668-16381918085108.png" alt="image-20211127174214668"></p><p>TLM引用越来越广泛，uvm与sv验证平台互通可以通过这个标准</p><h3 id="1-1-2-开发结构图（软件开发消耗人力较多）"><a href="#1-1-2-开发结构图（软件开发消耗人力较多）" class="headerlink" title="1.1.2 开发结构图（软件开发消耗人力较多）"></a>1.1.2 开发结构图（软件开发消耗人力较多）</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174327342-163819180851010.png" alt="image-20211127174327342"></p><p>软件开发的两方面：</p><ul><li>对系统原型开发，没有硬件</li><li>等到设计开发到达稳定阶段时在稳定系统（simulator,FPGA,emulator硬件加速器）基础上</li></ul><h3 id="1-2-1-TLM"><a href="#1-2-1-TLM" class="headerlink" title="1.2.1 TLM"></a>1.2.1 TLM</h3><p>TLM：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185549442-163819180851012.png" alt="image-20211127185549442"></p><p>如何提高系统模型仿真性能：1、自身运算优化；2、通信优化</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185613000-163819180851114.png" alt="image-20211127185613000"></p><p>TLM就是通信角度的一种优化方式</p><h3 id="1-2-2-TLM通信基本概念"><a href="#1-2-2-TLM通信基本概念" class="headerlink" title="1.2.2 TLM通信基本概念"></a>1.2.2 TLM通信基本概念</h3><ul><li>基于事务的通信方式，可用于多种语言的模型中</li><li>需要两个通信对象，initiator与target，谁先发请求谁是initiator，谁响应谁是target<ul><li>initiator,target并不代表数据传输方向</li></ul></li><li>transaction数据流向分类分为producer（数据产生）与consumer（数据流向）</li><li>producer/consumer，initiator/target，关系不是固定的</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185746270-163819180851116.png" alt="image-20211127185746270"></p><h3 id="1-2-3-TLM通信步骤："><a href="#1-2-3-TLM通信步骤：" class="headerlink" title="1.2.3 TLM通信步骤："></a>1.2.3 TLM通信步骤：</h3><ul><li>确定通信对象</li><li>将TLM<strong>通信方法</strong>在target一段实现（从而init调用target方法）</li><li>两个对象中创建TLM端口（uvm中端口预设，只需例化）</li><li>在更高层次中将两个对象的端口进行连接</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127190821795-163819180851218.png" alt="image-20211127190821795"></p><h3 id="1-2-4-示意图"><a href="#1-2-4-示意图" class="headerlink" title="1.2.4 示意图"></a>1.2.4 示意图</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127190837689-163819180851220.png" alt="image-20211127190837689"></p><h3 id="1-2-5-分类"><a href="#1-2-5-分类" class="headerlink" title="1.2.5 分类"></a>1.2.5 分类</h3><p>单向(unidirection)和双向(bidirection)传输：</p><ul><li>单向传输：由initor发起req trans</li><li>双向传输：由initor发起req trans，传送到target；target处理req trans后发起rsp trans，返回initor</li></ul><p>端口类型三种：</p><ul><li>prot：常作为initor发起端，initor借助port才能访问target的TLM通信方法（port也能连接到port上）</li><li><p>export：作为initor与target中间层次的端口</p></li><li><p>imp(implementation)：作为target接收rsp的末端，无法作为中间层次端口，所以imp的连接无法再次延伸（无法再连接到imp或其他端口上）</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127192644202.png" alt="image-20211127192644202"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195412692-163819180851324.png" alt="image-20211127195412692"></p><p>单向通信补充(参考1.3节)：</p><ul><li>多个port可以连到同一port/export/imp上</li><li>一个port不能连接到多个imp</li><li>为什么：<ul><li>多个initor可对同一组件发起req请求</li><li>同一initor无法连接多个target</li></ul></li></ul><p>如上可知，将传输方向与端口类型组合，得出TLM端口共六类，进而理解TLM端口的继承树：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_UNDIR_port <span class="hljs-variable">#(trans_t)</span><br>uvm_UNDIR_export <span class="hljs-variable">#(trans_t)</span><br>uvm_UNDIR_imp <span class="hljs-variable">#(trans_t)</span><br>uvm_BIDIR_port <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br>uvm_BIDIR_export <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br>uvm_BIDIR_imp <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br></code></pre></div></td></tr></table></figure><p>端口既不是obj也不是comp类型，比较特殊<strong>不能通过type_id::create创建，即不存在factory的注册与创建</strong>：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127193020422-163819180851426.png" alt="image-20211127193020422"></p><h2 id="1-3-端口的使用："><a href="#1-3-端口的使用：" class="headerlink" title="1.3 端口的使用："></a>1.3 端口的使用：</h2><h3 id="1-3-1-结构示意图，port-import-export的符号"><a href="#1-3-1-结构示意图，port-import-export的符号" class="headerlink" title="1.3.1 结构示意图，port,import,export的符号"></a>1.3.1 结构示意图，port,import,export的符号</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127193208516-163819180851428.png" alt="image-20211127193208516"></p><h3 id="1-3-2-上述结构图代码"><a href="#1-3-2-上述结构图代码" class="headerlink" title="1.3.2 上述结构图代码"></a>1.3.2 上述结构图代码</h3><p>注意端口类型：</p><p>port：<code>uvm_blocking_get_port</code></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195110198-163819180851530.png" alt="image-20211127195110198"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195005868-163819180851532.png" alt="image-20211127195005868"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127194942991-163819180851634.png" alt="image-20211127194942991"></p><h3 id="1-3-3-示例得出的TLM通信常规步骤"><a href="#1-3-3-示例得出的TLM通信常规步骤" class="headerlink" title="1.3.3 示例得出的TLM通信常规步骤"></a>1.3.3 示例得出的TLM通信常规步骤</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127200002390.png" alt="image-20211127200002390"></p><h1 id="2-单向通信"><a href="#2-单向通信" class="headerlink" title="2 单向通信"></a>2 单向通信</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="2-1-1-单向通信-unidirection-communication"><a href="#2-1-1-单向通信-unidirection-communication" class="headerlink" title="2.1.1 单向通信(unidirection communication)"></a>2.1.1 单向通信(unidirection communication)</h3><p>指的是从initiator到target之间的数据刘翔是单一方向的，也就是书initor与target只能扮演producer或consumer其中之一</p><p>UVM中单一数据流向的TLM端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br>uvm_blockong_put_PORT<br>uvm_nonblockong_put_PORT<br>uvm_put_PORT<br><span class="hljs-comment">//get</span><br>uvm_blockong_get_PORT<br>uvm_nonblockong_get_PORT<br>uvm_get_PORT<br><span class="hljs-comment">//peek</span><br>uvm_blockong_peek_PORT<br>uvm_nonblockong_peek_PORT<br>uvm_peek_PORT<br><span class="hljs-comment">//get_peek</span><br>uvm_blockong_get_peek_PORT<br>uvm_nonblockong_get_peek_PORT<br>uvm_get_peek_PORT<br></code></pre></div></td></tr></table></figure><h3 id="2-1-2-类型与表（非常重要）"><a href="#2-1-2-类型与表（非常重要）" class="headerlink" title="2.1.2 类型与表（非常重要）"></a>2.1.2 类型与表（非常重要）</h3><p>PORT代表三种端口名：port、export和imp，例如：</p><ul><li><code>uvm_blocking_put_PORT</code></li><li><code>uvm_blocking_put_EXPORT</code></li><li><code>uvm_blocking_put_IMP</code></li></ul><p>按照UVM端口命名规则，它们指出了通信的两个要素：</p><ul><li>是否是阻塞方式（block/nonblock）</li><li>何种通信方法（put/get/peek/get_peek）</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127202106862-163819180851638.png" alt="image-20211127202106862"></p><p>例如：</p><ul><li><p>看到<code>uvm_blocking_put_PORT</code></p><ul><li>我们要在target实现<code>task put(T t)</code>这一个方法</li></ul></li><li><p>看到<code>uvm_nonblocking_put_PORT</code></p><ul><li>我们要在target实现实现 <code>function bit try_put(T t)</code>，<code>function bit can_put()</code></li></ul></li><li>看到<code>uvm_put_PORT</code><ul><li>我们要在target实现上述三个方法</li></ul></li></ul><p>关于put，get，peek，get_peek：</p><ul><li>put：initiator—&gt;target</li><li>get：target—&gt;initiator</li><li>peek：与get方向一样，但没有把target_buf内数据移除</li></ul><h3 id="2-1-3-方法"><a href="#2-1-3-方法" class="headerlink" title="2.1.3 方法"></a>2.1.3 方法</h3><p>阻塞的是任务，非阻塞的是函数（函数有返回值）</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203157709-163819180851740.png" alt="image-20211127203157709"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203247382-163819180851742.png" alt="image-20211127203247382"></p><h2 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203326914-163819180851844.png" alt="image-20211127203326914"></p><hr><p>代码：</p><p><strong>数据类型、组件一：</strong></p><p>传输的数据类型一定写的明明白白</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204455138-163819180851846.png" alt="image-20211127204455138"></p><hr><p><strong>组件1在run_phase是怎么做的呢</strong></p><p>线程1：</p><ul><li>通过bp_port.put发送出去<ul><li>port没有实现任何方法，这个方法不是port提供的，而是连接到的imp的组件2提供的</li></ul></li><li>更好的隔离性：完全看不到组件2，组件2的句柄，组件2的方法，完全不知道trans要发送到哪里；只知道要调用我的put方法</li></ul><p>线程2：</p><ul><li>try_get进行forever轮询</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204113119-163819180851848.png" alt="image-20211127204113119"></p><hr><p><strong>组件2：</strong></p><p>为什么要多传递所例化在的类型？</p><ul><li>这样才能在port找到imp端口后，再通过imp找到组件二的方法</li></ul><p>省略号省略例化</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204821405-163819180851950.png" alt="image-20211127204821405"></p><hr><p><strong>组件二方法定义续，端口连接</strong></p><ul><li>对c1,c2例化</li><li>对c1,c2连接<ul><li>从initor_port连接到target_imp</li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205350698-163819180851954.png" alt="image-20211127205350698"></p><hr><p><strong>示例代码总结</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205728745-163819180851952.png" alt="image-20211127205728745"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205412314-163819180852056.png" alt="image-20211127205412314"></p><h2 id="2-3-调用端口方法之前的几个步骤是必不可少的"><a href="#2-3-调用端口方法之前的几个步骤是必不可少的" class="headerlink" title="2.3 调用端口方法之前的几个步骤是必不可少的"></a>2.3 调用端口方法之前的几个步骤是必不可少的</h2><ul><li>定义端口</li><li>实现对应方法啊</li><li>在上层将端口进行连接</li></ul><h1 id="3-双向通信"><a href="#3-双向通信" class="headerlink" title="3 双向通信"></a>3 双向通信</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-双向通信-bidirectional-communication"><a href="#3-1-1-双向通信-bidirectional-communication" class="headerlink" title="3.1.1 双向通信(bidirectional communication)"></a>3.1.1 双向通信(bidirectional communication)</h3><p>应用场景较少，目前大多数是单向通信</p><p>与单向通信相同的是，双向通信(bidirectional communication)的两端也分为initiator与target</p><p>但数据流向在端对端之间是双向的，两端同时扮演者着producer与consumer的角色，而initiator作为request发起方在发起request之后还会等待response返回</p><p>UVM双向端口分为以下类型：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//transport</span><br>uvm_blockong_transport_PORT<br>uvm_nonblockong_transport_PORT<br>uvm_transport_PORT<br><span class="hljs-comment">//master</span><br>uvm_blockong_master_PORT<br>uvm_nonblockong_master_PORT<br>uvm_master_PORT<br><span class="hljs-comment">//slave</span><br>uvm_blockong_slave_PORT<br>uvm_nonblockong_slave_PORT<br>uvm_slave_PORT<br></code></pre></div></td></tr></table></figure><h3 id="3-1-2-类型与表"><a href="#3-1-2-类型与表" class="headerlink" title="3.1.2 类型与表"></a>3.1.2 类型与表</h3><ul><li>transport双向通信<ul><li>调用task transport/nb_transport 使得在一次传输中同时完成req与rsp的返回</li></ul></li><li>master/slave成对双向通信<ul><li>至少要调用两次对应的方法</li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122449307-163819180852058.png" alt="image-20211128122449307"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128122841747.png" alt="image-20211128122841747"></p><h2 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a>3.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122924921-163819180852162.png" alt="image-20211128122924921"></p><p><strong>transport双向通信方式，因为它明显区分于之前的单向通信方式</strong></p><hr><p>代码：</p><p>组件一：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122953437-163819180852164.png" alt="image-20211128122953437"></p><p>组件二：</p><ul><li><p>下二语句内类型严格一致：</p><ul><li><p>uvm_blocking_transport_imp #（类型）</p></li><li><p>task transport(类型)</p></li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128124144451-163819180852166.png" alt="image-20211128124144451"></p><p>env例化：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128124351358.png" alt="image-20211128124351358"></p><p>输出结果：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128124421630-163819180852270.png" alt="image-20211128124421630"></p><h1 id="4-多向通信"><a href="#4-多向通信" class="headerlink" title="4 多向通信"></a>4 多向通信</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-多向通信-multi-directional-communication"><a href="#4-1-1-多向通信-multi-directional-communication" class="headerlink" title="4.1.1 多向通信(multi-directional communication)"></a>4.1.1 多向通信(multi-directional communication)</h3><p>仍然是两个组件的通信，但是两个组件的通信由多个端口完成</p><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128125224093-163819180852272.png" alt="image-20211128125224093"></p><p>具体内容：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128124518033-16381062899701.png" alt="image-20211128124518033"></p><p>多向通信解决的问题：</p><ul><li><p>comp2中需要实现两个put造成的命名冲突</p></li><li><p>同时降低了耦合性</p></li></ul><h3 id="4-1-2-解决方案与命名方式"><a href="#4-1-2-解决方案与命名方式" class="headerlink" title="4.1.2 解决方案与命名方式"></a>4.1.2 解决方案与命名方式</h3><p>UVM通过<strong>端口宏</strong>声明端口来解决</p><p>它解决问题的核心在于<strong>让不同端口对应不同名的任务</strong></p><ul><li>也就是让方法名不一样</li></ul><p>UVM 为解决多向通信问题的宏按照端口名的命名方式分为：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br><span class="hljs-meta">`uvm_blockong_put_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_put_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_put_imp_decl(SFX)</span><br><span class="hljs-comment">//get</span><br><span class="hljs-meta">`uvm_blockong_get_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_get_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_get_imp_decl(SFX)</span><br><span class="hljs-comment">//peek</span><br><span class="hljs-meta">`uvm_blockong_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_peek_imp_decl(SFX)</span><br><span class="hljs-comment">//get_peek</span><br><span class="hljs-meta">`uvm_blockong_get_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_get_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_get_peek_imp_decl(SFX)</span><br><span class="hljs-comment">//transport</span><br><span class="hljs-meta">`uvm_blockong_transport_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_transport_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_transport_imp_decl(SFX)</span><br><span class="hljs-comment">//master</span><br><span class="hljs-meta">`uvm_blockong_master_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_master_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_master_imp_decl(SFX)</span><br><span class="hljs-comment">//slave</span><br><span class="hljs-meta">`uvm_blockong_slave_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_slave_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_slave_PORT</span><br></code></pre></div></td></tr></table></figure><p>上述宏名称解释：</p><ul><li>decl：表明要声明一个新的端口</li><li>SFX：独一无二的名称</li></ul><h2 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a>4.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128125224093-163819180852272.png" alt="image-20211128125224093"></p><hr><p>代码：</p><p><strong>宏声明与组件一</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221446172.png" alt="image-20211128221446172"></p><p><strong>组件二</strong></p><ul><li>方法实现</li><li>push到buf里<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221811119.png" alt="image-20211128221811119"></li></ul></li><li>旗语锁定buf</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221758250.png" alt="image-20211128221758250"></p><p><strong>env（顶层）做连接</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128214115156.png" alt="image-20211128214115156"></p><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221858109.png" alt="image-20211128221858109"></p><hr><p>与这种端口区别开，这种直接单向通信就可以</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222125651.png" alt="image-20211128222125651"></p><h1 id="5-通信管道"><a href="#5-通信管道" class="headerlink" title="5 通信管道"></a>5 通信管道</h1><h2 id="5-1-问题及相关TLM组件和端口"><a href="#5-1-问题及相关TLM组件和端口" class="headerlink" title="5.1 问题及相关TLM组件和端口"></a>5.1 问题及相关TLM组件和端口</h2><p>TLM通信的实现方式都是端到端的，即target实现传输方法</p><ul><li><p>如何可以自己不是现这些传输方法同时使用到TLM呢</p></li><li><p>对于monitor、coverage collector等组件存在一端到多端的传输如何解决</p></li></ul><p>几个TLM组件和端口可以解决：</p><ul><li>TLM FIFO</li><li>analysis port</li><li>analysis TLM FIFO</li><li>request &amp; response 通信管道</li></ul><h2 id="5-2-TLM-FIFO组件"><a href="#5-2-TLM-FIFO组件" class="headerlink" title="5.2 TLM_FIFO组件"></a>5.2 TLM_FIFO组件</h2><h3 id="5-2-1-概述：TLM-FIFO是一个组件"><a href="#5-2-1-概述：TLM-FIFO是一个组件" class="headerlink" title="5.2.1 概述：TLM_FIFO是一个组件"></a>5.2.1 概述：TLM_FIFO是一个组件</h3><p>put方法一般就是往FIFO里面送数据，我们使用UVM组件进行简单化就不用我们自己实现了</p><hr><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">TLM　FIFO uvm_tlm_fifo<br></code></pre></div></td></tr></table></figure><p>TLM_FIFO是一个组件，继承于uvm_component，预先<strong>内置多个端口</strong>以及<strong>实现了多个对应方法</strong>供用户使用</p><ul><li><p>为什么是组件？</p><ul><li>因为只有组件才可以例化端口</li></ul></li><li><p>因此transaction不能例化该端口（组件），因为obj不是继承于comp</p></li></ul><p>uvm_tlm_fifo功能类似于mailbox，只不过提供了各种端口使用</p><p>我们推荐在initiator例化put_port，或者get_peek_port来匹配uvm_tlm_fifo的端口类型。当然如果用户例化了其它类型的端口，uvm_tlm_fifo还提供了put、get、peek对应端口</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222642907.png" alt=""></p><hr><p>uvm_tlm_fifo结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222656394.png" alt="image-20211128222656394"></p><h3 id="5-2-2-TLM-FIFO-具有的端口"><a href="#5-2-2-TLM-FIFO-具有的端口" class="headerlink" title="5.2.2 TLM_FIFO 具有的端口"></a>5.2.2 TLM_FIFO 具有的端口</h3><p>uvm_tlm_fifo功能类似于mailbox，只不过提供了各种端口使用</p><p>我们推荐在initiator例化put_port，或者get_peek_port来匹配uvm_tlm_fifo的端口类型。当然如果用户例化了其它类型的端口，uvm_tlm_fifo还提供了put、get、peek对应端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br>uvm_put_imp <span class="hljs-variable">#(T, this_type)</span> blockong_put_export<br>uvm_put_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_put_export<br><span class="hljs-comment">//get</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_get_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_get_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> get_export<br><span class="hljs-comment">//peek</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> peek_export<br><span class="hljs-comment">//get_peek</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_get_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_get_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> get_peek_export<br></code></pre></div></td></tr></table></figure><ul><li>_export：实际上都是实现的方法</li></ul><h2 id="5-3-Analysis-Port"><a href="#5-3-Analysis-Port" class="headerlink" title="5.3 Analysis Port"></a>5.3 Analysis Port</h2><p>本节内容唯一一个一端到多端的组件，利用到观察者模式/广播模式实现</p><hr><p>observer patten的核心：</p><ul><li>从一个initiator到多个target端</li><li>analysis port采取push模式，即从initiator端调用多个target端的<strong>write</strong>函数实现传输</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102446101.png" alt="image-20211129102446101"></p><p>Analysis Port连接结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102358636.png" alt="image-20211129102358636"></p><ul><li>我只管把消息发送出来</li></ul><h3 id="5-3-2-连接思路"><a href="#5-3-2-连接思路" class="headerlink" title="5.3.2 连接思路"></a>5.3.2 连接思路</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102358636.png" alt="image-20211129102358636"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target1<span class="hljs-variable">.amp</span>);<br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target2<span class="hljs-variable">.amp</span>);<br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target3<span class="hljs-variable">.amp</span>);<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129103636616.png" alt="image-20211129103636616"></p><h2 id="5-3-Analysis-TLM-FIFO"><a href="#5-3-Analysis-TLM-FIFO" class="headerlink" title="5.3 Analysis TLM FIFO"></a>5.3 Analysis TLM FIFO</h2><h3 id="5-3-1-uvm-tlm-analysis-fifo"><a href="#5-3-1-uvm-tlm-analysis-fifo" class="headerlink" title="5.3.1 uvm_tlm_analysis_fifo"></a>5.3.1 uvm_tlm_analysis_fifo</h3><p>Analysis TLM FIFO就是Analysis Port中间加一个fifo的一种结构封装为的类</p><ul><li>第一部分是端到端</li><li>第二部分是单向传递的port</li></ul><p>uvm_tlm_analysis_fifo类继承于uvm_tlm_fifo类，再此基础上添加了uvm_analysis_imp端口</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_analysis_imp <span class="hljs-variable">#(T,uvm_tlm_analysis_fifo #(T))</span> analysis_export<br></code></pre></div></td></tr></table></figure><ul><li>端口名称就叫analysis_export</li><li>FIFO参数类为T</li></ul><p>Analysis TLM FIFO连接结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129103747402.png" alt="image-20211129103747402"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104134652.png" alt="image-20211129104134652"></p><h3 id="5-3-2-连接思路-1"><a href="#5-3-2-连接思路-1" class="headerlink" title="5.3.2 连接思路"></a>5.3.2 连接思路</h3><p>两部分连接：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104816121.png" alt="image-20211129104816121"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104259780.png" alt="image-20211129104259780"></p><ul><li>ap</li><li>fifo1~3</li><li>target1~3</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo1<span class="hljs-variable">.analysis_export</span>);<br>target1<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo1<span class="hljs-variable">.get_export</span>);<br><br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo2<span class="hljs-variable">.analysis_export</span>);<br>target2<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo2<span class="hljs-variable">.get_export</span>);<br><br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo3<span class="hljs-variable">.analysis_export</span>);<br>target3<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo3<span class="hljs-variable">.get_export</span>);<br></code></pre></div></td></tr></table></figure><h2 id="5-4-Request-amp-Response管道"><a href="#5-4-Request-amp-Response管道" class="headerlink" title="5.4 Request&amp;Response管道"></a>5.4 Request&amp;Response管道</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><ul><li>单端（单向通信）：<ul><li>TLM FIFO、analysis port、analysis TLM FIFO</li></ul></li><li>双向通信，匹配双向通信的FIFO：<ul><li>request &amp; response 通信管道</li></ul></li></ul><p>双向通信端口名：transport</p><p>需要在target实现transport()方法完成一次传输既发送req又接受rsp</p><p>UVM提供两种简便的通信管道作为数据缓冲区，<strong>既有TLM端口从外侧接收req和rsp</strong>，同时也有TLM端口供外侧获取req和rsp，这两种TLM通信管道分别是：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_tlm_req_rsp_channel<br>uvm_tlm_transport_channel<br></code></pre></div></td></tr></table></figure><h3 id="5-4-2-端口"><a href="#5-4-2-端口" class="headerlink" title="5.4.2 端口"></a>5.4.2 端口</h3><p>对uvm_tlm_req_rsp_channel而言，提供端口是单一方向的，为简洁只列出该类例化的端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_put_export <span class="hljs-variable">#(REQ)</span> put_request_export;<br>uvm_put_export <span class="hljs-variable">#(RSP)</span> put_response_export;<br><br>uvm_get_peek_export <span class="hljs-variable">#(REQ)</span> get_peek_response_export;<br>uvm_put_peek_export <span class="hljs-variable">#(RSP)</span> get_peek_request_export;<br><br>uvm_analysis_port <span class="hljs-variable">#(REQ)</span> request_ap;<br>uvm_analysis_port <span class="hljs-variable">#(RSP)</span> response_ap;<br><br>uvm_master_imp <span class="hljs-variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> master_export<br>uvm_slave_imp <span class="hljs-variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> slave_export<br></code></pre></div></td></tr></table></figure><p>例化这么多端口，使用户可以在使用成对的端口进行数据的存储和访问</p><h3 id="5-4-3-示例结构一"><a href="#5-4-3-示例结构一" class="headerlink" title="5.4.3 示例结构一"></a>5.4.3 示例结构一</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129112631868.png" alt="image-20211129112631868"></p><hr><p>uvm_tlm_req_rsp_channel内部例化了两个mailbox分别用来存储req和rsp</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">protected</span> uvm_tlm_fifo <span class="hljs-variable">#(REQ)</span> m_request_fifo;<br><span class="hljs-keyword">protected</span> uvm_tlm_fifo <span class="hljs-variable">#(RSP)</span> m_response_fifo;<br></code></pre></div></td></tr></table></figure><p>例如initiator端可以连接channel的put_request_export, target连接channel的get_peek_request_export,同时target连接channel的put_response_export, initiator连接channel的 get_peek_response_export端口</p><hr><p>target不需要再实现对应的put,get,peek，对应的端口连接代码：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129112735235-16381564560181.png" alt="image-20211129112735235"></p><h3 id="5-4-4-示例结构二：利用一个端口实现双向通信（master-amp-slave）"><a href="#5-4-4-示例结构二：利用一个端口实现双向通信（master-amp-slave）" class="headerlink" title="5.4.4 示例结构二：利用一个端口实现双向通信（master&amp;slave）"></a>5.4.4 示例结构二：利用一个端口实现双向通信（master&amp;slave）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113506603.png" alt="image-20211129113506603"></p><hr><p>•也可以利用另外一种连接方式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.master_port</span><span class="hljs-variable">.connect</span>(req_rsp_channel,master_export);<br>target<span class="hljs-variable">.slave_port</span><span class="hljs-variable">.connect</span>(req_rsp_channel<span class="hljs-variable">.slave_export</span>);<br></code></pre></div></td></tr></table></figure><p>通过所述的这些方式，我们可以实现initiator与target之间自由的request和 response传输，而这两种连接方式仍然需要分别调用两次方法才可以完成 request 和 response 的传输。</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113521538.png" alt="image-20211129113521538"></p><hr><p>过程：</p><p>端口虽然减少了，调用的方法并没有减少</p><ul><li><p>put(rsp)-&gt;get(rsq)</p></li><li><p>get(rsp)&lt;-put(rsp)//target组件put时rr_channel才有数据</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113633263.png" alt="image-20211129113633263"></p><hr><h3 id="5-4-5-uvm-tlm-transport-channel"><a href="#5-4-5-uvm-tlm-transport-channel" class="headerlink" title="5.4.5 uvm_tlm_transport_channel"></a>5.4.5 uvm_tlm_transport_channel</h3><p>在uvm_t[m_req_rsp_channel的基础上，UVM又添加了具备transport端口的管道组件uvm_tlm_transport_channel类</p><p>它继承于 uvm_tlm_req_rsp_channel,并且新例化了transport端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm transport imp <span class="hljs-variable">#(REQ, RSP, this type)</span> transport_export<br></code></pre></div></td></tr></table></figure><p>新添加的这个TLM FIFO组件类型是针对于一些无法流水化处理的 request和response传输，例如initiator一端要求每次发送完 request,必须等到response接收到以后才可以发送下一个request, 这时transport。方法就可以满足这一需求<br>如果将上面的传输方式进行修改，需要变化的是initiator端到 req_rsp_channel的连接，应该修改为：</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.transport_port</span><span class="hljs-variable">.connect</span>(transport_channel<span class="hljs-variable">.transport_export</span>)<br></code></pre></div></td></tr></table></figure><p>•至于transport_channel和target之间的连接，则可以仍然保留之 前的单向传输连接方式</p><p>过程：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113923124.png" alt="image-20211129113923124"></p><h1 id="6-TLM2-0通信（了解）"><a href="#6-TLM2-0通信（了解）" class="headerlink" title="6 TLM2.0通信（了解）"></a>6 TLM2.0通信（了解）</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><h3 id="6-1-1-由TLM1-0到TLM2-0"><a href="#6-1-1-由TLM1-0到TLM2-0" class="headerlink" title="6.1.1 由TLM1.0到TLM2.0"></a>6.1.1 由TLM1.0到TLM2.0</h3><ul><li>TLM1.0用UVM各个组件之间连接</li><li>TLM2.0用于与SystemC进行连接</li></ul><p>目前TLM开源包也是基于TLM2.0，且TLM2.0早于UVM成立的标准</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204050389.png" alt="image-20211129204050389"></p><h3 id="6-1-2-对比、主要内容"><a href="#6-1-2-对比、主要内容" class="headerlink" title="6.1.2 对比、主要内容"></a>6.1.2 对比、主要内容</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204417791.png" alt="image-20211129204417791"></p><p><strong>什么时候用到</strong>TLM2.0，uvm与systemc做继承，把systemc作为reference model的时候</p><ul><li>因为systemc是纯设计模型，没有时间概念 </li></ul><p>纯验证环境中不需要TLM2.0</p><h2 id="6-2-接口实现"><a href="#6-2-接口实现" class="headerlink" title="6.2 接口实现"></a>6.2 接口实现</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205403805.png" alt=""></p><hr><h3 id="6-2-1-传输方法"><a href="#6-2-1-传输方法" class="headerlink" title="6.2.1 传输方法"></a>6.2.1 传输方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205432385.png" alt="image-20211129205432385"></p><p>两种方法：</p><ul><li>_fw：forward拿过来一个req</li><li>_bw：backward拿过来一个rsp</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205521092.png" alt="image-20211129205521092"></p><h3 id="6-2-2-传输端口：端口类socket"><a href="#6-2-2-传输端口：端口类socket" class="headerlink" title="6.2.2 传输端口：端口类socket"></a>6.2.2 传输端口：端口类socket</h3><p>socket由port,export和imp组合而成</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205557115.png" alt="image-20211129205557115"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205653551.png" alt="image-20211129205653551"></p><h3 id="6-2-3-端口类socket继承于uvm-port-base"><a href="#6-2-3-端口类socket继承于uvm-port-base" class="headerlink" title="6.2.3 端口类socket继承于uvm_port_base"></a>6.2.3 端口类socket继承于uvm_port_base</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205707575.png" alt="image-20211129205707575"></p><h2 id="6-3-传输数据"><a href="#6-3-传输数据" class="headerlink" title="6.3 传输数据"></a>6.3 传输数据</h2><h3 id="6-3-1-传输数据类型uvm-tlm-generic-payload"><a href="#6-3-1-传输数据类型uvm-tlm-generic-payload" class="headerlink" title="6.3.1 传输数据类型uvm_tlm_generic_payload"></a>6.3.1 传输数据类型uvm_tlm_generic_payload</h3><p>严格使用uvm_tlm_generic_payload类进行数据传输</p><p>这样才能与systemc无缝连接</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205747604-16381906688471.png" alt="image-20211129205747604"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205825619.png" alt="image-20211129205825619"></p><h3 id="6-3-2-uvm-tlm-generic-payload内部变量"><a href="#6-3-2-uvm-tlm-generic-payload内部变量" class="headerlink" title="6.3.2 uvm_tlm_generic_payload内部变量"></a>6.3.2 uvm_tlm_generic_payload内部变量</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205855177.png" alt="image-20211129205855177"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205938411.png" alt="image-20211129205938411"></p><h3 id="6-3-3-其他数据类型：两种解决方法"><a href="#6-3-3-其他数据类型：两种解决方法" class="headerlink" title="6.3.3 其他数据类型：两种解决方法"></a>6.3.3 其他数据类型：两种解决方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210001509.png" alt="image-20211129210001509"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210352251.png" alt="image-20211129210352251"></p><h2 id="6-4-时间标记"><a href="#6-4-时间标记" class="headerlink" title="6.4 时间标记"></a>6.4 时间标记</h2><h3 id="6-4-1-uvm-tlm-tim"><a href="#6-4-1-uvm-tlm-tim" class="headerlink" title="6.4.1 uvm_tlm_tim"></a>6.4.1 uvm_tlm_tim</h3><p>原则上systemc可以自己创建一些时钟，当我们很少这样做，因为会大幅度降低仿真效率</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210411249.png" alt="image-20211129210411249"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210541718.png" alt="image-20211129210541718"></p><h2 id="6-5-通信代码示例"><a href="#6-5-通信代码示例" class="headerlink" title="6.5 通信代码示例"></a>6.5 通信代码示例</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210558006.png" alt="image-20211129210558006"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210851775.png" alt="image-20211129210851775"></p><ul><li>数据类型固定所以不需要再指定数据传输类型</li><li>自始至终rsq与rsp都是一个对象</li></ul><p>顶层代码：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211419275.png" alt="image-20211129211419275"></p><h2 id="6-6-通信代码示例（有标注版）"><a href="#6-6-通信代码示例（有标注版）" class="headerlink" title="6.6 通信代码示例（有标注版）"></a>6.6 通信代码示例（有标注版）</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210811424.png" alt="image-20211129210811424"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211211453.png" alt="image-20211129211211453"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV练习选修</title>
    <link href="/202111242221/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E7%BB%83%E4%B9%A0%E9%80%89%E4%BF%AE/"/>
    <url>/202111242221/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E7%BB%83%E4%B9%A0%E9%80%89%E4%BF%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-练习内容"><a href="#1-练习内容" class="headerlink" title="1 练习内容"></a>1 练习内容</h1><p>sv练习来自V1课程，因为V1在语法点上讲的比V2细致</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124222429387.png" alt="image-20211124222429387"></p><h2 id="lec1：类型练习"><a href="#lec1：类型练习" class="headerlink" title="lec1：类型练习"></a>lec1：类型练习</h2><ul><li>data_type.sv</li><li>interface_type.sv</li><li>string_type.sv</li><li>sv_for_design：sv中的设计<ul><li>always、always_comb、unique case</li></ul></li></ul><h2 id="lec2："><a href="#lec2：" class="headerlink" title="lec2："></a>lec2：</h2><ul><li>array_type.sv：数组</li><li>class_encapsulation.sv：类的封装</li><li>class_inheritance.sv：类的继承</li><li>package_usage.sv：包的使用</li></ul><h2 id="lec3："><a href="#lec3：" class="headerlink" title="lec3："></a>lec3：</h2><ul><li><p>constrained_random.sv：随即约束</p></li><li><p>interprocess_sync.sv：进程间通信</p></li><li>task_and_function.sv：</li><li>thread_control.sv：进程控制</li><li>virtual_methods.sv：虚方法</li></ul><h2 id="练习技巧"><a href="#练习技巧" class="headerlink" title="练习技巧"></a>练习技巧</h2><ul><li>每一个练习内有一个练习点，使用initial包住</li><li><p>全局initial同名的bit变量作为练习开关，如右图：<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124225912339.png" alt="image-20211124225912339"></p><ul><li>修改方法：1.编译前修改值；2.仿真时修改值</li></ul></li><li><p>编译时warning的查看方法：</p><ul><li>点击successful</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125225129574.png" alt="image-20211125225129574"></li></ul></li><li>查询命令历史：<ul><li>上下键</li><li><code>&gt;history</code></li></ul></li><li>命令：<ul><li>编译命令：<code>&gt;vlog -sv xxx.sv</code>，vlog是编译命令，-sv是sv的形式，最后xxx.sv是具体文件</li><li>仿真命令：<code>&gt;vsim -voptargs=+acc work.xxx</code>最后xxx是具体模型名</li><li>从零开始加载模型，从零开始仿真：<code>&gt;restart</code></li><li>运行仿真：<code>&gt;run [time]</code></li><li>保存波形：<code>&gt;log -r /*</code> ，log是保存的意思，-r递归模式，/*表示从当前的顶层，即从当前顶层递归的去保存所有信号波形</li><li>仿真时修改静态信号的值（所有没有auto声明的都是静态变量）(linux的questasim有优化，解决方法见最后一节)<ul><li><code>&gt;restart</code></li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125220012324.png" alt="image-20211125220012324"></li><li>freeze一直保持该值；Drive以硬件驱动模式保持（会与硬件产生冲突）；Depost更高优先级的硬件驱动（不会与硬件产生冲突）<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125220030623.png" alt="image-20211125220030623"></li></ul></li></ul></li></ul><h1 id="2-练习一指导"><a href="#2-练习一指导" class="headerlink" title="2 练习一指导"></a>2 练习一指导</h1><h2 id="2-1-data-type"><a href="#2-1-data-type" class="headerlink" title="2.1 data_type"></a>2.1 data_type</h2><h3 id="1-bytes与bit"><a href="#1-bytes与bit" class="headerlink" title="(1) bytes与bit"></a>(1) bytes与bit</h3><p>b0是byte四值逻辑(默认有符号数），b1是bit二值逻辑（默认无符号数），b2是有符号bit</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: signed_vs_unsigned<br>  <span class="hljs-keyword">byte</span> b0;<br>  <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] b1;<br>  <span class="hljs-keyword">bit</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] b2;<br>  <span class="hljs-keyword">wait</span>(b_signed_vs_unsigned == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;signed_vs_unsigned process block started&quot;</span>);<br>  b0 = <span class="hljs-number">&#x27;b1000_0000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;byte variable b0 = %d&quot;</span>, b0);<br>  b1 = b0;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit vector variable b1 = %d&quot;</span>, b1);<br>  b2 = b0;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit vector signed variable b2 = %d&quot;</span>, b2);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># signed_vs_unsigned process block started</span><br><span class="hljs-comment"># byte variable b0 = -128</span><br><span class="hljs-comment"># bit vector variable b1 = 128</span><br><span class="hljs-comment"># bit vector signed variable b2 = -128</span><br></code></pre></div></td></tr></table></figure><p>1000_0000为有符号的-128，无符号的128</p><p>有符号最高位是符号位，所以是-128，范围也就是-128~127</p><p>无符号最高位还是数，因此表示范围可以到2^8也就是255个数</p><h3 id="2-bit-vs-logic"><a href="#2-bit-vs-logic" class="headerlink" title="(2) bit_vs_logic"></a>(2) bit_vs_logic</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: bit_vs_logic<br>  <span class="hljs-keyword">bit</span> v1;<br>  <span class="hljs-keyword">logic</span> v2;<br>  <span class="hljs-keyword">wait</span>(b_bit_vs_logic == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit_vs_logic process block started&quot;</span>);<br><br>  v2 = <span class="hljs-number">&#x27;b1</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;b0</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;bx</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;bz</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># logic variable v2 = 1</span><br><span class="hljs-comment"># bit variable v1 = 1</span><br><span class="hljs-comment"># logic variable v2 = 0</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br><span class="hljs-comment"># logic variable v2 = x</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br><span class="hljs-comment"># logic variable v2 = z</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br></code></pre></div></td></tr></table></figure><p>四值变量中的x,z值转为二值变量时转为0</p><h3 id="3-enum-type：枚举类型的打印，与整数转枚举"><a href="#3-enum-type：枚举类型的打印，与整数转枚举" class="headerlink" title="(3) enum_type：枚举类型的打印，与整数转枚举"></a>(3) enum_type：枚举类型的打印，与整数转枚举</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: enum_type<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;IDLE, START, PROC, END&#125; state_t;<br>  state_t st1, st2;<br>  <span class="hljs-keyword">wait</span>(b_enum_type == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;enum_type process block started&quot;</span>);<br>  st1 = IDLE;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %0d (int)&quot;</span>, st1);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %s (string)&quot;</span>, st1); <span class="hljs-comment">// 推荐使用，有隐式转换implicit conversion</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %s (string)&quot;</span>, st1<span class="hljs-variable">.name</span>());<br><br>  st2 = state_t&#x27;(<span class="hljs-number">1</span>);<span class="hljs-comment">//一个整数转为枚举类型，合法值legal value</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %0d (int)&quot;</span>, st2);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %s (string)&quot;</span>, st2<span class="hljs-variable">.name</span>());<br>  <br>  st2 = state_t&#x27;(<span class="hljs-number">4</span>);<span class="hljs-comment">//out of range</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %0d (int)&quot;</span>, st2);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %s (string)&quot;</span>, st2<span class="hljs-variable">.name</span>());<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p><code>%0d</code>：抛去输出中的0与空格，使输出更紧密</p><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># st1 value = 0 (int)</span><br><span class="hljs-comment"># st1 value = IDLE (string)</span><br><span class="hljs-comment"># st1 value = IDLE (string)</span><br><span class="hljs-comment"># st1 value = 1 (int)</span><br><span class="hljs-comment"># st1 value = START (string)</span><br><span class="hljs-comment"># st1 value = 4 (int)</span><br><span class="hljs-comment"># st1 value = START (string) //这里没有显示枚举类型，因为字符串为空</span><br></code></pre></div></td></tr></table></figure><p>补充：</p><ul><li>整形直接赋值枚举</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">st2 = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>结果：报错</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125222901318-16378505421341.png" alt="image-20211125222901318"></p><ul><li>使用$cast做转换（这种方法转换有返回值，推荐）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125223023932.png" alt="image-20211125223023932"></p><h3 id="4-struct-type"><a href="#4-struct-type" class="headerlink" title="(4) struct_type"></a>(4) struct_type</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-4: struct type</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: struct_type<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">bit</span> is_write;<br>    <span class="hljs-keyword">int</span> id;<br>  &#125; trans_t;<br>  trans_t t1, t2, t3;<br>  <span class="hljs-keyword">wait</span>(b_struct_type == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;struct_type process block started&quot;</span>);<br>  t1 = &#x27;&#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t1 data content is %p&quot;</span>, t1);<br><br><br>  t2<span class="hljs-variable">.addr</span> = <span class="hljs-number">&#x27;h20</span>;<br>  t2<span class="hljs-variable">.data</span> = <span class="hljs-number">&#x27;h5566_7788</span>;<br>  t2<span class="hljs-variable">.is_write</span> = <span class="hljs-number">&#x27;b0</span>;<br>  t2<span class="hljs-variable">.id</span> = <span class="hljs-number">&#x27;h2000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t2 data content is %p&quot;</span>, t2);<br><br>  t3 = t2;<br>  t3<span class="hljs-variable">.data</span> = <span class="hljs-number">&#x27;h99AA_BBCC</span>;<br>  t3<span class="hljs-variable">.id</span> = <span class="hljs-number">&#x27;h3000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t3 data content is %p&quot;</span>, t3);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t2 data content is %p&quot;</span>, t2);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># struct_type process block started</span><br><span class="hljs-meta"># t1 data content is &#x27;&#123;addr:16, data:287454020, is_write:1, id:4096&#125;</span><br><span class="hljs-meta"># t2 data content is &#x27;&#123;addr:32, data:1432778632, is_write:0, id:8192&#125;</span><br><span class="hljs-meta"># t3 data content is &#x27;&#123;addr:32, data:2578103244, is_write:0, id:12288&#125;</span><br><span class="hljs-meta"># t2 data content is &#x27;&#123;addr:32, data:1432778632, is_write:0, id:8192&#125;</span><br></code></pre></div></td></tr></table></figure><p><code>%p</code>：十进制打印全部元素（数组，动态数组，队列，结构体），<strong>用的较多</strong></p><p>补充：</p><ul><li>struct packed：把struct串成一个vector</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> &#123;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">bit</span> is_write;<br>    <span class="hljs-keyword">int</span> id;<br>  &#125; trans_t;<br><br>t1 = &#x27;&#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<span class="hljs-comment">//正常</span><br>t1 = &#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<span class="hljs-comment">//warning并仿真后值不对应，此处&#123;&#125;内自动补全32位共128位与t1结构体73位不对应</span><br>t1 = &#123;<span class="hljs-number">8&#x27;h10</span>, <span class="hljs-number">32&#x27;h1122_3344</span>, <span class="hljs-number">1&#x27;b1</span>, <span class="hljs-number">32&#x27;h1000</span>&#125;;<span class="hljs-comment">//加位宽正常</span><br></code></pre></div></td></tr></table></figure><ul><li><ul><li>‘{a,b,c,d};并联成四个定长向量</li><li>{a,b,c,d};串联四个元素称为一个向量0</li></ul></li></ul><h2 id="2-2-string-type"><a href="#2-2-string-type" class="headerlink" title="2.2 string_type"></a>2.2 string_type</h2><h3 id="1-string-format"><a href="#1-string-format" class="headerlink" title="(1) string_format"></a>(1) string_format</h3><ul><li><p>判断字符串为空</p><p><code>if(str == &quot;&quot;)</code></p></li><li><p>字符串拼接</p><ul><li>方法一：<code>s3 = &#123;s1, &quot; to &quot;, s2&#125;; // concatenation operator &#39;&#123;...&#125;&#39;</code></li><li>方法二：<code>s4 = $sformatf(&quot;%s to %s&quot;, s1, s2); // system format function</code></li><li>方法三：<code>s5 = $psprintf(&quot;%s to %s&quot;, s1, s2); // system format function</code></li></ul></li><li>源码：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-1 understand how to formulate a new string</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: string_format<br>  <span class="hljs-keyword">string</span> s1, s2, s3, s4;<br>  <span class="hljs-keyword">wait</span>(b_string_format == <span class="hljs-number">1</span>);<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;string_format process block started&quot;</span>);<br>  s1 = <span class="hljs-string">&quot;Welcome&quot;</span>;<br>  s2 = <span class="hljs-string">&quot;www.rockeric.com&quot;</span>;<br><br>  s3 = &#123;s1, <span class="hljs-string">&quot; to &quot;</span>, s2&#125;; <span class="hljs-comment">// concatenation operator &#x27;&#123;...&#125;&#x27;</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: %s&quot;</span>, s3);<br><br>  s4 = <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s to %s&quot;</span>, s1, s2); <span class="hljs-comment">// system format function</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s4 content: %s&quot;</span>, s4);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><h3 id="2-string-builtin-function"><a href="#2-string-builtin-function" class="headerlink" title="(2) string_builtin_function"></a>(2) string_builtin_function</h3><p>拼接部分只是启示作用，正常直接{}就行</p><p>源码：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-2  understand how s3 is composed with s1 and s2</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: string_builtin_function<br>  <span class="hljs-keyword">string</span> s1, s2, s3;<br>  <span class="hljs-keyword">int</span> i1;<br>  <span class="hljs-keyword">wait</span>(b_string_builtin_function == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;string_builtin_function process block started&quot;</span>);<br>  s1 = <span class="hljs-string">&quot;RockerIC is established in &quot;</span>;<br>  i1 = <span class="hljs-number">2015</span>;<br>  s2<span class="hljs-variable">.itoa</span>(i1); <span class="hljs-comment">// integer converted to string</span><br>  s3 = &#123;s1<span class="hljs-variable">.len</span>()+s2<span class="hljs-variable">.len</span>()&#123;<span class="hljs-string">&quot; &quot;</span>&#125;&#125;; <span class="hljs-comment">// try to comment this line and check the result</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: [%s]&quot;</span>, s3);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s1<span class="hljs-variable">.len</span>()+s2<span class="hljs-variable">.len</span>(); i++) <span class="hljs-keyword">begin</span><br>    s3[i] = i &lt; s1<span class="hljs-variable">.len</span>() ? s1[i] : s2[i-s1<span class="hljs-variable">.len</span>()]; <br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: [%s]&quot;</span>, s3);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># string_builtin_function process block started</span><br><span class="hljs-comment"># s2 = 2015</span><br><span class="hljs-comment"># s3 content: [                               ]</span><br><span class="hljs-comment"># s3 content: [RockerIC is established in 2015]</span><br></code></pre></div></td></tr></table></figure><p>结论：</p><ul><li>整形转字符串：<code>itoa</code></li><li>字符串拼接的时候一定要用{}预留足够的位宽：<code>s3 = &#123;s1.len()+s2.len()&#123;&quot; &quot;&#125;&#125;;</code></li></ul><p>补充：</p><ul><li><p>使用自己拼接完成字符串复制</p><ul><li>```<br>  for(int i=0; i&lt;s1.len()+s2.len(); i++) begin<div class="hljs code-wrapper"><pre><code>s3[i] = i &lt; s1.len() ? &#123;s3,s1[i]&#125; : &#123;s3,s2[i-s1.len()]&#125;; </code></pre></div>  end<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><br>## <span class="hljs-number">2.3</span> interface_type<br><br>### 导入<br><br>程序结构<br><br>+ 一个结构体<br>+ 一个函数<br>+ <span class="hljs-keyword">module</span>里<br>  + 定义一个interface<br>  + 对interface例化<br>  + line-<span class="hljs-number">50</span>对接口数据进行修改<br><br>需要理解：<br><br>+ 接口的定义与例化<br>+ 接口内部定义的方法在接口外或接口内调用<br>+ 怎么准备transaction并进行驱动和监测<br><br>```verilog<br><br><span class="hljs-comment">// TODO-1 understand how the interface is defined and instantied</span><br><span class="hljs-comment">// TODO-2 check how to define methods inside interface and call them internally or externally</span><br><span class="hljs-comment">// TODO-3 understand how to prepare transactions, drive them and monitor them</span><br><span class="hljs-keyword">module</span> interface_type;<br>  typedef <span class="hljs-keyword">struct</span> &#123;<br>    bit<span class="hljs-literal">[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]</span> addr;<br>    bit<span class="hljs-literal">[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]</span> data;<br>    bit write;<br>    <span class="hljs-built_in">int</span> id;<br>  &#125; trans_t;<br><br>  <span class="hljs-comment">// struct print utility function</span><br>  <span class="hljs-keyword">function</span> void trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>, <span class="hljs-params">string</span> <span class="hljs-params">name</span> = <span class="hljs-string">&quot;trans&quot;</span>)</span>;<br>    <span class="hljs-built_in">string</span> s;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s struct content is as below \n&quot;</span>, <span class="hljs-params">name</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\taddr  = &#x27;h%2x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">addr</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\tdata  = &#x27;h%8x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">data</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\twrite = &#x27;b%0b \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">write</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\tid    = &#x27;h%8x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-constructor">$display(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-params">s</span>)</span>;<br>  endfunction<br><br>  interface intf1;<br>    logic <span class="hljs-literal">[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]</span> addr;<br>    logic <span class="hljs-literal">[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]</span> data;<br>    logic write;<br>    <span class="hljs-built_in">int</span> id;<br><br>    <span class="hljs-comment">// transaction drive task</span><br>    task drive<span class="hljs-constructor">_trans(<span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>)</span>;<br>      addr  &lt;= t.addr ;<br>      data  &lt;= t.data ;<br>      write &lt;= t.write;<br>      id    &lt;= t.id   ;<br>    endtask<br><br>    <span class="hljs-comment">// transaction monitor task</span><br>    task mon<span class="hljs-constructor">_trans(<span class="hljs-params">output</span> <span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>)</span>;<br>      t.addr  = addr ;<br>      t.data  = data ;<br>      t.write = write;<br>      t.id    = id   ;<br>    endtask<br>  endinterface<br><br>  <span class="hljs-comment">// interface instantiation</span><br>  intf1 if1<span class="hljs-literal">()</span>;<br><br>  initial <span class="hljs-keyword">begin</span><br>    trans_t trans_in<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>, trans_mon<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>;<br>    <span class="hljs-comment">// stimulus preparation</span><br>    trans_in = <span class="hljs-character">&#x27;&#123;&#x27;</span>&#123;&#x27;h10, &#x27;h1122_3344, &#x27;b1, &#x27;h1000&#125;<br>                ,<span class="hljs-character">&#x27;&#123;&#x27;</span>h14, &#x27;h5566_7788, &#x27;b0, &#x27;h1001&#125;<br>                ,<span class="hljs-character">&#x27;&#123;&#x27;</span>h18, &#x27;h99AA_BBCC, &#x27;b1, &#x27;h1002&#125;<br>                &#125;;<br>    foreach(trans_in<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      <span class="hljs-comment">// stimulus drive</span><br>      if1.drive<span class="hljs-constructor">_trans(<span class="hljs-params">trans_in</span>[<span class="hljs-params">i</span>])</span>;<br>      trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_in</span>[<span class="hljs-params">i</span>], $<span class="hljs-params">sformatf</span>(<span class="hljs-string">&quot;trans_in[%0d]&quot;</span>,<span class="hljs-params">i</span>)</span>);<br>      #<span class="hljs-number">10</span>;<br>      <span class="hljs-comment">// stimulus monitor</span><br>      if1.mon<span class="hljs-constructor">_trans(<span class="hljs-params">trans_mon</span>[<span class="hljs-params">i</span>])</span>;<br>      trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_mon</span>[<span class="hljs-params">i</span>], $<span class="hljs-params">sformatf</span>(<span class="hljs-string">&quot;trans_mon[%0d]&quot;</span>,<span class="hljs-params">i</span>)</span>);<br><br>      <span class="hljs-comment">// transaction comparison</span><br>      <span class="hljs-keyword">if</span>(trans_in<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> === </span>trans_mon<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>        <span class="hljs-constructor">$display(<span class="hljs-string">&quot;trans_in[%0d] === trans_mon[%0d]&quot;</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-constructor">$error(<span class="hljs-string">&quot;trans_in[%0d] !== trans_mon[%0d]&quot;</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>endmodule<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>提示：</p><ul><li>接口内有时间概念</li><li>接口与struct放在module外面仿真时才能看见，而且这种方式<strong>更常见</strong><ul><li>接口中不能在类里面或包里面定义，因为他是软件的概念</li></ul></li><li>接口内部定义的函数与module里面定义的是一样的，换句话module里做一件事在interface也都是可以做</li></ul><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">run<br><span class="hljs-comment"># trans_in[0] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h10 </span><br><span class="hljs-comment"># data  = &#x27;h11223344 </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001000 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[0] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h10 </span><br><span class="hljs-comment"># data  = &#x27;h11223344 </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001000 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[0] === trans_mon[0]</span><br><span class="hljs-comment"># trans_in[1] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h14 </span><br><span class="hljs-comment"># data  = &#x27;h55667788 </span><br><span class="hljs-comment"># write = &#x27;b0 </span><br><span class="hljs-comment"># id    = &#x27;h00001001 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[1] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h14 </span><br><span class="hljs-comment"># data  = &#x27;h55667788 </span><br><span class="hljs-comment"># write = &#x27;b0 </span><br><span class="hljs-comment"># id    = &#x27;h00001001 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[1] === trans_mon[1]</span><br><span class="hljs-comment"># trans_in[2] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h18 </span><br><span class="hljs-comment"># data  = &#x27;h99aabbcc </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001002 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[2] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h18 </span><br><span class="hljs-comment"># data  = &#x27;h99aabbcc </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001002 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[2] === trans_mon[2]</span><br></code></pre></div></td></tr></table></figure><h1 id="Questasim-in-Linux"><a href="#Questasim-in-Linux" class="headerlink" title="Questasim in Linux"></a>Questasim in Linux</h1><p>使用linux上10.7版本的Questasim对仿真强制优化，从而看不见模块内部变量，无法进行仿真时修改</p><p>解决方法：</p><ul><li><code>vsim -voptargs=+acc work.xxx</code><ul><li>work.xxx xxx是仿真的文件名</li><li>-voptargs：vsim optimision arguments =+ access<ul><li>access：表示当前所有信号都可看到</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶3：组件家族（如何例化部分较为重要）</title>
    <link href="/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B63%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%AE%B6%E6%97%8F/"/>
    <url>/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B63%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p><strong>注意，本文内大部分组件介绍分为两节：</strong>第一节主要介绍该组件，第二节介绍该组件的定义示例</p><h1 id="0-组件家族"><a href="#0-组件家族" class="headerlink" title="0 组件家族"></a>0 组件家族</h1><h2 id="0-0-回顾"><a href="#0-0-回顾" class="headerlink" title="0.0 回顾"></a>0.0 回顾</h2><h3 id="上节课内容"><a href="#上节课内容" class="headerlink" title="上节课内容"></a>上节课内容</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124104754455.png" alt="image-20211124104754455"></p><p>UVM实验一到实验二的代码会突然增加，实验二会看到如何把SV中的组件过度到UVM的组件的，过度比较简单的组件</p><h3 id="SV验证环境回顾"><a href="#SV验证环境回顾" class="headerlink" title="SV验证环境回顾"></a>SV验证环境回顾</h3><p>SV实验四、实验五的时候</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105111186.png" alt="image-20211124105111186"></p><p>没有体现出各个agent的generator，</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105238593.png" alt="image-20211124105238593"></p><h2 id="0-1-概述"><a href="#0-1-概述" class="headerlink" title="0.1 概述"></a>0.1 概述</h2><p><strong>前言</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105324168.png" alt="image-20211124105324168"></p><p>为什么要把generator拆分成sequence(产生)和sequencer(发送)，入门进阶4会见讲</p><hr><p><strong>三个核心组件：</strong>stimulator、monitor、checker</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105518697.png" alt="image-20211124105518697"></p><ul><li>uvm_agent, uvm_env, uvm_test：构成整个环境的层次结构</li><li>uvm_driver, uvm_random_stimulus, uvm_sequencer_base, uvm_sequencer：发送激励</li><li>uvm_monitor：监测激励</li><li>uvm_scoreboard, uvm_in_order_comparator, uvm_algorithm_comparator：数据比较</li><li>uvm_reg_predictor：UVM专门的，寄存器包，构建寄存器模型的时候（第五周会谈到）</li></ul><hr><p><strong>组件都有phase机制</strong>，九大phase共同完成环境的构建，并由uvm_root顶层控制（在后台运行，core_servicer）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124110131847.png" alt="image-20211124110131847"></p><h1 id="1-uvm-driver"><a href="#1-uvm-driver" class="headerlink" title="1 uvm_driver"></a>1 uvm_driver</h1><ul><li>学习思路：基于component又添加了什么成员方法</li><li>更具体的学习在第四周，这里简单了解</li></ul><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="大体功能"><a href="#大体功能" class="headerlink" title="大体功能"></a>大体功能</h3><p>uvm_driver与sv_driver类似的都要获取trans，sv的stimulator是从generator获取trans，uvm_driver从sequencer获取</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124142246033.png" alt="image-20211124142246033"></p><h3 id="类声明形式"><a href="#类声明形式" class="headerlink" title="类声明形式"></a>类声明形式</h3><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">uvm_driver</span> <span class="hljs-title">#</span>(<span class="hljs-params">type <span class="hljs-type">REQ</span>=uvm_sequence_item, type <span class="hljs-type">RSP</span>=<span class="hljs-type">REQ</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">uvm_component</span></span>;<br><span class="hljs-comment">//REQ参数：默认情况下为uvm_sequence_item</span><br><span class="hljs-comment">//RSP参数和REQ在默认情况下一样</span><br></code></pre></div></td></tr></table></figure><p>你不能直接使用uvm_driver，所有的dirver你必须自己去定义，然后继承于uvm_driver</p><h3 id="与component比较"><a href="#与component比较" class="headerlink" title="与component比较"></a>与component比较</h3><p>uvm_driver在uvm_component基础上<strong>没有扩展新的函数</strong>，而有一些新的通信端口和变量：</p><figure class="highlight leaf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs leaf">uvm_seq_item_pull_port <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">REQ</span>, <span class="hljs-variable">RSP</span>)</span></span> seq_item_port;//通信端口1<br>uvm_analysis_port <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">RSP</span>)</span></span> rsq_port;//通信端口2<br>REQ req;//变量1<br>RSP rsp;//变量2<br></code></pre></div></td></tr></table></figure><h3 id="端口的连接（第四周）"><a href="#端口的连接（第四周）" class="headerlink" title="端口的连接（第四周）"></a>端口的连接（第四周）</h3><p>driver类与sequencer类之间的通信时未来获取新的事务对象，这一操作时通过pull方式（即端口的连接）实现的</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>两种端口连接的方法<br>driver.seq_item_port.connect(sequencer.seq_item_export);<span class="hljs-regexp">//</span>req,rsp双向都可以（rsp的方式第四周讲）<br>driver.rsp_port.connect(sequencer.rsp_export);<span class="hljs-regexp">//</span>返回rsp<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124151813694.png" alt="image-20211124151813694"></p><h2 id="1-2-示例代码：如何定义一个driver"><a href="#1-2-示例代码：如何定义一个driver" class="headerlink" title="1.2 示例代码：如何定义一个driver"></a>1.2 示例代码：如何定义一个driver</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124151949354.png" alt="image-20211124151949354"></p><p><strong>经典步骤</strong>：</p><ol><li>extends</li><li>注册</li><li>new函数</li></ol><p><strong>虚接口</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">virtual</span> chip_if vif;<span class="hljs-comment">//接口指针，用来把激励发送到接口上</span><br></code></pre></div></td></tr></table></figure><p><strong>phase</strong></p><p>我们不一定全部写九大phase，只有在哦们真正要用的时候定义</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">extern task run<span class="hljs-constructor">_phase(<span class="hljs-params">uvm_phase</span> <span class="hljs-params">phase</span>)</span>;<span class="hljs-comment">//参考c++，在外部通过dut_driver::run_phase定义</span><br></code></pre></div></td></tr></table></figure><p>extern补充：.sv和.svh</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124153841240.png" alt="image-20211124153841240"></p><h1 id="2-uvm-monitor"><a href="#2-uvm-monitor" class="headerlink" title="2 uvm_monitor"></a>2 uvm_monitor</h1><h2 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124153914184.png" alt="image-20211124153914184"></p><p>我们定义的monitor完全继承于uvm_monitor，但也要老老实实的继承uvm_monitor</p><p><strong>PASSIVE模式：</strong>我不做任何主动修改内部设计的信号，不和激励一样。即要求我们的monitor永远只做监测</p><h2 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124154308328.png" alt="image-20211124154308328"></p><p><strong>虚接口</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">virtual</span> serial_if.monitor mi;<span class="hljs-comment">//使用vi中的一个modport</span><br></code></pre></div></td></tr></table></figure><h3 id="run-phase"><a href="#run-phase" class="headerlink" title="run_phase"></a>run_phase</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124154538786.png" alt="image-20211124154538786"></p><p><strong>执行步骤</strong></p><ul><li><p>我们要监测一个tr</p></li><li><p>首先我们要等待interface上一个信号<code>wait(mi.rts);</code></p></li><li><p>又等待一个下降沿</p></li><li>再等待一个时刻</li><li>接下来按照特定时刻<code>#(bit_period)</code>对数据进行监测</li><li>for之后检查协议</li><li>最后put</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124155629037.png" alt="image-20211124155629037"></p><h1 id="3-uvm-sequencer"><a href="#3-uvm-sequencer" class="headerlink" title="3 uvm_sequencer"></a>3 uvm_sequencer</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>my_sequencer所有组件功能都在父类uvm_sequencer，定义起来最简单</strong></p><p>sequencer就像一个管道一样，本身不产生激励，激励从sequence来的，然后激励传递给了driver</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124155807937.png" alt="image-20211124155807937"></p><hr><p>为什么不讲uvm_sequencer_base, uvm_sequencer_param_base<REQ,RSP> ,uvm_report_object类：</p><ul><li>因为它们都是中间类，中间类添加了单一职责，但它们在uvm继承上不是终点，不是直接面向用户的</li><li>如uvm_report_object在uvm_object基础上添加了report机制，而component又在uvm_report_object基础上添加了phase机制和override机制</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124160942941.png" alt="image-20211124160942941"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161005246.png" alt="image-20211124161005246"></p><p>第四周讲，sequencer没有那么简单，有路由器的作用</p><p>路由器：我们有很多很多sequence1…n，都传送到sequencer，再交给drv；因此需要sequencer有arbiter仲裁作用；同时接收信号传送回哪个sequence</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161226221.png" alt="image-20211124161226221"></p><hr><p>为什么sequence是obj，sequencer是component：</p><ul><li>sequence是动态产生的用完可以丢掉</li></ul><h2 id="3-2-示例代码：sequencer是我们所有组件定义起来最最简单的"><a href="#3-2-示例代码：sequencer是我们所有组件定义起来最最简单的" class="headerlink" title="3.2 示例代码：sequencer是我们所有组件定义起来最最简单的"></a>3.2 示例代码：sequencer是我们所有组件定义起来最最简单的</h2><p>my_sequencer所有组件功能都在父类uvm_sequencer</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161529897.png" alt="image-20211124161529897"></p><h2 id="4-uvm-agent（重要参考）"><a href="#4-uvm-agent（重要参考）" class="headerlink" title="4 uvm_agent（重要参考）"></a>4 uvm_agent（重要参考）</h2><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>简介与功能：agent就是一个标准的验证环境<strong>基本单位</strong>，包括了monitor，driver和sequencer</p><p>额外成员：见5.2</p><p>内部：具体实现了三个组建的例化(build)与连接(connect)</p><p>同时为了复用有时候只包括monitor不需要例化driver与sequencer</p><ul><li>uvm_active_passive_enum is_active为agent内一个成员<ul><li>is_active = UVM_ACTIVE时，uvm为ACTIVE态 agent需要发送激励</li><li>is_active = UVM_PASSIVE时，uvm为PASSIVE态 agent只做监测</li><li>is_active由谁控制<ul><li>由更高一层的环境控制，通过config_db来做</li></ul></li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161740460.png" alt="image-20211124161740460"></p><h3 id="4-1-2-master与slave的概念"><a href="#4-1-2-master与slave的概念" class="headerlink" title="4.1.2 master与slave的概念"></a>4.1.2 master与slave的概念</h3><ul><li><p>master agent：</p><ul><li><p>register agent</p></li><li><p>channel agent</p></li></ul></li><li><p>slave agent：</p><ul><li>formatter agent，被动的做相应，被动发起grand信号，</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124164434848.png" alt="image-20211124164434848"></p><h2 id="4-2-示例代码"><a href="#4-2-示例代码" class="headerlink" title="4.2 示例代码"></a>4.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124164836919.png" alt="image-20211124164836919"></p><p><strong>成员</strong></p><ul><li>sequencer</li><li>driver</li><li>monitor</li><li>vif</li><li>is_active</li></ul><p><strong>phase</strong></p><ul><li>build</li><li>connect</li></ul><h3 id="4-2-2-phase"><a href="#4-2-2-phase" class="headerlink" title="4.2.2 phase"></a>4.2.2 phase</h3><p><strong>build_phase</strong></p><ul><li>创建组件/其他实例</li><li>根据is_active判断是否例化seqr与driver<ul><li>此处省略了一个从顶层(is_active)::get()的方法</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165025458.png" alt="image-20211124165025458"></p><p><strong>connect_phase</strong></p><ul><li>driver和sequencer之间做连接</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165048530.png" alt="image-20211124165048530"></p><h1 id="5-uvm-scoreboard"><a href="#5-uvm-scoreboard" class="headerlink" title="5 uvm_scoreboard"></a>5 uvm_scoreboard</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>功能：进行数据比较和报告，与SV checker类似；会接受来自多个monitor的监测数据，继而进行对比和报告</p><ul><li>scoreboard内部是否需要例化一些reference model?<ul><li>取决于实际情况，如果DUT复杂则需要自己写reference model且继承于uvm_component从而参与到组件构建过程中</li></ul></li></ul><p>额外成员：没有添加额外的成员变量和方法，与monitor类似，直接自定义一个类继承就行，特殊情况需要例化一些reference model</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165551344.png" alt="image-20211124165551344"></p><h3 id="5-1-2-自带的数据比较方法"><a href="#5-1-2-自带的数据比较方法" class="headerlink" title="5.1.2 自带的数据比较方法"></a>5.1.2 自带的数据比较方法</h3><p>SV中推荐自己实现数据比较方法，uvm自带两个数据比较方法但了解即可实际工程中很少去用，因为他们的工作非常有限大部分需要自己实现</p><figure class="highlight leaf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs leaf">uvm_in_order_comparator <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">type</span> <span class="hljs-variable">T</span>)</span></span>//一个组件，往往放在sb<br>uvm_algorithm_comparator <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">type</span> <span class="hljs-variable">BEFORE</span>, <span class="hljs-variable">type</span> <span class="hljs-variable">AFTER</span>, <span class="hljs-variable">type</span> <span class="hljs-variable">TRANSFORMER</span>)</span></span><br></code></pre></div></td></tr></table></figure><ul><li>uvm_in_order_comparator（数据类型，完整性，顺序一样的时候比较）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172218854.png" alt="image-20211124172218854"></p><p>输入输出数据自动作比较</p><p>不推荐的原因是：你往往在数据比较的时候还有其他的逻辑</p><ul><li>uvm_algorithm_comparator（不同类型比较）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172351965.png" alt="image-20211124172351965"></p><p>before，after两种类型</p><p>TRANSFORMER为bef转换成after的转换类</p><p>不适合MDCF比较</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124171724994.png" alt="image-20211124171724994"></p><h2 id="5-2-示例代码：如何定义一个sb-typedef在create时的作用-重要"><a href="#5-2-示例代码：如何定义一个sb-typedef在create时的作用-重要" class="headerlink" title="5.2 示例代码：如何定义一个sb|typedef在create时的作用(重要)"></a>5.2 示例代码：如何定义一个sb|typedef在create时的作用(重要)</h2><ul><li>在sb中通常会声明TLM端口供monitor传输数据（下周讲端口连接），这些端口(in_export,out_export)最终和monitor相连</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172717681.png" alt="image-20211124172717681"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172727238.png" alt="image-20211124172727238"></p><p><strong>创建一个comparator</strong></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//写法1:使用typedef后的类型进行create</span><br>tyepdef uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)</span> comp_t;<br>comp_t m_comp;<br>...<br><span class="hljs-keyword">function</span> build_phase();<br>...<br>    m_comp = comp_t::type_id::create(<span class="hljs-string">&quot;m_comp&quot;</span>,<span class="hljs-keyword">this</span>);<br>    ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//写法2:带参数的声明，与带参数的create</span><br>uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)</span> m_comp;<br>...<br><span class="hljs-keyword">function</span> build_phase();<br>...<br>    m_comp = uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)::type_id::create(&quot;m_comp&quot;,this)</span>;<br>    ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure><p><strong>端口接入comparator</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124173759946.png" alt="image-20211124173759946"></p><h1 id="6-uvm-env"><a href="#6-uvm-env" class="headerlink" title="6 uvm_env"></a>6 uvm_env</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>uvm_env<strong>一种结构化的容器</strong></p><p>简介：与SVenv没有区别，就是做一个层次，从环境层次层次，uvm_env可能包含多个uvm_agent或其他component</p><p>不同的组件<strong>共同</strong>构成一个完整的验证环境，并且这个黄健在将来服用中可以作为子环境被进一步集成到更高的环境中。如下图的验证结构中，就定义了一个高层的环境，它里包含sub_env、agent、scoreboard</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124173845213.png" alt="一种验证结构"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124185258724.png" alt="sub_env可以作为复用"></p><p>解释：</p><ul><li>sub_env原来验证M1模块，现在M1被集成到M2大的模块中。此时sub_env可以通过被封装在top_env继续对M1进行验证，同时接口也对应相连；对M2的其他部分，它们再与top_env中新添加的agent相连</li><li>对于sb：top_env的scoreboard是M2的，而M1对应的sb在原来的sub_env里面</li><li>对于顶层：只能由一个env</li></ul><h3 id="6-1-2-uvm-env的角色，以及与agent对比"><a href="#6-1-2-uvm-env的角色，以及与agent对比" class="headerlink" title="6.1.2 uvm_env的角色，以及与agent对比"></a>6.1.2 uvm_env的角色，以及与agent对比</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124190748961.png" alt="image-20211124190748961"></p><p>env可以嵌套而，agent一定不要去嵌套agent</p><h2 id="6-2-示例代码"><a href="#6-2-示例代码" class="headerlink" title="6.2 示例代码"></a>6.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124191859795-16377527411321.png" alt="image-20211124191859795"></p><h1 id="7-uvm-test"><a href="#7-uvm-test" class="headerlink" title="7 uvm_test"></a>7 uvm_test</h1><h2 id="7-1-概论"><a href="#7-1-概论" class="headerlink" title="7.1 概论"></a>7.1 概论</h2><p>与SV test几乎没有差别</p><p>sv中test：sv测试以test为单位进行。test规定了测试场景，即规定了发送什么样的激励</p><p>uvm的test：也规定了发送什么样的激励，只不过激励是sequence产生的</p><p>uvm的结构：例化唯一的env顶层，并决定结构和连接关系</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124192241725.png" alt="image-20211124192241725"></p><h2 id="7-2-示例代码"><a href="#7-2-示例代码" class="headerlink" title="7.2 示例代码"></a>7.2 示例代码</h2><p>这里两个env只是做演示，工程里面应该把env1,env2与a1封装到一个top_env中</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124193620637.png" alt="image-20211124193620637"></p><p>之后就是sv实验5的组件过度到uvm实验2，两个实验验证结构一致</p><p>验证结构到uvm实验3才会进行变化</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶4：结构_顶层方案_环境元素</title>
    <link href="/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B64%EF%BC%9A%E7%BB%93%E6%9E%84_%E9%A1%B6%E5%B1%82%E6%96%B9%E6%A1%88_%E7%8E%AF%E5%A2%83%E5%85%83%E7%B4%A0/"/>
    <url>/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B64%EF%BC%9A%E7%BB%93%E6%9E%84_%E9%A1%B6%E5%B1%82%E6%96%B9%E6%A1%88_%E7%8E%AF%E5%A2%83%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li><p>UVM结构回顾</p></li><li><p>MCDF顶层验证方案</p></li><li><p>构建验证环境的内径</p></li></ul><h1 id="1-UVM结构回顾"><a href="#1-UVM结构回顾" class="headerlink" title="1 UVM结构回顾"></a>1 UVM结构回顾</h1><h2 id="1-1-uvm-top：（系统）"><a href="#1-1-uvm-top：（系统）" class="headerlink" title="1.1 uvm_top：（系统）"></a>1.1 uvm_top：（系统）</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">const</span> uvm_root uvm_top = uvm_root::get()<br></code></pre></div></td></tr></table></figure><p>uvm_top(uvm_root)，一个隐形的顶层，并不继承于object/component（因为要创建这些）</p><ul><li>uvm_top 是uvm_root类的<strong>唯一</strong>实例，即是UVM为界的“一” <ul><li>它由UVM创建和管理</li><li>它所在的域是uvm_pkg</li></ul></li><li>uvm_top是<strong>所有test组件的顶层</strong>，即永远是我们环境的最顶层<ul><li>所有验证环境中的组件在创建时都需要指明它的父一级</li><li>如果某些组件在创建时指定父一级的参数为“null”，那么它将直接隶属于uvm_top。不过这么做存在风险，也并不推荐</li></ul></li><li><strong>（主要作用）</strong>uvm_top提供一系列的方法来<strong>控制仿真</strong>，例如：九个phase机制、objection防止仿真退出机制（在run_phase中设置举手（尽量有且只有一个，防止退出避免额外协调，详情查看进阶2）等</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126150832349.png" alt="金字塔结构"></p><h2 id="1-2-uvm-test：-自定义"><a href="#1-2-uvm-test：-自定义" class="headerlink" title="1.2 uvm_test：(自定义)"></a>1.2 uvm_test：(自定义)</h2><ul><li><p>“test”类是用户<strong>自定义类</strong>的顶层结构</p></li><li><p><strong>所有的test类都应该继承于uvm_tes3</strong>，否则uvm_top将不识别，“后果很严重”一一无法启动test</p></li><li><strong>（主要作用）</strong>test的<strong>目标</strong>包括：<ul><li>提供不同的<strong>配置</strong>，包括环境结构配置、测试模式配置等，然后再创建验证环境</li><li>例化测试<strong>序列</strong>，并且挂载(attach)到目标sequencer,使其命令driver发送激励</li><li>补充：所有变量都要放在test里面，方便管理与维护</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126152704144.png" alt="image-20211126152704144"></p><p>为什么不放到env里面：test可以划分出静态与动态部分</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126153104909.png" alt="image-20211126153104909"></p><h2 id="1-3-构建验证环境的主要组件对比"><a href="#1-3-构建验证环境的主要组件对比" class="headerlink" title="1.3 构建验证环境的主要组件对比"></a>1.3 构建验证环境的主要组件对比</h2><p>主要由三类UVM构建模块（基类）共同组成验证环境</p><ul><li>uvm_component<ul><li>继承于uvm_report_object （进一步继承于uvm_object）,提供消息方法</li><li>所有的验证环境组件均继承于uvm_component</li><li>管理验证环境的层次</li></ul></li><li>uvm_env<ul><li>继承于 uvm_component</li><li><strong>没有额外的功能</strong>：如果拿到别人环境看到env，尽量少去动env而是去动test</li><li>用来为验证环境结构提供一个容器（container）</li></ul></li><li>uvm_test<ul><li>继承于 uvm_component</li><li><strong>没有额外的功能</strong></li><li>用来提供对uvm_env的<strong>额外配置以及挂载激励</strong></li></ul></li></ul><h2 id="1-4-uvm-component：是一个虚类不能例化，可以继承"><a href="#1-4-uvm-component：是一个虚类不能例化，可以继承" class="headerlink" title="1.4 uvm_component：是一个虚类不能例化，可以继承"></a>1.4 uvm_component：是一个虚类不能例化，可以继承</h2><h3 id="1-4-1-介绍"><a href="#1-4-1-介绍" class="headerlink" title="1.4.1 介绍"></a>1.4.1 介绍</h3><p>一个虚类(virtual class),所有环境组件均继承于该类。所有继承于该类的子类，我们称之为组件或者环境组件</p><p>该类提供已下接口或者API：</p><ul><li>结构， 例如get_full_name(), get_parent(), get_num_children()</li><li>阶段(phase)机制，例如build_phase(), connect_phase(), run_phase()</li><li>配置(configuration)机制，例如print_config(), print_override_info()</li><li>报告(report)机制，例如report_hook(), set_report_verbosity_level_hier ()</li><li>事务记录(transaction recording),例如record，用的比较少模块三会讲</li><li>工厂(factory)机制,例如set_inst_override(), set_type_override()</li></ul><p>由于环境中所有的组件都继承于uvm_component，因此也就可以使得UVM提供统一的方式来管理层次结构和组件方法</p><h3 id="1-4-2-构造函数：有关层次的说明"><a href="#1-4-2-构造函数：有关层次的说明" class="headerlink" title="1.4.2 构造函数：有关层次的说明"></a>1.4.2 构造函数：有关层次的说明</h3><p>对于组件的构建函数，固定形式为：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br></code></pre></div></td></tr></table></figure><ul><li>string name：用来声明当前例化组件的名称，用来自动和它所在的父一级层次组合为组件的整个层次名称，可以 <strong>get_full_name()</strong>方法获取</li><li>uvm_component parent：用来指示所例化的父一级句柄，通常用“this”来指代，即例化在当前的父一级组件中</li><li>注意与uvm_object的构建函数new(string name)进行区分，由于uvm_object<strong>不参与组件的层次构建</strong>，因此它只有一个形参， 而没有 uvm_component parent</li><li>凡是继承于uvm_component的组件，也应该保持同样的形式参 数列表</li></ul><h1 id="2-MCDF顶层验证方案"><a href="#2-MCDF顶层验证方案" class="headerlink" title="2 MCDF顶层验证方案"></a>2 MCDF顶层验证方案</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1  概述"></a>2.1  概述</h2><p>在SV模块中，四位verifier需要给MCDF (Multiple Channel Data Formatter)搭建验证环境，进而利用这些模块验证组件在顶层可以完成集成复用</p><p>MCDF的主要功能是将输入端的三个通道数据，通过数据整形和过滤，最终输出</p><p>将MCD结构分为四个模块：</p><ul><li>上行数据的通道从端(Channel Slave)</li><li>仲裁器(Arbiter)</li><li>整形器(Formatter)</li><li>控制寄存器(Control Registers)</li></ul><h2 id="2-2-子模块环境搭建方案"><a href="#2-2-子模块环境搭建方案" class="headerlink" title="2.2 子模块环境搭建方案"></a>2.2 子模块环境搭建方案</h2><h3 id="2-2-1-reg-env：对于寄存器的验证环境"><a href="#2-2-1-reg-env：对于寄存器的验证环境" class="headerlink" title="2.2.1 reg_env：对于寄存器的验证环境"></a>2.2.1 reg_env：对于寄存器的验证环境</h3><p>对于寄存器模块的验证环境reg_env,它的组织包括：</p><ul><li>reg_master_agent,提供寄存器接口驱动信号</li><li>reg_slave_agent,提供寄存器接口反馈信号</li><li>scoreboard,分另从reg_master_agent内的monitor和reg_slave_agent内 的monitor获取监测数据，并且进行数据比对</li></ul><hr><ul><li>reg_master_agent：对reg配置包括addr，data_w/r，cmd</li><li>reg_slave_agent：<ul><li>驱动channel_fifo_avaible</li><li>其他信号做监测</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126155046191.png" alt="image-20211126155046191"></p><h3 id="2-2-2-chnl-env：对channel"><a href="#2-2-2-chnl-env：对channel" class="headerlink" title="2.2.2 chnl_env：对channel"></a>2.2.2 chnl_env：对channel</h3><p>下图是验证一个channel</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126221535193.png" alt="image-20211126221535193"></p><p>数据通道从端的验证环境chnLenv的组件包括：</p><ul><li>chnl_master_agent,提供上行的激励数据</li><li>chnLslave.agent,提供用来模拟arbiter仲裁信号，并且接收流出数<br>据</li><li>reg_cfg_agent,提供用来模拟寄存器的配置信号，并且接收内置<br>FIFO的余量信号</li><li>scoreboard,分另ll从chnl_master_agent、chnl_slave_agent和reg_cfg_agent的monitor接受监测激据，并且对channel的流入流出 数据进行比对</li></ul><h3 id="2-3-arb-env"><a href="#2-3-arb-env" class="headerlink" title="2.3 arb_env"></a>2.3 arb_env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126222105799.png" alt="image-20211126222105799"></p><p>仲裁器的验证环境arb_env的组件包括：</p><ul><li>模拟channel输出接口的arbiter_master_agent的三个实例，用来对 arbiter提供并行数据输入，同时对arbiter反馈的仲裁信号做出响应</li><li>arbiter_slave_agent,用来接收arbiter的输出数据，模拟formatter 的行为，对arbiter的输出信号做出响应</li><li>reg_cfg_agent,提供用来模拟寄存器的配置信号，对三个channel 数据源分别做出不同的优先级配置</li><li>scoreboard,从三个arbiter_master_agent、arbiter_slave_agent 和reg_cfg_agent中的monitor获取监测数据，对arbiter的仲裁机制 做出预测，并且将输入输出数据按照预测的优先级做出比对</li></ul><h3 id="2-2-4-fmt-env"><a href="#2-2-4-fmt-env" class="headerlink" title="2.2.4 fmt_env"></a>2.2.4 fmt_env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126222804346.png" alt="image-20211126222804346"></p><p>整形器的验证环境 fmt env 的组件包括：</p><ul><li>fmt_master_agent， 用来模拟arbiter的输出数据</li><li>fmt_slave_agent ，用来模拟MCDF的下行数据接收端</li><li>reg _cfg _agent ，用来模拟寄存器的配置信号，用来指定输出数据包的长</li><li>scoreboard ，从 fmt <em>master _agent 、 fmt_slave_agent 和 reg_cfg </em> agent 的 monitor 获取数据监测数据，通过数据包长度来预测输出的数据包，与formatter输出的数据包进行比对</li></ul><h2 id="2-3-环境集成方案"><a href="#2-3-环境集成方案" class="headerlink" title="2.3 环境集成方案"></a>2.3 环境集成方案</h2><p>两个方案没有谁好谁坏</p><h3 id="2-3-1-方案1"><a href="#2-3-1-方案1" class="headerlink" title="2.3.1 方案1"></a>2.3.1 方案1</h3><p>基本就是我们SV的环境，除了vitrual sequencer我们后期学</p><p>MCDF顶层验证环境复用了这些模块验证环境的组件：</p><ul><li>reg_master_agent</li><li>chnl_master_agent</li><li>fmt_slave_agent</li></ul><p>通过这三个激励组件可以有效生成新的激励序列，而将各个agent的 sequencer句柄合并在一处时，virtual sequencer的作用就体现出来了</p><p>我们可以通过这个中心化的序列分发管道，将各个agent的sequence也集中管理</p><p>MCDF的scoreboard提供了一个完整的数据通路覆盖方案，即从各个 agent的monitor数据监测端口将数据收集起来，同时建立MCDF的参 考模型，预测输出数据包，最终进行数据比对</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126223512492.png" alt="image-20211126223512492"></p><h4 id="集成代码"><a href="#集成代码" class="headerlink" title="集成代码"></a>集成代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126223528514.png" alt="image-20211126223528514"></p><p> <img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095406294.png" alt="image-20211127095406294"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095443041.png" alt="image-20211127095443041"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095837297.png" alt="image-20211127095837297"></p><p>sqr作用就是传递trans</p><p>virtual_sequencer拿着各个agent_sequencer句柄，相当于句柄的路由，进行中间的管理作用</p><h3 id="2-3-2-方案2"><a href="#2-3-2-方案2" class="headerlink" title="2.3.2 方案2"></a>2.3.2 方案2</h3><p>较为复杂一点，组件更多，多了cfg</p><ul><li><p>可以把例如：agent.slave配置成passive，agent.master配置成active</p></li><li><p>好处：</p><ul><li>子系统出问题agent.sb仍然可以工作</li><li>独立性好，别人的拿过来直接可以用，做之前进行cfg就可以</li><li>（可选）方案二大多数情况下还是需要一个顶层的sb检查，针对性检查（use case）</li></ul></li></ul><p>为什么arbiter也要放进来，因为可以单独检查arbiter</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127100007270.png" alt="image-20211127100007270"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127102738381.png" alt="image-20211127102738381"></p><h4 id="集成代码-1"><a href="#集成代码-1" class="headerlink" title="集成代码"></a>集成代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103114903.png" alt="image-20211127103114903"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103319241.png" alt="image-20211127103319241"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103357056.png" alt="image-20211127103357056"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103456895.png" alt="image-20211127103456895"></p><h3 id="2-3-3-方案对比"><a href="#2-3-3-方案对比" class="headerlink" title="2.3.3 方案对比"></a>2.3.3 方案对比</h3><p>方案一与方案二相同的地方在于，顶层都需要新建 virtual sequencer 和 virtual sequence ，用来生成顶层的测试序列</p><p>而 virtual sequence也不是从零创建的，它本身也是利用原有模块环了有机的组合，最后协调生成了新的测试序列</p><p>从方案二可以看出， mcdf<em>env的子组件不再是uvm </em> agent类，而是各个模块的验证环境 uvm _ env 类</p><p>通过直接复用这些子环境，我们也间接复用了它们内部的 score board。在 build 阶段，我们需要将各个子环境中不需要再产生激励的 agent , 配置为 passive 模式，而默认情况 下这些 agent 均为 active 模式</p><p>这种复用方式使得我们无需再新建一个 MCDF scoreboard ，只需要确保 MCDF 的各个子模块均有 scoreboard 会检查功能，这样从整体上便可以覆盖完整的数据通路</p><hr><p>方案一中最大的额外投入在于需要新建一个scoreboard用来检查MCDF的整体功能</p><p>如果顶层设计没那么复杂，重新实现一个顶层scoreboard其复杂度还是可控的；但是如果将来的顶层环境更加复杂，那么复用底层的scoreboard就变得省时省力了</p><p>方案二的目的在于复用底层模块环境的scoreboard,减少顶层环境的额外成本。方案二不同于方案一的有下列几个地方：</p><ul><li>顶层环境的组件都直接复用了各个模块验证环境</li><li>顶层环境在集成模块验证环境时，需要将各个子模块中的agent配置为不同模式（ active或者passive） ,以此适应顶层场景</li><li>不再需要实现新的scoreboard,而是可以复用原有模块验证环境的scoreboard</li></ul><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>从上面框图和代码中观察到，UVM带来的环境复用，相比于之前SV验 证环境做到了下面的几个优势：</p><ul><li>各个模块的验证环境是独立封装的，对外不需要保留数据端口，因此便于环境 的进一步集成复用</li><li>UVM自身的phase机制，在顶层协调各个子环境时，无需考虑由于子环境 之间的例化顺序而导致的对象句柄引用悬空的问题</li><li>由于子环境的测试序列是相对独立的，这使得顶层在复用子环境测试序列而构 成virtual sequence时，不需要其它额外的迁移成本</li><li>UVM提供的config_db配置方式，使得整体环境的结构和运行模式都可以从树 状的config对象中获取，这也使得顶层环境可以在不同uvm_test进行集中管理配置</li></ul><hr><p>相比SV </p><p>数据接口：</p><ul><li><p>以前是用mailbox句柄</p></li><li><p>现在使用端口</p></li><li>为什么？<ul><li>使用mailbox会有跨层次问题</li></ul></li></ul><p>phase机制</p><p>子环境而是相对独立，具有sequence</p><p>config_db配置，使得结构和运行模式从树状config对象获取，对顶层环境再不同uvm_test进行集中管理</p><h1 id="3-构建验证环境的内径"><a href="#3-构建验证环境的内径" class="headerlink" title="3 构建验证环境的内径"></a>3 构建验证环境的内径</h1><h2 id="3-1-构建环境四要素"><a href="#3-1-构建环境四要素" class="headerlink" title="3.1 构建环境四要素"></a>3.1 构建环境四要素</h2><p>发送测试序列之前，首先需要创建一个结构化环境。将环境核心要素拆解开，分为四部分：</p><ul><li><p>单元组件的自闭性：完全的封装，不依赖其他组件，可以单独编译<strong>（非常重要）</strong></p></li><li><p>回归创建：type_id::create</p></li><li>通信都那口连接</li><li>顶层配置</li></ul><p>ps：在构建环境时，可从这四点查找是否缺少了某个组件</p><h2 id="3-2-四要素详细介绍"><a href="#3-2-四要素详细介绍" class="headerlink" title="3.2 四要素详细介绍"></a>3.2 四要素详细介绍</h2><h3 id="3-2-1-单元组件的自闭性"><a href="#3-2-1-单元组件的自闭性" class="headerlink" title="3.2.1 单元组件的自闭性"></a>3.2.1 单元组件的自闭性</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127110438497.png" alt="image-20211127110438497"></p><p>即以后你提供的env一定要独立</p><h3 id="3-2-2-回归创建"><a href="#3-2-2-回归创建" class="headerlink" title="3.2.2 回归创建"></a>3.2.2 回归创建</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127155259291.png" alt="image-20211127155259291"></p><p>SV：上一级的组件例化子一级的组件通过执行new()</p><p>UVM：通过build_phase</p><ul><li>保证了父级组件先于子级组件</li></ul><p>补充两种配置方式：</p><ul><li>config：build拿到后固化，即config只config一次</li><li>transaction：动态配置</li></ul><h3 id="3-2-3-通信端口连接"><a href="#3-2-3-通信端口连接" class="headerlink" title="3.2.3 通信端口连接"></a>3.2.3 通信端口连接</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127155944971.png" alt="image-20211127155944971"></p><h3 id="3-2-4-顶层配置（配置层次可参考本节叙述）"><a href="#3-2-4-顶层配置（配置层次可参考本节叙述）" class="headerlink" title="3.2.4 顶层配置（配置层次可参考本节叙述）"></a>3.2.4 顶层配置（配置层次可参考本节叙述）</h3><p><strong>顶层环境的变量部分</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160004104.png" alt="image-20211127160004104"></p><p>使用config_db字符串而不是直接用句柄</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160400298.png" alt="image-20211127160400298"></p><h4 id="如下放置到config-db数据库里面"><a href="#如下放置到config-db数据库里面" class="headerlink" title="如下放置到config_db数据库里面"></a>如下放置到config_db数据库里面</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160526167.png" alt="image-20211127160526167"></p><h4 id="子一级组件创建时拿出来"><a href="#子一级组件创建时拿出来" class="headerlink" title="子一级组件创建时拿出来"></a>子一级组件创建时拿出来</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160558859.png" alt="image-20211127160558859"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160728972.png" alt="image-20211127160728972"></p><h2 id="3-3-顶层配置结构"><a href="#3-3-顶层配置结构" class="headerlink" title="3.3 顶层配置结构"></a>3.3 顶层配置结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160831321.png" alt="image-20211127160831321"></p><ul><li>rgm：寄存器模型</li><li>scbd</li><li>topcfg：传递rgm句柄，is_active，变量值等配置信息</li></ul><h2 id="3-4-环境元素分类"><a href="#3-4-环境元素分类" class="headerlink" title="3.4 环境元素分类"></a>3.4 环境元素分类</h2><p>uvm_test作为比uvm_env更高层次，将对test传递配置信息，包括构成环境的组件uvm_component在内环境元素可以分为以下部分：</p><ul><li>成员变量<ul><li>一般变量</li><li>结构变量</li><li>模式变量</li></ul></li><li>子组件<ul><li>固定组件</li><li>条件组件</li><li>引用组件</li></ul></li><li>子对象<ul><li>自生对象</li><li>克隆对象</li><li>引用对象</li></ul></li></ul><h2 id="3-5-环境元素详细介绍"><a href="#3-5-环境元素详细介绍" class="headerlink" title="3.5 环境元素详细介绍"></a>3.5 环境元素详细介绍</h2><h3 id="3-5-1-成员变量"><a href="#3-5-1-成员变量" class="headerlink" title="3.5.1 成员变量"></a>3.5.1 成员变量</h3><ul><li>一般变量：内部操作与外部访问</li><li>结构变量：内部子组件</li><li>模式变量：控制组件行为</li></ul><p>对u结构变量和模式变量使用int/enum进行定义</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163150402.png" alt="image-20211127163150402"></p><h3 id="3-5-2-子组件"><a href="#3-5-2-子组件" class="headerlink" title="3.5.2 子组件"></a>3.5.2 子组件</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163308958.png" alt="image-20211127163308958"></p><p>引用组件就是个句柄，有结构变量决定的组件叫结构组件</p><p>下图展示了谁是固定组件谁是引用组件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163340189.png" alt="image-20211127163340189"></p><h3 id="3-5-3-子对象"><a href="#3-5-3-子对象" class="headerlink" title="3.5.3 子对象"></a>3.5.3 子对象</h3><p>查看<strong>例如</strong>部分</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163509745.png" alt="image-20211127163509745"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门实验0</title>
    <link href="/202111212135/IC/uvm%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%AE%9E%E9%AA%8C0/"/>
    <url>/202111212135/IC/uvm%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%AE%9E%E9%AA%8C0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶2：核心基类_阶段_配置_消息机制</title>
    <link href="/202111181835/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B62%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%B1%BB_%E9%98%B6%E6%AE%B5_%E9%85%8D%E7%BD%AE_%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/202111181835/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B62%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%B1%BB_%E9%98%B6%E6%AE%B5_%E9%85%8D%E7%BD%AE_%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><h1 id="1-核心基类-uvm-object"><a href="#1-核心基类-uvm-object" class="headerlink" title="1 核心基类(uvm_object)"></a>1 核心基类(uvm_object)</h1><h2 id="1-1-核心基类指的就是uvm-object"><a href="#1-1-核心基类指的就是uvm-object" class="headerlink" title="1.1 核心基类指的就是uvm_object"></a>1.1 <strong>核心基类指的就是uvm_object</strong></h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119165852944.png" alt="image-20211119165852944"></p><ul><li><code>uvm_void</code>只是一个虚类(virtual class)，等待将来继承于他的子类去开垦</li><li>有两类<code>uvm_object</code>、<code>uvm_port_base</code>类继承于<code>uvm_void</code></li><li>uvm世界里面十大类八大类继承于<code>uvm_object</code></li><li><code>除了</code>uvm_port_base<IF>``类以外uvm里面的类都可以溯源到uvm_object类</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119170014086.png" alt="image-20211119170014086"></p><h2 id="1-2-uvm-object"><a href="#1-2-uvm-object" class="headerlink" title="1.2 uvm_object"></a>1.2 uvm_object</h2><p><strong>uvm_object核心方法</strong>：不用自己实现，uvm自动去实现</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">copy<span class="hljs-comment">;</span><br>clone<span class="hljs-comment">;</span><br>compare<span class="hljs-comment">;</span><br>print<br>pack/unpack<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119175234308.png" alt="image-20211119175234308"></p><p>uvm里面把sv的句柄拷贝和对象拷贝区分成了copy与clone，且同样需要src，dst object</p><h2 id="1-3-主要机制：域的自动化-field-automation"><a href="#1-3-主要机制：域的自动化-field-automation" class="headerlink" title="1.3 主要机制：域的自动化(field automation)"></a>1.3 主要机制：域的自动化(field automation)</h2><p><strong>域：</strong>UVM里任何的成员变量都可以称之为域(field)，在sv里面称之为属性property</p><p><strong>域的自动化：</strong>使得在注册时，声明之后可能会用到的对象拷贝、克隆、打印等操作的成员变量</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119175354669.png" alt="image-20211119175354669"></p><h3 id="1-3-2-代码"><a href="#1-3-2-代码" class="headerlink" title="1.3.2 代码"></a>1.3.2 代码</h3><p><strong>代码原文</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119200932044.png" alt="image-20211119200932044"></p><p><strong>上文代码解释</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201123177.png" alt="image-20211119201123177"></p><p>第一点：开始域自动化声明和结束声明</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl">`<span class="hljs-function"><span class="hljs-title">uvm_object_utils_begin</span>(<span class="hljs-variable">box</span>)</span><br>`<span class="hljs-function"><span class="hljs-title">uvm_object_utils_end</span>(<span class="hljs-variable">box</span>)</span><br></code></pre></div></td></tr></table></figure><hr><p>第二点：域的自动化声明方式：如下添加参与到自动化声明的变量（也是使用宏，<strong>提醒一下，宏是不用分号的</strong>）</p><p>宏函数参考表：P275页 表10.2</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_field_int(<span class="hljs-params">volume</span>, UVM_ALL_ON)</span><br>`uvm<span class="hljs-constructor">_field_enum(<span class="hljs-params">color_t</span>, <span class="hljs-params">color</span>, UVM_ALL_ON)</span><br>`uvm<span class="hljs-constructor">_field_string(<span class="hljs-params">name</span>, UVM_ALL_ON)</span><br></code></pre></div></td></tr></table></figure><hr><p>补充点：域自动化数据操作宏参数<code>UVM_ALL_ON</code>：是与之前数据变量对应的，数据操作的一个宏</p><p>数据操作宏参考表P276页 表10.3</p><p>对于小白来讲默认采取<code>UVM_ALL_ON</code>或<code>UVM_ALL_DEFAULT</code>就可以将所有数据操作(copy,compare,print,record,pack)都打开</p><h3 id="1-3-3-代码续"><a href="#1-3-3-代码续" class="headerlink" title="1.3.3 代码续"></a>1.3.3 代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201732071.png" alt="image-20211119201732071"></p><hr><p><strong>调用未定义的copy函数</strong></p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">b2.copy(b1)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201852449.png" alt="image-20211119201852449"></p><p>b1的成员变量都拷贝到b2</p><p>SV的copy是自己实现的，uvm不需要</p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3 总结"></a>1.3.3 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119202328296.png" alt="image-20211119202328296"></p><h2 id="1-4-核心方法之一：拷贝-copy-默认deepcopy-copy-do-copy"><a href="#1-4-核心方法之一：拷贝-copy-默认deepcopy-copy-do-copy" class="headerlink" title="1.4 核心方法之一：拷贝(copy)        默认deepcopy=copy()+do_copy()"></a>1.4 核心方法之一：拷贝(copy)        默认deepcopy=copy()+do_copy()</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119202538653.png" alt="image-20211119202538653"></p><ul><li>SV里面的copy先做对象的创建再做数据的copy —-&gt; UVM里面的clone</li><li>SV里面的数据copy拷贝 —&gt; UVM里面的copy拷贝即对象已经创建好就进行数据的拷贝</li><li>默认执行deepcopy即先执行copy()再调用回调函数do_copy()，do_copy()可在类里定义</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">_copy(<span class="hljs-params">uvm_object</span> <span class="hljs-params">obj</span>)</span>;<br></code></pre></div></td></tr></table></figure><p><strong>相同点都会对数据进行复制</strong></p><pre><code class=" mermaid">graph LRSV里面的copy先做对象的创建再做数据的copy ---&gt; UVM里面的cloneSV里面的数据copy拷贝 --&gt; UVM里面的copy拷贝即对象已经创建好就进行数据的拷贝</code></pre><h3 id="1-4-2-代码"><a href="#1-4-2-代码" class="headerlink" title="1.4.2 代码"></a>1.4.2 代码</h3><p><strong>定义ball类，在box类中对ball进行例化</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119203055568.png" alt="image-20211119203055568"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120103356118.png" alt="image-20211120103356118"></p><ul><li>box类中的成员变量完全拷贝过去了</li><li>内部成员ball类b的成员变量没有完全拷贝<ul><li>原因：<ul><li>对于color_t 声明时使用<code>UVM_NOCOPY</code>不执行拷贝</li><li>对于diameter从10变成20，因为uvm的拷贝执行了do_copy</li></ul></li></ul></li></ul><h2 id="1-5-核心方法之一：比较-compare"><a href="#1-5-核心方法之一：比较-compare" class="headerlink" title="1.5 核心方法之一：比较(compare)"></a>1.5 核心方法之一：比较(compare)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120105837242.png" alt="image-20211120105837242"></p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">bit</span> compare (uvm_object rhs, uvm_comparer comparer=null);<br></code></pre></div></td></tr></table></figure><h3 id="1-5-2-例子"><a href="#1-5-2-例子" class="headerlink" title="1.5.2 例子"></a>1.5.2 例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110305745.png" alt="image-20211120110305745"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110429625.png" alt="image-20211120110429625"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110557313.png" alt="image-20211120110557313"></p><ul><li>第三点当比较器为空uvm_comparer=null则会使用<strong>全局的默认比较器：uvm_default_comparer（详细参考1.6）</strong>，最大的错误次数为1，只要失败一次就返回</li></ul><h2 id="1-7-打印：print-直接打印，spring-返回字符串，do-print-回调"><a href="#1-7-打印：print-直接打印，spring-返回字符串，do-print-回调" class="headerlink" title="1.7 打印：print()直接打印，spring()返回字符串，do_print()回调"></a>1.7 打印：print()直接打印，spring()返回字符串，do_print()回调</h2><h3 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7.1"></a>1.7.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120111454285.png" alt="image-20211120111454285"></p><h3 id="1-7-2-例子"><a href="#1-7-2-例子" class="headerlink" title="1.7.2 例子"></a>1.7.2 例子</h3><p>声明了一个uvm_table_printer句柄local_printer<br>并使用   ；p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120113914694.png" alt="image-20211120113914694"></p><ul><li>第一次print，没对打印机printer指定，uvm使用默认uvm_default_printer打印</li><li>第二次print，指定uvm_default_printer=uvm_default_line_printer，uvm使用uvm_default_line_printer打印</li><li>第三次print，指定uvm_default_printer=uvm_default_tree_printer，uvm使用uvm_default_tree_printer打印</li><li>第四次print，配置local_printer<code>local_printer.knobs.full_name=1</code>，并指定使用前面使用的local_printer</li></ul><hr><p>输出结果</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120151732202.png" alt="image-20211120151732202"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120151900842.png" alt="image-20211120151900842"></p><h2 id="1-8-打包和解包-pack-amp-unpack"><a href="#1-8-打包和解包-pack-amp-unpack" class="headerlink" title="1.8 打包和解包(pack&amp;unpack)"></a>1.8 打包和解包(pack&amp;unpack)</h2><h3 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8.1"></a>1.8.1</h3><p><strong>一般在纯粹的UVM环境里是用不到的</strong>，一般用不到</p><p><strong>把域(标量)打包成一个比特流动态数组</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152031282.png" alt="image-20211120152031282"></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-type">int</span> pack (<span class="hljs-keyword">ref</span> <span class="hljs-type">bit</span> bitstream[], <span class="hljs-keyword">input</span> uvm_packer packer=<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-type">int</span> unpack (<span class="hljs-keyword">ref</span> <span class="hljs-type">bit</span> bitstream[], <span class="hljs-keyword">input</span> uvm_packer packer=<span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><hr><p>如下：volume-32位、color-32位、box-24位 —-&gt;最终打包成32+32+24=88位比特流的数组</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152358177.png" alt="image-20211120152358177"></p><h3 id="1-8-2-为什么这么做"><a href="#1-8-2-为什么这么做" class="headerlink" title="1.8.2 为什么这么做"></a>1.8.2 为什么这么做</h3><p>仿真器与FPGA(或其他模型)连接</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152756985.png" alt="image-20211120152756985"></p><p>sim UVM仿真器与FPGA(或其他模型)连接通信，到具体的物理接口上，数据以bitstream形式，通过PCIE/USB/JTAG/UART等协议传输</p><p>UVM的pack&amp;unpack是simUVM(软件侧)对数据打包的方法</p><p>对应FPGA或SystemC模型或不同语言也是通过相关硬件模块实现</p><h2 id="1-6-全局对象"><a href="#1-6-全局对象" class="headerlink" title="1.6 全局对象"></a>1.6 全局对象</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120111057485.png" alt="image-20211120111057485"></p><p><strong>uvm_top</strong>为全局的顶层，与其他全局对象处于并列位置</p><p>如果不想用默认比较器uvm_default_comparer可以创建一个<code>uvm_comparer</code>对象</p><p>（补充：uvm_factory不要去修改）</p><h2 id="1-9-使用到的方法总结"><a href="#1-9-使用到的方法总结" class="headerlink" title="1.9 使用到的方法总结"></a>1.9 使用到的方法总结</h2><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">class</span>.sprint<br>`uvm_info<br></code></pre></div></td></tr></table></figure><h1 id="2-phase机制"><a href="#2-phase机制" class="headerlink" title="2 phase机制"></a>2 phase机制</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121104044563.png" alt="image-20211121104044563"></p><p>解决的问题：</p><ul><li>例化先后关系</li><li>例化之前进行配置</li><li>UVM仿真阶段层次化</li></ul><h2 id="2-2-执行机制"><a href="#2-2-执行机制" class="headerlink" title="2.2 执行机制"></a>2.2 执行机制</h2><h3 id="2-2-1"><a href="#2-2-1" class="headerlink" title="2.2.1"></a>2.2.1</h3><p><strong>一共有九个phase，对应九个方法，只有uvm_component具备</strong>，即如果你的类型是个组件的话一定会有phase机制</p><p><strong>主要用到build, connect, run, report</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121105434100.png" alt="image-20211121105434100"></p><ul><li>执行顺序自顶向下，从build到final</li><li>只有run是任务，其他的是函数，函数意味着要立即返回</li></ul><h3 id="2-2-2-uvm-phase形参、例子、工厂创建对象的实例"><a href="#2-2-2-uvm-phase形参、例子、工厂创建对象的实例" class="headerlink" title="2.2.2 uvm_phase形参、例子、工厂创建对象的实例"></a>2.2.2 uvm_phase形参、例子、工厂创建对象的实例</h3><p><strong>uvm_phase形参用于传入当前phase</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121105541924.png" alt="image-20211121105541924"></p><hr><p><strong>执行方法名：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> void <span class="hljs-constructor">T_phase(<span class="hljs-params">uvm_phase</span> <span class="hljs-params">phase</span>)</span>;<br></code></pre></div></td></tr></table></figure><p>uvm_phase phase指的传入当前phase</p><hr><p><strong>工厂机制创建：</strong></p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">handle</span> = subcomp::type_id::create(<span class="hljs-string">&quot;c1&quot;</span>,this)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>this指的是c1或c2的parent，这里是创建这些对象的外部类，对应的topcomp</p><hr><p><strong>该例子例化的类结构图</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133437198.png" alt="image-20211121133437198"></p><h4 id="2-2-2-2-执行结果"><a href="#2-2-2-2-执行结果" class="headerlink" title="2.2.2.2 执行结果"></a>2.2.2.2 执行结果</h4><p>从结果看，<strong>执行顺序：自顶向下</strong>（先创建顶层实例，在创建底层实例）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133528289.png" alt="image-20211121133528289"></p><h2 id="2-3-九个主要phase：run-phase的功能"><a href="#2-3-九个主要phase：run-phase的功能" class="headerlink" title="2.3 九个主要phase：run_phase的功能"></a>2.3 九个主要phase：run_phase的功能</h2><h3 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3.1"></a>2.3.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133758460.png" alt="image-20211121133758460"></p><ul><li>上电</li><li>复位</li><li>寄存器配置</li><li>发送主要测试内容</li><li>等待DUT完成测试</li></ul><h3 id="2-3-2-进一步细分run-phase为12个分支phase"><a href="#2-3-2-进一步细分run-phase为12个分支phase" class="headerlink" title="2.3.2 进一步细分run_phase为12个分支phase"></a>2.3.2 进一步细分run_phase为12个分支phase</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133908469.png" alt="image-20211121133908469"></p><ul><li>pre_reset_phase</li><li>reset_phase</li><li>post_reset_phase</li><li>pre_configure_phase</li><li>post_comfigure_phase</li><li>pre_main_phase</li><li>main_phase</li><li>post_main_phase</li><li>pre_shutdown_phase</li><li>shutdown_phase</li><li>post_shutdown_phase</li></ul><h3 id="2-3-3-run-phase与12分支phase关系"><a href="#2-3-3-run-phase与12分支phase关系" class="headerlink" title="2.3.3 run_phase与12分支phase关系"></a>2.3.3 run_phase与12分支phase关系</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121134135788.png" alt="image-20211121134135788"></p><p><strong>建议不要使用12个分支phase</strong></p><p>当环境中同时存在run_phase与分支phase时：</p><p>run_phase和定义的分支会同时运行为两个线程，且两个线程都结束时才进入下一个phase</p><h2 id="2-4-UVM编译和运行顺序"><a href="#2-4-UVM编译和运行顺序" class="headerlink" title="2.4 UVM编译和运行顺序"></a>2.4 UVM编译和运行顺序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121134507421.png" alt="image-20211121134507421"></p><p>run是task所以可以消耗时间</p><h2 id="2-5-UVM仿真开始：run-test"><a href="#2-5-UVM仿真开始：run-test" class="headerlink" title="2.5 UVM仿真开始：run_test()"></a>2.5 UVM仿真开始：run_test()</h2><h3 id="2-5-1"><a href="#2-5-1" class="headerlink" title="2.5.1"></a>2.5.1</h3><p>类比SV中仿真开始</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121142237253.png" alt="image-20211121142237253"></p><ul><li><p>方法一：<strong>run_test(“xxxx-test”)</strong></p></li><li><p>方法二：run_test()参数为空，仿真时传递参数<code>+UVM_TESTNAME=&lt;test_name&gt;</code></p></li></ul><h3 id="2-5-2-UVM世界的诞生：run-test"><a href="#2-5-2-UVM世界的诞生：run-test" class="headerlink" title="2.5.2 UVM世界的诞生：run_test()"></a>2.5.2 UVM世界的诞生：run_test()</h3><p>run_test()从uvm_root创建了一个UVM世界，是唯一的顶层</p><p>run_test(string test_name=””);源码如下：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121142724706.png" alt="image-20211121142724706"></p><ul><li><p>先拿到一个coreservice_t</p></li><li><p>再用拿到的coreservice_t拿到全局顶层top</p></li><li>再调用顶层的run_test(test_name)</li></ul><p>即run_test(str)调用顶层，顶层top创建test，test再创建下面的哥哥结构</p><h3 id="2-5-3-uvm-top承担的责任"><a href="#2-5-3-uvm-top承担的责任" class="headerlink" title="2.5.3 uvm_top承担的责任"></a>2.5.3 uvm_top承担的责任</h3><p>uvm_top承担的责任非常重要，但无需我们去实现</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121144411570.png" alt="image-20211121144411570"></p><ul><li>uvm_top是uvm_root类的全局唯一一个实例</li><li>uvm_top是uvm里面例化的任何一个实例的顶层<ul><li>对于component来讲，parent定为null则默认顶层为uvm_top，称为其子组件</li></ul></li><li>uvm_top控制各个phase的执行顺序</li><li>uvm_top完成使用层次名索引的功能；配置部分都在uvm_top里面</li></ul><h3 id="2-5-4-uvm-top调用run-test，uvm-top做了什么"><a href="#2-5-4-uvm-top调用run-test，uvm-top做了什么" class="headerlink" title="2.5.4 uvm_top调用run_test，uvm_top做了什么"></a>2.5.4 uvm_top调用run_test，uvm_top做了什么</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121145217232.png" alt="image-20211121145217232"></p><ul><li>objection机制是用来控制仿真退出的</li><li>创建uvm_test_top是为了调用各个组件的phase方法，进行安排</li></ul><h2 id="2-6-UVM仿真结束：我们的组件需要至少有一个能够挂起run-phase"><a href="#2-6-UVM仿真结束：我们的组件需要至少有一个能够挂起run-phase" class="headerlink" title="2.6 UVM仿真结束：我们的组件需要至少有一个能够挂起run_phase"></a>2.6 UVM仿真结束：我们的组件需要至少有一个能够挂起run_phase</h2><h3 id="2-6-1"><a href="#2-6-1" class="headerlink" title="2.6.1"></a>2.6.1</h3><p><strong>控制（实现阻碍仿真退出）仿真退出只有一种方式，就是objection机制</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121150059484.png" alt="image-20211121150059484"></p><p>uvm_objection机制实际上就是个计数器，在SV中是semapho旗语</p><h3 id="2-6-2-uvm-objection用来实现反停止的方法"><a href="#2-6-2-uvm-objection用来实现反停止的方法" class="headerlink" title="2.6.2 uvm_objection用来实现反停止的方法"></a>2.6.2 uvm_objection用来实现反停止的方法</h3><h3 id="2-6-1raise挂起、drop落下"><a href="#2-6-1raise挂起、drop落下" class="headerlink" title="2.6.1raise挂起、drop落下"></a>2.6.1raise挂起、drop落下</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121150748646.png" alt="image-20211121150748646"></p><p>我们一般在run的阶段会把仿真挂起，对各<strong>个组件来说至少有一个需要把objection挂起防止uvm退出</strong>，如下：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151047519.png" alt="image-20211121151047519"></p><p>如果uvm在run_phase时没有任何组件挂起，则会直接跳到report阶段</p><h3 id="2-6-2-2-例子代码"><a href="#2-6-2-2-例子代码" class="headerlink" title="2.6.2.2 例子代码"></a>2.6.2.2 例子代码</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151418897.png" alt="image-20211121151418897"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">phase.raise_objection(this);<span class="hljs-regexp">//</span>this指的是把当前组件挂起phase.drop_objection(this);<span class="hljs-regexp">//</span>this指的是把当前组件落下<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151343183.png" alt="image-20211121151343183"></p><h4 id="2-6-2-3-例子代码2：你需要把你的挂起代码放在run-phase-的第一行执行"><a href="#2-6-2-3-例子代码2：你需要把你的挂起代码放在run-phase-的第一行执行" class="headerlink" title="2.6.2.3 例子代码2：你需要把你的挂起代码放在run_phase()的第一行执行"></a>2.6.2.3 例子代码2：你需要把你的挂起代码放在run_phase()的第一行执行</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151552696.png" alt="image-20211121151552696"></p><p>错误的，直接全部跳过了</p><p>你需要把你的挂起代码放在run_phase()的第一行执行</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151711248.png" alt="image-20211121151711248"></p><h3 id="2-6-4-你可以在component、test、sequence中进行挂起操作"><a href="#2-6-4-你可以在component、test、sequence中进行挂起操作" class="headerlink" title="2.6.4 你可以在component、test、sequence中进行挂起操作"></a>2.6.4 你可以在component、test、sequence中进行挂起操作</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151809157-16374790902901.png" alt="image-20211121151809157"></p><h1 id="3-config机制"><a href="#3-config机制" class="headerlink" title="3 config机制"></a>3 config机制</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151834681.png" alt="image-20211121151834681"></p><p>config不同参数来选择：组件类型、组件实例数目、组件之间的连接、组件的运行模式；或是修改更细节的内容</p><h3 id="3-1-2-uvm-config-db配置类"><a href="#3-1-2-uvm-config-db配置类" class="headerlink" title="3.1.2 uvm_config_db配置类"></a>3.1.2 uvm_config_db配置类</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121153004400.png" alt="image-20211121153004400"></p><p>可以把一个变量从任何一个层次传递到其他层次，甚至底层组件没有创建也可以传递</p><p>可传递内容：</p><ul><li>interface指针(SV中set_interface函数传递的)</li><li>单一变量或句柄的配置</li></ul><p>传递形式(成功返回1，失败返回0)：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">uvm_config_db#(T)::<span class="hljs-keyword">set</span>(uvm_component cntxt, <span class="hljs-built_in">string</span> inst_name, <span class="hljs-built_in">string</span> field_name, T value);<br>uvm_config_db#(T)::<span class="hljs-keyword">get</span>(uvm_component cntxt, <span class="hljs-built_in">string</span> inst_name, <span class="hljs-built_in">string</span> field_name, <span class="hljs-keyword">inout</span> T value);<br></code></pre></div></td></tr></table></figure><ul><li><h1 id="号对应参数类内容（参考SV第七讲）"><a href="#号对应参数类内容（参考SV第七讲）" class="headerlink" title="号对应参数类内容（参考SV第七讲）"></a>号对应参数类内容（参考SV第七讲）</h1></li><li><p>由层次索引</p><ul><li>string inst_name没有例化则就直接写空字符串“”</li></ul></li><li><p>(后面是错误的笔记)先set再创建，就会生成相应设置后的类</p></li></ul><h2 id="3-3-interface传递"><a href="#3-3-interface传递" class="headerlink" title="3.3 interface传递"></a>3.3 interface传递</h2><h3 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121154614767.png" alt="image-20211121154614767"></p><p>SV中使用层次化的interface所以完成传递，即调用每一层的set_interface进行层层传递，非常不好</p><ul><li>一定要对interface与vitural interface区分开，传递的过程中应该是virtual interface即传递指针</li></ul><h3 id="3-3-2-例子代码"><a href="#3-3-2-例子代码" class="headerlink" title="3.3.2 例子代码"></a>3.3.2 例子代码</h3><p>下面例子</p><ul><li><p>在build_phase里get vif</p></li><li><p>在test1的initial中进行set，且set一定要发生在run_test()之前确保了可以成功传递</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121155052295.png" alt="image-20211121155052295"></p><p>注意<code>virtual interface</code>，在软件中都得使用virtual interface</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121164443607.png" alt="image-20211121164443607"></p><p>get(this,””,”vif”,vif)前三个参数完成的层次为“root.test.c1.vif”。其中第二个参数代表的时实例名，由于这里还没有进行例化所以用空字符串代替</p><h3 id="3-3-3-例子代码续"><a href="#3-3-3-例子代码续" class="headerlink" title="3.3.3 例子代码续"></a>3.3.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171501531.png" alt="image-20211121171501531"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171442924.png" alt="image-20211121171442924"></p><p>uvm_config_db里面就是一些关系数组，做了中间的变量存放，通过set,get改变值：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171600469.png" alt="image-20211121171600469"></p><h2 id="3-4-变量设置"><a href="#3-4-变量设置" class="headerlink" title="3.4 变量设置"></a>3.4 变量设置</h2><h3 id="3-4-1-3-4-2-例子代码"><a href="#3-4-1-3-4-2-例子代码" class="headerlink" title="3.4.1 , 3.4.2 例子代码"></a>3.4.1 , 3.4.2 例子代码</h3><p>下面例子</p><ul><li><p>在build_phase里get vif</p></li><li><p>在test1的initial中进行set，再进行create</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171945087.png" alt="image-20211121171945087"></p><h3 id="3-4-3-例子代码续"><a href="#3-4-3-例子代码续" class="headerlink" title="3.4.3 例子代码续"></a>3.4.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172019437.png" alt="image-20211121172019437"></p><h2 id="3-5-object传递"><a href="#3-5-object传递" class="headerlink" title="3.5 object传递"></a>3.5 object传递</h2><h3 id="3-5-1"><a href="#3-5-1" class="headerlink" title="3.5.1"></a>3.5.1</h3><p>当变量比较多的时候，一个一个写不方便</p><p>可以把这些变量封装到uvm_object类里面，类例化，传递该对象句柄</p><ul><li>先set再create</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172401435.png" alt="image-20211121172401435"></p><h3 id="3-5-2-例子代码"><a href="#3-5-2-例子代码" class="headerlink" title="3.5.2 例子代码"></a>3.5.2 例子代码</h3><ul><li>可以父类uvm_oject传递：此时注意get时父类句柄转换为子类</li><li>可以直接以继承过来的子类进行传递</li><li>set , get 严格类型一致</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172535029.png" alt="image-20211121172535029"></p><p>注意代码<code>void`($cast(cfg, tmp))</code>把父类句柄转成子类句柄，从而访问子类句柄里的成员变量</p><h3 id="3-5-2-例子代码续"><a href="#3-5-2-例子代码续" class="headerlink" title="3.5.2 例子代码续"></a>3.5.2 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121173653346.png" alt="image-20211121173653346"></p><h3 id="类型要完全一致：底层get是父类句柄-uvm-objection-顶层set也得是该父类句柄"><a href="#类型要完全一致：底层get是父类句柄-uvm-objection-顶层set也得是该父类句柄" class="headerlink" title="类型要完全一致：底层get是父类句柄(uvm_objection)顶层set也得是该父类句柄"></a>类型要完全一致：底层get是父类句柄(uvm_objection)顶层set也得是该父类句柄</h3><h2 id="3-6-总结与建议"><a href="#3-6-总结与建议" class="headerlink" title="3.6 总结与建议"></a>3.6 总结与建议</h2><h3 id="3-6-1-总结"><a href="#3-6-1-总结" class="headerlink" title="3.6.1 总结"></a>3.6.1 总结</h3><ul><li><p><strong>set,get成对出现</strong></p></li><li><p>类型严格一致</p></li><li>路径中的*星号表通配符，意思是任意路径</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121174228374.png" alt="image-20211121174228374"></p><h3 id="3-6-1-建议"><a href="#3-6-1-建议" class="headerlink" title="3.6.1 建议"></a>3.6.1 建议</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121174345564.png" alt="image-20211121174345564"></p><h1 id="4-消息管理"><a href="#4-消息管理" class="headerlink" title="4 消息管理"></a>4 消息管理</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>一个好的验证系统应具有消息管理特性：</p><ul><li>一种标准化的方式打印</li><li>过滤信息（按重要级别）</li><li>打印通道</li></ul><p>这些特性UVM都有支持，UVM提供一系列丰富的类和方法来生成和过滤消息：</p><ul><li>消息方法</li><li>消息处理</li><li>消息机制</li></ul><p>类似的SV中的report package</p><h2 id="4-2-消息方法"><a href="#4-2-消息方法" class="headerlink" title="4.2 消息方法"></a>4.2 消息方法</h2><h3 id="4-2-1"><a href="#4-2-1" class="headerlink" title="4.2.1"></a>4.2.1</h3><p>在UVM环境中或者<strong>环境外</strong>，只要引入uvm_pkg，均可以通过下面的方法来按照消息的严重级别和冗余度来打印消息</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_info(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_MEDIUM, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_warning(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_MEDIUM, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_error(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_LOW, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_fatal(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_NONE, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><ul><li><p>id：消息的名称是什么</p></li><li><p>message：消息的内容是什么</p></li><li><p>verbosity：消息的重要性/冗余程度</p></li><li><p>filename：消息发生时该程序文件的名称（留空就行，一般系统自动添加）</p></li><li><p>line：消息发生时该程序的行号（留空就行，一般系统自动添加）</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121175458444.png" alt="image-20211121175458444"></p><h3 id="4-2-2-verbosity冗余度：UVM-NONE"><a href="#4-2-2-verbosity冗余度：UVM-NONE" class="headerlink" title="4.2.2 verbosity冗余度：UVM_NONE"></a>4.2.2 verbosity冗余度：UVM_NONE</h3><p>冗余度：代表消息重要不重要，与我们的直观认识相反</p><ul><li>UVM_NONE：最重要，没有任何bur/filter可以过滤</li><li>UVM_LOW</li><li>UVM_MEDIUM</li><li>UVM_HIGH</li><li>UVM_FULL：更容易被过滤</li><li>UVM_DEBUG：更容易被过滤</li></ul><h2 id="4-3-消息处理"><a href="#4-3-消息处理" class="headerlink" title="4.3 消息处理"></a>4.3 消息处理</h2><h3 id="4-4-1-处理方式"><a href="#4-4-1-处理方式" class="headerlink" title="4.4.1 处理方式"></a>4.4.1 处理方式</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121175515039.png" alt="image-20211121175515039"></p><h3 id="4-4-2-消息宏"><a href="#4-4-2-消息宏" class="headerlink" title="4.4.2 消息宏"></a>4.4.2 消息宏</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180007597.png" alt="image-20211121180007597"></p><p>谁提供的这些消息？：uvm_report_object</p><ul><li>我们可以用组件的方法进行调用</li><li>使用宏进行调用（更推荐）</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`uvm_info(ID, MESSAGE, VERBOSITY)</span><br><span class="hljs-meta">`uvm_warning(ID, MESSAGE)</span><br><span class="hljs-meta">`uvm_error(ID, MESSAGE)</span><br><span class="hljs-meta">`uvm_fatal(ID, MESSAGE)</span><br></code></pre></div></td></tr></table></figure><p>对于w,e,f不用传verbosity，他们默认是UVM_LOW，较高等级了</p><h2 id="4-4-消息机制"><a href="#4-4-消息机制" class="headerlink" title="4.4 消息机制"></a>4.4 消息机制</h2><p><strong>消息处理是uvm_report_handler类完成的</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180526774.png" alt="image-20211121180526774"></p><ul><li><code>set_max_quit_count</code>对ERROR消息计数停止上限</li></ul><h2 id="4-5-消息处理中的回调函数"><a href="#4-5-消息处理中的回调函数" class="headerlink" title="4.5 消息处理中的回调函数"></a>4.5 消息处理中的回调函数</h2><p><strong>回调函数有如下固定形式，在任何地方实现都可以</strong></p><p>一般来说一定要定义<strong>report_hook</strong>，其他看细分要求</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180714439.png" alt="image-20211121180714439"></p><h3 id="4-5-2-例子代码"><a href="#4-5-2-例子代码" class="headerlink" title="4.5.2 例子代码"></a>4.5.2 例子代码</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180827395.png" alt="image-20211121180827395"></p><ul><li><strong>build_phase</strong><ul><li>set_report_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_CALL_HOOK);//只有error会打印调用回调函数</li><li>set_report_verbosity_level(UVM_LOW);//只有冗余为uvm_low会被打印1<ul><li>此处error2为HIGH则不会打印也不会调用回调函数</li></ul></li></ul></li></ul><h3 id="4-5-3-回调函数返回值："><a href="#4-5-3-回调函数返回值：" class="headerlink" title="4.5.3 回调函数返回值："></a>4.5.3 <strong>回调函数返回值：</strong></h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121181339630.png" alt="image-20211121181339630"></p><p>report_hook返回值为1时，继续执行分类report_error_hook否则不再继续调用</p><p>一般来说一定要定义<strong>report_hook</strong></p><h3 id="4-5-3-例子代码续"><a href="#4-5-3-例子代码续" class="headerlink" title="4.5.3 例子代码续"></a>4.5.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180842859.png" alt="image-20211121180842859"></p><h3 id="4-5-4-隐藏在后台的uvm-report-handler与uvm-report-server"><a href="#4-5-4-隐藏在后台的uvm-report-handler与uvm-report-server" class="headerlink" title="4.5.4 隐藏在后台的uvm_report_handler与uvm_report_server"></a>4.5.4 隐藏在后台的uvm_report_handler与uvm_report_server</h3><p>对每一个组件都有report_handler实例，它们把消息申请到<strong>全局</strong>的实例report_server</p><p>report_server和factory一样的，放在coserver下面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121181735130.png" alt="image-20211121181735130"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶1：验证方法学概述_类库地图_工厂机制_覆盖方法</title>
    <link href="/202111171106/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B61%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%AD%A6%E6%A6%82%E8%BF%B0_%E7%B1%BB%E5%BA%93%E5%9C%B0%E5%9B%BE_%E5%B7%A5%E5%8E%82%E6%9C%BA%E5%88%B6_%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95/"/>
    <url>/202111171106/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B61%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%AD%A6%E6%A6%82%E8%BF%B0_%E7%B1%BB%E5%BA%93%E5%9C%B0%E5%9B%BE_%E5%B7%A5%E5%8E%82%E6%9C%BA%E5%88%B6_%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><h1 id="1-验证方法学概述"><a href="#1-验证方法学概述" class="headerlink" title="1 验证方法学概述"></a>1 验证方法学概述</h1><h2 id="1-1-我们所处的验证时代"><a href="#1-1-我们所处的验证时代" class="headerlink" title="1.1 我们所处的验证时代"></a>1.1 我们所处的验证时代</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111111480.png" alt="image-20211117111111480"></p><p>原有HDL受限于静态例化，同时随即约束短板<br>验证技术应该更为灵活化</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111401950.png" alt="image-20211117111401950"></p><p> Verilog1.0-&gt;Verilog2.0———&gt;SystemVerilog3.0(基于verilog发展的所以一上来就是3.0)</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111706037.png" alt="image-20211117111706037"></p><h2 id="1-2-UVM的优势"><a href="#1-2-UVM的优势" class="headerlink" title="1.2 UVM的优势"></a>1.2 UVM的优势</h2><p>Universal(通用)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114327436.png" alt="image-20211117114327436"></p><p>精力集中到：设计验证计划，减轻创建测试环境</p><h3 id="1-3UVM的发展历程与演变"><a href="#1-3UVM的发展历程与演变" class="headerlink" title="1.3UVM的发展历程与演变"></a>1.3UVM的发展历程与演变</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114426035.png" alt="image-20211117114426035"></p><ul><li>UVM 1.0就是基于OVM</li><li>UVM1.1 UVM1.2</li><li>UVM1.2重大里程碑，被纳为标准</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114539211.png" alt="image-20211117114539211"></p><p>注意哪些是新方法，哪些是旧方法(一些旧方法已注销)</p><h2 id="1-4-学习路线-共五周"><a href="#1-4-学习路线-共五周" class="headerlink" title="1.4 学习路线(共五周)"></a>1.4 学习路线(共五周)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114931874.png" alt="image-20211117114931874"></p><p>同v2SV一样，参考如何构建环境进行学习</p><p>五周学习不会超过50个类，非常核心的也就二十到三十个类之间大概十分之一，剩下的谁在用（UVM自动调用）</p><h1 id="2-类库地图"><a href="#2-类库地图" class="headerlink" title="2 类库地图"></a>2 类库地图</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114959864.png" alt="image-20211117114959864"></p><ul><li><p>SV通过句柄一层一层的实现访问，UVM有替代</p></li><li><p>创建、访问、修改、配置都是可以重用的，所以反到类库当中</p></li><li><p>标准化减轻了构建验证环境的负担</p></li></ul><h3 id="SV与UVM对验证环境的共同需求"><a href="#SV与UVM对验证环境的共同需求" class="headerlink" title="SV与UVM对验证环境的共同需求"></a>SV与UVM对验证环境的共同需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134433441.png" alt="image-20211117134433441"></p><h2 id="2-2-UVM世界-10大核心类"><a href="#2-2-UVM世界-10大核心类" class="headerlink" title="2.2 UVM世界(10大核心类)"></a>2.2 UVM世界(10大核心类)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134654558.png" alt="image-20211117134654558"></p><p>对象的生成是动态的，需要UVM帮助去创建，如②提供对底层组建的创建与访问</p><p>环境中层次之间的创建，链接，层次间组建的控制方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134917565.png" alt="image-20211117134917565"></p><h2 id="2-3-UVM世界讲解"><a href="#2-3-UVM世界讲解" class="headerlink" title="2.3 UVM世界讲解"></a>2.3 UVM世界讲解</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134941044.png" alt="image-20211117134941044"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134654558.png" alt="image-20211117134654558"></p><p>核心基类：</p><p>​    ① uvm_void与<strong>uvm_object(非常核心)</strong>：会提空基本的方法，比如：拷贝、创建、打印</p><p>​    ② 工厂类：注册、创建、覆盖我们的一些类型</p><p>​    ③ 事务和序列类：发送激励，帮助实现测试场景。<br>事务类：组件之间数据类型的定义，数据是如何产生</p><p>​    ④ 结构创建类：uvm_component(uvm组件类，重要，因为第五个所有的类型都继承于uvm_component。我们在UVM会经常提到这个类是继承于object还是component)</p><p>​    ⑤  环境组件类</p><p>​    ⑥ 通信管道类：fifo , channel 与SV学到的队列和信箱类比<br><strong>组件</strong>间相连用<strong>端口</strong>，发送数据的存储到通信<strong>管道</strong>内（因此第四周学通信管道和事务接口）</p><p>​    ⑦ 消息报告类：消息如何打印，消息是怎么样控制的</p><p>​    ⑧ 寄存器模型类(第五周学)</p><p>​    ⑨ 线程同步类：与SVevent对比</p><p>​    ⑩ 事务接口类(稍微特殊) ：<br>有一些port后缀，代表端口，端口用来做通信的<br>这些端口是验证组件之间要通信的话他们之间往往需要端口，即⑩类与⑤类有关系，在组件之间例化，通过端口连接<br>⑩类还比较特殊再不继承于object而直接继承void</p><h3 id="组件类、管道类、接口类的关系"><a href="#组件类、管道类、接口类的关系" class="headerlink" title="组件类、管道类、接口类的关系"></a>组件类、管道类、接口类的关系</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117141338198.png" alt="image-20211117141338198"></p><h1 id="3-工厂机制"><a href="#3-工厂机制" class="headerlink" title="3 工厂机制"></a>3 工厂机制</h1><h2 id="3-1-概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式-design-pattern"><a href="#3-1-概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式-design-pattern" class="headerlink" title="3.1 概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式(design pattern)"></a>3.1 概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式(design pattern)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117142434126.png" alt="image-20211117142434126"></p><h2 id="3-2-工厂的意义"><a href="#3-2-工厂的意义" class="headerlink" title="3.2 工厂的意义"></a>3.2 工厂的意义</h2><h3 id="3-2-1-替换、注册、配置"><a href="#3-2-1-替换、注册、配置" class="headerlink" title="3.2.1 替换、注册、配置"></a>3.2.1 替换、注册、配置</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117144807092.png" alt="image-20211117144807092"></p><ul><li><p>工厂为了：替换实例或注册过的类，为配置和覆盖(override)带来灵活性</p></li><li><p><strong>覆盖</strong>：替换实例或类型。被替换的实例或类型应满足注册(registration)和多态(polymorphism)的要求</p></li><li><p>UVM验证环境两部分：</p><ul><li>一部分构成了环境层次：通过uvm_component完成</li><li>一部分构成了环境属性(如配置)：通过uvm_object完成</li><li>uvm_component与uvm_object对比</li></ul><h3 id="3-2-2-注册"><a href="#3-2-2-注册" class="headerlink" title="3.2.2 注册"></a>3.2.2 注册</h3></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117145329019.png" alt="image-20211117145329019"></p><p>依赖于工厂创建对象</p><p>创建对象之前工厂需要模具/蓝图（类进行注册）：SV的new与注册的区别在哪，因为有一个覆盖的好处</p><h2 id="3-3-uvm-component与uvm-object"><a href="#3-3-uvm-component与uvm-object" class="headerlink" title="3.3 uvm_component与uvm_object"></a>3.3 uvm_component与uvm_object</h2><p><strong>工厂我们一共就注册两大类型：uvm_component与uvm_object</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117145646932.png" alt="image-20211117145646932"></p><ul><li><p>验证不动产</p><ul><li>性质：构成验证环境的</li><li>在uvm_component都有对应</li></ul></li><li><p>非不动产</p><ul><li>性质：帮助实现验证场景，在验证过程中动态产生</li><li>transcation事务级传输对象数据包，这些类在UVM统一由uvm_object表示</li></ul></li></ul><h3 id="3-3-2-uvm-component-object-的例化"><a href="#3-3-2-uvm-component-object-的例化" class="headerlink" title="3.3.2 uvm_{component, object}的例化"></a>3.3.2 uvm_{component, object}的例化</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117151628452.png" alt="image-20211117151628452"></p><p><strong>工厂提供的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建uvm_component对象</span><br>comp_type::type_id::<span class="hljs-built_in">create</span>(string name, uvm_component parent);<br><span class="hljs-comment">//创建uvm_object对象</span><br>object_type::type_id::<span class="hljs-built_in">create</span>(string name);<br></code></pre></div></td></tr></table></figure><p><strong>type_id</strong>是你注册到工厂里面的类型</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">comp_type::type_id::<span class="hljs-built_in">create</span>(val1,val2);<br><span class="hljs-comment">//type_id是你注册到工厂里面的类型</span><br><span class="hljs-comment">//create调用方法</span><br></code></pre></div></td></tr></table></figure><h4 id="creat与new"><a href="#creat与new" class="headerlink" title="creat与new"></a>creat与new</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117160636008.png" alt="image-20211117160636008"></p><p><strong>使用new或者create都能完成例化</strong>，但在UVM中我们用create，他是工厂提供的创建实例方式</p><h3 id="3-3-4-工程提供的便利——创建分两步：①注册-registration-、②创建-create"><a href="#3-3-4-工程提供的便利——创建分两步：①注册-registration-、②创建-create" class="headerlink" title="3.3.4 工程提供的便利——创建分两步：①注册(registration)、②创建(create)"></a>3.3.4 工程提供的便利——创建分两步：①注册(registration)、②创建(create)</h3><h4 id="注册两个宏"><a href="#注册两个宏" class="headerlink" title="注册两个宏"></a>注册两个宏</h4><p>`uvm_component_utils(comp_name);</p><p>`uvm_object_utils(obj_name);</p><h4 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h4><ul><li>定义：extends</li><li>注册：宏</li><li>构建：new</li></ul><h4 id="第一个例子-继承于component类"><a href="#第一个例子-继承于component类" class="headerlink" title="第一个例子(继承于component类)"></a>第一个例子(继承于component类)</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117151917395.png" alt="image-20211117151917395"></p><p>泛式：形式不变，内容变</p><p><strong>第一步：注册环节</strong>，第一个泛式</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_component_utils(<span class="hljs-params">comp1</span>)</span>;<span class="hljs-comment">//使用宏。固定的泛式，把当前的comp1类型注册到工厂里</span><br></code></pre></div></td></tr></table></figure><p><strong>第二步：new函数</strong>，new函数参数是第二个泛式，参数不能添加新的参数也不能减少原有的参数</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-keyword">new</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name=<span class="hljs-string">&quot;comp1&quot;</span>, uvm_component parent=<span class="hljs-literal">null</span></span>)</span>;<span class="hljs-comment">//parent是说例化当前实例的组件</span><br></code></pre></div></td></tr></table></figure><p>各个phase函数第二周学</p><h4 id="第二个例子-继承于uvm-object类"><a href="#第二个例子-继承于uvm-object类" class="headerlink" title="第二个例子(继承于uvm_object类)"></a>第二个例子(继承于uvm_object类)</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117155253185.png" alt="image-20211117155253185"></p><p>泛式：形式不变，内容变</p><p><strong>第一步：注册环节</strong>，第一个泛式</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_object_utils(<span class="hljs-params">obj1</span>)</span>;<span class="hljs-comment">//使用宏。固定的泛式，把当前的obj1类型注册到工厂里</span><br></code></pre></div></td></tr></table></figure><p><strong>第二步：new函数</strong>，new函数参数是第二个泛式</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-keyword">new</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name=<span class="hljs-string">&quot;obj1&quot;</span></span>)</span>;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p>各个phase函数第二周学</p><h3 id="3-3-5-工厂提供的便利"><a href="#3-3-5-工厂提供的便利" class="headerlink" title="3.3.5 工厂提供的便利"></a>3.3.5 工厂提供的便利</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117160759991.png" alt="image-20211117160759991"></p><h2 id="3-4-工厂机制：工厂类"><a href="#3-4-工厂机制：工厂类" class="headerlink" title="3.4 工厂机制：工厂类"></a>3.4 工厂机制：工厂类</h2><p>不一定会出现在你的代码里面，但帮你规划了你的类</p><h3 id="3-4-1-uvm-coreservice-t类"><a href="#3-4-1-uvm-coreservice-t类" class="headerlink" title="3.4.1 uvm_coreservice_t类"></a>3.4.1 uvm_coreservice_t类</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117161530640.png" alt="image-20211117161530640"></p><ul><li><p>uvm_factory成员类：<strong>唯一并全局</strong>，负责注册、覆盖、例化</p></li><li><p>report_server成员类：<strong>唯一并全局</strong>，消息统筹和报告</p></li><li><p>tr_database成员类：<strong>全局</strong>，用于记录transaction记录</p></li><li>get_root成员方法：返回UVM环境的结构顶层对象</li></ul><p><strong>uvm_coreservice_t,uvm_factory并不是uvm_component或uvm_object</strong>，没有例化在UVM环境结构中</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162456418.png" alt="image-20211117162456418"></p><p>目前学习的实例uvm_default_factory是已经存在的，不需要自己做例化</p><h3 id="3-4-2-注册宏-uvm下划线-component-object-下划线utils"><a href="#3-4-2-注册宏-uvm下划线-component-object-下划线utils" class="headerlink" title="3.4.2 注册宏`uvm下划线{component, object}下划线utils"></a>3.4.2 注册宏`uvm下划线{component, object}下划线utils</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162932344.png" alt="image-20211117162932344"></p><hr><p>注册机制与create，以下自学：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162949271.png" alt="image-20211117162949271"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117163120240.png" alt="image-20211117163120240"></p><h3 id="3-4-3-注册后的对象创建-component或者object"><a href="#3-4-3-注册后的对象创建-component或者object" class="headerlink" title="3.4.3 注册后的对象创建(component或者object)"></a>3.4.3 注册后的对象创建(component或者object)</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173114760.png" alt="image-20211117173114760"></p><p><strong>注意有无parent关系到是否可以看到UVM结构</strong></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173140816.png" alt="image-20211117173140816"></p><p>创建后放置到类型库中</p><p>创建时，创建的类型如果没有被覆盖，则直接使用该类型的基础类型</p><h3 id="3-5-6-componetn-object与工厂有关的方法（三类创建方法）"><a href="#3-5-6-componetn-object与工厂有关的方法（三类创建方法）" class="headerlink" title="3.5.6 componetn/object与工厂有关的方法（三类创建方法）"></a>3.5.6 componetn/object与工厂有关的方法（三类创建方法）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173443440.png" alt="image-20211117173443440"></p><p>用<strong>object/component组件(uvm_component)去创建</strong>对象的方法：</p><ul><li>create()</li><li>create_component()</li><li>get()</li><li>get_type_name()</li><li>set_inst_override()</li><li>set_type_override()</li></ul><hr><p>一旦创建，会把当前类型的图纸，放入到类型库里面</p><p>如果没有覆盖类型，则用工厂去创建</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173544207.png" alt="image-20211117173544207"></p><p>用<strong>工厂去创建</strong>也有很多方法：</p><ul><li><p><strong>使用typeid::创建</strong></p></li><li><p><strong>create_component_by_name()</strong></p></li><li><strong>create_component_by_name()</strong></li><li><strong>create_object_by_name()</strong></li><li><strong>create_object_by_type()</strong></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173802217.png" alt="image-20211117173802217"></p><hr><p>我们<strong>只需要使用这些就可以了</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173843219.png" alt="image-20211117173843219"></p><h1 id="4-覆盖方法"><a href="#4-覆盖方法" class="headerlink" title="4 覆盖方法"></a>4 覆盖方法</h1><h2 id="4-1-工厂提供的便利——覆盖-override"><a href="#4-1-工厂提供的便利——覆盖-override" class="headerlink" title="4.1 工厂提供的便利——覆盖(override)"></a>4.1 工厂提供的便利——覆盖(override)</h2><h3 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1"></a>4.1.1</h3><p><strong>从原来所属类型创建一个新的替换类型</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117174947637.png" alt="image-20211117174947637"></p><ul><li>无需修改原始代码，保持了原始代码封装性</li><li><strong>新的替换类型必须与原有类型兼容</strong></li></ul><h3 id="4-1-2-举例说明"><a href="#4-1-2-举例说明" class="headerlink" title="4.1.2 举例说明"></a>4.1.2 举例说明</h3><p>你想要修改一个成型验证平台，你想修改driver</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175034720.png" alt="image-20211117175034720"></p><p>如果你修改driver很容易影响到别人，因此不能轻易修改代码</p><p>如果driver是VIP，内部代码不开放的</p><hr><p><strong>使用新的类型driver2替换driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175408088.png" alt="image-20211117175408088"></p><h3 id="4-1-3-覆盖实现的要求"><a href="#4-1-3-覆盖实现的要求" class="headerlink" title="4.1.3 覆盖实现的要求"></a>4.1.3 覆盖实现的要求</h3><ul><li>原有类型与新类型都需要注册</li><li>使用create()也就是工厂创建对象</li><li>新的替换类型必须与原有类型兼容</li></ul><hr><ul><li>覆盖发生时，可以使用类型覆盖或实例覆盖</li></ul><p><strong><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175547831.png" alt="image-20211117175547831"></strong></p><h3 id="4-2-相关函数"><a href="#4-2-相关函数" class="headerlink" title="4.2 相关函数"></a>4.2 相关函数</h3><h3 id="4-2-1-set-type-override-替换类型"><a href="#4-2-1-set-type-override-替换类型" class="headerlink" title="4.2.1 set_type_override()//替换类型"></a>4.2.1 set_type_override()//替换类型</h3><ul><li>函数原型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_type_override(uvm_object_wrapper override_type, <span class="hljs-keyword">bit</span> replace =<span class="hljs-number">1</span> );<span class="hljs-comment">//一个静态函数</span><br></code></pre></div></td></tr></table></figure><ul><li>函数形参</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_object_wrapper<span class="hljs-comment">//注册过后的某一个类在工厂中注册时的句柄</span><br>new_type::get_type()<span class="hljs-comment">//找到uvm_object_wrapper的方法</span><br></code></pre></div></td></tr></table></figure><ul><li>调用方法</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">orig_type::type_id::set_type_override(new_type::get_type())<br><span class="hljs-comment">//orig_type:原始类型</span><br><span class="hljs-comment">//type_id:类型id</span><br></code></pre></div></td></tr></table></figure><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182321158.png" alt="image-20211117182321158"></p><h3 id="4-2-2-set-inst-override-替换实例"><a href="#4-2-2-set-inst-override-替换实例" class="headerlink" title="4.2.2 set_inst_override()//替换实例"></a>4.2.2 set_inst_override()//替换实例</h3><ul><li>函数原型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_inst_override(uvm_object_wrapper override_type, <span class="hljs-keyword">string</span> inst_path , uvm_component parent=<span class="hljs-literal">null</span> );<span class="hljs-comment">//一个静态函数</span><br></code></pre></div></td></tr></table></figure><ul><li>函数形参</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">inst_path<span class="hljs-comment">//当前替换实例的路径</span><br>parent()<span class="hljs-comment">//缺省时为绝对路径，有值传递是使用&#123;parent.get_full_name(),&#x27;.&#x27;,inst_path&#125;为目标路径，实际代码中常常直接写入上面的inst_path</span><br></code></pre></div></td></tr></table></figure><ul><li>调用方法</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">orig_type::type_id::set_inst_override(new_type::get_type(), <span class="hljs-string">&quot;orig_inst_path&quot;</span>)<br><span class="hljs-comment">//orig_type:原始类型</span><br><span class="hljs-comment">//type_id:类型id</span><br></code></pre></div></td></tr></table></figure><ul><li>路径解释</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">string inst_path = <span class="hljs-string">&quot;root.test.env.checker&quot;</span><span class="hljs-regexp">//</span>法一直接写<br><span class="hljs-regexp">//</span>法二通过句柄直接拿到路径，去掉双引号<br><br></code></pre></div></td></tr></table></figure><p><strong>句柄所代表的结构层级</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182619069.png" alt="image-20211117182619069"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182936862.png" alt="image-20211117182936862"></p><h2 id="4-3-如何使用覆盖相关的函数"><a href="#4-3-如何使用覆盖相关的函数" class="headerlink" title="4.3 如何使用覆盖相关的函数"></a>4.3 如何使用覆盖相关的函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118171633289.png" alt="image-20211118171633289"></p><p>不止一个类提供与覆盖有关的函数，然而名称与参数列表可能各不相同：</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">uvm_component::set_&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span>&#123;<span class="hljs-variable">_by_type</span>&#125;<br>uvm_component_registry::set_&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br>uvm_object_registry::<span class="hljs-built_in">set</span>&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br>uvm_factory::<span class="hljs-built_in">set</span>&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br></code></pre></div></td></tr></table></figure><p>但我们推荐的就是使用typeid来调用<code>set_&#123;type, inst&#125;_override</code></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">orig_type::type_id<br></code></pre></div></td></tr></table></figure><h2 id="4-4-覆盖实例"><a href="#4-4-覆盖实例" class="headerlink" title="4.4 覆盖实例"></a>4.4 覆盖实例</h2><p><strong>定义例子comp1类</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172022625.png" alt="image-20211118172022625"></p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-keyword">import</span> uvm_pkg::*; <span class="hljs-regexp">//</span>想要使用uvm类型必须<span class="hljs-keyword">import</span>这个，questa已经自动编译了这个pkg,vcs则需要实现编译一下<br>`<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uvm_macros,svh&quot;</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>定义例子2comp2类</strong></p><p>后面将1使用comp2替代comp1</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172138765.png" alt="image-20211118172138765"></p><hr><p><strong>进行覆盖</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172222740.png" alt="image-20211118172222740"></p><ul><li>c1通过new实例化的没有受到影响，没有经过工厂</li><li>c2通过工厂create实例化的，因此成为了替换后的类型</li></ul><hr><p><strong>如果没有</strong><code>comp1::type_id::set_type_override(comp2::get_type());</code><strong>进行覆盖</strong></p><p>则c1,c2指向的都是comp1类型对象</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118181347671.png" alt="image-20211118181347671"></p><h2 id="4-5-解释为什么comp2要继承comp1"><a href="#4-5-解释为什么comp2要继承comp1" class="headerlink" title="4.5 解释为什么comp2要继承comp1"></a>4.5 解释为什么comp2要继承comp1</h2><p>例化时：</p><ol><li>去找comp1的查找表</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182032108.png" alt="image-20211118182032108"></p><ol><li>发现覆盖类型不为空，把comp1的类型替换为comp2的类型 </li></ol><hr><p><strong>能不能comp2与comp1没有继承关系</strong>：不能，你的override会有问题</p><p><strong>因此，必须要有继承关系在</strong></p><hr><p><strong>定义成员函数(除了new)能不能不用virtual</strong>：不能</p><p><strong>例化时comp2仍然是父类comp1的句柄</strong>，调用方法则会调用父类的方法</p><h2 id="4-6-确保正确覆盖的代码要求"><a href="#4-6-确保正确覆盖的代码要求" class="headerlink" title="4.6 确保正确覆盖的代码要求"></a>4.6 确保正确覆盖的代码要求</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182636783.png" alt="image-20211118182636783"></p><h2 id="4-7-parent-wins"><a href="#4-7-parent-wins" class="headerlink" title="4.7 parent wins"></a>4.7 parent wins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182738070.png" alt="image-20211118182738070"></p><ul><li>覆盖发生在例化之前，即</li></ul><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">comp1<span class="hljs-type">::type_id</span><span class="hljs-type">::set_type_override</span>(comp2<span class="hljs-type">::get_type</span>());<br>c2 = comp1<span class="hljs-type">::type_id</span><span class="hljs-type">::create</span>(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-built_in">null</span>);<br></code></pre></div></td></tr></table></figure><ul><li>多次对同一对象override：谁的层次高听谁的(顶层test起作用了)，<strong>即在配置过程中，谁层次高听谁的</strong></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118183046598.png" alt="image-20211118183046598"></p><h2 id="4-8-总结：factory三要素：注册、创建和覆盖"><a href="#4-8-总结：factory三要素：注册、创建和覆盖" class="headerlink" title="4.8 总结：factory三要素：注册、创建和覆盖"></a>4.8 总结：factory三要素：注册、创建和覆盖</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118183138887.png" alt="image-20211118183138887"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCDT测试结构</title>
    <link href="/202111161414/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/MCDT%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%84/"/>
    <url>/202111161414/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/MCDT%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MCDT"><a href="#1-MCDT" class="headerlink" title="1 MCDT"></a>1 MCDT</h1><p>多通道数据传送器，mult-channel data transmitter</p><p>迷你版的MCDF</p><h2 id="1-1-MCDT测试平台结构"><a href="#1-1-MCDT测试平台结构" class="headerlink" title="1.1 MCDT测试平台结构"></a>1.1 MCDT测试平台结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116141617844.png" alt="image-20211116141617844"></p><h2 id="1-2-主要验证组件"><a href="#1-2-主要验证组件" class="headerlink" title="1.2 主要验证组件"></a>1.2 主要验证组件</h2><h3 id="1-2-1-stimulator"><a href="#1-2-1-stimulator" class="headerlink" title="1.2.1 stimulator"></a>1.2.1 stimulator</h3><p>stimulator激励发生器，是验证环境的重要部件，在一些场合中，它也被称为driver(驱动器)、BFM(bus function model , 总线功能模块)、behavioral(行为模型)或者generator(发生器)</p><p>stimulator主要职责是模拟与DUT相邻设计的接口协议，只需要关注于如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT</p><p>stimulator不应违反协议，但布局属于真实的硬件行为，还可以给出更多丰富的只要协议允许的激励场景</p><p>从stimulator同DUT的连接关系来看，我们可以进一步分为两种：<strong>initiator(发生器)</strong>、<strong>responder(响应器)</strong></p><p> initiator是主动发出数据，responder被动接受响应</p><p>就我们要验证的MCDT来看，与下行通道从端(channel slave)的连接，这种stimulator属于initiator功能是主动发起接口数据传输</p><h3 id="1-2-2-monitor"><a href="#1-2-2-monitor" class="headerlink" title="1.2.2 monitor"></a>1.2.2 monitor</h3><p>Monitor(监测器)的主要功能是用来观察DUT的边界或者内部信号，并且经过打包整理传送给其他验证平台的组件，例如checker(比较器)</p><p>从监测信号的层次来划分monitor的功能，它们可以分为观察DUT边界信号和观察DUT内部信号：</p><ul><li>观察DUT边界信号。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据内容，以及检查总线时序是否符合协议</li><li>观察DUT内部信号。从<strong>灰盒验证</strong>的手段来看，往往需要探视DUT内部信号，用来指导stimulator的激励发送，或者完成覆盖率收集，又或者完成内部功能的检查</li></ul><h3 id="1-2-3-checker"><a href="#1-2-3-checker" class="headerlink" title="1.2.3 checker"></a>1.2.3 checker</h3><p><em>无论从实现难度和维护人力上讲，checker(比较器)都应该是最需要事件投入的验证组件</em></p><p>checker肩负了<strong>模拟设计行为</strong>和<strong>功能检查</strong>的任务</p><p>内部往往有缓存器，<strong>缓存</strong>从各个monitor收集到的数据</p><p>将DUT输入接口侧的数据汇集给内置的<strong>reference model</strong>(参考模型)。Reference model在这里扮演了模拟硬件功能的角色，也是需要较多精力维护的部分，因为验证者需要在熟悉硬件的功能的情况下实现该模型，而又不应参考真实硬件的逻辑</p><hr><p>通过数据比较的方法，检查实际收集到的DUT输出端接口数据是否同reference model产生的期望数据一致</p><p>对于设计内部的关键功能模块，也有相对应的线程进行独立的检查</p><p>在检查过程中，可以将检查成功的信息统一纳入到检查报告中，便于仿真后的追溯。如果检查失败，也可以采取暂停仿真同时报告错误信息的方式，进行在线调试</p><h2 id="3-理解验证环境结构的第三个要点"><a href="#3-理解验证环境结构的第三个要点" class="headerlink" title="3 理解验证环境结构的第三个要点"></a>3 理解验证环境结构的第三个要点</h2><h3 id="1-3-1-学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分"><a href="#1-3-1-学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分" class="headerlink" title="1.3.1 学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分"></a>1.3.1 学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分</h3><ul><li><p>硬件部分：代验设计mcdt</p></li><li><p>软件部分</p><ul><li>验证环境：激励发生器、检测器、比较器等</li><li>为什么上述是软件部分：由于它们都是类的实例构成</li></ul></li><li>软硬件交互部分<ul><li>接口interface</li><li>软硬件之间数据通信依赖于此接口</li></ul></li></ul><h3 id="1-3-2-弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信"><a href="#1-3-2-弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信" class="headerlink" title="1.3.2 弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信"></a>1.3.2 弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信</h3><p>例如：我们对mcdt的数据通道发送数据，必须通过channel_interface，而驱动channel_interface的组件时<strong>channel_initiator</strong></p><p>channel_initiator，它从channel_generator获得需要发送的<strong>随机数据</strong>，而这些数据内容按照我们之前了解的接口时序协议驱动到接口上面</p><p>而channel_generator与channel_initiator之间存在数据通信关系，前者创建随机数据事务<strong>transcation</strong>实例，并发送到initiator，这种通信关系利用到之前学的sv通信要素<strong>mailbox</strong></p><p>channel_monitor与MCDT_monitor需要在各自接口上检测到MCDT的接口数据，并且写入到transcation实例中，发送到checker</p><p>最后checker将输入和输出数据做数据检查，从monitor到checker的数据通信也是基于事物的，也是mailbox实现</p><p>可以从这种验证组件之间的通信关系，验证组建之间的通信都是基于<strong>事务级</strong>的传送，而验证组件和硬件端口之间的通信必须以来接口，通过硬件时序才能实现</p><h3 id="1-3-3-能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的"><a href="#1-3-3-能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的" class="headerlink" title="1.3.3 能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的"></a>1.3.3 能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的</h3><p>也可将这一要点理解为，验证如何展开运行</p><p>在接下来各个核心验证组件，和环境集成的代码中，我们理解到，每一个验证组件他们的单一职责是什么，各个验证组件如何运转的，仿真是如何开始如何结束的</p><hr><p>channel_initiator与channel_monitor一一对应</p><p>initiator与monitor被封装在agent中</p><p>由于arbiter不需要握手，因此只外置了mcdt monitor而不需要mcdt responder，即不需要任何数据反馈</p><p>两种类型的Monitor都将检测到的数据写入transcation实例并发送到mcdt_checker</p><p>mcdt_checker内置若开FIFO，接受从MCDT的输入端和输出端检测到的数据</p><p>由于checker输入和输出端FIFO中存储的数据类型一致，这也给做数据比较带来了方便</p><h1 id="2-实现stiumlator"><a href="#2-实现stiumlator" class="headerlink" title="2 实现stiumlator"></a>2 实现stiumlator</h1><h2 id="2-1-目前实现结构图"><a href="#2-1-目前实现结构图" class="headerlink" title="2.1 目前实现结构图"></a>2.1 目前实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116141617844.png" alt="目前实现结构图"></p><p>还没实现，所以一片空白</p><h2 id="2-2-如何实现channel-generator-channel-initiator"><a href="#2-2-如何实现channel-generator-channel-initiator" class="headerlink" title="2.2 如何实现channel_generator,channel_initiator"></a>2.2 如何实现channel_generator,channel_initiator</h2><p>generator：产生数据</p><p>initiator：将这些数据解析并驱动到interface的驱动组件</p><p>transcation:用来定义一个抽象数据的数据包内容</p><h2 id="2-3-channel-transcation"><a href="#2-3-channel-transcation" class="headerlink" title="2.3 channel_transcation"></a>2.3 channel_transcation</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116172647941.png" alt="image-20211116172647941"></p><p>数据成员有若干个<code>rand</code>形变量</p><p>并针对数据成员声明了有效的数据约束，用来对单个随机变量或多个随机变量之间加以约束</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">data:</span>容纳一个数据包所有数据的动态数组data<br><span class="hljs-symbol">ch_id:</span>channel_id表示数据源<br><span class="hljs-symbol">pkg_id:</span>package_id表示数据所在数据包的packageid<br><span class="hljs-symbol">data_nidel:</span>控制数据包内相邻数据间隔周期的<br><span class="hljs-symbol">pkg_nidel:</span>相邻数据包间隔周期<br><span class="hljs-symbol">rsp:</span>用来表示反馈的(非随机)<br><span class="hljs-symbol">obj_id:</span>当前实例id(非随机)<br></code></pre></div></td></tr></table></figure><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116173239063.png" alt="image-20211116173239063"></p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">new:</span>构造函数<br><span class="hljs-symbol">clone:</span>当前实例克隆，包括两个操作：①创建新的实例②当前示例的数据成员拷贝到新实例对应成员，最后返回句柄<br></code></pre></div></td></tr></table></figure><h2 id="2-4-channel-initiator"><a href="#2-4-channel-initiator" class="headerlink" title="2.4 channel_initiator"></a>2.4 channel_initiator</h2><h3 id="2-4-1-定义"><a href="#2-4-1-定义" class="headerlink" title="2.4.1 定义"></a>2.4.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116173441139.png" alt="image-20211116173441139"></p><p>从channel_generator获取，channel_transcation数据，并且将其中的数据驱动到接口interface上</p><p>成员变量包括：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">name</span><br>虚接口:channel_interfadce<br>与channel_generator做数据通信的两个mailbox句柄,request_mailbox,response_maibox<br></code></pre></div></td></tr></table></figure><p>成员方法</p><figure class="highlight ceylon"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ceylon">chnl<span class="hljs-number">_</span>initiator的<span class="hljs-keyword">new</span>函数中，它将参数赋值给了成员变量<br>set<span class="hljs-number">_</span><span class="hljs-keyword">interface</span>函数作用是为了从外部获得接口指针，并赋值于自己的虚接口成员变量，在类似句柄或者虚接口赋值过程中经常会做句柄或虚接口是否为空的判断，以免发生空句柄赋值<br></code></pre></div></td></tr></table></figure><h3 id="2-4-2-任务：run运行任务"><a href="#2-4-2-任务：run运行任务" class="headerlink" title="2.4.2 任务：run运行任务"></a>2.4.2 任务：run运行任务</h3><p>chnl_initiator的run是个task任务</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116182335043.png" alt="image-20211116182335043"></p><p>它表示，该组件在验证环境开始时的职责就是调用driver任务，在接口上做数据驱动激励，在driver任务中他会等待系统复位信号释放后，利用forever循环语句不断地从request_mailbox中获取激励数据，并且将其通过chnl_write方法写出到接口上面，待发送完毕之后，还要克隆request数据再将其数据成员response值为1</p><p>并且将反馈数据respose句柄通过resposen_mailbox写回到generator，如此完成了initiator和generator之间的<strong>事务数据握手</strong></p><p>需要注意：Initiator或许和返回数据的两个句柄requestmb,respnosemb并没有在initiator中例化，而是在稍后的generator中例化的</p><h3 id="2-4-3-任务：chnl-write，chnl-idle"><a href="#2-4-3-任务：chnl-write，chnl-idle" class="headerlink" title="2.4.3  任务：chnl_write，chnl_idle"></a>2.4.3  任务：chnl_write，chnl_idle</h3><ul><li>chnl_write数据驱动</li><li>chnl_idle数据复位</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116183030785.png" alt="image-20211116183030785"></p><p>chnl_write ：</p><ul><li>从chnl_transcation对象中抽取动态数据data中的每一个子成员</li><li>在时钟上升沿，将其与valid信号一同置为有效发送到接口上面，且按照协议要求只在ch_ready为高时认为此次数据发送完好处呢</li><li>在相邻数据之间插入若干空闲周期</li></ul><p>chnl_idle：</p><ul><li>在时钟上升沿，将接口中的valid与data同时置为零</li></ul><h3 id="2-4-4-为什么没有channel-transcation没有体现在结构图中"><a href="#2-4-4-为什么没有channel-transcation没有体现在结构图中" class="headerlink" title="2.4.4  为什么没有channel_transcation没有体现在结构图中"></a>2.4.4  为什么没有channel_transcation没有体现在结构图中</h3><p>为什么没有channel_transcation没有体现在结构图中，是因为它作为chnl_init与chnl_gen之间通信的数据事务，并非验证结构中的成员</p><h2 id="2-5-channel-generator"><a href="#2-5-channel-generator" class="headerlink" title="2.5 channel_generator"></a>2.5 channel_generator</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116192157072.png" alt="image-20211116192157072"></p><p>与trans相似的是都有rand变量与相应约束</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>函数例化两个信箱<br></code></pre></div></td></tr></table></figure><h3 id="2-5-2-任务：run运行任务"><a href="#2-5-2-任务：run运行任务" class="headerlink" title="2.5.2 任务：run运行任务"></a>2.5.2 任务：run运行任务</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116192705880.png" alt="image-20211116192705880"></p><ul><li>调用了多次创建数据事务，并且发送个chnl_init的任务</li><li>发送完之后，调用用来控制仿真结束的旗语<code>run_stop_flags.put</code>,返回了一把钥匙</li></ul><h3 id="2-5-3-任务：send-trans"><a href="#2-5-3-任务：send-trans" class="headerlink" title="2.5.3 任务：send_trans"></a>2.5.3 任务：send_trans</h3><ul><li>chnl_init先创建了事务实例request，并调用randomize函数王城随机化</li><li>将随机化的实例request放到rsq_mb中，这个放入的句柄稍后被initor取出</li><li>同时genor从rsp_mb中等待initor返回的response事务</li></ul><p><strong>利用这两个组件完成initor与genor的一次握手</strong></p><p>如何理解：genor的约束变量与创建并随机化的实例rsq做的组合，进而将约束完成层次化的控制传递</p><h2 id="2-6-chnl-initiator与chnl-generator"><a href="#2-6-chnl-initiator与chnl-generator" class="headerlink" title="2.6 chnl_initiator与chnl_generator"></a>2.6 chnl_initiator与chnl_generator</h2><p>chnl_initor与chnl_gen or通过mailbox连接，在最后一张环境集成中讲解</p><h1 id="3-实现monitor与checker"><a href="#3-实现monitor与checker" class="headerlink" title="3 实现monitor与checker"></a>3 实现monitor与checker</h1><h2 id="3-1-目前实现结构图"><a href="#3-1-目前实现结构图" class="headerlink" title="3.1 目前实现结构图"></a>3.1 目前实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116193349393.png" alt="目前实现结构图"></p><h2 id="3-1-monitor"><a href="#3-1-monitor" class="headerlink" title="3.1 monitor"></a>3.1 monitor</h2><p>两种检测器：</p><ul><li>channel_monitor依靠对应的channel_interface，从接口获取写入每个通道从端的数据，并打包整理写入到监测数据中</li><li>MCDT_monitor依靠另外接口，获取MCDT最终送出去的数据，也打包整理写入到监测数据中</li></ul><p>有时候monitor和stiumlator可以选择相同的trans，做数据解析或写入</p><p>实验中用自定义的结构体monitor_data用于存放检测到的数据，也被chnl_monitor和MCDT_monitor同时使用</p><h2 id="3-2-monitor-data"><a href="#3-2-monitor-data" class="headerlink" title="3.2 monitor data"></a>3.2 monitor data</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116201845632.png" alt="image-20211116201845632"></p><p>只定义两个成员，因为对于两个Monitor没有数据包的概念，每个数据之间不存在联系，因此用chnl_trans做监测数据的事务类型是不妥的</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>只是单数据而不是数组，不同于chnl_trans定义的动态数组</span><br><span class="hljs-title">id</span><br></code></pre></div></td></tr></table></figure><h2 id="3-3-channel-monitor"><a href="#3-3-channel-monitor" class="headerlink" title="3.3 channel_monitor"></a>3.3 channel_monitor</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116201820105.png" alt="image-20211116201820105"></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">name变量，在<span class="hljs-keyword">new</span><span class="hljs-type"></span>中赋值，用于后期的数据打印的消息中标记每个chnl_monitor名字<br>chnl_intf，同chnl_initiator，由外部传入接口指针<br>mon_mb：用于发送检测到书的mailbox句柄，没有例化，利用句柄，最终写到了checker中的mailbox实例<br></code></pre></div></td></tr></table></figure><h3 id="3-3-2-任务run"><a href="#3-3-2-任务run" class="headerlink" title="3.3.2 任务run"></a>3.3.2 任务run</h3><p>chnl_monitor同initiator与generator，在验证环境运行时执行工作，所以也有任务run</p><p>用于不断地等待输出数据事件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116202603263.png" alt="image-20211116202603263"></p><p>用于判断什么时候的采集数据是有效的：时钟上升沿的同时，valid===1并且ready===1</p><p>注意三个等号，用来判断四值逻辑变量</p><p>chnl_data数据写入到监测数据中，并通过mon_mb写入到checker中的监测数据缓存里面</p><h2 id="3-4-MCDT-Monitor"><a href="#3-4-MCDT-Monitor" class="headerlink" title="3.4 MCDT Monitor"></a>3.4 MCDT Monitor</h2><h3 id="3-4-1-定义"><a href="#3-4-1-定义" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p>成员变量和方法与chnl_mon类似，只是传入的指针接口是<strong>mcdt_interface</strong>，因为该接口监控与驱动的数据内容不同于chnl_interface</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116202955592.png" alt="image-20211116202955592"></p><h3 id="3-4-2-任务：mon-trans"><a href="#3-4-2-任务：mon-trans" class="headerlink" title="3.4.2 任务：mon_trans"></a>3.4.2 任务：mon_trans</h3><p>不断地等待有效的输出数据事件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203146373.png" alt="image-20211116203146373"></p><p>由于MCDT的输出数据同时还包括id信息，所以需要将mcdt_data , mcdt_id都写入到检测数据中</p><h1 id="4-checker"><a href="#4-checker" class="headerlink" title="4 checker"></a>4 checker</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203423848.png" alt="目前实现的结构"></p><h2 id="3-4-checker"><a href="#3-4-checker" class="headerlink" title="3.4 checker"></a>3.4 checker</h2><h3 id="3-4-1-定义-1"><a href="#3-4-1-定义-1" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203656979.png" alt="image-20211116203656979"></p><p>成员变量包括</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">name</span><br><span class="hljs-attribute">error_count</span>：用于对错误比较技术<br><span class="hljs-attribute">cmp_count</span>：对所有比较技术<br><span class="hljs-attribute">in_mbs</span>[<span class="hljs-number">3</span>]：三个输入端监测数据的mailbox<br><span class="hljs-attribute">out_mb</span>：一个输出端检测数据的mailbox<br></code></pre></div></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>中分别对name、error_count、cmp_count做初始化<br>例化了所有的mb实例<br></code></pre></div></td></tr></table></figure><h3 id="3-4-2-任务：run"><a href="#3-4-2-任务：run" class="headerlink" title="3.4.2 任务：run"></a>3.4.2 任务：run</h3><p>运行方法，调用单一的指责方法do_compare()</p><hr><h3 id="3-4-3-任务：do-compare"><a href="#3-4-3-任务：do-compare" class="headerlink" title="3.4.3 任务：do_compare"></a>3.4.3 任务：do_compare</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116204108341.png" alt="image-20211116204108341"></p><p>是数据比较的核心</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">每次从输出端缓存mb中获取一个输出数据<br>凭借该输出数据ID判断从哪一个输入端缓存中获取数据<br>都获取数据之后进行比较<br>比较错误借助$<span class="hljs-keyword">error</span>打印错误信息,error_cnt计数<br>比较成功打印成功信息<br>无论成功失败每次比较给cmp_cnt计数<br></code></pre></div></td></tr></table></figure><h1 id="5-实现顶层环境和测试用例"><a href="#5-实现顶层环境和测试用例" class="headerlink" title="5 实现顶层环境和测试用例"></a>5 实现顶层环境和测试用例</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116210118259.png" alt="目前实现结构图"></p><h2 id="5-1-agent"><a href="#5-1-agent" class="headerlink" title="5.1 agent"></a>5.1 agent</h2><p>基本的验证单元，或者被称为<strong>代理</strong>，本身不具备特定职责，只是在内部例化了initiator和monitor，并将它们作为小队组织在一起，这么做是因为无论激励还是监测，在验证环境中都是必不可少的，且每一个接口都对应着一个initiator和monitor</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211317271.png" alt="image-20211116211317271"></p><p>成员变量都在new中得到初始化和例化</p><p>也具备set_interface函数</p><hr><p><strong>任务：</strong>set_interface</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211721080.png" alt="image-20211116211721080"></p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">除了自身获得虚接口，还会进一步传递给initiator和<span class="hljs-literal">monitor</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>任务：</strong>run</p><p>并不承担其他职责而是负责唤醒initiator和monitor的run任务起到承上启下的作用</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211908782.png" alt="image-20211116211908782"></p><h2 id="5-2-顶层环境mdct-root-test"><a href="#5-2-顶层环境mdct-root-test" class="headerlink" title="5.2 顶层环境mdct_root_test"></a>5.2 顶层环境mdct_root_test</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212050647.png" alt="image-20211116212050647"></p><h3 id="5-2-1-定义"><a href="#5-2-1-定义" class="headerlink" title="5.2.1 定义"></a>5.2.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212312316.png" alt="image-20211116212312316"></p><p>成员对象包括：</p><ul><li>三个channel_generator(chnl_generator gen)</li><li>三个channle_agent(chnl_agent agent)</li><li>一个mcdt_monitor(mcdt_monitor mcdt_mon)</li><li>一个mcdt_check(mcdt_checker chker)</li></ul><p>成员变量：</p><ul><li>成员变量name</li><li>控制generator停止产生激励数据的<strong>事件</strong>generator_stop_event(gen_stop_e)</li></ul><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>对所有组件进行例化，将所有组件数据通信关系进行连接<br></code></pre></div></td></tr></table></figure><h3 id="5-2-2-new（续）"><a href="#5-2-2-new（续）" class="headerlink" title="5.2.2 new（续）"></a>5.2.2 new（续）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212633341.png" alt="image-20211116212633341"></p><p>在连接组件之前对组件先进行例化</p><p>参照组件之间的通信关系，完成mailbox句柄赋值</p><h3 id="5-2-3-gen-stop-callback-run-stop-callback"><a href="#5-2-3-gen-stop-callback-run-stop-callback" class="headerlink" title="5.2.3 gen_stop_callback , run_stop_callback"></a>5.2.3 gen_stop_callback , run_stop_callback</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116213437000.png" alt="image-20211116213437000"></p><p>gen_stop_callback：</p><ul><li><p>mcdt_root_test是父类，没有对gen_stop_callback这个回调函数填充</p></li><li><p>如果成员变量，gen_stop_event被触发之后并且已经停止了，gen产生数据之后，还需要做什么额外的回调处理</p></li></ul><p>run_stop_callback：</p><ul><li>默认填充</li><li>等待三个generator在发送完所有激励数据后，且每个generator均交换了一把钥匙，可以从旗语run_stop_flags.get获得三把钥匙；接下来利用$finish结束仿真</li><li>mcdt_root_test是父类，没有对gen_stop_callback这个回调函数填充</li><li>run_stop_callback结合channel_generator发送完数据给旗语run_stop_flag交还钥匙的逻辑共同完成了对结束仿真的时序控制</li></ul><h3 id="5-2-4-run-顶层环境的运行任务"><a href="#5-2-4-run-顶层环境的运行任务" class="headerlink" title="5.2.4 run(顶层环境的运行任务)"></a>5.2.4 run(顶层环境的运行任务)</h3><p>起到调度整体环境组建的作用</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116224255876.png" alt="image-20211116224255876"></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">调用do<span class="hljs-emphasis">_config任务，该任务决定产生多少个什么样的随机数据事务</span><br><span class="hljs-emphasis">触发各个agent、mcdt_monitor、checker让他们各自开始执行</span><br><span class="hljs-emphasis">通识准备了等候gen_stop_</span>e的事件，并强行停止gen产生激励事物的线程<br></code></pre></div></td></tr></table></figure><p>使用并行线程<code>fork...join_none</code>语句，为的是启动程序而不阻碍各个程序执行</p><p>但本例没有用到这一特性</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225039863.png" alt="image-20211116225039863"></p><p>除了generator以外都进入到run的运行任务，但他们并没有走多远，因为他们没有generator生成的trans</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">因此最后使用<span class="hljs-string">``</span>fork<span class="hljs-params">...</span><span class="hljs-keyword">join</span><span class="hljs-string">``</span>控制generator开始运行<br>并且产生和发送随机事务给initiator<br>结束后调用run_stop_callback()<br></code></pre></div></td></tr></table></figure><h3 id="5-2-5-set-interface"><a href="#5-2-5-set-interface" class="headerlink" title="5.2.5 set_interface"></a>5.2.5 set_interface</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225450808.png" alt="image-20211116225450808"></p><p>set_interface：同channel_agent一致，主要做虚接口传递</p><p>do_config：</p><ul><li>空函数，在子类中填充</li><li>用于随机化控制产生多少个，什么样内容的随机数据transcation</li></ul><h2 id="5-3-父类实现结构图"><a href="#5-3-父类实现结构图" class="headerlink" title="5.3 父类实现结构图"></a>5.3 父类实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225710606.png" alt="目前实现结构图"></p><p>至此我们使用顶层盒子mcdt_root_test封装了这些组件</p><p>并通过.run运行任务</p><h2 id="5-4-do-config重定义"><a href="#5-4-do-config重定义" class="headerlink" title="5.4 do_config重定义"></a>5.4 do_config重定义</h2><p>在触发组件运行之前，需确定需要产生什么样的数据激励(重定义do_config函数)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230019374.png" alt="image-20211116230019374"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230104837.png" alt="image-20211116230104837"></p><p>通过对三个generator随机化，指定了各个chnl_gen需要产生的数据事务器(trans)的数量、数据之间和数据包之间的空闲周期、每个数据包的数据容量中</p><p>在随机化过程中，通过立即断言判断随机化是否成功。如果失败使用$fatal报告错误信息并停止仿真</p><h2 id="5-5-最后实现结构图"><a href="#5-5-最后实现结构图" class="headerlink" title="5.5 最后实现结构图"></a>5.5 最后实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230119510.png" alt="目前实现结构图"></p><p><strong>没有激励，整个环境无法运转</strong></p><p><strong>所有激励发送结束以后可以结束仿真</strong></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld | SV实验0 | SV实验1</title>
    <link href="/202111151136/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/202111151136/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1 创建工程"></a>1 创建工程</h3><p>不会新建项目文件夹需要自己mkdir</p><h3 id="2-创建sv文件"><a href="#2-创建sv文件" class="headerlink" title="2 创建sv文件"></a>2 创建sv文件</h3><ul><li>你想做任何工作，要在module里面才能运行</li><li>initial包括所有过程语句</li></ul><h3 id="3-gvim编辑"><a href="#3-gvim编辑" class="headerlink" title="3 gvim编辑"></a>3 gvim编辑</h3><h3 id="4-Project-gt-compile"><a href="#4-Project-gt-compile" class="headerlink" title="4 Project-&gt;compile"></a>4 Project-&gt;compile</h3><h3 id="5-Library-gt-simulate-without-optimization"><a href="#5-Library-gt-simulate-without-optimization" class="headerlink" title="5 Library-&gt;simulate without optimization"></a>5 Library-&gt;simulate without optimization</h3><p>编译到库里面（前面新建的时候默认work），之后在库里面仿真</p><p><strong>好像会出错</strong>，因此这里不使用without optimization，直接命令行vsim work.tb</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vsim work.tb<br></code></pre></div></td></tr></table></figure><h3 id="6-run"><a href="#6-run" class="headerlink" title="6 run"></a>6 run</h3><p>命令行输入run</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">run<br></code></pre></div></td></tr></table></figure><h1 id="SV实验0"><a href="#SV实验0" class="headerlink" title="SV实验0"></a>SV实验0</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><p>认识什么是设计功能描述文档</p><p>是设计功能描述文档</p><h2 id="2-设计结构"><a href="#2-设计结构" class="headerlink" title="2.设计结构"></a>2.设计结构</h2><h3 id="2-1-MCDF"><a href="#2-1-MCDF" class="headerlink" title="2.1 MCDF"></a>2.1 MCDF</h3><p>多通道数据整形器MCDF, mult-channel data formatter</p><p>FIFO的margin信号提示内部缓存余量</p><ul><li>Arbiter：仲裁</li><li>Formatter：Formatter输出明显比输入多，时序与输入不同</li><li>Registers：功能寄存器，起到配置MCDF作用<ul><li>使能具体channel（哪个channel工作）</li><li>channel优先级</li><li>输出数据包长度</li><li>….</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223932224.png" alt=""></p><h3 id="2-2-实验0实现结构"><a href="#2-2-实验0实现结构" class="headerlink" title="2.2 实验0实现结构"></a>2.2 实验0实现结构</h3><p>降低难度要求</p><p><img src="../../../../img/SV实验一/image-20211122214540946.png" alt="image-20211122214540946"></p><h3 id="2-3-需要准备的源代码"><a href="#2-3-需要准备的源代码" class="headerlink" title="2.3 需要准备的源代码"></a>2.3 需要准备的源代码</h3><p>每次运行一个实验前把mcdt三个<strong>设计</strong>文件（arbiter.v, mcdt.v, slave_fifo.v)，与tb.v文件都放在一个文件夹里面</p><h2 id="3-实验步骤"><a href="#3-实验步骤" class="headerlink" title="3.实验步骤"></a>3.实验步骤</h2><p>有人会问只编译tb那<strong>DUT</strong>怎么办，实际上DUT就在tb里面</p><p><strong>实验1，实验2是在实验0很简单的基础上一步一步修改</strong></p><h3 id="3-1熟悉questasim"><a href="#3-1熟悉questasim" class="headerlink" title="3.1熟悉questasim"></a>3.1熟悉questasim</h3><ul><li>前面没重点</li></ul><hr><ul><li><strong>库</strong>（questasim-&gt;library）<ul><li>与sv中的package的区别（在SVpackage中讲的）</li><li>同时库和你的工程是完全两个概念</li></ul></li></ul><p><img src="../../../../img/SV实验一/image-20211122220405589.png" alt="image-20211122220405589"></p><p>work里面包含编译后的module</p><p>双击这些module可以运行仿真，但单个module运行没有作用</p><hr><ul><li><strong>transcript</strong>可以输入命令</li></ul><h3 id="3-2编译"><a href="#3-2编译" class="headerlink" title="3.2编译"></a>3.2编译</h3><ul><li>先编译设计<ol><li>编译底层的模块：arbiter和slave_fifo</li><li>编译上层的mcdt</li></ol></li><li>再编译tb文件</li></ul><h3 id="3-3-simulate"><a href="#3-3-simulate" class="headerlink" title="3.3 simulate"></a>3.3 simulate</h3><p>藩镇建议simulate without optimazition：不逻辑优化的仿真</p><h3 id="3-4-Add-Wave"><a href="#3-4-Add-Wave" class="headerlink" title="3.4 Add Wave"></a>3.4 Add Wave</h3><p>shift从上到下选中，右键Add Wave</p><p><img src="../../../../img/SV实验一/image-20211122230540347.png" alt="image-20211122230540347"></p><p>此时右边会出现波形窗口</p><h3 id="3-5-运行1us"><a href="#3-5-运行1us" class="headerlink" title="3.5 运行1us"></a>3.5 运行1us</h3><p><img src="../../../../img/SV实验一/image-20211122230907458.png" alt="image-20211122230907458"></p><h3 id="3-6-放大波形显示"><a href="#3-6-放大波形显示" class="headerlink" title="3.6 放大波形显示"></a>3.6 放大波形显示</h3><ul><li>键盘敲击F：整个波形适应窗口显示</li><li>鼠标滚轮按住拖动：放大区间内波形</li></ul><h3 id="可选-调整sim结构窗口内容"><a href="#可选-调整sim结构窗口内容" class="headerlink" title="(可选)调整sim结构窗口内容"></a>(可选)调整sim结构窗口内容</h3><p>sim结构窗口内容中有：module，task，过程块，语句等等</p><p>当我们不需要看这么多东西时我们怎么设置</p><p><img src="../../../../img/SV实验一/image-20211122230042510.png" alt="image-20211122230042510"></p><p><img src="../../../../img/SV实验一/image-20211122230053149.png" alt="image-20211122230053149"></p><hr><p>或者</p><h3 id="可选-object"><a href="#可选-object" class="headerlink" title="(可选)object"></a>(可选)object</h3><p>窗口显示信号</p><p><img src="../../../../img/SV实验一/image-20211122230319699.png" alt="image-20211122230319699"></p><ul><li>In：输入信号，后缀_i</li><li>Out：输出信号，后缀_o</li><li>Internal：内部信号，后缀_s</li></ul><h3 id="可选-Wave窗口不显示路径"><a href="#可选-Wave窗口不显示路径" class="headerlink" title="(可选)Wave窗口不显示路径"></a>(可选)Wave窗口不显示路径</h3><p><img src="../../../../img/SV实验一/image-20211122230719067.png" alt="image-20211122230719067"></p><p><img src="../../../../img/SV实验一/image-20211122230724187.png" alt="image-20211122230724187"></p><h1 id="三个小实验"><a href="#三个小实验" class="headerlink" title="三个小实验"></a>三个小实验</h1><p>f</p><h1 id="SV实验1"><a href="#SV实验1" class="headerlink" title="SV实验1"></a>SV实验1</h1>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机linux系统忘记密码修改root或其他用户密码的方法</title>
    <link href="/202111151029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E7%B3%BB%E7%BB%9F%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9root%E6%88%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/202111151029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E7%B3%BB%E7%BB%9F%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9root%E6%88%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机linux系统忘记密码修改root或其他用户密码的方法"><a href="#虚拟机linux系统忘记密码修改root或其他用户密码的方法" class="headerlink" title="虚拟机linux系统忘记密码修改root或其他用户密码的方法"></a>虚拟机linux系统忘记密码修改root或其他用户密码的方法</h1><span id="more"></span><p>本文基于centos7环境进行操作，由于centos的版本是有差异的，继续之前请确定好版本。</p><h2 id="解决方法一（可能存在权限问题）"><a href="#解决方法一（可能存在权限问题）" class="headerlink" title="解决方法一（可能存在权限问题）"></a>解决方法一（可能存在权限问题）</h2><p>(1) 重启系统，在开机过程中，快速按下键盘上的方向键↑和↓。目的是告知引导程序，我们需要在引导页面选择不同的操作，以便让引导程序暂停</p><p>以下是暂停后的界面，可以查看下方的英文可知↑和↓的作用。 </p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112334445.png" alt="image-20211115112334445"></p><p>(2) 使用↑和↓将选择行设置为第一行（背景高亮即为选中），按下键盘上的e，进入编辑模式</p><p>(3) 将光标一直移动到 <code>LANG=en_US.UTF-8</code>后面，空格，再追加<code>init=/bin/sh</code>。这里特别注意，需要写在UTF-8后，保持在同一行，并注意空格。有些虚拟机由于屏幕太小，会自动添加\换行，这个是正常的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">init=/bin/sh<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112557239.png" alt="image-20211115112557239"></p><p>(4) 按下CTRL+X进行引导启动，成功后进入该界面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112624497.png" alt="image-20211115112624497"></p><p>(5) 输入以下命令</p><ul><li>挂载根目录  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mount -o remount, rw /<br></code></pre></div></td></tr></table></figure><ul><li>选择要修改密码的用户名，这里选择root用户进行修改，可以更换为你要修改的用户  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">passwd root<br></code></pre></div></td></tr></table></figure><ul><li>输入2次一样的新密码，注意输入密码的时候屏幕上不会有字符出现。  </li></ul><p>如果输入的密码太简单，会提示警告（BAD PASSWORD：Thepassword fails the dictionary check – it is too simplistic/systematic），可以无视它，继续输入密码，不过建议还是设置比较复杂一些的密码，以保证安全性</p><ul><li>如果已经开启了SElinux，则需要输入以下命令  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch /.autorelabel<br></code></pre></div></td></tr></table></figure><ul><li>最后输入以下命令重启系统即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> /sbin/init <br></code></pre></div></td></tr></table></figure><h2 id="解决方法二（未测试）"><a href="#解决方法二（未测试）" class="headerlink" title="解决方法二（未测试）"></a>解决方法二（未测试）</h2><p>(1)(2)(3)(4) 前四步同方法一</p><p>(5) 输入以下命令</p><p>输入以下命令</p><ul><li>挂载根目录  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mount -o remount, rw /<br></code></pre></div></td></tr></table></figure><ul><li>选择要修改密码的用户名，这里选择root用户进行修改，可以更换为你要修改的用户  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">passwd root<br></code></pre></div></td></tr></table></figure><ul><li>输入2次一样的新密码，注意输入密码的时候屏幕上不会有字符出现。  </li></ul><p>如果输入的密码太简单，会提示警告（BAD PASSWORD：Thepassword fails the dictionary check – it is too simplistic/systematic），可以无视它，继续输入密码，不过建议还是设置比较复杂一些的密码，以保证安全性</p><ul><li>vi etc/selinux/config 把 enforcing 改为 disable</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vi etc/selinux/config<br></code></pre></div></td></tr></table></figure><ul><li>最后输入以下命令重启系统即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> /sbin/init 或 <span class="hljs-built_in">exec</span> /sbin/reboot<br></code></pre></div></td></tr></table></figure><h3 id="方法一解决权限问题，同时也是方法二更改enforcing为disable"><a href="#方法一解决权限问题，同时也是方法二更改enforcing为disable" class="headerlink" title="方法一解决权限问题，同时也是方法二更改enforcing为disable"></a>方法一解决权限问题，同时也是方法二更改enforcing为disable</h3><ul><li>查看SElinux状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">方法1：<br>[root@localhost ~]<span class="hljs-comment"># /usr/sbin/sestatus -v</span><br>SELinux status:                 enabled<br>SELinuxfs mount:                /selinux<br>Current mode:                   enforcing<br><br>方法2：<br>[root@localhost ~]<span class="hljs-comment"># getenforce</span><br>Enforcing<br></code></pre></div></td></tr></table></figure><ul><li>关闭SELinux</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1、临时关闭（不用重启机器）：<br>setenforce 0    <span class="hljs-comment">#设置SELinux 成为permissive模式</span><br><span class="hljs-comment">#setenforce 1    #设置SELinux 成为enforcing模式</span><br><br><br>2、修改配置文件需要重启机器：<br>vi /etc/selinux/config<br>将SELINUX=enforcing改为SELINUX=disabled<br>重启<br></code></pre></div></td></tr></table></figure><h3 id="仅仅求改某个文件的权限？"><a href="#仅仅求改某个文件的权限？" class="headerlink" title="仅仅求改某个文件的权限？"></a>仅仅求改某个文件的权限？</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">chown root:root /usr/bin/passwd<br>chmod u=rwx,go=rx,u+s /usr/bin/passwd<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解决方法</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解决方法</tag>
      
      <tag>Linux</tag>
      
      <tag>Centos</tag>
      
      <tag>账户</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo执行hexo d时报错：OpenSSL SSL_read：Connection was aborted , errno 10053</title>
    <link href="/202111141924/%E9%80%9A%E7%9F%A5notify/hexo_d%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <url>/202111141924/%E9%80%9A%E7%9F%A5notify/hexo_d%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo执行hexo-d时报错：OpenSSL-SSL-read-Connection-was-aborted-errno-10053"><a href="#hexo执行hexo-d时报错：OpenSSL-SSL-read-Connection-was-aborted-errno-10053" class="headerlink" title="hexo执行hexo d时报错：OpenSSL SSL_read: Connection was aborted, errno 10053"></a>hexo执行hexo d时报错：OpenSSL SSL_read: Connection was aborted, errno 10053</h1><span id="more"></span><p>git遇到fatal: unable to access ‘<a href="https://github.com/xxx/xxx/’:OpenSSL">https://github.com/xxx/xxx/’:OpenSSL</a> SSL_read: Connection was aborted, errno 10053的问题</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Git默认限制推送的大小，运行命令更改限制大小即可</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>增加缓冲</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config http.postBuffer 524288000<br></code></pre></div></td></tr></table></figure><ol><li>更改网络认证设置</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config http.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解决方法</tag>
      
      <tag>GIT</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDA工具学习目录</title>
    <link href="/202111141521/IC/sv%E5%AD%A6%E4%B9%A0/EDAessay/ic/sv%E5%AD%A6%E4%B9%A0/EDA%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/"/>
    <url>/202111141521/IC/sv%E5%AD%A6%E4%B9%A0/EDAessay/ic/sv%E5%AD%A6%E4%B9%A0/EDA%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="EDA工具"><a href="#EDA工具" class="headerlink" title="EDA工具"></a>EDA工具</h1><p>三家公司</p><ul><li>Synopsys：<ul><li>VCS(常用且好用)</li></ul></li><li>Canddence<ul><li>irun</li></ul></li><li>Mentor：<ul><li>modelsim(用于FPGA)</li><li>questasim(linux用于ic验证)</li></ul></li></ul><h2 id="我的虚拟机环境"><a href="#我的虚拟机环境" class="headerlink" title="我的虚拟机环境"></a>我的虚拟机环境</h2><h3 id="1-已安装IC工具及命令"><a href="#1-已安装IC工具及命令" class="headerlink" title="1 已安装IC工具及命令"></a>1 已安装IC工具及命令</h3><p><strong>Synopsys：</strong></p><ul><li>vcs(-SP2)</li><li>vcs_mx（-SP2）</li><li>vcs_mx（-1）</li><li>verdi</li><li>dve</li><li>pt</li><li>icc2</li><li>dc</li><li>dv（dc的gui）</li><li>spyglass</li><li>synplify</li></ul><hr><p><strong>Cadence：</strong></p><ul><li>IC617：virtuoso</li><li>INCISIVE152：irun、simvision、imc等</li></ul><hr><p><strong>Mentor：</strong></p><ul><li>questasim10.7c（带UVM）</li></ul><hr><p><strong>开源工具：</strong></p><ul><li>iverilog</li><li>gtkwave（有问题用不了）</li></ul><hr><p><strong>FPGA：</strong></p><ul><li>vivado2019.1</li></ul><hr><p><strong>工艺库：</strong></p><ul><li>TSMC_018</li><li>TSMC_013</li><li>smic180</li></ul><hr><p><strong>其他：</strong></p><ul><li>git</li><li>gvim</li></ul><h3 id="2-工具所在目录"><a href="#2-工具所在目录" class="headerlink" title="2 工具所在目录"></a>2 工具所在目录</h3><p>​    工具均在home下</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115215509575.png" alt="image-20211115215509575"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115215520781.png" alt="image-20211115215520781"></p><h3 id="3-vivado与vcs"><a href="#3-vivado与vcs" class="headerlink" title="3 vivado与vcs"></a>3 vivado与vcs</h3><p>​    vivado与第三方仿真工具之间是有版本要求的，需要按照Xilinx官方要求进行匹配，Vivado2019.1与VCS-MX2018.09-1匹配，目前环境中默认使用VCS-MX2018.09-1，并且已编译好Vivado IP库；<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/640.webp" alt="图片"></p><h3 id="4-联网"><a href="#4-联网" class="headerlink" title="4 联网"></a>4 联网</h3><p>​    默认是断开网络的，需要联网时，保证电脑联网，然后在虚拟机中点击“链接”；<br>​    注意：联网会影响仿真速度；<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/640-16369845593362.webp" alt="图片"></p><h2 id="补充-基于standcell的ASIC设计流程"><a href="#补充-基于standcell的ASIC设计流程" class="headerlink" title="补充(基于standcell的ASIC设计流程)"></a>补充(基于standcell的ASIC设计流程)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115120359764.png" alt="image-20211115120359764"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115120515745.png" alt="image-20211115120515745"></p><h1 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h1><span id="more"></span><p>x.x.x代表文件夹目录</p><p>(x)代表具体文件</p><h2 id="1-SV-2pro"><a href="#1-SV-2pro" class="headerlink" title="1 SV 2pro"></a>1 SV 2pro</h2><h3 id="1-1-Questasim"><a href="#1-1-Questasim" class="headerlink" title="1.1 Questasim"></a>1.1 Questasim</h3><h4 id="1-014-Questasim基本使用"><a href="#1-014-Questasim基本使用" class="headerlink" title="(1) 014 Questasim基本使用"></a>(1) 014 Questasim基本使用</h4><p>03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><h4 id="2-Questasim安装教程"><a href="#2-Questasim安装教程" class="headerlink" title="(2) Questasim安装教程"></a>(2) Questasim安装教程</h4><p>04配套软件安装教程</p><h4 id="3-Questasim使用指导HelloWord"><a href="#3-Questasim使用指导HelloWord" class="headerlink" title="(3) Questasim使用指导HelloWord"></a>(3) Questasim使用指导HelloWord</h4><p>04配套软件安装教程</p><h3 id="1-2-DVT"><a href="#1-2-DVT" class="headerlink" title="1.2 DVT"></a>1.2 DVT</h3><h4 id="1-DVT-帮助理解实验代码"><a href="#1-DVT-帮助理解实验代码" class="headerlink" title="(1) DVT 帮助理解实验代码"></a>(1) DVT 帮助理解实验代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152600764.png" alt="image-20211114152600764"></p><h3 id="1-3-VCS"><a href="#1-3-VCS" class="headerlink" title="1.3 VCS"></a>1.3 VCS</h3><h4 id="1-015-Linux-VCS编译仿真步骤"><a href="#1-015-Linux-VCS编译仿真步骤" class="headerlink" title="(1) 015 Linux VCS编译仿真步骤"></a>(1) 015 Linux VCS编译仿真步骤</h4><p>03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><h2 id="2-SV-2pro增量"><a href="#2-SV-2pro增量" class="headerlink" title="2 SV 2pro增量"></a>2 SV 2pro增量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152258160.png" alt="image-20211114152258160"></p><h3 id="2-1-DVT"><a href="#2-1-DVT" class="headerlink" title="2.1 DVT"></a>2.1 DVT</h3><h4 id="2-1-1-DVTEclipse集成开发环境"><a href="#2-1-1-DVTEclipse集成开发环境" class="headerlink" title="2.1.1 DVTEclipse集成开发环境"></a>2.1.1 DVTEclipse集成开发环境</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154032282.png" alt="image-20211114154032282"></p><h4 id="2-1-2-DVT工具项目运用"><a href="#2-1-2-DVT工具项目运用" class="headerlink" title="2.1.2 DVT工具项目运用"></a>2.1.2 DVT工具项目运用</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154145512.png" alt="image-20211114154145512"></p><h3 id="2-2-Tcl"><a href="#2-2-Tcl" class="headerlink" title="2.2 Tcl"></a>2.2 Tcl</h3><h4 id="2-2-1-CDV覆盖率驱动验证-Tcl基础"><a href="#2-2-1-CDV覆盖率驱动验证-Tcl基础" class="headerlink" title="2.2.1 CDV覆盖率驱动验证-Tcl基础"></a>2.2.1 CDV覆盖率驱动验证-Tcl基础</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154353695.png" alt="image-20211114154353695"></p><h3 id="2-3-CDV-验证流程管理"><a href="#2-3-CDV-验证流程管理" class="headerlink" title="2.3 CDV + 验证流程管理"></a>2.3 CDV + 验证流程管理</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154507425.png" alt="image-20211114154507425"></p><h3 id="2-4-Questasim仿真常用命令，Questasim脚本"><a href="#2-4-Questasim仿真常用命令，Questasim脚本" class="headerlink" title="2.4 Questasim仿真常用命令，Questasim脚本"></a>2.4 Questasim仿真常用命令，Questasim脚本</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114153740868.png" alt="image-20211114153740868"></p><h3 id="2-5-自动化流程辅助实现RA寄存器"><a href="#2-5-自动化流程辅助实现RA寄存器" class="headerlink" title="2.5 自动化流程辅助实现RA寄存器"></a>2.5 自动化流程辅助实现RA寄存器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154539950.png" alt="image-20211114154539950"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154549930.png" alt="image-20211114154549930"></p><h4 id="要点：MCDF验证结构自动生成"><a href="#要点：MCDF验证结构自动生成" class="headerlink" title="要点：MCDF验证结构自动生成"></a>要点：MCDF验证结构自动生成</h4><h3 id="2-6-Quseta-VRM"><a href="#2-6-Quseta-VRM" class="headerlink" title="2.6 Quseta VRM"></a>2.6 Quseta VRM</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154623889.png" alt="image-20211114154623889"></p><h3 id="2-7-VRM术语-XML基本语法-RMDB文件"><a href="#2-7-VRM术语-XML基本语法-RMDB文件" class="headerlink" title="2.7 VRM术语 + XML基本语法 + RMDB文件"></a>2.7 VRM术语 + XML基本语法 + RMDB文件</h3><h4 id="2-7-1-VRM术语"><a href="#2-7-1-VRM术语" class="headerlink" title="2.7.1 VRM术语"></a>2.7.1 VRM术语</h4><h4 id="2-7-2-XML基本语法"><a href="#2-7-2-XML基本语法" class="headerlink" title="2.7.2 XML基本语法"></a>2.7.2 XML基本语法</h4><h4 id="2-7-3-RMDB文件"><a href="#2-7-3-RMDB文件" class="headerlink" title="2.7.3 RMDB文件"></a>2.7.3 RMDB文件</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154637793.png" alt="image-20211114154637793"></p><h3 id="3-选学"><a href="#3-选学" class="headerlink" title="3 选学"></a>3 选学</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152229178.png" alt="image-20211114152229178"></p><h3 id="3-1-VCS仿真器操作指导"><a href="#3-1-VCS仿真器操作指导" class="headerlink" title="3.1 VCS仿真器操作指导"></a>3.1 VCS仿真器操作指导</h3><h4 id="1-VSC常用操作1-5"><a href="#1-VSC常用操作1-5" class="headerlink" title="(1) VSC常用操作1-5"></a>(1) VSC常用操作1-5</h4><h4 id="2-Verdi启动仿真"><a href="#2-Verdi启动仿真" class="headerlink" title="(2) Verdi启动仿真"></a>(2) Verdi启动仿真</h4><h3 id="3-2-Vim"><a href="#3-2-Vim" class="headerlink" title="3.2 Vim"></a>3.2 Vim</h3><h3 id="3-3-SVTAPB-VIP"><a href="#3-3-SVTAPB-VIP" class="headerlink" title="3.3 SVTAPB:VIP"></a>3.3 SVTAPB:VIP</h3><p><strong>VIP是指的别人提供给你的IP，是不开放的</strong></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114160013930.png" alt="封面图片"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114160331274.png" alt="封面图片"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>EDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>学习</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV|UVM 学习实验目录</title>
    <link href="/202111141520/IC/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/"/>
    <url>/202111141520/IC/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="SV实验"><a href="#SV实验" class="headerlink" title="SV实验"></a>SV实验</h1><h2 id="实验文件目录"><a href="#实验文件目录" class="headerlink" title="实验文件目录"></a>实验文件目录</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114145633503.png" alt="image-20211114145633503"></p><h2 id="视频目录"><a href="#视频目录" class="headerlink" title="视频目录"></a>视频目录</h2><h3 id="DT帮助理解实验代码"><a href="#DT帮助理解实验代码" class="headerlink" title="DT帮助理解实验代码"></a>DT帮助理解实验代码</h3><p>目录：03学前指导</p><h3 id="实验0："><a href="#实验0：" class="headerlink" title="实验0："></a>实验0：</h3><p>目录：03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><p>范围：</p><ul><li>014 Questasim基本使用</li><li>015 [选学] Linux VCS编译仿真步骤</li></ul><h3 id="实验1："><a href="#实验1：" class="headerlink" title="实验1："></a>实验1：</h3><p>目录1：07【SV精通2】接口采样驱动、测试结束开始、调试方法</p><p>范围：</p><ul><li>040 实验1验证结构</li><li>041 实验1代码讲解</li><li>实验一 思考如何发送更快更紧密的数据</li></ul><p>目录2：08【SV练习选修】练习一指导</p><p>范围：</p><ul><li><p>01-数据类型-1</p></li><li><p>02-数据类型-2</p></li><li>03-数据类型-3</li><li>04-字符串类型</li><li>05-接口类型</li></ul><h3 id="实验2："><a href="#实验2：" class="headerlink" title="实验2："></a>实验2：</h3><p>目录：09【SV精通3】类的方法和继承、动态对象、包的使用</p><p>范围：</p><ul><li>053 实验2验证结构</li><li>054 实验2代码讲解</li></ul><p>目录2：15【SV练习选修】练习二指导</p><ul><li>1数组类型-1</li><li>2数组类型-2</li><li>3类的封装</li><li>4类的继承</li><li>5包的使用</li></ul><h3 id="实验3："><a href="#实验3：" class="headerlink" title="实验3："></a>实验3：</h3><p>目录：12【SV精通4】实验3代码讲解</p><p>范围：</p><ul><li><p>068 实验3代码讲解1</p></li><li><p>069 实验3代码讲解2</p></li><li>070 实验3代码讲解3</li><li>071 实验3代码讲解4</li><li>072-9-13 直播答疑4</li><li>v2.1 lab3 fifo_full_test详解</li><li>v2.1 lab3 数据通过形象进行传输的理解</li><li>v2.1 lab3 时序逻辑采样和组合逻辑采样区别</li><li>v2.1 lab3 为什么不需要拷贝obj_id</li></ul><h3 id="实验4："><a href="#实验4：" class="headerlink" title="实验4："></a>实验4：</h3><p>目录：15【SV精通5】实验4代码详解</p><p>范围：</p><ul><li>085 实验4代码讲解1</li><li>086 实验4代码讲解2</li><li>087 实验4代码讲解3</li><li>088 实验4代码讲解4</li><li>089 实验4代码讲解5</li><li>090-9-20 直播答疑5</li></ul><h3 id="实验5："><a href="#实验5：" class="headerlink" title="实验5："></a>实验5：</h3><p>目录：17【SV精通7】高级话题</p><p>范围：</p><ul><li>103 实验5代码讲解1</li><li>104 实验5代码讲解2</li></ul><h1 id="UVM实验"><a href="#UVM实验" class="headerlink" title="UVM实验"></a>UVM实验</h1><h2 id="入门实验0"><a href="#入门实验0" class="headerlink" title="入门实验0"></a>入门实验0</h2><p>目录：24【UVM入门进阶2】核心基类、阶段、配置、消息机制</p><p>范围：</p><ul><li>101-UVM入门实验0讲解.mp4</li></ul><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>目录：24【UVM入门进阶2】核心基类、阶段、配置、消息机制</p><p>范围：</p><ul><li>102-UVM入门实验1讲解1</li><li>103-UVM入门实验1讲解2</li><li>v2.2 lab1 object创建名字传入问题</li></ul><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>目录：26【UVM入门进阶4】结构_、顶层方案、环境元素</p><p>范围：</p><ul><li>112-UVM入门实验2代码讲解1</li><li>112-UVM入门实验2代码讲解2</li><li>v2.2 lab2 创建对象返回的句柄为何要做转化</li><li>v2.2 lab2 为什么配置应先于组件创建</li><li>v2.2 lab2 组件的phase如何自动执行</li></ul><p>内容：</p><ul><li>把SV验证结构利用UVM机制进行改造</li><li>uvm结构在uvm_root下呈现树状结构<ul><li>没有做结构图是因为结构没有变化，只是SV组件替代到UVM组件 </li></ul></li></ul><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><p>目录：28【UVM入门进阶6】TLM2通信_同步通信</p><p>范围：</p><ul><li>122-UVM入门实验3代码讲解</li><li>v2.2 lab3 TLM端口通信缓存与信箱的比较</li><li>v2.2 lab3 回调与继承的应用区别</li></ul><p>内容：</p><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><p>目录：30【UVM入门进阶8】Sequencer仲裁_Sequence层次化</p><p>范围：</p><ul><li>132-UVM入门实验4代码讲解</li><li>v2.2 lab4 测试场景为什么在序列而不在test</li><li>v2.2 lab4 从SEQ到DRV的Item传输类型转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通7：高级话题|SV理论知识完结🎉</title>
    <link href="/202111122204/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A07%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <url>/202111122204/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A07%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h1><h2 id="概述：类型转换分为静态动态两种转换"><a href="#概述：类型转换分为静态动态两种转换" class="headerlink" title="概述：类型转换分为静态动态两种转换"></a>概述：类型转换分为静态动态两种转换</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112220604793.png" alt="image-20211112220604793"></p><p><strong>静态转换：</strong><code>int&#39;(4.0) //实数转成一个整形</code>,是否成功无从得知</p><p>动态转换：<code>$cast(tgt , src)</code>右边的转成左边的类型，可以把中间的”,”理解成”=”</p><h2 id="2-动态转换"><a href="#2-动态转换" class="headerlink" title="2 动态转换"></a>2 动态转换</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112220950634.png" alt="image-20211112220950634"></p><p>子类句柄转父类句柄：<code>h1=h2</code>，但转换成的父类句柄无法访问子类成员</p><p>父类句柄转子类句柄：<code>$cast(h2,h1)</code></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221319401.png" alt="image-20211112221319401"></p><p>答案：AB</p><h2 id="3-子类句柄赋值于父类句柄"><a href="#3-子类句柄赋值于父类句柄" class="headerlink" title="3 子类句柄赋值于父类句柄"></a>3 子类句柄赋值于父类句柄</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221502557.png" alt="image-20211112221502557"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221514473.png" alt="image-20211112221514473"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221558027.png" alt="image-20211112221558027"></p><p>A</p><hr><h2 id="4-父类句柄转换为子类句柄"><a href="#4-父类句柄转换为子类句柄" class="headerlink" title="4 父类句柄转换为子类句柄"></a>4 父类句柄转换为子类句柄</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221659539.png" alt="image-20211112221659539"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221721147.png" alt="image-20211112221721147"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221750376.png" alt="image-20211112221750376"></p><p>可以成功因为bad指向子类对象<br>tr也指向子类对象</p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221916497.png" alt="image-20211112221916497"></p><p>答案：B</p><hr><h1 id="二、虚方法：virtual"><a href="#二、虚方法：virtual" class="headerlink" title="二、虚方法：virtual"></a>二、虚方法：virtual</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222220698.png" alt="image-20211112222220698"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222415541.png" alt="image-20211112222415541"></p><p><strong>为什么虚方法：</strong></p><p>父类句柄只能调用父类成员，子类句柄只能调用子类成员<br>当子类句柄赋值给父类句柄时，父类句柄调用的是父类中的<strong>同名成员</strong><br>想要调用，必须要把父类句柄转成子类句柄进行调用，<strong>不够简洁容易出错</strong></p><p>虚方法：</p><p>动态绑定(dynamic binding) / SV中称动态方法查找(dynamic method lookup)</p><h2 id="2-非虚函数的调用：即override覆盖写法-同名函数-，不是我们期望的"><a href="#2-非虚函数的调用：即override覆盖写法-同名函数-，不是我们期望的" class="headerlink" title="2 非虚函数的调用：即override覆盖写法(同名函数)，不是我们期望的"></a>2 非虚函数的调用：即override覆盖写法(同名函数)，不是我们期望的</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222914131.png" alt="image-20211112222914131"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222926037.png" alt="image-20211112222926037"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222943787.png" alt="image-20211112222943787"></p><h2 id="3-虚函数的调用"><a href="#3-虚函数的调用" class="headerlink" title="3 虚函数的调用"></a>3 虚函数的调用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223140274.png" alt="image-20211112223140274"></p><p>为了实现动态绑定，我们应该将父类方法定义为虚函数</p><h3 id="声明为：virtual"><a href="#声明为：virtual" class="headerlink" title="声明为：virtual"></a>声明为：virtual</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223250929.png" alt="image-20211112223250929"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223310179.png" alt="image-20211112223310179"></p><h2 id="4-建议：定义父类方法时，直接声明为虚方法"><a href="#4-建议：定义父类方法时，直接声明为虚方法" class="headerlink" title="4 建议：定义父类方法时，直接声明为虚方法"></a>4 建议：定义父类方法时，直接声明为虚方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223353297.png" alt="image-20211112223353297"></p><p><strong>子类无需再次声明，只需父类声明即可</strong></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223634781.png" alt="image-20211112223634781"></p><p>答案：A</p><p>C是错的，没有虚成员的概念，<strong>请牢记！！！</strong>，没有任何办法可以通过父类句柄找到子类对象中的变量</p><p>D不能使用不同类型参数</p><h1 id="三、对象拷贝"><a href="#三、对象拷贝" class="headerlink" title="三、对象拷贝"></a>三、对象拷贝</h1><h2 id="1-赋值和拷贝"><a href="#1-赋值和拷贝" class="headerlink" title="1 赋值和拷贝"></a>1 赋值和拷贝</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193044171.png" alt="image-20211113193044171"></p><h2 id="2-声明变量和创建对象"><a href="#2-声明变量和创建对象" class="headerlink" title="2 声明变量和创建对象"></a>2 声明变量和创建对象</h2><p>是两个过程，也可以一步完成</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">Packet p1;<br>p1 = <span class="hljs-keyword">new</span>();<br></code></pre></div></td></tr></table></figure><p>new不可以有返回值，也不可定义为虚函数</p><h2 id="3-从p1拷贝到p2：浅拷贝shallow-copy"><a href="#3-从p1拷贝到p2：浅拷贝shallow-copy" class="headerlink" title="3 从p1拷贝到p2：浅拷贝shallow copy"></a>3 从p1拷贝到p2：浅拷贝shallow copy</h2><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">Packet p1;<br>Packet p2;<br>p1 = new();<br>p2 = new() p1;//把p1的值拷贝给p2，并通过new创建对象<br></code></pre></div></td></tr></table></figure><h2 id="4-对象的拷贝让人当心"><a href="#4-对象的拷贝让人当心" class="headerlink" title="4 对象的拷贝让人当心"></a>4 对象的拷贝让人当心</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193450909.png" alt="image-20211113193450909"></p><p>不要与<strong>句柄的拷贝搞混</strong>：子类变父类，父类变子类</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193553972.png" alt="image-20211113193553972"></p><h2 id="5-自定义拷贝函数：自己声明定义的赋值函数与copy函数"><a href="#5-自定义拷贝函数：自己声明定义的赋值函数与copy函数" class="headerlink" title="5 自定义拷贝函数：自己声明定义的赋值函数与copy函数"></a>5 自定义拷贝函数：自己声明定义的赋值函数与copy函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193642312.png" alt="image-20211113193642312"></p><h3 id="父类copy"><a href="#父类copy" class="headerlink" title="父类copy"></a>父类copy</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193656716.png" alt="image-20211113193656716"></p><ul><li>copy_data()用于数据赋值</li><li>copy()用于创建对象和返回句柄</li></ul><p><strong>子类对象copy会创建一个子类的对象，但返回的是父类类型的句柄</strong></p><h3 id="子类copy（重点1）"><a href="#子类copy（重点1）" class="headerlink" title="子类copy（重点1）"></a>子类copy（重点1）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193915025.png" alt="image-20211113193915025"></p><ul><li><p>t是子类句柄，直接带入copy_data隐式转换成父类句柄</p></li><li><p>super.copy_data调用父类的copy_data，</p></li><li><p>填入一行代码：<code>$cast(h,t);</code>，<strong>h.def才能把子类同名变量赋值</strong></p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113194409221.png" alt="image-20211113194409221"></p><p><strong>即：子类中用到的同名变量要转换成子类句柄进行copy</strong>，如果直接t.def，则会导致赋值到父类的def中</p><h3 id="module中（重点2）"><a href="#module中（重点2）" class="headerlink" title="module中（重点2）"></a>module中（重点2）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113194616350.png" alt="image-20211113194616350"></p><p><strong>子类对象copy会创建一个子类的对象，但返回的是父类类型的句柄</strong></p><p><code>$cast(h,wr.copy());</code></p><p>最终结果是：</p><ul><li>wr = new () ; //创建了一个test_wr子类对象</li><li>h句柄通过wr.copy获得了拷贝过的一个未命名对象的父类句柄，并通过$cast完成父类转到h子类句柄上</li><li>所以存在wr，h两个句柄分别指向的不同的子类对象</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113195519471.png" alt="image-20211113195519471"></p><p><strong>copy,copy_data声明为虚函数很重要</strong></p><p>遵循只拷贝改类的域成员的原则：</p><ul><li>子类的copy_data里的方法：<ul><li>调用父类的copy_data，为了更好的复用</li><li>拷贝子类中数据</li></ul></li></ul><h1 id="四、回调函数-callback-钩子函数"><a href="#四、回调函数-callback-钩子函数" class="headerlink" title="四、回调函数(callback,钩子函数)"></a>四、回调函数(callback,钩子函数)</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113200203617.png" alt="image-20211113200203617"></p><p>复用：水平复用、垂直复用</p><p>为什么回调：解决<strong>直接修改父类</strong>会牵一发而动全身的情况，通过<strong>预留回调函数</strong>入口在子函数补充完成对父类方法的修改</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113200733862.png" alt="image-20211113200733862"></p><h2 id="2-实例：定义虚类和虚函数virtual-class-amp-virtual-function"><a href="#2-实例：定义虚类和虚函数virtual-class-amp-virtual-function" class="headerlink" title="2 实例：定义虚类和虚函数virtual class &amp; virtual function"></a>2 实例：定义虚类和虚函数virtual class &amp; virtual function</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113201009701.png" alt="image-20211113201009701"></p><p>虚类（或者说类的一个模板），虚类是不能例化的，为了你不例化这个类</p><hr><p>同时你也可以不定义虚类就定义普通的，事实上目前我们可以这样做简单</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113201219936.png" alt="image-20211113201219936"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203045002.png" alt="image-20211113203045002"></p><p>把callback类型的句柄放在队列<code>Driver_cbs cbs</code> 里面</p><p>按行分析：</p><ul><li>agt2drv.get(tr)//拿到一个transcation</li><li>foreach挨个调用句柄，如果返回的drop是1则不会执行<code>transmit(tr)</code>（即不会发送tr了），直接continue到forever入口处</li><li>transmit(tr)//发送transcation</li></ul><p>大致意思：</p><p>重点是callback作用是可能返回drop<strong>进一步控制driver的行为</strong>，driver什么时候可以发送什么时候不发送</p><h4 id="定义了一个类：虚类不可以例化但能继承"><a href="#定义了一个类：虚类不可以例化但能继承" class="headerlink" title="定义了一个类：虚类不可以例化但能继承"></a>定义了一个类：虚类不可以例化但能继承</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203307071.png" alt="image-20211113203307071"></p><p>drop声类型可以ref也可以output</p><ul><li><p>drop = 1 ：1%概率</p></li><li><p>drop = 0 ：99%概率</p></li></ul><h3 id="要使用回调函数了（看标红的代码）"><a href="#要使用回调函数了（看标红的代码）" class="headerlink" title="要使用回调函数了（看标红的代码）"></a>要使用回调函数了（看标红的代码）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203723480.png" alt="image-20211113203723480">7</p><ul><li>begin…end里面考虑要不要修改driver行为<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203928872.png" alt="image-20211113203928872"></li></ul></li></ul><h2 id="3-如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）"><a href="#3-如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）" class="headerlink" title="3 如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）"></a>3 如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）</h2><ul><li>预留回调函数入口</li><li>定义回调类和回调函数</li><li>例化及添加回调类实例</li></ul><h2 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113204202872.png" alt="image-20211113204202872"></p><p>答案：ABCD</p><h1 id="五、参数化的类：类似于C-模板"><a href="#五、参数化的类：类似于C-模板" class="headerlink" title="五、参数化的类：类似于C++模板"></a>五、参数化的类：类似于C++模板</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113204317704.png" alt="image-20211113204317704"></p><p><strong>类型也可以做参数</strong></p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2 例子"></a>2 例子</h2><h3 id="（1-一个简单的mailbox"><a href="#（1-一个简单的mailbox" class="headerlink" title="（1) 一个简单的mailbox"></a>（1) 一个简单的mailbox</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113205418610.png" alt="image-20211113205418610"></p><p>只能操作整形</p><h3 id="使用参数化的类：-type-T-int-声明参数化的类，同时默认类型int"><a href="#使用参数化的类：-type-T-int-声明参数化的类，同时默认类型int" class="headerlink" title="使用参数化的类： # (type T = int)//声明参数化的类，同时默认类型int"></a>使用参数化的类： <code># (type T = int)</code>//声明参数化的类，同时默认类型int</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113205639763.png" alt="image-20211113205639763"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113210058383.png" alt="image-20211113210058383"></p><h2 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113210148500.png" alt="image-20211113210148500"></p><p>答案：ABD</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通6：验证的量化与功能覆盖率</title>
    <link href="/202111121646/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A06-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E9%87%8F%E5%8C%96%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <url>/202111121646/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A06-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E9%87%8F%E5%8C%96%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、覆盖率"><a href="#一、覆盖率" class="headerlink" title="一、覆盖率"></a>一、覆盖率</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112165259519.png" alt="image-20211112165259519"></p><h2 id="2-覆盖率反馈回路"><a href="#2-覆盖率反馈回路" class="headerlink" title="2 覆盖率反馈回路"></a>2 覆盖率反馈回路</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172014070.png" alt="image-20211112172014070"></p><ul><li>随机约束(constrained random tests) 很窄的时候会变成定向测试(directed testcase)</li><li>Many runs , different seeds ： 跑多次使用不同的种子</li><li>Functionall Coverage ： 功能覆盖率</li><li>Identify holes：分析漏洞</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172300816.png" alt="image-20211112172300816"></p><p>即一开始可以使用定向测试</p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172336045.png" alt="image-20211112172336045"></p><p>答案：AB</p><h2 id="3-漏洞率曲线"><a href="#3-漏洞率曲线" class="headerlink" title="3 漏洞率曲线"></a>3 漏洞率曲线</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112193838775.png" alt="image-20211112193838775"></p><p><strong>漏洞率下降时</strong>，应寻找各种不同的办法去测试可能的边界情况(corner case)</p><h2 id="4-功能覆盖率步骤"><a href="#4-功能覆盖率步骤" class="headerlink" title="4 功能覆盖率步骤"></a>4 功能覆盖率步骤</h2><h1 id="二、-覆盖率类型"><a href="#二、-覆盖率类型" class="headerlink" title="二、 覆盖率类型"></a>二、 覆盖率类型</h1><h2 id="1-代码覆盖率"><a href="#1-代码覆盖率" class="headerlink" title="1 代码覆盖率"></a>1 代码覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172457412-16367090980413.png" alt="image-20211112172457412"></p><p><strong>工具分析，编译时添加选项，不需要额外代码</strong></p><ul><li>行覆盖率</li><li>路径覆盖率</li><li>反转覆盖率</li><li>状态机覆盖率</li></ul><p><strong>最终结果用于衡量设计代码</strong>，关注点在设计代码的分析上，而不是测试平台</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172807856.png" alt="image-20211112172807856"></p><p><strong>代码覆盖率100%是必要不充分条件</strong></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112173008178.png" alt="image-20211112173008178"></p><p>答案：C</p><p>实际情况常常达不到100%，我们会：1、设置编译器这部分达不到；2、设置100%的阈值</p><h2 id="2-断言覆盖率"><a href="#2-断言覆盖率" class="headerlink" title="2 断言覆盖率"></a>2 断言覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112173150029.png" alt="image-20211112173150029"></p><p>可以使用SV的程序性代码：<code>assert</code></p><p>但使用SVA更简单</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112193553513.png" alt="image-20211112193553513"></p><p>断言除了用于信号和状态的检查外，还可以用作覆盖率收集</p><p>只有代码覆盖率会自动收集，断言覆盖率需要自己定义</p><h2 id="3-功能覆盖率（重要）"><a href="#3-功能覆盖率（重要）" class="headerlink" title="3 功能覆盖率（重要）"></a>3 功能覆盖率（重要）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112194059827.png" alt="image-20211112194059827"></p><h3 id="功能覆盖率关系图"><a href="#功能覆盖率关系图" class="headerlink" title="功能覆盖率关系图"></a>功能覆盖率关系图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112194448584.png" alt="image-20211112194448584"></p><p>不止仿真，形式验证、加速都可以收集覆盖率</p><p>pass：功能测试有没有通过</p><h3 id="功能覆盖率步骤"><a href="#功能覆盖率步骤" class="headerlink" title="功能覆盖率步骤"></a>功能覆盖率步骤</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195017497.png" alt="image-20211112195017497"></p><p><strong>合并覆盖率</strong></p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195116210.png" alt="image-20211112195116210"></p><p>答案：BCD</p><h1 id="三、功能覆盖策略"><a href="#三、功能覆盖策略" class="headerlink" title="三、功能覆盖策略"></a>三、功能覆盖策略</h1><h2 id="1-收集信息而非数据"><a href="#1-收集信息而非数据" class="headerlink" title="1 收集信息而非数据"></a>1 收集信息而非数据</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195304711.png" alt="image-20211112195304711"></p><p>着眼于感兴趣的状态，而不是具体数值</p><h2 id="2-只测量需要的内容"><a href="#2-只测量需要的内容" class="headerlink" title="2 只测量需要的内容"></a>2 只测量需要的内容</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195645515.png" alt="image-20211112195645515"></p><ul><li><p>什么时候打开覆盖率收集，什么时候关闭</p></li><li><p>只收集哪些？功能点…</p></li><li><p>合理的定义覆盖率采样事件</p></li></ul><h2 id="3-验证的完备性：代码覆盖率与功能覆盖率的关系"><a href="#3-验证的完备性：代码覆盖率与功能覆盖率的关系" class="headerlink" title="3 验证的完备性：代码覆盖率与功能覆盖率的关系"></a>3 验证的完备性：代码覆盖率与功能覆盖率的关系</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195858313.png" alt="image-20211112195858313"></p><p>目标是同时<strong>驱动</strong>高的代码覆盖率和功能覆盖率</p><h3 id="Functional-Coverage-amp-Code-Coverage-figure"><a href="#Functional-Coverage-amp-Code-Coverage-figure" class="headerlink" title="Functional Coverage &amp; Code Coverage figure"></a>Functional Coverage &amp; Code Coverage figure</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112200010561.png" alt="image-20211112200010561"></p><ul><li>Need more FC points ,including corner cases : 部分代码代表的功能还没有提取，需要定义更多的功能覆盖率</li><li>Is design complete ? : （最常见的）某些感兴趣的状态还是没有被测试到，分析我们的功能覆盖率哪些没有测试到，针对他们去添加修改约束和性能测试</li></ul><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112200059155.png" alt="image-20211112200059155"></p><p>答案：CD</p><h1 id="四、覆盖组-关键词covergroup"><a href="#四、覆盖组-关键词covergroup" class="headerlink" title="四、覆盖组(关键词covergroup)"></a>四、覆盖组(关键词covergroup)</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><ul><li><code>covergroup</code>与类相似，一次定义多次例化</li><li><code>covergroup</code>可定义在类、interface、module中</li><li><code>covergroup</code>包含一个或多个<code>coverpoint</code>，所有points全部同一时间采集</li><li><code>covergroup</code>可采样任何可见变量，例如程序变量、接口信号、设计端口</li><li>一个类里面面可包含多个<code>covergroup</code></li><li>你拥有多个独立的<code>covergroup</code>时，每个<code>covergroup</code>可以根据需要自行使能或禁止</li><li>每个<code>covergroup</code>可以定义单独的触发采样时间，允许从多个源头收集数据</li><li><code>covergroup</code>必须例化后才能收集数据</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">CovPort ck = <span class="hljs-keyword">new</span> ();<br>ck<span class="hljs-variable">.start</span>();<span class="hljs-comment">//new之后默认已经启动，只有stop只有才需要重启</span><br>ck<span class="hljs-variable">.stop</span>();<br>ck<span class="hljs-variable">.sample</span>();<span class="hljs-comment">//采样</span><br></code></pre></div></td></tr></table></figure><h2 id="2-在类里定义covergroup"><a href="#2-在类里定义covergroup" class="headerlink" title="2 在类里定义covergroup"></a>2 在类里定义covergroup</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112201312010.png" alt="image-20211112201312010"></p><h3 id="两种例化方式"><a href="#两种例化方式" class="headerlink" title="两种例化方式"></a>两种例化方式</h3><p><strong>第一种：</strong>实例名和类名一致，但类名还是类名，实例名也是实例名，但没法例化多次</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">covergroup</span> CovPort;<br>....<br>CovPort = <span class="hljs-keyword">new</span> ();<span class="hljs-comment">//和类的例化不太一样</span><br></code></pre></div></td></tr></table></figure><p><strong>第二种（建议）：</strong>实例名与类名不一致，我们定义类也是用这种，可以例化多次</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">CovPort cg1 = <span class="hljs-keyword">new</span>();<br></code></pre></div></td></tr></table></figure><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p><strong>第一种</strong>采样方式（手动）</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">cg1<span class="hljs-variable">.sample</span>();<br></code></pre></div></td></tr></table></figure><p><strong>第二种</strong>采样方式：<strong>covergroup的采样触发</strong>等待某些特定的信号（自动）</p><h2 id="3-covergroup的采样触发"><a href="#3-covergroup的采样触发" class="headerlink" title="3 covergroup的采样触发"></a>3 covergroup的采样触发</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202040146.png" alt="image-20211112202040146"></p><h3 id="使用事件触发"><a href="#使用事件触发" class="headerlink" title="使用事件触发"></a>使用事件触发</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202147138.png" alt="image-20211112202147138"></p><p>借助已有事件，比如已有的时钟或event</p><h2 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202248248.png" alt="image-20211112202248248"></p><p>答案：ABC</p><h1 id="五、数据采样"><a href="#五、数据采样" class="headerlink" title="五、数据采样"></a>五、数据采样</h1><h2 id="1-概述：仓bin"><a href="#1-概述：仓bin" class="headerlink" title="1 概述：仓bin"></a>1 概述：仓bin</h2><p>定义coverpoint时，SV会创建很多仓，可以是自己定义的bin，也可以是自动生成的bin，推荐自己定义</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202342351.png" alt="image-20211112202342351"></p><h2 id="2-coverpoint-和-bin"><a href="#2-coverpoint-和-bin" class="headerlink" title="2 coverpoint 和 bin"></a>2 coverpoint 和 bin</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210126670.png" alt="image-20211112210126670"></p><h2 id="3-bin的创建和应用"><a href="#3-bin的创建和应用" class="headerlink" title="3 bin的创建和应用"></a>3 bin的创建和应用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210244773.png" alt="image-20211112210244773"></p><h2 id="4-命名coverpoint和bin"><a href="#4-命名coverpoint和bin" class="headerlink" title="4 命名coverpoint和bin"></a>4 命名coverpoint和bin</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210343326.png" alt="image-20211112210343326"></p><p><strong>misc</strong> = default</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210432170-16367222726244.png" alt="image-20211112210432170"></p><h2 id="5-条件覆盖率：iff关键词给coverpoint添加额外条件"><a href="#5-条件覆盖率：iff关键词给coverpoint添加额外条件" class="headerlink" title="5 条件覆盖率：iff关键词给coverpoint添加额外条件"></a>5 条件覆盖率：iff关键词给coverpoint添加额外条件</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210817547.png" alt="image-20211112210817547"></p><p>关注port变量，不单单要触发采样条件<code>ck.sample()</code>，还要<code>(!bus_if.reset)</code>即已经复位</p><p>为什么ck要先关闭：因为要操作复位信号</p><h2 id="6-翻转覆盖率：-gt-符号"><a href="#6-翻转覆盖率：-gt-符号" class="headerlink" title="6 翻转覆盖率：=&gt; 符号"></a>6 翻转覆盖率：=&gt; 符号</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211158581.png" alt="image-20211112211158581"></p><h3 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211257808.png" alt="image-20211112211257808"></p><p>答案：ABD</p><h2 id="7-wildcard覆盖率：把X-Z或？当成0，1的通配"><a href="#7-wildcard覆盖率：把X-Z或？当成0，1的通配" class="headerlink" title="7 wildcard覆盖率：把X,Z或？当成0，1的通配"></a>7 wildcard覆盖率：把X,Z或？当成0，1的通配</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211500653.png" alt="image-20211112211500653"></p><h2 id="8-忽略某些bin：关键词ignore-bins"><a href="#8-忽略某些bin：关键词ignore-bins" class="headerlink" title="8 忽略某些bin：关键词ignore_bins"></a>8 忽略某些bin：关键词ignore_bins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211609744.png" alt="image-20211112211609744"></p><p>使用<code>ignore_bins</code>定义bin</p><h2 id="9-非法某些bin：关键词illegal-bins"><a href="#9-非法某些bin：关键词illegal-bins" class="headerlink" title="9 非法某些bin：关键词illegal_bins"></a>9 非法某些bin：关键词illegal_bins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211746972.png" alt="image-20211112211746972"></p><h2 id="10-交叉覆盖率：关键词cross"><a href="#10-交叉覆盖率：关键词cross" class="headerlink" title="10 交叉覆盖率：关键词cross"></a>10 交叉覆盖率：关键词cross</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211810842.png" alt="image-20211112211810842"></p><h3 id="1-排除部分cross-bin：ignore-bins-binsof-intersect"><a href="#1-排除部分cross-bin：ignore-bins-binsof-intersect" class="headerlink" title="(1) 排除部分cross bin：ignore_bins + binsof + intersect"></a>(1) 排除部分cross bin：ignore_bins + binsof + intersect</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112212537184.png" alt="image-20211112212537184"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">binsof</span><span class="hljs-params">(覆盖率组变量A)</span></span> itersect &#123;整形&#125;<br><span class="hljs-comment">//与7有关的“A”组合</span><br><br></code></pre></div></td></tr></table></figure><hr><p><code>ignore_bins md = binsof(port) intersect&#123;0&#125; &amp;&amp; binsof(kind) intersect &#123;[9:11]&#125;</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112212947981.png" alt="image-20211112212947981"></p><hr><p><code>ignore_bins lo = binsof(kind.lo)//lo在前面定义了bin lo = &#123;[8:$]&#125;</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213224109.png" alt="image-20211112213224109"></p><h3 id="2-精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof"><a href="#2-精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof" class="headerlink" title="(2) 精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof"></a>(2) 精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213515343.png" alt="image-20211112213515343"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213606529.png" alt="image-20211112213606529"></p><p>尽量不做排除法，而是指定法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213705741.png" alt="image-20211112213705741"></p><h3 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213730283.png" alt="image-20211112213730283"></p><p>答案：ABC</p><p>D错是因为，如果不连续（漏掉）某些bin，SV可能会自动帮你填充如：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112214020363.png" alt="image-20211112214020363"></p><p>456没有关心</p><h4 id="采样到illegal-bins仿真会停止"><a href="#采样到illegal-bins仿真会停止" class="headerlink" title="采样到illegal_bins仿真会停止"></a>采样到illegal_bins仿真会停止</h4><h1 id="六、覆盖选项"><a href="#六、覆盖选项" class="headerlink" title="六、覆盖选项"></a>六、覆盖选项</h1><h2 id="1-单个实例的覆盖率：查看单个覆盖率option-per-instance-1"><a href="#1-单个实例的覆盖率：查看单个覆盖率option-per-instance-1" class="headerlink" title="1 单个实例的覆盖率：查看单个覆盖率option.per_instance = 1"></a>1 单个实例的覆盖率：查看单个覆盖率option.per_instance = 1</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112214219083.png" alt="image-20211112214219083"></p><h2 id="2-添加注释-option-commet-string"><a href="#2-添加注释-option-commet-string" class="headerlink" title="2 添加注释 option.commet = string*"></a>2 添加注释 option.commet = string*</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215446401.png" alt="："></p><h2 id="3-覆盖次数限定：option-at-least"><a href="#3-覆盖次数限定：option-at-least" class="headerlink" title="3 覆盖次数限定：option.at_least"></a>3 覆盖次数限定：option.at_least</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215549608.png" alt="image-20211112215549608"></p><h2 id="4-覆盖率目标：option-goal"><a href="#4-覆盖率目标：option-goal" class="headerlink" title="4 覆盖率目标：option.goal"></a>4 覆盖率目标：option.goal</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215611103.png" alt="image-20211112215611103"></p><h2 id="5-covergroup方法"><a href="#5-covergroup方法" class="headerlink" title="5 covergroup方法"></a>5 covergroup方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215640227.png" alt="image-20211112215640227"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">get_coverage()<span class="hljs-comment">//所有group加权以后的覆盖率</span><br>get_inst_coverage()<span class="hljs-comment">//特定覆盖组实例覆盖率</span><br><span class="hljs-comment">//返回的0-100实数就是百分比</span><br>set_inst_name(<span class="hljs-keyword">string</span>)设置覆盖组名称<br></code></pre></div></td></tr></table></figure><h1 id="七、数据分析"><a href="#七、数据分析" class="headerlink" title="七、数据分析"></a>七、数据分析</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p><strong>获得总体覆盖率</strong>：使用系统函数，或使用<code>get_inst_coverage()</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215930314.png" alt="image-20211112215930314"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通5：线程的控制和同步</title>
    <link href="/202111112121/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-2%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5/"/>
    <url>/202111112121/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-2%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程的使用"><a href="#一、线程的使用" class="headerlink" title="一、线程的使用"></a>一、线程的使用</h1><h2 id="1-程序和模块"><a href="#1-程序和模块" class="headerlink" title="1 程序和模块"></a>1 程序和模块</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112113901134.png" alt="image-20211112113901134"></p><p><em>硬件之间有很多过程快，它们之间的通信可以理解为不同逻辑/时序块之间的通信或者同步，是通过信号变化来完成的</em></p><p>verilog通过always,initial过程语句块和<strong>信号</strong>连接建立进程间通信</p><p>将module看作独立的过程快，它们之间的同步通过</p><ul><li>信号的变化(event触发)</li><li>等待特定事件(时钟周期)</li><li>时间(固定延时)完成</li></ul><h3 id="module示意图"><a href="#module示意图" class="headerlink" title="module示意图"></a>module示意图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112114323500.png" alt="image-20211112114323500"></p><p>不同模块可以看作不同进程</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115621758.png" alt="image-20211112115621758"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115724226.png" alt="image-20211112115724226"></p><p>答案：AB</p><h2 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2 什么是线程"></a>2 什么是线程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115825884.png" alt="image-20211112115825884"></p><p>线程可以结束，也可以选择不结束</p><hr><h3 id="测试题：降低仿真时的内存负载"><a href="#测试题：降低仿真时的内存负载" class="headerlink" title="测试题：降低仿真时的内存负载"></a>测试题：降低仿真时的内存负载</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112120037482.png" alt="image-20211112120037482"></p><p>答案：ABCD</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112120538650.png" alt="image-20211112120538650"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join</span><span class="hljs-comment">//里面的语句都是并行的</span><br><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join_any</span><br><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join_none</span><br></code></pre></div></td></tr></table></figure><h2 id="3-线程概念澄清"><a href="#3-线程概念澄清" class="headerlink" title="3 线程概念澄清"></a>3 线程概念澄清</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124235862.png" alt="image-20211112124235862"></p><h1 id="二、线程的控制"><a href="#二、线程的控制" class="headerlink" title="二、线程的控制"></a>二、线程的控制</h1><h2 id="1-fork并行线程语句块"><a href="#1-fork并行线程语句块" class="headerlink" title="1 fork并行线程语句块"></a>1 fork并行线程语句块</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124359432.png" alt="image-20211112124359432"></p><p>对比图</p><ul><li><p>join等待所有子线程运行结束后进行后面的主线程</p></li><li><p>join_any任何一个线程结束就直接就直接进行主线程（其他T1,T2线程也继续运行）</p></li><li><p>join_none开辟子线程后直接进行之后的主线程</p></li></ul><h2 id="2-fork…join"><a href="#2-fork…join" class="headerlink" title="2 fork…join"></a>2 fork…join</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124750443.png" alt="image-20211112124750443"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124830167.png" alt="image-20211112124830167"></p><h2 id="3-join-any"><a href="#3-join-any" class="headerlink" title="3 join_any"></a>3 join_any</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124915926.png" alt="image-20211112124915926"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124956438-16366925968321.png" alt="image-20211112124956438"></p><h2 id="4-fork…join-none"><a href="#4-fork…join-none" class="headerlink" title="4 fork…join_none"></a>4 fork…join_none</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125112200.png" alt="image-20211112125112200">4</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125139712.png" alt="image-20211112125139712"></p><h2 id="5-等待所有衍生线程：wait-fork"><a href="#5-等待所有衍生线程：wait-fork" class="headerlink" title="5 等待所有衍生线程：wait fork"></a>5 等待所有衍生线程：wait fork</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125421840.png" alt="image-20211112125421840"></p><p><code>wait fork</code></p><h2 id="6-停止单个线程、停止多个线程：disable"><a href="#6-停止单个线程、停止多个线程：disable" class="headerlink" title="6 停止单个线程、停止多个线程：disable"></a>6 停止单个线程、停止多个线程：disable</h2><h3 id="停止单个线程"><a href="#停止单个线程" class="headerlink" title="停止单个线程"></a>停止单个线程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125517978.png" alt="image-20211112125517978"></p><h3 id="停止多个线程"><a href="#停止多个线程" class="headerlink" title="停止多个线程"></a>停止多个线程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132512284.png" alt="image-20211112132512284"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">disable</span> <span class="hljs-keyword">fork</span>;<span class="hljs-comment">//停止所有衍生子线程</span><br></code></pre></div></td></tr></table></figure><h3 id="停止多次被调用的任务"><a href="#停止多次被调用的任务" class="headerlink" title="停止多次被调用的任务"></a>停止多次被调用的任务</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132611826.png" alt="image-20211112132611826"></p><p>disable会停止所有<strong>同名</strong>线程</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132651261.png" alt="image-20211112132651261"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133030715.png" alt="image-20211112133030715"></p><h2 id="7-僵尸线程"><a href="#7-僵尸线程" class="headerlink" title="7 僵尸线程"></a>7 僵尸线程</h2><p>join_none , join_any 的线程，父线程很快结束后，子线程仍在运行，子线程不会被回收，称这些子线程为僵尸线程</p><ul><li>因此需要给fork起名字，给他手动disable关掉</li><li>父线程触发event使得外部程序disable子线程</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112163246395.png" alt="image-20211112163246395"></p><h1 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>SV一共就三种线程通信方法，三个要素只有event不需要用new，但仍然可以看作一个对象因为同样需要调用方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133200873.png" alt="image-20211112133200873"></p><p>线程之间通过mailbox搅浑数据，SV称之为IPC(Interprocess Communication)</p><h2 id="2-event事件"><a href="#2-event事件" class="headerlink" title="2 event事件"></a>2 event事件</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p>verilog中一个线程总是要等待一个带@操作符的时间。这个操作符是边沿敏感的，所以它总是阻塞着、等待的时间变化</p><p>SV中抽象出来，称为<code>event</code>，其他线程可以通过<code>-&gt;</code>操作符<strong>触发</strong>事件，结束对线程的阻塞（constraint里面也学过箭头）</p><p>三个要素只有event不需要用new，但仍然可以看作一个对象因为同样需要调用方法</p><h3 id="2-在event的边沿阻塞"><a href="#2-在event的边沿阻塞" class="headerlink" title="(2) 在event的边沿阻塞"></a>(2) 在event的边沿阻塞</h3><h4 id="直接-e"><a href="#直接-e" class="headerlink" title="直接 @ e ;"></a>直接 <code>@ e ;</code></h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133804979.png" alt="image-20211112133804979"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133852009.png" alt="image-20211112133852009"></p><p>@ event 的时候事件时，因为事件只在当前时间步长保持，所以会丢失event</p><p>delta cycle使得同一时间内没法确认是t1先执行还是t2先执行，这样的化肯定有一个线程等不到事件</p><p>triggered是一个类似留言的功能，即询问事件是否<strong>被</strong>触发过</p><p><strong>修改内容：</strong></p><ul><li>event 触发在 wait triggered之前则不会等待到</li><li>event 触发在 wait triggered 时或之后才会等待到</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162540357.png" alt="image-20211112162540357"></p><h5 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h5><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">事件的触发状态只会在当前时间步长保持，一但仿真开始向前运行，就会失去这个状态。也就是说，在仿真时间20的这个时间步长中（可以把它想象成1ns或1ps），事件是处于触发状态的，到21仿真时间后触发状态消失。在上面的代码中，两个阻塞等待<span class="hljs-meta">@和.triggered都是和事件触发同时发生的，出现了竞争条件，结果是虽然触发和等待发生在同一个仿真时间，但是还有执行顺序，根据代码顺序，先执行事件的触发，由于</span><span class="hljs-meta">@事件控制是边沿敏感的，等到执行</span><span class="hljs-meta">@语句时，事件的触发的“上升沿”已经消失，所以</span><span class="hljs-meta">@并没有被触发，而</span><span class="hljs-meta">@和.triggered的不同就在于此，</span><span class="hljs-meta">@是边沿敏感，后者是电平敏感，所以在整个20仿真时间步长中，wait语句都能被触发。</span><br>触发和等待在同一时间开始的话就不要用<span class="hljs-meta">@改用.triggered，当然如果触发进程在等待进程（的仿真时间）之前发生，那这两种等待都不会收到trigger。</span><br>其实将Thread2initial块移动到Thread1 initial块之前，也能让<span class="hljs-meta">@阻塞等待被触发，这就是因为</span><span class="hljs-meta">@的执行顺序在触发事件之前</span><br></code></pre></div></td></tr></table></figure><h4 id="修改为-wait-e-triggered"><a href="#修改为-wait-e-triggered" class="headerlink" title="修改为 wait(e.triggered)"></a>修改为 <code>wait(e.triggered)</code></h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141011384.png" alt="image-20211112141011384"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161825960.png" alt="image-20211112161825960"></p><p>triggered引起阻塞（@e 是电平敏感，当event被触发则该语句一直运行）</p><h3 id="3-通知的需求"><a href="#3-通知的需求" class="headerlink" title="(3) 通知的需求"></a>(3) 通知的需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141711216.png" alt="image-20211112141711216"></p><h3 id="把-bit-变成-event"><a href="#把-bit-变成-event" class="headerlink" title="把 bit 变成 event"></a>把 bit 变成 event</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141828286.png" alt="image-20211112141828286"></p><h4 id="扩展：多次触发"><a href="#扩展：多次触发" class="headerlink" title="扩展：多次触发"></a>扩展：多次触发</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141911727.png" alt="image-20211112141911727"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162011904.png" alt="image-20211112162011904"></p><h3 id="4-，wait-triggered-和-wait-triggered-比较总结"><a href="#4-，wait-triggered-和-wait-triggered-比较总结" class="headerlink" title="(4) @ ，wait triggered() 和 wait triggered 比较总结"></a>(4) @ ，wait triggered() 和 wait triggered 比较总结</h3><ul><li><p>wait trigger()方法只能等待一次</p></li><li><p>等待event反复可以用@，也可以wait trigger状态变量</p></li><li><p>当你学习了UVM的event，UVM的event也有trigger状态，同时trigger状态可以清除掉</p><ul><li>SV比较老旧没有清除trigger语句</li></ul></li></ul><h3 id="5-wait-order与事件合并"><a href="#5-wait-order与事件合并" class="headerlink" title="(5) wait_order与事件合并"></a>(5) wait_order与事件合并</h3><p>参考博客：<a href="https://blog.csdn.net/weixin_43249032/article/details/84035517">https://blog.csdn.net/weixin_43249032/article/details/84035517</a></p><hr><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162647861.png" alt="image-20211112162647861"></p><p>答案：CD</p><p>多次触发</p><h2 id="3-semaphore旗语"><a href="#3-semaphore旗语" class="headerlink" title="3 semaphore旗语"></a>3 semaphore旗语</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p><strong>实现对统一资源的访问和控制</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112143230138.png" alt="image-20211112143230138"></p><ul><li>new()：创建实例，参数指定创建钥匙数，无参数表示没有</li><li>get()：获取一把或多把钥匙</li><li>put()：返回一把或多把钥匙，没有参数默认一把</li><li>try_get()：非阻塞的获取钥匙，1表示由足够多钥匙0表示钥匙不够</li></ul><h3 id="2-例子：总线访问，实现只有一个设备进行访问"><a href="#2-例子：总线访问，实现只有一个设备进行访问" class="headerlink" title="(2) 例子：总线访问，实现只有一个设备进行访问"></a>(2) 例子：总线访问，实现只有一个设备进行访问</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112143627456.png" alt="image-20211112143627456"></p><p>sequencer都是对总想进行访问的</p><p>可以理解为stimulator</p><p><strong>用完钥匙一定要归还</strong>，如果不归还，get会阻塞产生死锁</p><h3 id="3-资源共享需求"><a href="#3-资源共享需求" class="headerlink" title="(3) 资源共享需求"></a>(3) 资源共享需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144750770.png" alt="image-20211112144750770"></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144846154.png" alt="image-20211112144846154"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144925767.png" alt="image-20211112144925767"></p><p><strong>先到先得的原则</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145005924.png" alt="image-20211112145005924"></p><h4 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145046709.png" alt="image-20211112145046709"></p><p>答案：ABCD</p><h4 id="进阶：semaphora过于自由，使用时需要限制"><a href="#进阶：semaphora过于自由，使用时需要限制" class="headerlink" title="进阶：semaphora过于自由，使用时需要限制"></a>进阶：semaphora过于自由，使用时需要限制</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145739949.png" alt="image-20211112145739949"></p><p>carkeep：车管家</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150028598.png" alt="image-20211112150028598"></p><h2 id="4-mailbox信箱子"><a href="#4-mailbox信箱子" class="headerlink" title="4 mailbox信箱子"></a>4 mailbox信箱子</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p><strong>主要是放置数据进行缓存</strong>，线程同步用event，信息传递用mailbox</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150157938.png" alt="image-20211112150157938"></p><ul><li>new：例化，可选参数size不一样了时存储的最大容量，0是无限大</li><li>put()：放入数据</li><li>get()：移除数据</li><li>peek()：只拷贝，不删除</li><li>try_put , try_get , try_peek</li></ul><h3 id="2-在进程间使用信箱通信"><a href="#2-在进程间使用信箱通信" class="headerlink" title="(2) 在进程间使用信箱通信"></a>(2) 在进程间使用信箱通信</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150442051.png" alt="image-20211112150442051"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150506986-16367007075342.png" alt="image-20211112150506986"></p><p>细节在于为何mailbox是1，可以保证每次不需要传递过多数据，顺序不会变化</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112155326431.png" alt="image-20211112155326431"></p><h3 id="3-数据通信的需求：实际情况"><a href="#3-数据通信的需求：实际情况" class="headerlink" title="(3) 数据通信的需求：实际情况"></a>(3) 数据通信的需求：实际情况</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160103076.png" alt="image-20211112160103076"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160108460.png" alt="image-20211112160108460"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160027584.png" alt="image-20211112160027584"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160133669.png" alt="image-20211112160133669"></p><p>答案：ABCD</p><h3 id="4-数据通信的需求（续）"><a href="#4-数据通信的需求（续）" class="headerlink" title="(4) 数据通信的需求（续）"></a>(4) 数据通信的需求（续）</h3><p>对于mailbox的用法，同FIFO类似</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160219361.png" alt="image-20211112160219361"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160322083.png" alt="image-20211112160322083"></p><p><code>把mailbox替换成队列</code></p><h4 id="mailbox与quence的区别（重要）"><a href="#mailbox与quence的区别（重要）" class="headerlink" title="mailbox与quence的区别（重要）"></a>mailbox与quence的区别（重要）</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160515785.png" alt="image-20211112160515785"></p><h4 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160642148.png" alt="image-20211112160642148"></p><p>答案：BC</p><h3 id="5-mailbox-其他特性"><a href="#5-mailbox-其他特性" class="headerlink" title="(5) mailbox 其他特性"></a>(5) mailbox 其他特性</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160735856.png" alt="image-20211112160735856"></p><h3 id="6-进程同步的需求"><a href="#6-进程同步的需求" class="headerlink" title="(6) 进程同步的需求"></a>(6) 进程同步的需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160808988.png" alt="image-20211112160808988"></p><h4 id="event同步"><a href="#event同步" class="headerlink" title="event同步"></a>event同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160902694.png" alt="image-20211112160902694"></p><h4 id="semaphora同步"><a href="#semaphora同步" class="headerlink" title="semaphora同步"></a>semaphora同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160949039.png" alt="image-20211112160949039"></p><h4 id="mailbox同步"><a href="#mailbox同步" class="headerlink" title="mailbox同步"></a>mailbox同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161021129.png" alt="image-20211112161021129"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161050057.png" alt="image-20211112161050057"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161101075.png" alt="image-20211112161101075"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161126705.png" alt="image-20211112161126705"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识5-2：UVM简介</title>
    <link href="/202111112121/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-3%EF%BC%9AUVM%E7%AE%80%E4%BB%8B/"/>
    <url>/202111112121/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-3%EF%BC%9AUVM%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>为什么现在讲：</p><p>实验四、实验五、带着UVM思维考虑</p><p>实验四实验五mcdf阶段，DUT变大了，我们主要讲如何将验证结构extend，对mcdf进行扩展</p><h1 id="一、UVM简介"><a href="#一、UVM简介" class="headerlink" title="一、UVM简介"></a>一、UVM简介</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111212500649.png" alt="image-20211111212500649"></p><p>sv标准：2002—&gt;2012—&gt;2017</p><p>2011年：UVM发布(Universal Verification Methodology)，各种M指的是Methodology</p><p>UVM是验证敲门砖</p><p>动态仿真，性能验证和效能验证都和动态仿真（功能验证）有关</p><p>动态仿真离不开硬件加速</p><p>静态</p><hr><p><strong>语言趋势</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213037283.png" alt="image-20211111213037283"></p><hr><p>UVM吸取了各种M(AVM,OVM,UVM)的优点，且不绑定某一语言</p><p>为什么：<strong>验证方法注重可重用的类</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213047259.png" alt="image-20211111213047259"></p><p><strong>底下一定要多画结构</strong></p><hr><p><strong>UVM什么数字的都可以验</strong></p><p>他就是库，基于SV提供的一系列方法类库，提供一系列基础类库，UVM提供的类库和基本的验证结构可以很快的构建起来验证平台</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213507233.png" alt="image-20211111213507233"></p><hr><h3 id="学习UVM的路线"><a href="#学习UVM的路线" class="headerlink" title="学习UVM的路线"></a>学习UVM的路线</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111215918881.png" alt="image-20211111215918881"></p><p> mcdf相比mcdt来讲：大家共有channel和arbiter；mcdf多了个寄存器模块和Formatter模块，设计变复杂了</p><p>寄存器功能：配置功能、反应硬件状态，所以说既可写又可读，本身是硬件的一部分</p><h3 id="UVM类库"><a href="#UVM类库" class="headerlink" title="UVM类库"></a>UVM类库</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111220320176.png" alt="image-20211111220320176"></p><p>P260页</p><p><strong>分成了总共十大类</strong>：注意分类逻辑和处理场景</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111220422340.png" alt="image-20211111220422340"></p><h3 id="UVM类"><a href="#UVM类" class="headerlink" title="UVM类"></a>UVM类</h3><p>按照类库地图可以分为以下几类：</p><ul><li>核心基类：为什么克隆啊，自动定义的，自动的做比较，自动的打印</li><li>工厂(factory)类</li><li>事务(transactoin)和序列(sequence)类：SV中的事务和序列有机的组合起来</li><li>结构创建(structure creation)类</li><li>环境组件(environment component)类：SV里面的stimulator,monitor,driver,isdfsdtor,checker</li><li>通信管道(channel)类：mailbox(实验三里面讲过)</li><li>信息报告(message report)类：(实验四讲独立信息报告的包)</li><li>寄存器模型(register model)类：独立的我们不讲了</li><li>线程同步(thread synchronization)类：旗语等等</li><li>书屋接口(transaction interface)类：发送数据包两个mailBox接起来，为什么要有接口呢？</li></ul><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221214108.png" alt="image-20211111221214108"></p><p>答案：BCD</p><h1 id="二、UVM组件"><a href="#二、UVM组件" class="headerlink" title="二、UVM组件"></a>二、UVM组件</h1><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221245763.png" alt="image-20211111221245763"></p><p>MCDF中的组件按功能分为：激励器(stimulator)、监视器(monitor)、检查器(checker)</p><p><code>uvm_component</code>是非常重要的核心类，<strong>环境的组件类</strong></p><h3 id="1-环境组件类"><a href="#1-环境组件类" class="headerlink" title="(1) 环境组件类"></a>(1) 环境组件类</h3><p>方框里面的都继承于<code>uvm_component</code></p><ul><li>uvm_drivert：我们也学到了</li><li>uvm_monitort：我们也学到了</li><li>uvm_sequencer：不熟悉，承担了一部分generator的功能，目前我们的generator既要产生激励又要发送激励，sequener承担了发送激励的一部分，产生激励由另外一个类承担了</li><li>uvm_agent：我们也学到了</li><li>uvm_scoreboard：就是我们写的checker类</li><li>uvm_env</li><li>uvm_test</li></ul><p>其中uvm_env和uvm_test的差别会体现在实验三和实验四里面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221535268.png" alt="image-20211111221535268"></p><h2 id="2、构建MCDF顶层验证环境：构建UVM最终结构图"><a href="#2、构建MCDF顶层验证环境：构建UVM最终结构图" class="headerlink" title="2、构建MCDF顶层验证环境：构建UVM最终结构图"></a>2、构建MCDF顶层验证环境：构建UVM最终结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221954118.png" alt="image-20211111221954118"></p><p>目前这张图是我们到模块二的时候UVM应该是怎么样的形式</p><hr><p><strong>测试题</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111222034799.png" alt="image-20211111222034799"></p><p>答案：ABCD</p><p>sequencer是agent里面的常客，产生激励在上图中看不到，因为此时产生激励不属于UVM的结构，属于动态的产生激励的过程，属于sequence(和sequencer就差了一个字母)，我们后来学</p><hr><h1 id="三、UVM环境"><a href="#三、UVM环境" class="headerlink" title="三、UVM环境"></a>三、UVM环境</h1><h2 id="1、phase机制"><a href="#1、phase机制" class="headerlink" title="1、phase机制"></a>1、phase机制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p>我们讲完组件，就需要例化了吧，再进行组件之间的连接，最后运行</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111222431847.png" alt="image-20211111222431847"></p><p>SV中我们通过new()函数没法解决一个重要问题，就是无法保证例化的先后关系，即在验证层次中没法保证先例化顶层，再例化下一层</p><p>我们必须小心的不断通过new()里面进行嵌套，这个连接也成为了问题，需要确保上层例化了再对底层进行连接</p><p>UVM可以事先进行配置，不用等待例化（即phase机制）</p><p>phase机制名词上解释是阶段机制，就是按照阶段进行</p><h3 id="2-phase机制函数表"><a href="#2-phase机制函数表" class="headerlink" title="(2) phase机制函数表"></a>(2) phase机制函数表</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111224701109.png" alt="image-20211111224701109"></p><p><strong>在各个组件内部只需要去填充预定义好的方法</strong>，这些方法有的是函数、有的是任务</p><p>phase机制解决了，例化的先后关系，从而只需要在对应组件中定义需要的任务</p><h3 id="3-phase机制流程图"><a href="#3-phase机制流程图" class="headerlink" title="(3) phase机制流程图"></a>(3) phase机制流程图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225028176.png" alt="image-20211111225028176"></p><p><strong>总共九个阶段</strong>：图中少了一个final阶段（其他的是除了黄色快的阶段与函数表一一对应）</p><p>不一定都要在每个组件中实现所有方法，只需要实现对你有帮助的，其他阶段不定义就是空置的</p><p>黄色部分先不讲</p><h2 id="2、创建测试平台：流程图"><a href="#2、创建测试平台：流程图" class="headerlink" title="2、创建测试平台：流程图"></a>2、创建测试平台：流程图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225406992.png" alt="image-20211111225406992"></p><hr><p><strong>测试题</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225444256.png" alt="image-20211111225444256"></p><p>答案：ABCD</p><p>函数是不消耗时间的所以B是对的，new函数也不消耗时间</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
      <tag>缩写</tag>
      
      <tag>地图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识5-1：验证方法</title>
    <link href="/202111101732/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <url>/202111101732/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的方法"><a href="#一、验证的方法" class="headerlink" title="一、验证的方法"></a>一、验证的方法</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110173623922.png" alt="image-20211110173623922"></p><p>SystemC也会讲到</p><p>利用多种工具把覆盖率合并起来</p><p>通过脚本进行整合</p><h3 id="1、动态比较与脚本"><a href="#1、动态比较与脚本" class="headerlink" title="1、动态比较与脚本"></a>1、动态比较与脚本</h3><p><strong>（1） 动态比较（线上比对）</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110185101311.png" alt="image-20211110185101311"></p><pre><code class=" mermaid">graph LRstim激励 --&gt; DUTstim激励 --&gt;moniterDUT --&gt; 输出DUT --&gt; monitermoniter --&gt; checker</code></pre><p><strong>（2） 线下比对</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110190008403.png" alt="image-20211110190008403"></p><pre><code class=" mermaid">graph LRstim激励 --&gt; DUTstim激励 --&gt;moniterDUT --&gt; 输出DUT --&gt; monitermoniter --&gt; input文本moniter --&gt; output文本input文本 --&gt; Cmod算法模型Cmod算法模型 --&gt; output2文本output2文本 --&gt; 脚本处理output文本 --&gt; 脚本处理</code></pre><h2 id="2、主要方法分类"><a href="#2、主要方法分类" class="headerlink" title="2、主要方法分类"></a>2、主要方法分类</h2><ul><li>动态仿真(dynamic simulation)</li><li>静态检查(formail check)：不止包括形式验证，与形式验证有联系有差别</li><li>虚拟模型(virtual prototype)：ESL/SystemC</li><li>硬件加速(hardware acceleration)</li><li>电源功耗(power consumption)：UPF/CPF</li><li>性能评估(performance evaluation)</li></ul><p>一般这几种方法都会做</p><h1 id="二、具体介绍"><a href="#二、具体介绍" class="headerlink" title="二、具体介绍"></a>二、具体介绍</h1><h2 id="1、动态仿真"><a href="#1、动态仿真" class="headerlink" title="1、动态仿真"></a>1、动态仿真</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110190714272.png" alt="image-20211110190714272"></p><ul><li>定向测试</li><li>随机测试：比对：线上比对和线下比对</li><li>参考模型检查</li><li>断言检查</li></ul><p>检查方式：参考模型检查和断言检查</p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110193630426.png" alt="image-20211110193630426"></p><h2 id="2、静态检查"><a href="#2、静态检查" class="headerlink" title="2、静态检查"></a>2、静态检查</h2><p><strong>本身不需要仿真，工具选择至关重要</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110193740585.png" alt="image-20211110193740585"></p><ul><li>语法检查(syntax check)</li><li>语义检查(linting check)</li><li>跨时钟域检查(CDC , Cross-clock Domain Check)：一个设计中有两个以上的时钟信号，从一个时钟区域到另一个区域的同步问题</li><li>形式验证(formoal verification)</li></ul><h3 id="1-语法检查"><a href="#1-语法检查" class="headerlink" title="(1) 语法检查"></a>(1) 语法检查</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194018595.png" alt="image-20211110194018595"></p><h3 id="2-语义检查linting-check"><a href="#2-语义检查linting-check" class="headerlink" title="(2) 语义检查linting check"></a>(2) 语义检查linting check</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194102113.png" alt="image-20211110194102113"></p><ul><li><p>做完语法检查再语义检查</p></li><li><p>使用专用工具</p></li><li><p>主要内容：</p></li><li><ul><li>常见设计错误</li><li>影响覆盖率收敛的问题</li><li>可能会产生X值以及受其影响的设计部分（寄存器忘记复位会产生X）</li></ul></li></ul><h3 id="3-跨时钟域检查"><a href="#3-跨时钟域检查" class="headerlink" title="(3) 跨时钟域检查"></a>(3) 跨时钟域检查</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194619901.png" alt="image-20211110194619901"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194626550.png" alt="image-20211110194626550"></p><p><strong>重点：</strong></p><ul><li>无法通过常规的验证方法分析(即仿真的时候看不出来，门级仿真时的暴漏也是概论问题)</li><li>常规的验证方法验证（动态仿真）的是RTL阶段，无法体现建立保持时间，拿一个异步信号对另一个信号检查不会体现出来，建立保持时间在门级时暴露出来</li></ul><p><strong>为什么门级才暴漏，RTL就要做检查：</strong></p><ul><li>越往后耗费精力越大</li><li>门级问题仅仅有可能会发现（概率问题）</li></ul><p><strong>我们是怎么做的：</strong></p><ul><li>在早期RTL阶段识别出来跨时钟域电路有没有合适的同步处理（即跨时钟域检查CDC），保证所有跨时钟域信号能正确的同步</li><li>相关工具：Spyglass、0-In(Mentor)</li></ul><h3 id="4-形式验证"><a href="#4-形式验证" class="headerlink" title="(4) 形式验证"></a>(4) 形式验证</h3><ul><li>等价检查(EC , Equivalence Check)：LEC属于其中之一，用来保证两个电路的行为是等价的，可以用来检查不同抽象级的电路是否一致，例如RTL级和网表</li><li>属性检查(PC , Property Check)，又称模型检查(MC , Model Check)：电路行为通过验证语言来描述其属性property，随后通过静态方式来证明所有状态空间下都满足该条件，否则举出反例(counter example)来证明设计行为不符合属性描述(property description)</li></ul><p>属性检查用到的方法：SVA(SystemVerilog Assertion)、PSL(Property Specification Language)，不止SVA可以做属性检查PSL也可以。通过一些数学方法，证明在所有状态空间都满足属性的描述，若不满足，使用形式验证工具就会给出反例</p><p>SVA不止可以用在形式验证中做属性检查，也可以用在动态仿真里</p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110200421837.png" alt="image-20211110200421837"></p><p>答案：没说</p><h2 id="3、虚拟模型"><a href="#3、虚拟模型" class="headerlink" title="3、虚拟模型"></a>3、虚拟模型</h2><p>同样的一种对硬件抽象的模型，只不过抽象级更高</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110200648852.png" alt="image-20211110200648852"></p><p>虚拟模型是由SystemC构建的，软件基于虚拟模型来完成早期软件开发</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110203115942.png" alt="image-20211110203115942"></p><h3 id="目前软件是怎么做的第一段"><a href="#目前软件是怎么做的第一段" class="headerlink" title="目前软件是怎么做的第一段"></a>目前软件是怎么做的第一段</h3><p>什么时候开发：</p><h4 id="传统（古老方式）："><a href="#传统（古老方式）：" class="headerlink" title="传统（古老方式）："></a>传统（古老方式）：</h4><p>我们的RTL、Gate和TO，硬件走完了，系统比较稳定了，再到到板上测试</p><pre><code class=" mermaid">graph LRsoftware流程RTL--&gt;Gate --&gt; TO--&gt;流片--&gt;测试板上运行</code></pre><h4 id="现在的方式（没标注流片）："><a href="#现在的方式（没标注流片）：" class="headerlink" title="现在的方式（没标注流片）："></a>现在的方式（没标注流片）：</h4><pre><code class=" mermaid">graph LRsoftware流程RTL --系统比较稳定的时候--&gt;上板子fpga原型开发/EMO模拟器上面--&gt; Gate --&gt; TO --&gt; FinalESL --&gt; Final</code></pre><h3 id="第二段就是Fpga我们的原型开发"><a href="#第二段就是Fpga我们的原型开发" class="headerlink" title="第二段就是Fpga我们的原型开发"></a>第二段就是Fpga我们的原型开发</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110204201542.png" alt="image-20211110204201542"></p><p>开发ESL往往是一些算法的人，一些系统工程师，与designer不同，如果ESL相差不大可以基于ESL开发软件，但流片后仍然需要修改（ESL抽象级过高，如等待状态的时间无法确定）</p><h3 id="接上文第三段"><a href="#接上文第三段" class="headerlink" title="接上文第三段"></a>接上文第三段</h3><p>SystemC是可综合的，构建ESL的模型，可以经过verilog或直接跳过直接生成网表，使得算法直接综合为网表</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110204844698.png" alt="image-20211110204844698"></p><p>为什么我们一般不用这种方式：</p><ul><li><p>软件架构一般很大，硬件架构迭代很慢</p></li><li><p>ESL对于目前来说无法验证，机器翻译映射出来的内容很难理解</p></li></ul><h3 id="第四段"><a href="#第四段" class="headerlink" title="第四段"></a>第四段</h3><p>子系统落后于进度，测试用例没法做了，碰到这种情况把ESL暂时替代RTL的模型</p><p>一个SystemC可以非常抽象，可以没有时序没有硬件端口，但有些语法可以让你实现端口和时序</p><p>因此无论如何需要改造的，暂时性嵌入罢了</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110205930657.png" alt="image-20211110205930657"></p><p>系统工程师需要写ESL模型和功能描述文档，即ESL模型功能代表希望实现的模型，这种模型不仅可以嵌入到SOC上辅助功能验证赶上进度，同时集成到UVM和SV中做RefenceModel，红宝书17章17.2节UV.r的这样一个包</p><p>更早暴漏功能问题，提早完成窗口需求</p><h3 id="虚拟模型流程"><a href="#虚拟模型流程" class="headerlink" title="虚拟模型流程"></a>虚拟模型流程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110210340141.png" alt="image-20211110210340141"></p><p>RTL—&gt;SystemC模型：不同公司开发流程不一样，有一帮人（虚拟建模组），从RTL中抽取称为SC模型，这种不能做RefenceModel，但可以做硬件模型因为理论上一致，有助于软件开发</p><p>虚拟模型岗位不多</p><h2 id="4、硬件加速"><a href="#4、硬件加速" class="headerlink" title="4、硬件加速"></a>4、硬件加速</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110210738434.png" alt="image-20211110210738434"></p><p>仿真速度存在限制</p><p>软件团队把代码瘦身然后交给硬件团队</p><h3 id="主要硬件加速平台"><a href="#主要硬件加速平台" class="headerlink" title="主要硬件加速平台"></a>主要硬件加速平台</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111202935736.png" alt="image-20211111202935736"></p><ul><li>FPGA：专门为软件提供，为什么：主要因为速度快是emulatior的几千到上万倍</li><li>专用模拟器(emulatior)：又是是仿真器的上千倍速度；由主流EDA公司提供（可以理解为FPGA+仿真器？）</li></ul><p><strong>速度比较：</strong></p><p>FPGA &gt; emulation &gt; simulation仿真</p><p><strong>比较：</strong></p><p>模拟器的调试比fpga方便，且速度比反正快，用于测试硬件（提高仿真速度）</p><p>FPGA往往是硬件已经得到充分验证后，用它做软件开发，而不是硬件验证</p><p>仿真器和模拟器都可以设置断点，而FPGA不可以</p><p><strong>EDA提供的模拟器如何实现：</strong>绝大多数模拟器内部都是FPGA，EDA公司只是基于定制的FPGA基础上做了软件开发，明白信号如何查看，且具有仿真器技术；为什么EDA公司做这个：附加值高</p><p>IC公司里模拟器资源宝贵，每个人使用要排队</p><h2 id="5、效能验证"><a href="#5、效能验证" class="headerlink" title="5、效能验证"></a>5、效能验证</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111204524451.png" alt="image-20211111204524451"></p><h3 id="1-效能验证分类"><a href="#1-效能验证分类" class="headerlink" title="(1) 效能验证分类"></a>(1) 效能验证分类</h3><p>这里我们主要针对硅前设计阶段进行效能验证，涉及的流程可分为两个部分</p><ul><li><p>功能验证：主要采用PA(Power Aware)( 主要包括由UPF(Unified Power Format) 或者CPF(Comment Power Format) ) 方式，通过与仿真器结合，模拟电源域的开关进行设计检查</p><ul><li><p>需要进入相关环境中跑仿真</p></li><li><p>多个电源域需要考虑不同电源域之间会不会有影响，什么时候开关某些电源域</p></li></ul></li><li><p><strong>功耗预测与优化：</strong>通过第三方功耗分析工具，结合仿真数据(FSDB/VCD/SAIF)，进行功耗预测，并给出分析结果</p><ul><li>不同仿真器保存下来数据格式不同(FSDB/VCD/SAIF)</li><li>数据交给第三方工具分析，进行功耗预测</li><li>RTL、Gate级都可以做预测，在门级做功耗预测真准确，RTL也要预测因为越早测结果越早分析越早优化硬件和软件</li></ul></li></ul><h3 id="2-效应验证-UPF-CPF-：从硬件或软件角度，我们一般会采用到的节能技术"><a href="#2-效应验证-UPF-CPF-：从硬件或软件角度，我们一般会采用到的节能技术" class="headerlink" title="(2) 效应验证(UPF/CPF)：从硬件或软件角度，我们一般会采用到的节能技术"></a>(2) 效应验证(UPF/CPF)：从硬件或软件角度，我们一般会采用到的节能技术</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111205708266.png" alt="image-20211111205708266"></p><ul><li><p><strong>多核与聚合结构：</strong>大小核结构</p><ul><li>高性能用大核心，低性能用小核心，但带来问题是面积增大<ul><li>扩展：原来每个子系统中心需要有核心进行调度控制各个子系统，中心的核心太慢了怎么办，把中心核变成小核，其他各个系统都带个核心自己控制，这就是一个聚合的结构</li></ul></li></ul></li><li><p><strong>多电压域：</strong>工作频率高电压高，频率低电压低</p></li></ul><h2 id="6、性能验证"><a href="#6、性能验证" class="headerlink" title="6、性能验证"></a>6、性能验证</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111210734687.png" alt="image-20211111210734687"></p><p>性能测试提前，硅前硅后使用相同测试用例，结果相差不大</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111211511327.png" alt="image-20211111211511327"></p><p>还是新颖概念，没有统一标准，更多的是在衡量指标（指标是由架构和系统工程师定的）</p><pre><code class=" mermaid">graph LR验证顺序功能验证 --&gt; 效能验证 --&gt; 性能验证</code></pre><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111211818512.png" alt="image-20211111211818512"></p><p>答案：ABCD</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110230643036.png" alt="miku"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通4：随机约束分布_约束块控制_数组约束_随机控制</title>
    <link href="/202111071946/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-2%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%88%86%E5%B8%83_%E7%BA%A6%E6%9D%9F%E5%9D%97%E6%8E%A7%E5%88%B6_%E6%95%B0%E7%BB%84%E7%BA%A6%E6%9D%9F_%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6/"/>
    <url>/202111071946/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-2%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%88%86%E5%B8%83_%E7%BA%A6%E6%9D%9F%E5%9D%97%E6%8E%A7%E5%88%B6_%E6%95%B0%E7%BB%84%E7%BA%A6%E6%9D%9F_%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、随机约束和分布"><a href="#一、随机约束和分布" class="headerlink" title="一、随机约束和分布"></a>一、随机约束和分布</h1><h2 id="1、为什么要有随机"><a href="#1、为什么要有随机" class="headerlink" title="1、为什么要有随机"></a>1、为什么要有随机</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194951207.png" alt="image-20211107194951207"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213400187.png" alt="image-20211107213400187"></p><h2 id="2、我们要随机什么"><a href="#2、我们要随机什么" class="headerlink" title="2、我们要随机什么"></a>2、我们要随机什么</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213528100.png" alt="image-20211107213528100"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213622944.png" alt="image-20211107213622944"></p><p>AC</p><h2 id="3、声明随机变量的类"><a href="#3、声明随机变量的类" class="headerlink" title="3、声明随机变量的类"></a>3、声明随机变量的类</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107220825182.png" alt="image-20211107220825182"></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::<span class="hljs-built_in">randomize</span>();<span class="hljs-comment">//随机化变量，返回值0成功1失败</span><br></code></pre></div></td></tr></table></figure><p>rand、randc以及constranint同随机变量一起在类中声明</p><p><strong>一般随机都会伴随着约束</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107220949467.png" alt="image-20211107220949467"></p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">assert</span></span>(<span class="hljs-variable">p.randomize</span>());一般用这种写法进行随机化</span><br></code></pre></div></td></tr></table></figure><h2 id="4、什么是约束"><a href="#4、什么是约束" class="headerlink" title="4、什么是约束"></a>4、什么是约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222030463.png" alt="image-20211107222030463"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222043352.png" alt="image-20211107222043352"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222056315.png" alt="image-20211107222056315"></p><p>AB</p><p>C不对的原因是位宽对不上</p><h3 id="什么是约束（续）：约束不能产生冲突"><a href="#什么是约束（续）：约束不能产生冲突" class="headerlink" title="什么是约束（续）：约束不能产生冲突"></a>什么是约束（续）：约束不能产生冲突</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222236599.png" alt="image-20211107222236599"></p><h2 id="5、权重的分布：dist"><a href="#5、权重的分布：dist" class="headerlink" title="5、权重的分布：dist"></a>5、权重的分布：dist</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222507828.png" alt="image-20211107222507828"></p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-symbol">:/</span>或<span class="hljs-symbol">:</span>=<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222547302.png" alt="image-20211107222547302"></p><p><code>:=</code>意味着常量相加</p><p><code>:/</code>意味着比例平分</p><h2 id="六、集合成员和inside运算符"><a href="#六、集合成员和inside运算符" class="headerlink" title="六、集合成员和inside运算符"></a>六、集合成员和inside运算符</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222830531.png" alt="image-20211107222830531"></p><p><code>inside</code>规定区间</p><p><code>$</code>表示最大值或最小值</p><h2 id="7、条件约束"><a href="#7、条件约束" class="headerlink" title="7、条件约束"></a>7、条件约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222948156.png" alt="image-20211107222948156"></p><h2 id="8、双向约束"><a href="#8、双向约束" class="headerlink" title="8、双向约束"></a>8、双向约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107223027629.png" alt="image-20211107223027629"></p><p><strong>约束是声明语句，是并行的</strong></p><p>不同约束之间会产生冲突，如子类继承父类的约束(约束也可以继承)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107223222650.png" alt="image-20211107223222650"></p><h1 id="二、约束块控制"><a href="#二、约束块控制" class="headerlink" title="二、约束块控制"></a>二、约束块控制</h1><h2 id="1、打开或关闭约束"><a href="#1、打开或关闭约束" class="headerlink" title="1、打开或关闭约束"></a>1、打开或关闭约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152432117.png" alt="image-20211110152432117"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">constraint_mode()<span class="hljs-comment">//打开或关闭约束</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152538507.png" alt="image-20211110152538507"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">p<span class="hljs-variable">.constrain_mode</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//关闭p内全部约束</span><br>p<span class="hljs-variable">.c_short</span><span class="hljs-variable">.constrain_mode</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//打开c_short约束</span><br></code></pre></div></td></tr></table></figure><p>与条件约束的不同，条件约束是在一个约束内进行判断，约束控制可以控制多个约束</p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152844072.png" alt="image-20211110152844072"></p><p>D</p><h2 id="2、内嵌约束"><a href="#2、内嵌约束" class="headerlink" title="2、内嵌约束"></a>2、内嵌约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153056081.png" alt="image-20211110153056081"></p><p>使用<code>randomize() with</code>来增加临时约束，<strong>参考下图绿色部分</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153157520.png" alt="image-20211110153157520"></p><h3 id="重要-测试题：soft软约束"><a href="#重要-测试题：soft软约束" class="headerlink" title="(重要)测试题：soft软约束"></a>(重要)测试题：soft软约束<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153224798.png" alt="image-20211110153224798"></h3><p>soft红色标注部分，没有soft选B，有soft选C</p><p>软约束<code>soft</code>，约束有冲突时soft声明的约束不起作用</p><h1 id="三、随机函数"><a href="#三、随机函数" class="headerlink" title="三、随机函数"></a>三、随机函数</h1><h3 id="1、无论是rand还是constraint能出现的范围就是类"><a href="#1、无论是rand还是constraint能出现的范围就是类" class="headerlink" title="1、无论是rand还是constraint能出现的范围就是类"></a>1、无论是rand还是constraint能出现的范围就是类</h3><p><strong>我们更希望把随机变量用<code>rand</code>或<code>randc</code>修饰，把他们封装到类里面</strong>：类是变量的自洽体，可以把相关的变量放在类里，变量之间的约束关系也可以方便的放在类里面</p><p><strong>无论是rand还是constraint能出现的范围就是类</strong></p><h3 id="2、randomize-预定义函数的解释，以及pre-randomize-和post-randomize-可自定义"><a href="#2、randomize-预定义函数的解释，以及pre-randomize-和post-randomize-可自定义" class="headerlink" title="2、randomize()预定义函数的解释，以及pre_randomize()和post_randomize()可自定义"></a>2、randomize()预定义函数的解释，以及pre_randomize()和post_randomize()可自定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153907765.png" alt="image-20211110153907765"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">pre_randomzie();<br>post_randomzie();<br></code></pre></div></td></tr></table></figure><p>randomize() 回调函数</p><h3 id="3、系统函数：随机数函数"><a href="#3、系统函数：随机数函数" class="headerlink" title="3、系统函数：随机数函数"></a>3、系统函数：随机数函数</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110154802930.png" alt="image-20211110154802930"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-built_in">$random</span>()<br>$urandom()<br>$urandom_range()<br></code></pre></div></td></tr></table></figure><h2 id="4、-随机化个别变量"><a href="#4、-随机化个别变量" class="headerlink" title="4、 随机化个别变量"></a>4、 随机化个别变量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110155807524.png" alt="image-20211110155807524"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">randomize(变量名)<span class="hljs-comment">//只会随机化指定变量名，不会随机化其他</span><br></code></pre></div></td></tr></table></figure><p><strong>你不管随机化哪些指定变量，所有作用的约束依然有效</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110160424516.png" alt="image-20211110160424516"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110160520930.png" alt="image-20211110160520930"></p><h3 id="所有的约束条件都必须满足，否则约束失败"><a href="#所有的约束条件都必须满足，否则约束失败" class="headerlink" title="所有的约束条件都必须满足，否则约束失败"></a>所有的约束条件都必须满足，否则约束失败</h3><p>答案选C<br>A不对的原因是因为med&lt;hi不满足<br>low=报错 是因为randomize无法产生非rand的low的值，med,hi保持一开始的0</p><h1 id="四、数组约束"><a href="#四、数组约束" class="headerlink" title="四、数组约束"></a>四、数组约束</h1><h2 id="1、数组的大小"><a href="#1、数组的大小" class="headerlink" title="1、数组的大小"></a>1、数组的大小</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110161515221.png" alt="image-20211110161515221"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">rand</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] d[];<br><span class="hljs-keyword">constraint</span> d_size&#123;d<span class="hljs-variable">.size</span>() <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]&#125; &#125;<br></code></pre></div></td></tr></table></figure><p>随机化内容：</p><ul><li>动态数组的长度</li><li>动态数组的内容</li></ul><p>随机化时应：对数组的大小给定范围，防止生成大体积或空数组(不限制动态数组范围，则数组无意义）</p><p>可以使用约束的方法：<code>sum()</code>,<code>product()</code>,<code>and()</code>,<code>or()</code>,<code>xor()</code></p><h3 id="2、约束数组中的元素"><a href="#2、约束数组中的元素" class="headerlink" title="2、约束数组中的元素"></a>2、约束数组中的元素</h3><p><code>`foreach</code>更方便，使用它进行约束</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162030080.png" alt="image-20211110162030080"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162040215.png" alt="image-20211110162040215"></p><h2 id="3、产生唯一元素值的数组与randc"><a href="#3、产生唯一元素值的数组与randc" class="headerlink" title="3、产生唯一元素值的数组与randc"></a>3、产生唯一元素值的数组与randc</h2><h3 id="1-不是使用randc，而是嵌套循环"><a href="#1-不是使用randc，而是嵌套循环" class="headerlink" title="(1) 不是使用randc，而是嵌套循环"></a>(1) 不是使用randc，而是嵌套循环</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162134117.png" alt="image-20211110162134117"></p><p><strong>randc不能使数组内每一个元素都不同，而是每一次randomize后随机数都不同</strong></p><h3 id="2-利用randc变量来辅助生成：randc类比扑克牌"><a href="#2-利用randc变量来辅助生成：randc类比扑克牌" class="headerlink" title="(2) 利用randc变量来辅助生成：randc类比扑克牌"></a>(2) 利用randc变量来辅助生成：randc类比扑克牌</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162943509.png" alt="image-20211110162943509"></p><p>randomize之前，自动先调用pre_randomize()</p><h3 id="3-SV新标准解决数组问题，关键词：unique"><a href="#3-SV新标准解决数组问题，关键词：unique" class="headerlink" title="(3) SV新标准解决数组问题，关键词：unique"></a>(3) SV新标准解决数组问题，关键词：unique</h3><p>unique限定一个数组，使其独一无二</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110165836345.png" alt="image-20211110165836345"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110165907602.png" alt="image-20211110165907602"></p><p>经常出错，答案是D</p><p>原因不是因为动态数组没有new，关键是动态数组有限定语<code>rand</code>，rand添加后指示<code>randomize</code>会帮助你例化填充这个元素</p><p>foreach这个约束不存在，不合理，需要增加if(i&lt;=da.size()-2()</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170350783.png" alt="image-20211110170350783"></p><h2 id="4、随机化句柄数组"><a href="#4、随机化句柄数组" class="headerlink" title="4、随机化句柄数组"></a>4、随机化句柄数组</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170428370.png" alt="image-20211110170428370"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170436764.png" alt="image-20211110170436764"></p><h3 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110171819881.png" alt="image-20211110171819881"></p><p>答案：B</p><p>RandStuff类里面没有被rand修饰的变量，因此作为句柄被上级对象随机的过程中无法对内部的变量值随机</p><p>为什么MAX_SIZE个例化，因为保证randomize所有句柄都指向一个对象都是合法的</p><h1 id="五、随机控制"><a href="#五、随机控制" class="headerlink" title="五、随机控制"></a>五、随机控制</h1><h2 id="1、随机序列：关键词，randsequence-atomic"><a href="#1、随机序列：关键词，randsequence-atomic" class="headerlink" title="1、随机序列：关键词，randsequence,atomic"></a>1、随机序列：关键词，randsequence,atomic</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172410044.png" alt="image-20211110172410044"></p><p><strong>没有用UVM之前，用这个产生激励</strong>，因此可做了解</p><p><code>randsequence(stream)</code></p><p><code>stream</code>是一个入口，可能会分别进入到，cfg_read,mem_read,io_read分支中，且进入的权重和可能性不一样</p><p>类比case语句</p><h2 id="2、随机控制：randcase"><a href="#2、随机控制：randcase" class="headerlink" title="2、随机控制：randcase"></a>2、随机控制：randcase</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172755254.png" alt="image-20211110172755254"></p><p><code>randcase</code>：一个随机决策树</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172828044.png" alt="image-20211110172828044"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识4：验证的管理</title>
    <link href="/202111021710/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <url>/202111021710/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的周期"><a href="#一、验证的周期" class="headerlink" title="一、验证的周期"></a>一、验证的周期</h1><h2 id="1-一个验证菜鸟在第一家公司第一个月的经历"><a href="#1-一个验证菜鸟在第一家公司第一个月的经历" class="headerlink" title="1.一个验证菜鸟在第一家公司第一个月的经历"></a>1.一个验证菜鸟在第一家公司第一个月的经历</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171144078.png" alt="image-20211102171144078"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171236404.png" alt="image-20211102171236404"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171321066.png" alt="image-20211102171321066"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171354986.png" alt="image-20211102171354986"></p><p><strong>AB</strong></p><h2 id="2-验证里程碑（RTL0-3，GLS，T0）"><a href="#2-验证里程碑（RTL0-3，GLS，T0）" class="headerlink" title="2.验证里程碑（RTL0~3，GLS，T0）"></a>2.验证里程碑（RTL0~3，GLS，T0）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171515725.png" alt="image-20211102171515725"></p><h3 id="RTL0：验证文档规范"><a href="#RTL0：验证文档规范" class="headerlink" title="RTL0：验证文档规范"></a>RTL0：验证文档规范</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171712289.png" alt="image-20211102171712289"></p><p>验证功能能规范</p><h3 id="RTL1：UVM模型"><a href="#RTL1：UVM模型" class="headerlink" title="RTL1：UVM模型"></a>RTL1：UVM模型</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171821935.png" alt="image-20211102171821935"></p><h3 id="RTL2：绝大多数核心节点的验证"><a href="#RTL2：绝大多数核心节点的验证" class="headerlink" title="RTL2：绝大多数核心节点的验证"></a>RTL2：绝大多数核心节点的验证</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102172042991.png" alt="image-20211102172042991"></p><h3 id="RTL3"><a href="#RTL3" class="headerlink" title="RTL3"></a>RTL3</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102172218157.png" alt="image-20211102172218157"></p><h3 id="GTS"><a href="#GTS" class="headerlink" title="GTS"></a>GTS</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105220900718.png" alt="image-20211105220900718"></p><p>RTL仿真与网表仿真？</p><h3 id="T0"><a href="#T0" class="headerlink" title="T0"></a>T0</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221532996.png" alt="image-20211105221532996"></p><h3 id="进入公司一定要看一下处于哪个验证周期"><a href="#进入公司一定要看一下处于哪个验证周期" class="headerlink" title="进入公司一定要看一下处于哪个验证周期"></a>进入公司一定要看一下处于哪个验证周期</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221654082.png" alt="image-20211105221654082"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221740561.png" alt="image-20211105221740561"></p><h1 id="二、验证三要素"><a href="#二、验证三要素" class="headerlink" title="二、验证三要素"></a>二、验证三要素</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221901393.png" alt="image-20211105221901393"></p><h2 id="2-时间管理"><a href="#2-时间管理" class="headerlink" title="2. 时间管理"></a>2. 时间管理</h2><h3 id="1-早行动"><a href="#1-早行动" class="headerlink" title="(1) 早行动"></a>(1) 早行动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221924054.png" alt="image-20211105221924054"></p><h3 id="2-时间管理之少依赖（对设计的依赖）"><a href="#2-时间管理之少依赖（对设计的依赖）" class="headerlink" title="(2) 时间管理之少依赖（对设计的依赖）"></a>(2) 时间管理之少依赖（对设计的依赖）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222546866.png" alt="image-20211105222546866"></p><h3 id="3-大局观"><a href="#3-大局观" class="headerlink" title="(3) 大局观"></a>(3) 大局观</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222759615.png" alt="image-20211105222759615"></p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222915443.png" alt="image-20211105222915443"></p><h2 id="3-人力资源安排"><a href="#3-人力资源安排" class="headerlink" title="3. 人力资源安排"></a>3. 人力资源安排</h2><h3 id="1-团队建设"><a href="#1-团队建设" class="headerlink" title="(1) 团队建设"></a>(1) 团队建设</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223159744.png" alt="image-20211105223159744"></p><h3 id="2-团队建设"><a href="#2-团队建设" class="headerlink" title="(2) 团队建设"></a>(2) 团队建设</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223327167.png" alt="image-20211105223327167"></p><h3 id="3-技术和管理"><a href="#3-技术和管理" class="headerlink" title="(3) 技术和管理"></a>(3) 技术和管理</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223508287.png" alt="image-20211105223508287"></p><h2 id="4-任务拆分和重组"><a href="#4-任务拆分和重组" class="headerlink" title="4. 任务拆分和重组"></a>4. 任务拆分和重组</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223719610.png" alt="image-20211105223719610"></p><h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223728950.png" alt="image-20211105223728950"></p><h3 id="任务重组"><a href="#任务重组" class="headerlink" title="任务重组"></a>任务重组</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105224058382.png" alt="image-20211105224058382"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105224959292.png" alt="image-20211105224959292"></p><h1 id="三、-验证的收敛"><a href="#三、-验证的收敛" class="headerlink" title="三、 验证的收敛"></a>三、 验证的收敛</h1><h2 id="1-概述：回归测试及考虑因素"><a href="#1-概述：回归测试及考虑因素" class="headerlink" title="1.概述：回归测试及考虑因素"></a>1.概述：回归测试及考虑因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105225537751.png" alt="image-20211105225537751"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107190623890.png" alt="image-20211107190623890"></p><ul><li>回归流程</li><li>回归质量</li><li>回归效率</li></ul><h2 id="2-回归流程"><a href="#2-回归流程" class="headerlink" title="2. 回归流程"></a>2. 回归流程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107190939681.png" alt="image-20211107190939681"></p><h3 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191052968.png" alt="image-20211107191052968"></p><p>B</p><h2 id="3-回归的质量"><a href="#3-回归的质量" class="headerlink" title="3. 回归的质量"></a>3. 回归的质量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191259842.png" alt="image-20211107191259842"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191309701.png" alt="image-20211107191309701"></p><h2 id="4-回归效率"><a href="#4-回归效率" class="headerlink" title="4. 回归效率"></a>4. 回归效率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191426112.png" alt="image-20211107191426112"></p><p>后期收益明显降低</p><h3 id="回归效率的提升"><a href="#回归效率的提升" class="headerlink" title="回归效率的提升"></a>回归效率的提升</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191520676.png" alt="image-20211107191520676"></p><h3 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191904194.png" alt="image-20211107191904194"></p><p>ABCD</p><h1 id="四、问题的跟踪"><a href="#四、问题的跟踪" class="headerlink" title="四、问题的跟踪"></a>四、问题的跟踪</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192037682.png" alt="image-20211107192037682"></p><h2 id="2-追踪的问题类型"><a href="#2-追踪的问题类型" class="headerlink" title="2. 追踪的问题类型"></a>2. 追踪的问题类型</h2><ul><li>系统功能定义问题</li><li>硬件设计问题</li><li>芯片验证环境问题</li><li>综合时序问题</li><li>硅前工具问题</li><li>引用库和IP问题</li></ul><h2 id="3-追踪工具"><a href="#3-追踪工具" class="headerlink" title="3. 追踪工具"></a>3. 追踪工具</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192309290.png" alt="image-20211107192309290"></p><h3 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192334890.png" alt="image-20211107192334890"></p><p>ABCD</p><h2 id="4-工具的功能"><a href="#4-工具的功能" class="headerlink" title="4. 工具的功能"></a>4. 工具的功能</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192413094.png" alt="image-20211107192413094"></p><p>记录、分类、派发、查找、追溯、报告</p><h2 id="5-追踪流程"><a href="#5-追踪流程" class="headerlink" title="5. 追踪流程"></a>5. 追踪流程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192552504.png" alt="image-20211107192552504"></p><h1 id="五、团队建设"><a href="#五、团队建设" class="headerlink" title="五、团队建设"></a>五、团队建设</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192636754.png" alt="image-20211107192636754"></p><h2 id="七个好习惯：追求百分百"><a href="#七个好习惯：追求百分百" class="headerlink" title="七个好习惯：追求百分百"></a>七个好习惯：追求百分百</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192732790.png" alt="image-20211107192732790"></p><h2 id="七个好习惯：保持面向对象的开发习惯"><a href="#七个好习惯：保持面向对象的开发习惯" class="headerlink" title="七个好习惯：保持面向对象的开发习惯"></a>七个好习惯：保持面向对象的开发习惯</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192929505.png" alt="image-20211107192929505"></p><h2 id="七个好习惯：合理复用"><a href="#七个好习惯：合理复用" class="headerlink" title="七个好习惯：合理复用"></a>七个好习惯：合理复用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193033349.png" alt="image-20211107193033349"></p><h2 id="七个好习惯：保持创新"><a href="#七个好习惯：保持创新" class="headerlink" title="七个好习惯：保持创新"></a>七个好习惯：保持创新</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193430794.png" alt="image-20211107193430794"></p><h2 id="七个好习惯：高效的沟通"><a href="#七个好习惯：高效的沟通" class="headerlink" title="七个好习惯：高效的沟通"></a>七个好习惯：高效的沟通</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193513702.png" alt="image-20211107193513702"></p><h2 id="七个好习惯：突破责任边界"><a href="#七个好习惯：突破责任边界" class="headerlink" title="七个好习惯：突破责任边界"></a>七个好习惯：突破责任边界</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193754756.png" alt="image-20211107193754756"></p><h1 id="六、验证的专业化"><a href="#六、验证的专业化" class="headerlink" title="六、验证的专业化"></a>六、验证的专业化</h1><h2 id="1、对验证的偏见"><a href="#1、对验证的偏见" class="headerlink" title="1、对验证的偏见"></a>1、对验证的偏见</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193905835.png" alt="image-20211107193905835"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193923570.png" alt="image-20211107193923570"></p><h2 id="2、验证面临的现状"><a href="#2、验证面临的现状" class="headerlink" title="2、验证面临的现状"></a>2、验证面临的现状</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194054454.png" alt="image-20211107194054454"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194123229.png" alt="image-20211107194123229"></p><h2 id="3、验证经验的积累和突破"><a href="#3、验证经验的积累和突破" class="headerlink" title="3、验证经验的积累和突破"></a>3、验证经验的积累和突破</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194231093.png" alt="image-20211107194231093"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用系统函数</title>
    <link href="/202111011730/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    <url>/202111011730/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>stop() //停止运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通3：类的方法和继承_动态对象_包的使用</title>
    <link href="/202110311523/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-2%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF_%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1_%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/202110311523/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-2%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF_%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1_%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类和对象的概述"><a href="#一、类和对象的概述" class="headerlink" title="一、类和对象的概述"></a>一、类和对象的概述</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><ul><li>property属性</li><li>function功能</li><li>class类</li><li>object对象</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031152459545.png" alt="image-20211031152459545"></p><h2 id="2-为什么验证需要有OOP"><a href="#2-为什么验证需要有OOP" class="headerlink" title="2.为什么验证需要有OOP"></a>2.为什么验证需要有OOP</h2><ul><li>激励生成器(stimulus generator)：生成激励内容</li><li>驱动器(driver)：将激励以时序形式发送给DUT</li><li>监控器(monitor)：监测信号并记录数据</li><li>比较器(checker)：比较数据</li></ul><p>验证环境的不同组件其功能和所需处理的数据内容是不同的</p><p>不同环境中同一类型组件所具备的功能和数据内容类似</p><h2 id="3-第一个激励数据类-transaction失误类"><a href="#3-第一个激励数据类-transaction失误类" class="headerlink" title="3. 第一个激励数据类(transaction失误类)"></a>3. 第一个激励数据类(transaction失误类)</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Transaction;<br><span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] addr, crc, data[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display;<br>$dispaly(<span class="hljs-string">&quot;Transcation:%h&quot;</span>,addr);<br>    <span class="hljs-keyword">endfunction</span>:display<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc;<br>    crc = addr ^ data<span class="hljs-variable">.xor</span>;<br>    <span class="hljs-keyword">endfunction</span>:calc_clc<br><span class="hljs-keyword">endclass</span>:Transcation<br></code></pre></div></td></tr></table></figure><h3 id="1-类里面变量的定义（重要）"><a href="#1-类里面变量的定义（重要）" class="headerlink" title="(1) 类里面变量的定义（重要）"></a>(1) 类里面变量的定义（重要）</h3><p>应该是软件的变量，缺省类型为<code>var</code>，不能是<code>reg</code>或<code>wire</code>等硬件类型</p><h3 id="2-软件与硬件的媒介：接口"><a href="#2-软件与硬件的媒介：接口" class="headerlink" title="(2) 软件与硬件的媒介：接口"></a>(2) 软件与硬件的媒介：接口</h3><p>virtual interface（接口指针）可以传递到类里面，类通过接口可以获得硬件中的信号</p><h3 id="对象和module的不同"><a href="#对象和module的不同" class="headerlink" title="对象和module的不同"></a>对象和module的不同</h3><ul><li><p>module里面的变量都是静态的，而对象是动态的生成</p></li><li><p>module里面定义方法只能在<strong>过程快</strong>中调用，class可以通过class嵌套class来调用，但class里面不能出现always和innashao</p></li><li><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031155036528.png" alt="image-20211031155036528"></p></li><li></li></ul><h2 id="4-OPP概念要素"><a href="#4-OPP概念要素" class="headerlink" title="4.OPP概念要素"></a>4.OPP概念要素</h2><ul><li>Class</li><li>Object</li><li>Handle句柄(指针)，为什么称之为指针？在SV中除了对象外没有类似的操作了，</li><li>Property</li><li>Method</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031154901529.png" alt="image-20211031154901529"></p><h2 id="5-创建对象-构造函数"><a href="#5-创建对象-构造函数" class="headerlink" title="5. 创建对象+构造函数"></a>5. 创建对象+构造函数</h2><p>构造函数<code>new()</code>是系统预定义函数，不需要指定返回值，函数会隐式地返回例化后的对象指针</p><p>注意构造函数<code>new()</code>是小括号，动态数组<code>new[$]</code>是中括号</p><p>创建对象：开辟了新的内存空间，用来存放新的成员变量和方法</p><p>构造函数可以定义形参缺省值，同C++</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031155932848.png" alt="image-20211031155932848"></p><h4 id="谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）"><a href="#谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）" class="headerlink" title="谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）"></a>谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）</h4><p>答案10</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160033614.png" alt="image-20211031160033614"></p><h2 id="6-声明和例化的区分——句柄的传递"><a href="#6-声明和例化的区分——句柄的传递" class="headerlink" title="6. 声明和例化的区分——句柄的传递"></a>6. 声明和例化的区分——句柄的传递</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Transcation</span> t<span class="hljs-number">1</span> ,t<span class="hljs-number">2</span>;//不是例化，只是声明句柄t<span class="hljs-number">1</span>,t<span class="hljs-number">2</span><br><span class="hljs-attribute">t1</span> = new ();//这里才是例化，例化对象将其句柄赋予t<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160521161-16356675228628.png" alt="image-20211031160521161"></p><h2 id="7-对象的销毁：SV也有自动回收内存空间的机制"><a href="#7-对象的销毁：SV也有自动回收内存空间的机制" class="headerlink" title="7. 对象的销毁：SV也有自动回收内存空间的机制"></a>7. 对象的销毁：SV也有自动回收内存空间的机制</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160539755-16356675733889.png" alt="image-20211031160539755"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160840083.png" alt="image-20211031160840083"></p><p>选B，在module里面定义的即便是initial里面的都是静态的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031161055070.png" alt="image-20211031161055070"></p><p>下图加了个automatic就不存在了，答案是D</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162639036.png" alt="image-20211031162639036"></p><h2 id="8-句柄的使用（空指针很危险）"><a href="#8-句柄的使用（空指针很危险）" class="headerlink" title="8.句柄的使用（空指针很危险）"></a>8.句柄的使用（空指针很危险）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162727269.png" alt="image-20211031162727269"></p><h2 id="9-静态变量（static进行声明）"><a href="#9-静态变量（static进行声明）" class="headerlink" title="9. 静态变量（static进行声明）"></a>9. 静态变量（static进行声明）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162757018.png" alt="image-20211031162757018"></p><p><strong>引用方式有两种</strong></p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span>::<span class="hljs-keyword">var</span><span class="hljs-comment">//直接类名引用</span><br><span class="hljs-keyword">object</span>.<span class="hljs-keyword">var</span><span class="hljs-comment">//通过例化的对象引用</span><br></code></pre></div></td></tr></table></figure><h2 id="10-静态方法"><a href="#10-静态方法" class="headerlink" title="10. 静态方法"></a>10. 静态方法</h2><p>同C++，无法调用动态成员变量</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163108643.png" alt="image-20211031163108643"></p><h1 id="二、类的成员"><a href="#二、类的成员" class="headerlink" title="二、类的成员"></a>二、类的成员</h1><h2 id="1-概述-默认public，主动声明protected-local"><a href="#1-概述-默认public，主动声明protected-local" class="headerlink" title="1. 概述(默认public，主动声明protected,local)"></a>1. 概述(默认public，主动声明protected,local)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163245473.png" alt="image-20211031163245473"></p><ul><li><p>秉承单一职责原则(SRP , Single Responsibility Principle)</p></li><li><p><code>protected</code>,<code>local</code>进行封装，称为开放封闭原则(OCP , Open Closed Principle)</p></li></ul><h3 id="local-私有成员"><a href="#local-私有成员" class="headerlink" title="local 私有成员"></a>local 私有成员</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163611076.png" alt="image-20211031163611076"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163703340.png" alt="image-20211031163703340"></p><p>选D</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163715150.png" alt="image-20211031163715150"></p><h3 id="public-protected-local"><a href="#public-protected-local" class="headerlink" title="public,protected,local"></a>public,protected,local</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163925657.png" alt="image-20211031163925657"></p><h2 id="2-类的封装"><a href="#2-类的封装" class="headerlink" title="2. 类的封装"></a>2. 类的封装</h2><h3 id="类与结构体的异同"><a href="#类与结构体的异同" class="headerlink" title="类与结构体的异同"></a>类与结构体的异同</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164238926.png" alt="image-20211031164238926"></p><h3 id="类与模块的异同"><a href="#类与模块的异同" class="headerlink" title="类与模块的异同"></a>类与模块的异同</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164321237.png" alt="image-20211031164321237"></p><p>答案A</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164516245.png" alt="image-20211031164516245"></p><h2 id="3-类的定义位置，嵌套类，this，类的编译顺序"><a href="#3-类的定义位置，嵌套类，this，类的编译顺序" class="headerlink" title="3. 类的定义位置，嵌套类，this，类的编译顺序"></a>3. 类的定义位置，嵌套类，this，类的编译顺序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164644625.png" alt="image-20211031164644625"></p><h1 id="三、类的继承"><a href="#三、类的继承" class="headerlink" title="三、类的继承"></a>三、类的继承</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164924500.png" alt="image-20211031164924500"></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cat</span></span>;<br><span class="hljs-keyword">protected</span> data;<br>function f1();<br>;<span class="hljs-comment">//statements</span><br>endfunction;<br>endclass<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">black_cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">cat</span></span>;<br>function <span class="hljs-keyword">new</span>();<br><br>endfunction<br>endclass<br></code></pre></div></td></tr></table></figure><h2 id="2-验证环境中的案例1"><a href="#2-验证环境中的案例1" class="headerlink" title="2. 验证环境中的案例1"></a>2. 验证环境中的案例1</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031171609238.png" alt="image-20211031171609238"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031171616311.png" alt="image-20211031171616311"></p><p><strong>要把数据发送到DUT，我们需要有以下基本元素和数据处理方法，我们将它们封装到Transaction类中</strong></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Transcation;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] src , dst , data[<span class="hljs-number">8</span>]; <span class="hljs-comment">//随机成员变量</span><br><span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<span class="hljs-comment">//二次处理后的成员数据</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc();<br>crc = src ^ dst ^ data<span class="hljs-variable">.xor</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> prefix=<span class="hljs-string">&quot;&quot;</span>);<br>$dispaly(<span class="hljs-string">&quot;%sTr:src=%h,dst-%h,crc=%h&quot;</span>,prefix,src,dst,crc);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172140615.png" alt="image-20211031172140615"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172214276.png" alt="image-20211031172214276"></p><p><strong>BadTr</strong>:使用super索引父类中的同名函数，默认情况下两个类的同名函数没有关系</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> BadTr <span class="hljs-keyword">extends</span> Transcation;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> bad_crc; <br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc();<br><span class="hljs-keyword">super</span><span class="hljs-variable">.calc_crc</span>();<span class="hljs-comment">//compute good CRC</span><br><span class="hljs-keyword">if</span>(bad_crc)<br>crc=~crc;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> prefix=<span class="hljs-string">&quot;&quot;</span>);<br>        dispaly(<span class="hljs-string">&quot;%sBadTr:bad_crc=%b&quot;</span>,prefix,bad_crc);<br><span class="hljs-keyword">super</span><span class="hljs-variable">.display</span>();<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure><h2 id="3-验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数"><a href="#3-验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数" class="headerlink" title="3. 验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数"></a>3. 验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172855646.png" alt="image-20211031172855646"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031173019135.png" alt="image-20211031173019135"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031173037085.png" alt="image-20211031173037085"></p><p><strong>特别注意：子类在定义new函数时应该首先调用父类的new函数</strong></p><ul><li><p>子类实例在初始化时首先会调用父类的构造函数</p></li><li><p>当父类构造函数完成时会见子类实例对象按照定义时进行默认值初始化，如果没有默认值则不初始化</p></li><li>在成员变量默认赋值后，才会进入用户定义中的new函数中</li></ul><h2 id="4-成员覆盖：子类和父类同名变量和方法"><a href="#4-成员覆盖：子类和父类同名变量和方法" class="headerlink" title="4.成员覆盖：子类和父类同名变量和方法"></a>4.成员覆盖：子类和父类同名变量和方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102152001680.png" alt="image-20211102152001680"></p><p>按照句柄类型来确定作用域：即各管各的，定义同名后，直接调用是子类的，super.是父类的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102152214429.png" alt="image-20211102152214429"></p><p>t是父类句柄，只能指向父类对象内的成员</p><h3 id="成员索引顺序"><a href="#成员索引顺序" class="headerlink" title="成员索引顺序"></a>成员索引顺序</h3><p>调用子类成员时，现在子类里面搜，子类里面没有相应成员则去父类里面搜</p><p>允许同名成员出现，不会覆盖，只是调用最先找到的成员（即子类内成员）</p><p>子类对象赋值给父类句柄时，父类无法访问子类成员变量，只能访问父类内对象</p><h1 id="四、句柄的使用"><a href="#四、句柄的使用" class="headerlink" title="四、句柄的使用"></a>四、句柄的使用</h1><h2 id="1-句柄的传递"><a href="#1-句柄的传递" class="headerlink" title="1. 句柄的传递"></a>1. 句柄的传递</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102153533672.png" alt="image-20211102153533672"></p><p><strong>形参中的类，总是句柄，而不是例化的对象</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102153622156.png" alt="image-20211102153622156"></p><h3 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154016268.png" alt="image-20211102154016268"></p><p>$display(t.addr)最后会报错</p><p>分析如上：<br>function (形参)，形参<strong>默认方向是input</strong>，声明完句柄后句柄的值为null，在function中完成例化，但并未被传递出去（没有返回出去）</p><h2 id="2-句柄的动态修改"><a href="#2-句柄的动态修改" class="headerlink" title="2. 句柄的动态修改"></a>2. 句柄的动态修改</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154327828.png" alt="image-20211102154327828"></p><p>笑死，不就是八吗，路桑是不是弱智啊</p><h1 id="五、包的使用"><a href="#五、包的使用" class="headerlink" title="五、包的使用"></a>五、包的使用</h1><h2 id="1-包的意义，相关的类可以组织在同一命名空间中"><a href="#1-包的意义，相关的类可以组织在同一命名空间中" class="headerlink" title="1. 包的意义，相关的类可以组织在同一命名空间中"></a>1. 包的意义，相关的类可以组织在同一命名空间中</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154752523.png" alt="image-20211102154752523"></p><p>多个module、Interface和program之间共享数据的方法</p><p><strong>命名空间实际上就是个package</strong></p><h2 id="2-包的定义"><a href="#2-包的定义" class="headerlink" title="2. 包的定义"></a>2. 包的定义</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155152726.png" alt="image-20211102155152726"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> reg_pkg;<br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;xxx_1.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;xxx_2.sv&quot;</span><br>...<br><span class="hljs-keyword">endpackage</span><br></code></pre></div></td></tr></table></figure><h3 id="包-域，不用担心重名冲突"><a href="#包-域，不用担心重名冲突" class="headerlink" title="包+域，不用担心重名冲突"></a>包+域，不用担心重名冲突</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155412032.png" alt="image-20211102155412032"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mcdf_tb;<br>regs_pkg::monitor mon1 = <span class="hljs-keyword">new</span>();<br>arb_pkg::monitor mon2 = <span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="3-包与库的区分，包-package-库-library"><a href="#3-包与库的区分，包-package-库-library" class="headerlink" title="3. 包与库的区分，包(package)库(library)"></a>3. 包与库的区分，包(package)库(library)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155543142.png" alt="image-20211102155543142"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102160948179.png" alt="image-20211102160948179"></p><p>package编译到library里面</p><h2 id="4-包的命名规则"><a href="#4-包的命名规则" class="headerlink" title="4.包的命名规则"></a>4.包的命名规则</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161023204.png" alt="image-20211102161023204"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161034379.png" alt="image-20211102161034379"></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">module</span> mcdf)tb;<br><span class="hljs-keyword">import</span> regs_pkg::*;<span class="hljs-comment">//类似于 using namespace xx;</span><br><span class="hljs-keyword">import</span> arb_pkg::*;<br>    regs_mon mon1 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>();<br>    arb_mon mon2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>();<br>endmodule<br></code></pre></div></td></tr></table></figure><h2 id="5-包的使用：包不用例化，包就是个容器"><a href="#5-包的使用：包不用例化，包就是个容器" class="headerlink" title="5.包的使用：包不用例化，包就是个容器"></a>5.包的使用：包不用例化，包就是个容器</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161534955.png" alt="image-20211102161534955"></p><ul><li><p>包就像一个library一样，只不过比Library低一个层级，你把定义好的东西放到包里面</p></li><li><p><strong>package</strong>里面不能定义与硬件相关的部分（module,interface,program都不能)</p></li><li><p>类是包的好朋友，包是类的归宿，我们会把类都放到包里面</p></li><li>一个完整的磨矿验证环境<strong>组件类</strong>，应该由一个对应的模块包来封装</li></ul><h2 id="软件的东西一定要放到包里面"><a href="#软件的东西一定要放到包里面" class="headerlink" title="软件的东西一定要放到包里面"></a>软件的东西一定要放到包里面</h2>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识3：验证计划概述</title>
    <link href="/202110292211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%AF%84%E4%BC%B0/"/>
    <url>/202110292211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、计划的概述"><a href="#一、计划的概述" class="headerlink" title="一、计划的概述"></a>一、计划的概述</h1><h2 id="1-验证计划是什么"><a href="#1-验证计划是什么" class="headerlink" title="1. 验证计划是什么"></a>1. 验证计划是什么</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029214110766.png" alt="image-20211029214110766"></p><h2 id="2-验证计划的步骤"><a href="#2-验证计划的步骤" class="headerlink" title="2. 验证计划的步骤"></a>2. 验证计划的步骤</h2><ul><li>创建验证<strong>计划</strong></li><li>选择验证<strong>方法</strong></li><li><strong>人力</strong>资源调配</li><li>构建验证<strong>平台</strong>和环境组件</li><li>开发测试<strong>用例</strong></li></ul><h2 id="3-收集的材料"><a href="#3-收集的材料" class="headerlink" title="3.收集的材料"></a>3.收集的材料</h2><ul><li>结构功能描述</li><li>设计的各种操作使用模式</li><li>在正常输入和错误输入情形下设计的行为</li><li>设计的接口</li><li>一些边界情况下设计的行为</li><li>设计在实际使用中的场景描述</li></ul><h2 id="4-为芯片开发带来的好处"><a href="#4-为芯片开发带来的好处" class="headerlink" title="4. 为芯片开发带来的好处"></a>4. 为芯片开发带来的好处</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031102808812-16356472902941.png" alt="image-20211031102808812"></p><h2 id="5-影响计划的因素"><a href="#5-影响计划的因素" class="headerlink" title="5. 影响计划的因素"></a>5. 影响计划的因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103102280-16356474658782.png" alt="image-20211031103102280"></p><h1 id="二、计划的内容"><a href="#二、计划的内容" class="headerlink" title="二、计划的内容"></a>二、计划的内容</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li>技术部分+项目部分</li><li>验证的功能点+验证层次+测试用例+验证方法+覆盖率要求</li><li>使用工具+人力安排+进度安排+风险评估</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103403323-16356476453873.png" alt="image-20211031103403323"></p><h2 id="2-验证的功能"><a href="#2-验证的功能" class="headerlink" title="2. 验证的功能"></a>2. 验证的功能</h2><ul><li>基本功能：时钟、电源、复位、寄存器访问和基本特性（模块级别验证）</li><li>互动功能：与其他模块互动的特性（更高一层）</li><li>次要功能：一般在项目后期验证：性能验证、效能验证，对芯片本身没有致命影响</li></ul><h2 id="3-验证的层次"><a href="#3-验证的层次" class="headerlink" title="3. 验证的层次"></a>3. 验证的层次</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103916405.png" alt="image-20211031103916405"></p><h2 id="4-验证的方法"><a href="#4-验证的方法" class="headerlink" title="4. 验证的方法"></a>4. 验证的方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104023829.png" alt="image-20211031104023829"></p><p>白盒不行，需要查看内部信号，无法复用，尽量黑盒</p><p>为什么UVM</p><h2 id="5-测试用例"><a href="#5-测试用例" class="headerlink" title="5. 测试用例"></a>5. 测试用例</h2><ul><li>更随机的测试方法，尽可能遍历可能的各种状态空间？</li><li>适中的随机约束，倾向于更贴近使用场景的随即激励？</li><li>采用定向测试，针对一些边界情况可以更有效地完善覆盖率？</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104336692.png" alt="image-20211031104336692"></p><p>一开始比较明确的数据输入，所以随即约束域比较窄(<strong>参考测试题4</strong>)</p><p>基本功能验证-&gt;完备功能验证-&gt;边界情况验证</p><h2 id="6-覆盖率的要求"><a href="#6-覆盖率的要求" class="headerlink" title="6. 覆盖率的要求"></a>6. 覆盖率的要求</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104723866-16356484448824-16356484477695.png" alt="image-20211031104723866"></p><p>FPGA测试也可以提高覆盖率</p><h2 id="7-工具的选择"><a href="#7-工具的选择" class="headerlink" title="7. 工具的选择"></a>7. 工具的选择</h2><ul><li>仿真工具</li><li>形式验证工具</li><li>验证IP</li><li>断言IP</li><li>调试器（UVM比SV调试方法多）</li><li>硬件加速器（与FPGA结合进行验证）</li><li>高层次验证语言(High-level Verification Language , HVL)</li></ul><h2 id="8-人力的安排"><a href="#8-人力的安排" class="headerlink" title="8. 人力的安排"></a>8. 人力的安排</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105138438-16356487022966.png" alt="image-20211031105138438"></p><h2 id="9-进度的安排"><a href="#9-进度的安排" class="headerlink" title="9. 进度的安排"></a>9. 进度的安排</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105225645.png" alt="image-20211031105225645"></p><h2 id="10-风险评估"><a href="#10-风险评估" class="headerlink" title="10. 风险评估"></a>10. 风险评估</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105340461.png" alt="image-20211031105340461"></p><p>芯片结构不稳定、工具的不稳定、人力的不稳定、模块交付时间的不稳定因素</p><h1 id="三、计划的实现"><a href="#三、计划的实现" class="headerlink" title="三、计划的实现"></a>三、计划的实现</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110244344.png" alt="image-20211031110244344"></p><p>创建验证计划-&gt;开发测试环境-&gt;覆盖率分析-&gt;覆盖率漏洞反馈-&gt;修改验证计划</p><h2 id="2-如何指定验证计划"><a href="#2-如何指定验证计划" class="headerlink" title="2. 如何指定验证计划"></a>2. 如何指定验证计划</h2><ul><li>邀请相关人员参加会议</li><li>开会讨论</li><li>确定测试场景</li><li>创建验证环境</li></ul><h2 id="3-相关人员"><a href="#3-相关人员" class="headerlink" title="3. 相关人员"></a>3. 相关人员</h2><p>设计、测试、规后测试、软件开发、系统人员、验证经理（项目经理）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110529866-16356495319797.png" alt="image-20211031110529866"></p><p> 系统人员和软件人员可能会有不一样，这个时候更多的听软件的，因为他需要使用</p><h2 id="4-开会讨论"><a href="#4-开会讨论" class="headerlink" title="4. 开会讨论"></a>4. 开会讨论</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111002143.png" alt="image-20211031111002143"></p><p>一份验证计划的模板（或组织结构）应包括下面的结构</p><ul><li>设计功能简要描述</li><li>硬件实现框图</li><li>待验证的功能点</li><li>验证环境搭建</li><li>测试用例构成</li><li>编译脚本和回归测试</li><li>覆盖率分析</li></ul><h2 id="5-确定测试场景"><a href="#5-确定测试场景" class="headerlink" title="5. 确定测试场景"></a>5. 确定测试场景</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111242666.png" alt="image-20211031111242666"></p><p>PA(Power Aware)场景</p><h2 id="6-创建验证环境"><a href="#6-创建验证环境" class="headerlink" title="6. 创建验证环境"></a>6. 创建验证环境</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111500738.png" alt="image-20211031111500738"></p><h1 id="四、计划进程的评估"><a href="#四、计划进程的评估" class="headerlink" title="四、计划进程的评估"></a>四、计划进程的评估</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在验证过程中，我们需要不断更新验证进度，从各项参数综合评估验证的完整性，我们通过收集以下信息来评估验证计划的实施进程：</p><ul><li>回归测试通过率(regressioin pass rate)</li><li>代码覆盖率(code coverage)</li><li>断言覆盖率(assertion coverage)</li><li>功能覆盖率(function coverage)</li><li>缺陷曲线(bug curve)</li><li>寄存器覆盖率(在v3里？)</li></ul><h2 id="2-回归测试通过率"><a href="#2-回归测试通过率" class="headerlink" title="2. 回归测试通过率"></a>2. 回归测试通过率</h2><ul><li>一份回归测试表是将测试设计所有功能点的用例合并为一个测试集</li><li>回归测试表主要功能是用来<strong>在设计经过缺陷修复或者性能提升后，测试原有的所有功能点</strong>，切薄设计依然可以正常工作</li><li>这种王府的测试方式不仅在于确保设计变化不会影响之前的功能，也可以用来避免修改后的设计对于别的模块造成的功能失效</li><li>设计的维护不仅在于按照设计需求提供新的功能，也要确保新功能不会影响到原有功能</li></ul><p>在回归测试中发现漏洞时的解决办法：</p><ul><li>回归测试表中的测试用例需要确保是可以重现激励场景的</li><li>这一点对于定向测试方法（c/c++）是容易实现的，而对随即约束的测试而言，我们需要在测试中显示出每次测试使用到的随机种子，只有通过这个<strong>特定</strong>的随机种子，我们才可以<strong>重新</strong>产生之前的激励，跟踪调试失败用例（即重现用例</li></ul><h3 id="验证层次：模块-gt-子系统-gt-芯片"><a href="#验证层次：模块-gt-子系统-gt-芯片" class="headerlink" title="验证层次：模块-&gt;子系统-&gt;芯片"></a>验证层次：模块-&gt;子系统-&gt;芯片</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113315394.png" alt="image-20211031113315394"></p><h3 id="层次解释"><a href="#层次解释" class="headerlink" title="层次解释"></a>层次解释</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113423306.png" alt="image-20211031113423306"></p><h2 id="3-代码覆盖率"><a href="#3-代码覆盖率" class="headerlink" title="3.代码覆盖率"></a>3.代码覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113635742.png" alt="image-20211031113635742"></p><p>常见的代码覆盖率：</p><ul><li>语句覆盖率(statement coverage)</li><li>条件覆盖率(condition coverage)</li><li>决策覆盖率(branch coverage)</li><li>事件覆盖率(event coverage)</li><li>跳转覆盖率(toggle coverage)</li><li>状态机覆盖率(finite stage machine coverage)</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113843620.png" alt="image-20211031113843620"></p><h2 id="4-断言覆盖率（在第三模块专门说到）"><a href="#4-断言覆盖率（在第三模块专门说到）" class="headerlink" title="4. 断言覆盖率（在第三模块专门说到）"></a>4. 断言覆盖率（在第三模块专门说到）</h2><p>不单单可以在验证方面，可以在硬件加速、形式验证中都可以实现覆盖率收集</p><p>基于验证方法的不同将断言分辨率分为：</p><ul><li>基于动态仿真或者硬件加速的断言覆盖率</li><li>基于形式验证的静态断言覆盖率</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031114018415.png" alt="image-20211031114018415"></p><h2 id="5-功能覆盖率"><a href="#5-功能覆盖率" class="headerlink" title="5. 功能覆盖率"></a>5. 功能覆盖率</h2><p>衡量设计的各项功能是否实现，主要关注设计的输入、输出和内部状态</p><p>内部状态：通过对信号的单一覆盖、交叉覆盖、时序覆盖来检查功能是否被触发</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151435108.png" alt="image-20211031151435108"></p><h2 id="6-缺陷曲线"><a href="#6-缺陷曲线" class="headerlink" title="6. 缺陷曲线"></a>6. 缺陷曲线</h2><p><strong>通过时间坐标和特定时间段数量绘制出缺陷曲线</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151826994.png" alt="image-20211031151826994"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151921297.png" alt="image-20211031151921297"></p><h1 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h1><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029214325797.png" alt="image-20211029214325797"></p><ol><li>A</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031102846977.png" alt="image-20211031102846977"></p><ol><li>AB</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103707035.png" alt="image-20211031103707035"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104616381.png" alt="image-20211031104616381"></p><ol><li>ABCD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105555906.png" alt="image-20211031105555906"></p><ol><li>BC</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110755561.png" alt="image-20211031110755561"></p><ol><li>ABCD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111535630.png" alt="image-20211031111535630"></p><ol><li>CD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113529638.png" alt="image-20211031113529638"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151705463.png" alt="image-20211031151705463"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151949489.png" alt="image-20211031151949489"></p><p>应该是总的缺陷数量</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV学习0-1：EDA的使用</title>
    <link href="/202110292004/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A00-1%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/202110292004/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A00-1%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Questasim"><a href="#一、Questasim" class="headerlink" title="一、Questasim"></a>一、Questasim</h1><h2 id="1-hello-world"><a href="#1-hello-world" class="headerlink" title="1 hello world"></a>1 hello world</h2><h3 id="1-编译会把它放到库里面，然后再库里仿真"><a href="#1-编译会把它放到库里面，然后再库里仿真" class="headerlink" title="1.编译会把它放到库里面，然后再库里仿真"></a>1.编译会把它放到库里面，然后再库里仿真</h3><ol><li>上图为编译前，status为？</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029195944381-16355087926651.png" alt="image-20211029195944381"></p><ol><li>编译成功后（编译成功后放到库里面，再做仿真）</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029200052177-16355088533832.png" alt="image-20211029200052177"></p><ol><li>在库里的work中运行仿真without Optimization</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029201949489-16355099905323.png" alt="image-20211029201949489"></p><ol><li>最后运行仿真，其中Now:是指的仿真时间</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029202357250-16355102398214.png" alt="image-20211029202357250"></p><h3 id="2-为什么是100ns"><a href="#2-为什么是100ns" class="headerlink" title="2. 为什么是100ns?"></a>2. 为什么是100ns?</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029205535026-16355121365295.png" alt="image-20211029205535026"></p><p>单步步长为100ns</p><h3 id="3-run代表的仿真继续执行-其他run命令"><a href="#3-run代表的仿真继续执行-其他run命令" class="headerlink" title="3. run代表的仿真继续执行_其他run命令"></a>3. run代表的仿真继续执行_其他run命令</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029205857374-16355123404767.png" alt="image-20211029205857374"></p><ul><li>run  时间</li><li>run  -all</li><li>run -continue </li></ul><p>run -all 为啥会有的时候成功有的时候没成功</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029210236017.png" alt="image-20211029210236017"></p><p>如果仿真已经运行完，则run -all没结果<br>如果仿真被暂停或没运行完，run -all才有结果</p><h1 id="二、VCS"><a href="#二、VCS" class="headerlink" title="二、VCS"></a>二、VCS</h1><p>compile,elabration,run,rungui,clean</p><p>编译文件：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211123215651722.png" alt="image-20211123215651722"></p><p>执行顺序：</p><ol><li><p>make comp</p></li><li><p>make elab</p></li><li><p>make run：bash模式运行，在后台</p></li><li>make rung：gui模式运行</li></ol>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通2：接口采样驱动_测试结束开始_调试方法1</title>
    <link href="/202110151604/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-2%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%87%87%E6%A0%B7%E9%A9%B1%E5%8A%A8_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9D%9F%E5%BC%80%E5%A7%8B_%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/202110151604/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-2%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%87%87%E6%A0%B7%E9%A9%B1%E5%8A%A8_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9D%9F%E5%BC%80%E5%A7%8B_%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>主要内容：</p><ul><li>接口</li><li>采样和数据驱动</li><li>测试的开始和结束</li><li>调试方法</li></ul><h2 id="注意重点"><a href="#注意重点" class="headerlink" title="注意重点"></a>注意重点</h2><p>采样：输入</p><p>驱动：输出</p><p>一般的采样是直接采样</p><p>而采样可以对于Interface采样，在clocking下采样</p><p>采样和驱动都可以通过并行的initial块进行监控具体可参考第二章第二节的几个例子：initital forever</p><h2 id="学习的定义和系统函数"><a href="#学习的定义和系统函数" class="headerlink" title="学习的定义和系统函数"></a>学习的定义和系统函数</h2><ul><li>interface</li><li>clocking</li><li>program</li><li>run 0 //命令</li><li>$stop()</li><li>$finish()</li><li>$exit()</li></ul><h1 id="一、接口-interface"><a href="#一、接口-interface" class="headerlink" title="一、接口(interface)"></a>一、接口(interface)</h1><h2 id="1-什么是接口"><a href="#1-什么是接口" class="headerlink" title="1 什么是接口"></a>1 什么是接口</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="(1) 简介"></a>(1) 简介</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190705553.png" alt="image-20211016190705553"></p><p><strong>硬件很重要，可以在软硬环境传递：如图上第三点</strong></p><h3 id="2-有无接口的测试方法对比"><a href="#2-有无接口的测试方法对比" class="headerlink" title="　(2) 有无接口的测试方法对比"></a>　(2) 有无接口的测试方法对比</h3><p>测试arbiter现有经典方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190936562.png" alt="image-20211016190936562"></p><p>使用了interface后的测试关系</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190958859.png" alt="image-20211016190958859">‘</p><h3 id="3-interface代码定义"><a href="#3-interface代码定义" class="headerlink" title="(3) interface代码定义"></a>(3) interface代码定义</h3><p><strong>下图对应design</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191110431.png" alt="image-20211016191110431"></p><ul><li><p>可作为形参在module的参数列表中声明，不需要声明方向</p></li><li><p>通过一个点表明层次关系（例如arbif.rst）</p></li></ul><hr><p><strong>下图对应testbench（要有壳子把design和testbench包起来）</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191323553.png" alt="image-20211016191323553"></p><ul><li>也是用initital作为驱动，</li><li>arbif.clk作为始终驱动，$finish结束仿真</li></ul><hr><p><strong>下图对应top</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191622363.png" alt="image-20211016191622363"></p><h2 id="2-接口的优势"><a href="#2-接口的优势" class="headerlink" title="2 接口的优势"></a>2 接口的优势</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191704811.png" alt="image-20211016191704811"></p><ul><li>更易于维护和使用</li><li>接口作为软(class)硬(module)的媒介</li><li>对于多组相同的总线，例化更为灵活</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191941795.png" alt=""></p><p>对最后一条：stimulator拿到接口的指针对其进行驱动</p><h2 id="3-接口的定义和使用"><a href="#3-接口的定义和使用" class="headerlink" title="3 接口的定义和使用"></a>3 接口的定义和使用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016192730438.png" alt="image-20211016192730438"></p><ul><li>用法与module类似</li><li>interface不定义任何端口信号，定义：复位、时钟等公共信号</li><li>interface可以添加参数提高复用性</li><li>例化的时候和module一样</li></ul><h1 id="二、采样和数据驱动"><a href="#二、采样和数据驱动" class="headerlink" title="二、采样和数据驱动"></a>二、采样和数据驱动</h1><h2 id="1-竞争问题"><a href="#1-竞争问题" class="headerlink" title="1 竞争问题"></a>1 竞争问题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194430737.png" alt="image-20211016194430737"></p><p><strong>避免竞争：使用非阻塞赋值或者特定的信号延迟来解决同步问题</strong></p><hr><p><strong>对于真实的物理环境下会有延迟</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195117342.png" alt="image-20211016195117342"></p><ul><li>clk时钟驱动数据a会有延迟：对应上图中间的”X”</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194954692.png" alt="image-20211016194954692"></p><p><strong>延迟只会在门级仿真的时候才会体现出来，我们RTL的时候没有</strong></p><p>那怎么办：我们只能每一个都加上一个最小单位的延迟（delta-cycle）</p><h3 id="时间片和delta-cycle："><a href="#时间片和delta-cycle：" class="headerlink" title="时间片和delta-cycle："></a>时间片和delta-cycle：</h3><p>run 1m , s, ms, us, ns, ps, fs, 0<br>0就是时间片，一个时间片里又包括无穷个delta-cycle，在仿真时无法用最小的时间单位衡量</p><h3 id="delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）"><a href="#delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）" class="headerlink" title="delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）"></a>delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）</h3><p>有两个时钟第一个时钟五纳秒翻转一次</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195832325.png" alt="image-20211016195832325"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195852932.png" alt="image-20211016195852932"></p><h3 id="race-sv"><a href="#race-sv" class="headerlink" title="race.sv"></a>race.sv</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202543007.png" alt="image-20211016202543007"></p><h4 id="EDA如何显示delta-cycle"><a href="#EDA如何显示delta-cycle" class="headerlink" title="EDA如何显示delta-cycle"></a>EDA如何显示delta-cycle</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202836218.png" alt="image-20211016202836218"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202911254.png" alt="image-20211016202911254"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016203031929.png" alt="image-20211016203031929"></p><ul><li>仿真采样存在不稳定性</li></ul><p><strong>如何避免：</strong></p><ul><li>添加认为延迟</li><li>采样时间前的某段时刻进行采样</li></ul><h2 id="2-接口中的clocking-时钟块"><a href="#2-接口中的clocking-时钟块" class="headerlink" title="2 接口中的clocking 时钟块"></a>2 接口中的clocking 时钟块</h2><h3 id="1-clocking学习背景modport在clocking中，不用额外去学"><a href="#1-clocking学习背景modport在clocking中，不用额外去学" class="headerlink" title="(1) clocking学习背景modport在clocking中，不用额外去学"></a>(1) clocking学习背景modport在clocking中，不用额外去学</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016214722868.png" alt="image-20211016214722868"></p><ul><li>modport有方向</li><li>clocking基于时钟进行采样，使得testbench不在苦恼于如何即使准确的对信号进行驱动和采样，消除了信号竞争问题</li></ul><hr><h3 id="2-clocking代码定义"><a href="#2-clocking代码定义" class="headerlink" title="(2) clocking代码定义"></a>(2) clocking代码定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016215024641.png" alt=""></p><ul><li>第一行@(信号)：定义上升沿事件</li><li>第二行指定的是：默认情况下所有的输出相比较上升沿后2ns延迟，对所有输入信号在上升沿之前10ns做一个采样。和电路里面建立保持时间差不多</li><li>第三行：我们要对data,ready和enable信号做采样了，且以及声明方向了</li><li>属于输出驱动额外强调在时钟下降沿</li><li><h1 id="1step-过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内"><a href="#1step-过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内" class="headerlink" title="1step 过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内"></a>1step 过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内</h1></li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016215612699.png" alt="image-20211016215612699"></p><ul><li>对于时钟而言可以定义在：module，Interface,program中</li><li>clocking内列举的信号是由interface或其他的地方去定义</li><li>对于时钟块他只声明而不定义</li><li>没有定义的画默认输入在事件前1step，驱动在事件后#0（一个时钟片相当于无穷多个step，肯定比step大）</li><li>处理定义默认的采样和驱动时间，可以用新的时间对默认事件覆盖</li></ul><h3 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="(3) 一个例子"></a>(3) 一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220043661.png" alt="image-20211016220043661"></p><h3 id="4-一个例子：利用clocking的采样"><a href="#4-一个例子：利用clocking的采样" class="headerlink" title="(4) 一个例子：利用clocking的采样"></a>(4) 一个例子：利用clocking的采样</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220306611.png" alt="image-20211016220306611"></p><ul><li><p>用了三个initial，第一个做驱动，第二三个做采样</p></li><li><p>@ck 等价于 @(posedge clk)</p></li><li>@ck 意思是在clocking这个变化事件</li><li>第二个在时钟的每一个上升沿直接对vld做采样@ck</li><li>在每一个上升沿利用clocking块进行采样</li></ul><p><strong>输出结果</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220901083.png" alt="image-20211016220901083"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220934039.png" alt="image-20211016220934039"></p><h3 id="5-一个例子：利用clocking的驱动"><a href="#5-一个例子：利用clocking的驱动" class="headerlink" title="(5)一个例子：利用clocking的驱动"></a>(5)一个例子：利用clocking的驱动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221247525.png" alt="image-20211016221247525"></p><p>@ck ck.grt &lt;= 1 ; //<strong>利用clocking</strong>在每个上升沿<strong>进行驱动</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221400065.png" alt="image-20211016221400065"></p><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="(6) 结论"></a>(6) 结论</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221421817.png" alt="image-20211016221421817"></p><h1 id="三、测试的开始和结束"><a href="#三、测试的开始和结束" class="headerlink" title="三、测试的开始和结束"></a>三、测试的开始和结束</h1><h2 id="1-介绍：各个设计自身可以作为一个大的线程"><a href="#1-介绍：各个设计自身可以作为一个大的线程" class="headerlink" title="1.介绍：各个设计自身可以作为一个大的线程"></a>1.介绍：各个设计自身可以作为一个大的线程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221528823.png" alt="image-20211016221528823"></p><p>但是如果只提供复位和时钟信号，整个仿真会一直持续下去并不会主动结束，这时候需要verilog系统函数主动结束仿真</p><h2 id="2-系统函数结束仿真"><a href="#2-系统函数结束仿真" class="headerlink" title="2. 系统函数结束仿真"></a>2. 系统函数结束仿真</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222523208.png" alt="image-20211016222523208"></p><h3 id="finish-直接结束仿真"><a href="#finish-直接结束仿真" class="headerlink" title="$finish():直接结束仿真"></a>$finish():直接结束仿真</h3><h3 id="stop-暂停仿真，可以再次启动"><a href="#stop-暂停仿真，可以再次启动" class="headerlink" title="$stop():暂停仿真，可以再次启动"></a>$stop():暂停仿真，可以再次启动</h3><h2 id="3-仿真开始"><a href="#3-仿真开始" class="headerlink" title="3.仿真开始"></a>3.仿真开始</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222747548.png" alt="image-20211016222747548"></p><p><strong>下文参考答案一章</strong></p><h2 id="4-program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少"><a href="#4-program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少" class="headerlink" title="4. program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少"></a>4. program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016223616175.png" alt="image-20211016223616175"></p><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225255238.png" alt="image-20211016225255238"></p><h5 id="program相当于把initial的内容封装到program里面了"><a href="#program相当于把initial的内容封装到program里面了" class="headerlink" title="program相当于把initial的内容封装到program里面了"></a>program相当于把initial的内容封装到program里面了</h5><p>最终放到tb里面，最终仿真自动结束，不需要调用$finish</p><h2 id="5-program显式-强制-结束：-exit-专门对program的结束函数"><a href="#5-program显式-强制-结束：-exit-专门对program的结束函数" class="headerlink" title="5.program显式(强制)结束：$exit()专门对program的结束函数"></a>5.program显式(强制)结束：$exit()专门对program的结束函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225510071.png" alt="image-20211016225510071"></p><h4 id="具体例子-1"><a href="#具体例子-1" class="headerlink" title="具体例子"></a>具体例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225608127.png" alt="image-20211016225608127"></p><h2 id="6-program和module"><a href="#6-program和module" class="headerlink" title="6. program和module"></a>6. program和module</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225657272.png" alt="image-20211016225657272"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225749237.png" alt="image-20211016225749237"></p><h1 id="四、调试方法"><a href="#四、调试方法" class="headerlink" title="四、调试方法"></a>四、调试方法</h1><h2 id="1-使用库、仿真和过程方法"><a href="#1-使用库、仿真和过程方法" class="headerlink" title="1. 使用库、仿真和过程方法"></a>1. 使用库、仿真和过程方法</h2><h2 id="2-不同仿真器是共通的"><a href="#2-不同仿真器是共通的" class="headerlink" title="2. 不同仿真器是共通的"></a>2. 不同仿真器是共通的</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230130087.png" alt="image-20211016230130087"></p><h2 id="3-库窗口"><a href="#3-库窗口" class="headerlink" title="3. 库窗口"></a>3. 库窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230346911.png" alt="image-20211016230346911"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230400490.png" alt="image-20211016230400490"></p><p><strong>可以创建属于自己的库</strong></p><p>实验里面默认library</p><p><strong>所有的文件编译都离不开库</strong></p><h2 id="4-仿真窗口"><a href="#4-仿真窗口" class="headerlink" title="4.仿真窗口"></a>4.仿真窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230631471.png" alt="image-20211016230631471"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230729220.png" alt="image-20211016230729220"></p><p><strong>最大帮助是用来看层次</strong></p><h2 id="5-过程窗口"><a href="#5-过程窗口" class="headerlink" title="5. 过程窗口"></a>5. 过程窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230800874.png" alt="image-20211016230800874"></p><p>hang-on：仿真进入死循环<br>active,ready</p><h2 id="6-查看信号和波形"><a href="#6-查看信号和波形" class="headerlink" title="6. 查看信号和波形"></a>6. 查看信号和波形</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230924609.png" alt="image-20211016230924609"></p><h2 id="7-打印消息：-display"><a href="#7-打印消息：-display" class="headerlink" title="7. 打印消息：$display"></a>7. 打印消息：$display</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231000603.png" alt="image-20211016231000603"></p><p>尽量格式化，字符串赋值和拼接</p><h2 id="8-设置断点（verify重点）"><a href="#8-设置断点（verify重点）" class="headerlink" title="8. 设置断点（verify重点）"></a>8. 设置断点（verify重点）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231107723.png" alt="image-20211016231107723"></p><h3 id="理解程序执行顺序"><a href="#理解程序执行顺序" class="headerlink" title="理解程序执行顺序"></a>理解程序执行顺序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231202857.png" alt="image-20211016231202857"></p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231351379.png" alt="image-20211016231351379"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231402018.png" alt="image-20211016231402018"></p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h3 id="1-ABCD"><a href="#1-ABCD" class="headerlink" title="1.ABCD"></a>1.ABCD</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194056429.png" alt="image-20211016194056429"></p><p>哪些事情不能做：模块里面可以例化模块和接口，但是接口里面不可以例化模块可以例化接口</p><h3 id="2-b-1"><a href="#2-b-1" class="headerlink" title="2. b=1"></a>2. b=1</h3><p>a被综合成4位寄存器，使用非阻塞赋值可以确定b是flip-flop，而这里不确定b被综合成什么</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194629074.png" alt="image-20211016194629074"></p><h3 id="3-对应delta-cycle小节"><a href="#3-对应delta-cycle小节" class="headerlink" title="3.对应delta-cycle小节"></a>3.对应delta-cycle小节</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195852932.png" alt="image-20211016195852932"></p><h3 id="4-clocking：C都可以"><a href="#4-clocking：C都可以" class="headerlink" title="4 .clocking：C都可以"></a>4 .clocking：C都可以</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220131851.png" alt="image-20211016220131851"></p><h3 id="5-仿真开始，run0：A？"><a href="#5-仿真开始，run0：A？" class="headerlink" title="5. 仿真开始，run0：A？"></a>5. 仿真开始，run0：A？</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222747548.png" alt="image-20211016222747548"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222828300.png" alt="image-20211016222828300"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222954064.png" alt="image-20211016222954064"></p><h3 id="6-哪些可以在program中定义-AC"><a href="#6-哪些可以在program中定义-AC" class="headerlink" title="6.哪些可以在program中定义 AC"></a>6.哪些可以在program中定义 AC</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225928352.png" alt="image-20211016225928352"></p><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231351379.png" alt="image-20211016231351379"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231402018.png" alt="image-20211016231402018"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231520344.png" alt="image-20211016231520344"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识2：验证环境的结构和组件</title>
    <link href="/202110112211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6/"/>
    <url>/202110112211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>mcdf</p><h1 id="一、测试平台"><a href="#一、测试平台" class="headerlink" title="一、测试平台"></a>一、测试平台</h1><p>testbench整个验证系统的总称：包括各个组件、组件支架的连接、测试平台的配置和控制<br>整个SV教学由verilog定向测试逐步过渡到SV，用SV去实现一些组件，用一些通信方法实现连接</p><p>更系统地来讲，tb还包括编译仿真、结果分析报告和覆盖率检查等<br>makefile可以更快的编译、更快的跑仿真</p><p>狭义上来讲，我们主要关注验证平台的结构和组件，他们可以产生设计所需要的各种输入，在此基础上捕捉各种行为，进行设计功能检查</p><h2 id="测试平台结构图"><a href="#测试平台结构图" class="headerlink" title="测试平台结构图"></a>测试平台结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011221829069.png" alt="image-20211011221829069"></p><p>实验0的MCDT，中间的DUT（Design on the Test）也叫DUV(Design on the verification)</p><p>实验0我们有.tb,.mcdt但没有专门模块产生激励，只有过程块产生激励，同时缺少检测模块，比较简单</p><p>实验1、实验2就比较完整了</p><p>由上述结构图得知：</p><ul><li>各组件之间相互独立（sv是，uvm也是）</li><li>验证组件设计之间需要连接</li><li>验证组件设计之间需要通信</li><li>验证环境需要时钟和复位信号驱动</li></ul><h2 id="验证语言的调查趋势"><a href="#验证语言的调查趋势" class="headerlink" title="验证语言的调查趋势"></a>验证语言的调查趋势</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011222931432.png" alt="image-20211011222931432"></p><p>verilog是下降的，vmm是什么是synopsys vera开发的</p><p>C\C++一定不会消亡，系统级都是C\C++</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223128157.png" alt="image-20211011223128157"></p><h1 id="二、关于硬件的设计描述"><a href="#二、关于硬件的设计描述" class="headerlink" title="二、关于硬件的设计描述"></a>二、关于硬件的设计描述</h1><h2 id="MCDF简介"><a href="#MCDF简介" class="headerlink" title="MCDF简介"></a>MCDF简介</h2><ul><li>遵循硬件设计描述的方式，介绍它的<strong>结构、功能‘寄存器和时序</strong></li><li>熟悉硬件描述的方式，也是验证基本技能</li><li>MCDF(multi-channel data formatter)多通道数据整形器， 它可以<strong>将上行uplink多个通道数据经过内部FIFO，最终以数据包data packet的形式送出</strong></li><li>上行数据和下行数据的接口协议不同</li><li>多通道数据整合器也有寄存器读写接口，可以支持更多的控制（寄存器可以对硬件配置同时获取其状态，一个成熟的硬件都要有）</li></ul><p>我们designer拿到datasheet设计代码，我们verificor也要看</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223932224.png" alt="image-20211011223932224"></p><h2 id="具体一个硬件设计应该包含的内容"><a href="#具体一个硬件设计应该包含的内容" class="headerlink" title="具体一个硬件设计应该包含的内容"></a>具体一个硬件设计应该包含的内容</h2><h3 id="系统信号接口（小括号0代表有一位）"><a href="#系统信号接口（小括号0代表有一位）" class="headerlink" title="系统信号接口（小括号0代表有一位）"></a>系统信号接口（小括号0代表有一位）</h3><ul><li>CLK(0)：时钟信号</li><li>RSTN(0)：复位信号低位有效</li></ul><h3 id="通道从端接口（x为通道ID）"><a href="#通道从端接口（x为通道ID）" class="headerlink" title="通道从端接口（x为通道ID）"></a>通道从端接口（x为通道ID）</h3><ul><li>CHx_DATA(31:0)：通道数据输入</li><li>CHx_VALID(0)：通道数据有效标志信号，高位有效</li><li>CHx_READY(0)：通道数据接收信号，高位表示接收成功</li></ul><h3 id="整形器接口"><a href="#整形器接口" class="headerlink" title="整形器接口"></a>整形器接口</h3><p>输出方向</p><ul><li>FMT_CHID(1:0)：整形数据包的通道ID，当前数据包是哪个channel</li><li>FMT_LENGTH(4:0)：整形数据包长度信号</li><li>FMT_REQ(0)：整形数据包发送请求</li></ul><p>输入方向对于Formater</p><ul><li>FMT_GRANT(0)：整形数据包被允许发送的接受标示</li></ul><p>输出方向</p><ul><li>FMT_DATA(31:0)：数据输出端口</li><li>FMT_START(0)：数据包起始标示</li><li>FMT_END(0)：数据包结束标示</li></ul><h3 id="控制寄存器接口"><a href="#控制寄存器接口" class="headerlink" title="控制寄存器接口"></a>控制寄存器接口</h3><p>控制模块需要一些数值</p><p>往mcdt是输入方向，对于激励是需要输出的</p><ul><li>CMD(1:0)：寄存器读写命令（肯定不止一个寄存器，因此需要有这个）</li><li>CMD_ADDR(7:0)：寄存器地址</li><li>CMD_DATA_IN(31:0)：寄存器写入数据</li></ul><p>对于mcdt是输出方向</p><ul><li>CMD_DATA_OUT(31:0)：寄存器读出数据</li></ul><h3 id="还没讲Arbiter，暂时不讲"><a href="#还没讲Arbiter，暂时不讲" class="headerlink" title="还没讲Arbiter，暂时不讲"></a>还没讲Arbiter，暂时不讲</h3><p>因为全部包括在MCDF里面，并没有裸露到MCDF外面的边界boundary上，对小白来说暂时不重要</p><h2 id="MCDF的接口时序"><a href="#MCDF的接口时序" class="headerlink" title="MCDF的接口时序"></a>MCDF的接口时序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011225732579.png" alt="image-20211011225732579"></p><h3 id="控制寄存器接口时序"><a href="#控制寄存器接口时序" class="headerlink" title="控制寄存器接口时序"></a>控制寄存器接口时序</h3><p>地址要写清楚，还有cmd命令，可以看到WR和CMD_DATA_IN同时变换</p><p>发起RD时会在下一拍返回</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011225818268.png" alt="image-20211011225818268"></p><p>为什么地址是00,04,08….那01,02去哪了<br>因为32位寄存器，按照一个word寻址的</p><p>不同寄存器，指令覆盖，对应读取</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011230131279.png" alt="image-20211011230131279"></p><h3 id="整形器时序"><a href="#整形器时序" class="headerlink" title="整形器时序"></a>整形器时序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011230250266.png" alt="image-20211011230250266"></p><p>数据包以req为准，他请求发送，它拉高chid,length都要变化<br>下行会给我们一个grant表示同意<br>又过了一拍start拉高表示formater真正开始发送数据<br>同时data有数据<br>end最后也起来了</p><h2 id="MCDF寄存器描述"><a href="#MCDF寄存器描述" class="headerlink" title="MCDF寄存器描述"></a>MCDF寄存器描述</h2><h3 id="前三个称为读写或控制寄存器，地址分别为00-04-08"><a href="#前三个称为读写或控制寄存器，地址分别为00-04-08" class="headerlink" title="前三个称为读写或控制寄存器，地址分别为00,04,08"></a>前三个称为读写或控制寄存器，地址分别为00,04,08</h3><p> <img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012163813840.png" alt="image-20211012163813840"></p><ul><li><p>优先级和arbiter有关</p></li><li><p>bit(31:6)是保留位，也叫reserverd bits，无法写入，一直为0</p></li></ul><h3 id="只读寄存器"><a href="#只读寄存器" class="headerlink" title="只读寄存器"></a>只读寄存器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012170644158.png" alt="image-20211012170644158"></p><p>写也不能写的，表示一个状态</p><h1 id="三、激励发生器（SV中stimulator，UVM中driver）"><a href="#三、激励发生器（SV中stimulator，UVM中driver）" class="headerlink" title="三、激励发生器（SV中stimulator，UVM中driver）"></a>三、激励发生器（SV中stimulator，UVM中driver）</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012171456403.png" alt="image-20211012171456403"></p><p>能够以<strong>真实的接口协议</strong>来发送激励给DUT</p><p>且比真实硬件激励跟丰富</p><h3 id="stimulator的接口"><a href="#stimulator的接口" class="headerlink" title="stimulator的接口"></a>stimulator的接口</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172140710.png" alt="image-20211012172140710"></p><p>主要是同DUT之间（边界而不是dut内部）的连接，此外还要有时钟和复位的输 入<br>也应该存储接口数据生成历史的功能<br>精细的stimulator还可以有其他配置接口用来控制接口数据</p><h3 id="stimulator分类：initiator发起器、responder响应器"><a href="#stimulator分类：initiator发起器、responder响应器" class="headerlink" title="stimulator分类：initiator发起器、responder响应器"></a>stimulator分类：initiator发起器、responder响应器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172410023.png" alt="image-20211012172410023"></p><h2 id="stimulator位置及实现考虑因素"><a href="#stimulator位置及实现考虑因素" class="headerlink" title="stimulator位置及实现考虑因素"></a>stimulator位置及实现考虑因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172619391.png" alt="image-20211012172619391"></p><h3 id="channel-initiator"><a href="#channel-initiator" class="headerlink" title="channel initiator"></a>channel initiator</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172731288.png" alt="image-20211012172731288"></p><ul><li>握手信号，需要遵守协议</li><li>相邻数据间没有数据包限制，所以也要考虑发送数据快慢</li><li>channel里面有FIFO，实现FIFO状态可遍历</li></ul><h3 id="register-initiator"><a href="#register-initiator" class="headerlink" title="register initiator"></a>register initiator</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173107232.png" alt="image-20211012173107232"></p><ul><li>cmd默认状态应该是idle，但没有规定默认值，考虑idle值是随机时寄存器是否稳定</li><li>寄存器读写上，考虑连续指令</li><li>读写寄存器所有比特位测试都应覆盖</li><li>只读状态寄存器需要测试是否为不可写入的设定，同时需要测试读出的数值是否真实反应硬件状态</li></ul><h3 id="Formatter-responder"><a href="#Formatter-responder" class="headerlink" title="Formatter responder"></a>Formatter responder</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173350752.png" alt="image-20211012173350752"></p><ul><li><strong>三种协议相对复杂的一个</strong>，侧重是否充分遍历</li></ul><h1 id="四、监测器"><a href="#四、监测器" class="headerlink" title="四、监测器"></a>四、监测器</h1><p>需要捕捉时序，接口+内部</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173551040.png" alt="image-20211012173551040"></p><p>Monitor（监视器）主要功能观察DUT的边界或者内部信号</p><p>对于DUT边界信号，如系统信号（时钟）；总线信号，总线时序</p><p>对于DUT内部信号。从灰盒验证的手段，</p><p>为什么检测内部信号：完成覆盖率手机、内部功能检查</p><h3 id="监视器组件结构方案"><a href="#监视器组件结构方案" class="headerlink" title="监视器组件结构方案"></a>监视器组件结构方案</h3><h4 id="全局式"><a href="#全局式" class="headerlink" title="全局式"></a>全局式</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181105759.png" alt="image-20211012181105759"></p><p>虚线指的是内部关键信号，实线关键信号</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181256390.png" alt="image-20211012181256390"></p><p>左下角mcdf monitor是检测内部信号的，独立的。其他的Monitor都对应的一组</p><h3 id="监视器结构方案比较"><a href="#监视器结构方案比较" class="headerlink" title="监视器结构方案比较"></a>监视器结构方案比较</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181357668.png" alt="image-20211012181357668"></p><p>独立性、复用性、可维护性、封装性</p><h2 id="内部信号监测建议"><a href="#内部信号监测建议" class="headerlink" title="内部信号监测建议"></a>内部信号监测建议</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181753692.png" alt="image-20211012181753692"></p><ul><li>应灰盒而不是白盒</li><li>观察的信号尽可能少，且应是状态信号而不是中间变量（不稳定）</li><li>能基于接口信息计算的就别去检测内部信号，这种方式有悖于假定设计有缺陷的验证思想</li></ul><h1 id="五、比较器checker"><a href="#五、比较器checker" class="headerlink" title="五、比较器checker"></a>五、比较器checker</h1><ul><li>难+维护人力多</li><li>checker肩负了模拟设计行为和功能检查的任务</li></ul><h2 id="checker主要功能"><a href="#checker主要功能" class="headerlink" title="checker主要功能"></a>checker主要功能</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012182110589.png" alt="image-20211012182110589"></p><ul><li>主要用于缓存</li><li>汇聚到内置的reference model，需要实现这样一个模型并花费大量精力维护且不应该参考真实硬件逻辑</li><li>通过数据比较</li><li>对关键功能模块，使用对应线程独立检查</li><li>检查成功信息纳入到检查报告，失败暂停仿真同时报告错误信息的方式进行在线调试</li></ul><h2 id="实现方式：线上比较、线下比较4"><a href="#实现方式：线上比较、线下比较4" class="headerlink" title="实现方式：线上比较、线下比较4"></a>实现方式：线上比较、线下比较4</h2><ul><li>online check</li><li>offline check</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012182508883.png" alt="image-20211012182508883"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183042018.png" alt="image-20211012183042018"></p><p>一开始经常做定向测试，线下测试也Ok，功能复杂起来了就把checker添加到环境里面进行Online check</p><p>这种<strong>预测</strong>的过程称为predictor，同时是reference model也会内置缓存存放DUT输入数</p><h2 id="比较器的组件结构"><a href="#比较器的组件结构" class="headerlink" title="比较器的组件结构"></a>比较器的组件结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183433571.png" alt="image-20211012183433571"></p><p>在结构图下方的一大块是checker</p><p>除了上面介绍的reference model 、formatter FIFO 和 data checker 之外考虑checker对应其他不同模块，进行更细化的检查：</p><ul><li>channel checker</li><li>arbiter checker</li><li>register checker</li><li>formater checker</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183658129.png" alt="image-20211012183658129"></p><p>不难发现checker，monitor，stimulator与MCDF内部的各个模块有着一一对应的关系</p><p>但我们这里<strong>不建议</strong>分布式（分散搁置checker）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183857292.png" alt="image-20211012183857292"></p><p>这里建议集群搁置</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183956070.png" alt="image-20211012183956070"></p><h2 id="比较器总结"><a href="#比较器总结" class="headerlink" title="比较器总结"></a>比较器总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184108611.png" alt="image-20211012184108611"></p><ul><li>对于复杂的系统验证，集中管理stimulator和checker</li><li>monitor相对独立，只需要把数据交给checker</li><li>monitor和stimulator（上图有错不是checker）一一对应，进一步将这部分封装在agent单元中，checker则最终集群搁置在中心化的位置</li></ul><h1 id="六、验证结构"><a href="#六、验证结构" class="headerlink" title="六、验证结构"></a>六、验证结构</h1><p>stimulator-&gt;driver<br>checker-&gt;scoreboard</p><h2 id="实际情景"><a href="#实际情景" class="headerlink" title="实际情景"></a>实际情景</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184518880.png" alt="image-20211012184518880"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184705760.png" alt="image-20211012184705760"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184758284.png" alt="image-20211012184758284"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184929023.png" alt="image-20211012184929023"></p><p><strong>1：1.5</strong></p><p>系统越往高，验证工作量越大，子系统设计的工作量越来越少</p><h2 id="项目计划表"><a href="#项目计划表" class="headerlink" title="项目计划表"></a>项目计划表</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012191702668.png" alt="image-20211012191702668"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012191940230.png" alt="image-20211012191940230"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通1：数据类型_过程方法_设计连接_验证结构</title>
    <link href="/202110112004/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E8%BF%87%E7%A8%8B%E6%96%B9%E6%B3%95_%E8%AE%BE%E8%AE%A1%E8%BF%9E%E6%8E%A5_%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84/"/>
    <url>/202110112004/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E8%BF%87%E7%A8%8B%E6%96%B9%E6%B3%95_%E8%AE%BE%E8%AE%A1%E8%BF%9E%E6%8E%A5_%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113212246487.png" alt="image-20211113212246487"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准相关与常见命名</title>
    <link href="/202110111818/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/01%E6%A0%87%E5%87%86%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D/"/>
    <url>/202110111818/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/01%E6%A0%87%E5%87%86%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="变量定义相关"><a href="#变量定义相关" class="headerlink" title="变量定义相关"></a>变量定义相关</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210928171853.png"/></p><h2 id="常见命名"><a href="#常见命名" class="headerlink" title="常见命名"></a>常见命名</h2><ul><li>mux,mmultiplexer：多路选择器</li><li>sel：多路选择器的那个选择</li><li>idle：状态机的一种状态，初始态、空闲态</li><li>MCDF：多通道数据整合器(一种设计)，可以将上行(uplink)多个通道数据经过内部FIFO最终以数据包的形式送出</li><li>Arbiter：仲裁</li><li>Formater：整形器</li><li>port/module_function_i/o/s(s是指内部信号)</li></ul><h2 id="其他命名"><a href="#其他命名" class="headerlink" title="其他命名"></a>其他命名</h2><ul><li>verifier</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>每个always只能有一个@(event-expression)</li><li>always @(敏感信号) always赋值的右值必须出现在敏感列表里，如果没有则会生成一个则会在综合时生成一个隐形锁存器</li><li>一定要避免生成锁存器，如果提示产生锁存器则代码一定在哪里有bug</li><li>reg和integer的赋值只能在always语句里，且不能在多个always语句中对同一个reg赋值</li><li>如果某个信号赋值为”‘bx”综合器会把其接生成无关状态，因而综合器为其生成的硬件电路最简洁</li><li>所有块的（非beginend,forkend语句）的声明语句右面要有<code>;</code>，如<code>class Transaction;</code>，不过如果后面跟着个冒号取名字就不用写冒号了</li><li>同理也存在<code>endfunction:随便起个名字</code>的命名块</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>标准</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00学前指导：VerilogHDL</title>
    <link href="/202110111718/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/00%E5%AD%A6%E5%89%8D%E6%8C%87%E5%AF%BC%EF%BC%9AVerilogHDL/"/>
    <url>/202110111718/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/00%E5%AD%A6%E5%89%8D%E6%8C%87%E5%AF%BC%EF%BC%9AVerilogHDL/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011172207954.png" alt="image-20211011172207954"></p><p>总体学习图</p><h1 id="一、Verilog-HDL设计速学指导"><a href="#一、Verilog-HDL设计速学指导" class="headerlink" title="一、Verilog HDL设计速学指导"></a>一、Verilog HDL设计速学指导</h1><h2 id="课程推荐"><a href="#课程推荐" class="headerlink" title="课程推荐"></a>课程推荐</h2><p>【电子】Verilog硬件描述语言 西安电子科技大学 蔡觉平等主讲 <a href="https://www.bilibili.com/video/BV12y4y1v7V3">https://www.bilibili.com/video/BV12y4y1v7V3</a></p><p>2020公开课【数字电路与逻辑设计】-华中科技大学 <a href="https://www.bilibili.com/video/BV197411u7dZ">https://www.bilibili.com/video/BV197411u7dZ</a></p><p>没有必要全都学，三无基础重点放在v2.1v2.2</p><h2 id="教材推荐"><a href="#教材推荐" class="headerlink" title="教材推荐"></a>教材推荐</h2><p>数电推荐：邬春明 《数字电路与逻辑设计》<br>verilog推荐：蔡觉平《Verilog HDL数字集成电路设计原理与应用》</p><h2 id="数电速学"><a href="#数电速学" class="headerlink" title="数电速学"></a>数电速学</h2><!-- ![image-20211011173233003](https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173233003.png) --><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173947985.png" alt="image-20211011173947985"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011174326415.png" alt="image-20211011174326415"></p><p><strong>数电和逻辑-4 触发器（时序电路基础） 数电和逻辑-5 时许逻辑电路</strong></p><h2 id="Verilog-速学"><a href="#Verilog-速学" class="headerlink" title="Verilog 速学"></a>Verilog 速学</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173318582.png" alt="image-20211011173318582"></p><p>2.1-2.4参考蔡老师课本</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173150821.png" alt="image-20211011173150821"></p><p>insert</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173248125.png" alt="image-20211011173248125"><br>Modelsim很多是为了做设计，Questasim为了跑验证，基本一致的一家的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173259382.png" alt="image-20211011173259382"></p><h1 id="二、查找学习SV语法的方法"><a href="#二、查找学习SV语法的方法" class="headerlink" title="二、查找学习SV语法的方法"></a>二、查找学习SV语法的方法</h1><p>带数字的是绿皮书章节</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011182644186.png" alt="image-20211011182644186"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="SV精通1（硬件偏多）"><a href="#SV精通1（硬件偏多）" class="headerlink" title="SV精通1（硬件偏多）"></a>SV精通1（硬件偏多）</h3><p>sv中使用always非常之少但也要学  </p><p>第一周是建立一个基本概念，</p><h3 id="SV精通2（硬软过度）"><a href="#SV精通2（硬软过度）" class="headerlink" title="SV精通2（硬软过度）"></a>SV精通2（硬软过度）</h3><ul><li><p>接口-&gt;从硬件过渡到软件</p></li><li><p>有了接口会讲到采样和驱动，时钟块，SV里面的开始和结1束</p></li><li><p>与verilog的program对比</p></li><li>quseta 的helloworld</li></ul><h3 id="SV精通3（软件友好）"><a href="#SV精通3（软件友好）" class="headerlink" title="SV精通3（软件友好）"></a>SV精通3（软件友好）</h3><p>第一周讲的是设计往验证过度</p><p>第二周讲的设计转到验证需要接口，作为激励和采样</p><p>第三周对验证环境进行创建</p><p> <strong>绿皮书没有讲到包的使用，较为重要这里学</strong></p><h3 id="SV精通4"><a href="#SV精通4" class="headerlink" title="SV精通4"></a>SV精通4</h3><p>进入到随机，为什么学完类学随机？</p><ul><li>我们会把做随机的数变量封装在类里</li></ul><p>为什不用系统函数？</p><ul><li>随机的精髓在于约束，自由随机没有意义，对多个变量约束会有真正意义</li></ul><p>多个变量的约束可以会映射到真实世界里</p><p> 随机会伴随着约束，约束我们会添加到类里面</p><p>约束添加到类意外时内嵌的约束</p><p>因此我们会讲到随机数的控制即：随机函数</p><p>最后讲到最常用到的数组约束，因为数组用到的太多了，更是<strong>难点</strong></p><h3 id="SV精通5（线程）"><a href="#SV精通5（线程）" class="headerlink" title="SV精通5（线程）"></a>SV精通5（线程）</h3><p>SV里面涉及到并行，真实的物理世界里面的信号在任何时刻并行</p><p>我想在同一个时间点对软件发送多个数据</p><p>用软件并行的方式和软件去做token4</p><p>emailbox做一个基本的存储、事件做一个基本的驱动、旗语对一个敏感资源进行保护</p><h3 id="SV精通6"><a href="#SV精通6" class="headerlink" title="SV精通6"></a>SV精通6</h3><p>谈到覆盖率和高级的一部分了</p><p>覆盖率的收集，</p><p>覆盖率有点像SV的收尾，我们想用一个宏观的高级的语言为设计构建验证环境，在构建后区别固定每次都是随机的，每次都是不同的数据，这样会出现没发现的bug，但我们组合出来的情况会非常多，因此我们增加加约束且应该是合理的激励，即便是合理的激励，我们要知道合理的激励的有效组合到底数据有没有发生过，激励有没有发生过，这些激励对关键信号有没有发生</p><p>你不能依赖眼睛去观察，应该是一种自动化的手段，这里面牵扯到覆盖率</p><p>覆盖率我门会讲到：<strong>代码覆盖率、功能覆盖率</strong></p><p>代码覆盖率是编译器仿真器，按照要求添加后，会把覆盖率要求添加上来</p><p>功能覆盖率需要认为定义，是我们的<strong>重点 </strong>，我们要知道我们关心哪些信号，关心那些事件把他们作为事件， 把他们作为定义；作为定义例化；我们需要指导什么样的时间段要采样到这些数据，为什么要采样到这些数据；采样的这些数据在不同的测试用例里面，不断地测试，不断地采样到这些数据，最终汇总起来，我们才能有一个<strong>量化</strong>的数据在里面，才能知道到底我们产生了什么样的激励、这些激励帮我们触发了那些状态、这些状态最终是否满足要求、还有哪些状态没有被触发。这几点是验证行业这里两年标准化的重要一点</p><h3 id="SV精通7"><a href="#SV精通7" class="headerlink" title="SV精通7"></a>SV精通7</h3><p>第六周还有高阶的一点是这里</p><p>这几点必须要讲到，对应UVM的各种场景，只有了解了才能明白那些是UVM的规范、哪些是SV的知识</p><p>各个点SV和UVM对应起来有区别</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011194152963.png" alt="image-20211011194152963"></p><h1 id="三、查找学习SV语法的方法"><a href="#三、查找学习SV语法的方法" class="headerlink" title="三、查找学习SV语法的方法"></a>三、查找学习SV语法的方法</h1><h2 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011204144473.png" alt="image-20211011204144473"></p><p><strong>到底哪些知识点是verilog哪些是sv?</strong></p><p>verilog：</p><p>绝大部分知识点在蔡老师《Verilog HDL数字集成电路设计原理与应用》这本书里，比较薄</p><p>SV语法：</p><ul><li>常见语法大类看绿皮书</li><li>细致语法看IEEE SystemVerilog标准手册</li><li>语法的应用，结合V2.1讲义和实验内容，完成从语法点到实际应用</li></ul><p><strong>学SV时你需要会分清楚那些事verilog那些事SV</strong></p><p>SV新扩展内容只占了10%，主要是验证扩展内容“for vefryication”，因此SV标准手册很少提到verilog，IEEE2012和2017版本差别不大</p><p>当我们拿到手册时，我们的思路是，如何知道细碎的语法点？</p><p>自己多应用吧</p><p>语法手册当作字典。没有人把字典读完。</p><h2 id="查看SV的方法、类’验证结构可以利用DVT-Eclipse"><a href="#查看SV的方法、类’验证结构可以利用DVT-Eclipse" class="headerlink" title="查看SV的方法、类’验证结构可以利用DVT Eclipse"></a>查看SV的方法、类’验证结构可以利用DVT Eclipse</h2><p>学了v2.4以后可以把项目都移植过去</p><h2 id="如何看手册"><a href="#如何看手册" class="headerlink" title="如何看手册"></a>如何看手册</h2><p>最常用的：第三章（只是介绍）</p><p>第四章不建议前期看，直接去第六章去看（数据类型），第六章每一节都很必要(var类型在定义wire或reg等其他类型时默认了)<br>scope &amp; lifetime 域和生命周期</p><p>第七章讲的各种类型的数组 </p><p>第八章和类相关</p><p>第九章是process在verilog中讲过<br>timing control?</p><p>第十一章Operators需要用到，以及优先级，以及默认无符号的可以通过signed 主动声明</p><p>第十五章进程间的通信</p><p>十六章讲断言</p><p>十七章Checker不再用，我们不再用SV中的Checker做检查</p><p>十八章随机数的产生，注意随机种子，其实不看也行</p><p>十九章V2.1第六周的内容相关，功能覆盖率</p><p>二十章二十一章系统函数有必要，找不到则在Verilog中找</p><p>二十二章编译向导在Verilog中提到，讲那些编译编那些编译不编</p><p>第二部分：层次化构建，更靠近设计部分的东西</p><p>二十三章模块是怎么定义的</p><p>二十四章Programs几乎不怎么用</p><p>二十五张Interface重点看一下，virtual interface其实指的是接口指针</p><p>二十六章package怎么定义，module里面import package，以及order。26.7讲内嵌的一些方法，始于以下标准库</p><p>二十七章Generate动态的参数来例化多少个模块以及语句，</p><p>第三部分：api的接口</p><p>暂时放一边</p><p>第四部分：附录</p><p>暂时放一边</p><p>重点在，第六章开始</p><h2 id="使用DVT"><a href="#使用DVT" class="headerlink" title="使用DVT"></a>使用DVT</h2><p>DVT如何去引用之前定义好的，建立好的实验导入进去，用DVT查找最大的好处是用来查找UVM</p><h1 id="四、DVT帮助理解实验代码"><a href="#四、DVT帮助理解实验代码" class="headerlink" title="四、DVT帮助理解实验代码"></a>四、DVT帮助理解实验代码</h1><h1 id="五、UVM入门进阶学习路线"><a href="#五、UVM入门进阶学习路线" class="headerlink" title="五、UVM入门进阶学习路线"></a>五、UVM入门进阶学习路线</h1><h2 id="路线图-1"><a href="#路线图-1" class="headerlink" title="路线图"></a>路线图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011194929424.png" alt="image-20211011194929424"></p><p>一旦进入UVM中，牵扯到的知识面广，没有办法用sv一样剥离开，里面有很多复杂的类和语法支撑他</p><p>地图里面十个大类，日常生活中用到不到百分之三十，要知道哪些类重要</p><h2 id="UVM核心机制"><a href="#UVM核心机制" class="headerlink" title="UVM核心机制"></a>UVM核心机制</h2><p>(1) 一开始介绍核心机制，以后看见UVM的验证代码里面用了某种机制实现的就在这里提到了</p><p>(2) 工厂一定要用到，UVM使用到的所有类型都要用到工厂</p><p>(3) 覆盖方法不一定会遇到，深入以后一定跑不了</p><p>(4) 核心基类：uvmobject/uvmcompoment，compoment继承于object，第二周的组件结构都是componment的内容，object不属于验证结构的一部分，在激励组织里面的sequentce,item属于object类型<br>什么时候compoment什么时候object?<br>不会轻易死亡的是compoment<br>在仿真的某一时间开始某一时间结束掉的是object</p><p>(5) phase机制，九大phase,十二个小的phase，对应在sv里面的创建部分</p><p>(6) config机制是sv的一个痛点，sv中要对验证组件进行配置时，必须先对组件进行配置。到了UVM中在组件没有创建前，把config保存到中间的某一个database，后来的底层部件在从这里get</p><p>(7) 消息机制，SV里面的report，是提前熟悉UVM里消息机制的</p><p>以上这些必须熟悉，不以后不好学</p><h2 id="UVM组件结构和环境构建"><a href="#UVM组件结构和环境构建" class="headerlink" title="UVM组件结构和环境构建"></a>UVM组件结构和环境构建</h2><p>容易理解，似曾相识<br>scoreboard对应chater<br>driver对应simulator<br>sequencer仲裁的功能</p><h2 id="TLM通信"><a href="#TLM通信" class="headerlink" title="TLM通信"></a>TLM通信</h2><h2 id="激励的组织和传输机制"><a href="#激励的组织和传输机制" class="headerlink" title="激励的组织和传输机制"></a>激励的组织和传输机制</h2><h2 id="寄存器模型组织及应用"><a href="#寄存器模型组织及应用" class="headerlink" title="寄存器模型组织及应用"></a>寄存器模型组织及应用</h2><h1 id="八、验证流程管理"><a href="#八、验证流程管理" class="headerlink" title="八、验证流程管理"></a>八、验证流程管理</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011203447304.png" alt="image-20211011203447304"></p><h2 id="DVT-Eclipse"><a href="#DVT-Eclipse" class="headerlink" title="DVT Eclipse"></a>DVT Eclipse</h2><p>SV/UVM v2.1提到，很好用</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>指导</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora使用帮助</title>
    <link href="/202110111507/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/typora%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"/>
    <url>/202110111507/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/typora%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不得不感叹typora是真的优美啊，之前一直用有道云记笔记，感觉多端同步挺舒服的，自己也烂的转移，终于到今天打脸了</p><p>下载就64MB，拜学校图书馆网速能跑炸测速网，平均速度68MB/s所赐一秒钟，真就一秒钟下完了</p><p>一打开界面就只有菜单栏和中间一大片的空白canvas，连图标都没有显示。侧边的文件栏也很有直觉可以切换视图，列表视图显示文件夹下所有markdown，树视图就直接文件夹层级了，点开的过度动画很有美感，可以直接打开文件夹，直呼过瘾</p><p>文档编写时markdown的显示与代码融合在一起，不过也可以底边切换成源代码格式，标题在写作模式也可以直接点开，是真的好用！配合以前装的PicGo直接ctrl v完成图片上传，舒服！</p><p>不得不边用便赞叹开发者的匠心，每一处细节都考虑的如此精确</p><h1 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h1><h3 id="关于enter与shift-enter"><a href="#关于enter与shift-enter" class="headerlink" title="关于enter与shift+enter"></a>关于enter与shift+enter</h3><p>本质上Shift+Enter和Enter的换行效果就是“换行符”和“段落标记”的区别，前者不分段，后者分段。在HTML中，前者表示为<code>&lt;br&gt;</code>标记，后者表示为<code>&lt;p&gt;</code>标记对应的结束标记<code>&lt;/p&gt;</code></p><p>之所以另起一段的换行效果与“单行换行”有区别，原因是css样式里往往将段落元素<code>&lt;p&gt;</code>的间距加大了，类似于加大了段间距。题主可以试着找一找有没有Typora的css样式模板把段间距改没了的，或者实在不行自己动手改原有的模板</p><h3 id="Typora-PicGo-Core"><a href="#Typora-PicGo-Core" class="headerlink" title="Typora+PicGo-Core"></a>Typora+PicGo-Core</h3><ol><li>按下图所示勾选<code>插入图片时</code>的选项，并在<code>上传服务设定</code>选择<code>PicGo-Core(command line)</code>，点击<code>下载或更新</code>按钮下载插件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f34bc8b782d6127ed0b3d2889b43058e.png" alt="图片1"></p><ol><li>安装插件：安装完成后，到软件安装目录，使用命令行分别安装三个插件</li></ol><ul><li>windows系统一般在C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\文件夹，文件名为picgo.exe；</li><li>linux系统一般在~/.config/Typora/picgo/linux/文件夹，文件名为picgo；</li></ul><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">.\picgo.exe <span class="hljs-keyword">install</span> smms-user<br>.\picgo.exe <span class="hljs-keyword">install</span> gitee-uploader<br>.\picgo.exe <span class="hljs-keyword">install</span> github-plus<br></code></pre></div></td></tr></table></figure><ol><li>修改typora配置文件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/6828e8cc3a78d6a8293d7124ee847f7e.png" alt=""></p><p>gitee仓库如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs &#123;">  &quot;picBed&quot;: &#123;<br>    &quot;current&quot;: &quot;gitee&quot;,<br>    &quot;uploader&quot;: &quot;gitee&quot;,<br>    &quot;gitee&quot;: &#123;<br>      &quot;branch&quot;: &quot;master&quot;,<br>      &quot;customPath&quot;: &quot;yearMonth&quot;,<br>      &quot;customUrl&quot;: &quot;&quot;,<br>      &quot;path&quot;: &quot;仓库下的文件夹&quot;,<br>      &quot;repo&quot;: &quot;用户id/仓库名&quot;,<br>      &quot;token&quot;: &quot;gitee上申请的私人令牌&quot;<br>    &#125;<br>  &#125;,<br>  &quot;picgoPlugins&quot;: &#123;<br>    &quot;picgo-plugin-gitee-uploader&quot;: true<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>阿里云仓库如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs &#123;">  &quot;picBed&quot;: &#123;<br>   &quot;uploader&quot;: &quot;aliyun&quot;,<br>    &quot;aliyun&quot;: &#123;<br>    &quot;accessKeyId&quot;: &quot;&quot;,<br>    &quot;accessKeySecret&quot;: &quot;&quot;,<br>    &quot;bucket&quot;: &quot;&quot;, // 存储空间名<br>    &quot;area&quot;: &quot;&quot;, // 存储区域代号<br>    &quot;path&quot;: &quot;img/&quot;, // 自定义存储路径<br>    &quot;customUrl&quot;: &quot;&quot;, // 自定义域名，注意要加 http://或者 https://<br>    &quot;options&quot;: &quot;&quot; // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+<br>    &#125;<br>  &#125;,<br>  &quot;picgoPlugins&quot;: &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>current</strong>为当前的图床，uploader表示上传用的图床，这里两个都设置为gitee；<br><strong>master</strong>表示主分支，一般用做图床的仓库是个单独的仓库，此处保持master就好；<br><strong>path</strong>为仓库下的文件夹，repo为仓库名，假如如有一个仓库名为a，图片存在这个仓库下的b文件夹，<strong>你的用户id是linux（浏览器地址栏仓库名前的字符串）</strong>，则path为b、repo为linux/a；<br><strong>token</strong>为私人令牌，需要在gitee网站申请，申请的token只出现一次，点击复制按钮将其粘贴到配置文件中即可，一个用户可以有多个token，可以在gitee网站管理自己的token。</p><p><strong>使用的插件都要在<code>picgoPlugins</code>里包含并设置为<code>true</code>，这里只使用了<code>gitee</code>插件</strong></p><h4 id="参考配置博客"><a href="#参考配置博客" class="headerlink" title="参考配置博客"></a>参考配置博客</h4><p><a href="https://blog.csdn.net/to_free/article/details/114981807">typora+gitee</a><br><a href="https://blog.csdn.net/to_free/article/details/108784006">Typora+gitee+notejs+坚果云构建私有云笔记</a><br><a href="https://blog.csdn.net/qq_39714832/article/details/111257518">Typora+图床详解（小白都能学得会）</a></p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识1：验证任务_目标、验证周期</title>
    <link href="/202110042004/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%E3%80%81%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F/"/>
    <url>/202110042004/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%E3%80%81%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的目标"><a href="#一、验证的目标" class="headerlink" title="一、验证的目标"></a>一、验证的目标</h1><h2 id="1-验证工程师面临的任务"><a href="#1-验证工程师面临的任务" class="headerlink" title="1.验证工程师面临的任务"></a>1.验证工程师面临的任务</h2><ul><li>模块级 module level</li><li>子系统级 subsytem level</li><li>系统级 chip level</li></ul><h2 id="2-验证的目标：按时、保质、低耗"><a href="#2-验证的目标：按时、保质、低耗" class="headerlink" title="2.验证的目标：按时、保质、低耗"></a>2.验证的目标：按时、保质、低耗</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201036.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201201.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201325.png"/></p><h1 id="二、验证周期"><a href="#二、验证周期" class="headerlink" title="二、验证周期"></a>二、验证周期</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201426.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201712.png"/></p><p><strong>回归测试简单来讲把已有的测试都做一遍</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201806.png"/></p><h2 id="上述细致解释"><a href="#上述细致解释" class="headerlink" title="上述细致解释"></a>上述细致解释</h2><h3 id="（1）功能描述文档"><a href="#（1）功能描述文档" class="headerlink" title="（1）功能描述文档"></a>（1）功能描述文档</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202117.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202700.png"/></p><h3 id="（2）验证计划"><a href="#（2）验证计划" class="headerlink" title="（2）验证计划"></a>（2）验证计划</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202842.png"/> </p><h3 id="（3）验证环境"><a href="#（3）验证环境" class="headerlink" title="（3）验证环境"></a>（3）验证环境</h3><p><strong>工具主流quasta，方法主流动态仿真</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203302.png"/></p><h3 id="（4）uvm帮助调试-debug"><a href="#（4）uvm帮助调试-debug" class="headerlink" title="（4）uvm帮助调试(debug)"></a>（4）uvm帮助调试(debug)</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203826.png"/></p><h3 id="（5）-回归测试"><a href="#（5）-回归测试" class="headerlink" title="（5） 回归测试"></a>（5） 回归测试</h3><p><strong>修复bug后再跑一边全部测试用例</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203944.png"/></p><h3 id="（6）硅后与流片"><a href="#（6）硅后与流片" class="headerlink" title="（6）硅后与流片"></a>（6）硅后与流片</h3><p>即便流片还需要功能验证，不断提高覆盖率</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204112.png"/></p><h3 id="（7）硅后系统测试"><a href="#（7）硅后系统测试" class="headerlink" title="（7）硅后系统测试"></a>（7）硅后系统测试</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204327.png"/></p><h3 id="（8）逃逸分析"><a href="#（8）逃逸分析" class="headerlink" title="（8）逃逸分析"></a>（8）逃逸分析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204442.png"/></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随便记一点：初识aurora接口</title>
    <link href="/202110042004/IC/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/auroraessay/ic/%E6%8E%A5%E5%8F%A3/aurora/%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%AD%A5/"/>
    <url>/202110042004/IC/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/auroraessay/ic/%E6%8E%A5%E5%8F%A3/aurora/%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190509145732524.png" alt=""></p><p><em>sof_n：数据传输开始标志，低电平有效；</em>eof_n：数据传输结束标志，低电平有效；<br>*rdy_n：传输数据有效标志，低电平有效；</p><h2 id="Status-and-Control-Ports"><a href="#Status-and-Control-Ports" class="headerlink" title="Status and Control Ports"></a>Status and Control Ports</h2><ul><li><p>reset/tx_ststem_reset/rx_system_reset</p></li><li><p>gt_reset：r. The gt_reset port should be asserted when the module is first powered up in hardware.</p></li><li><p>init_clk_in:The init_clk_in port is required because user_clk stops when </p><p>gt_reset is asserted. It is recommended that the frequency chosen for init_clk_in be lower than the GT Reference Clock input frequency.</p></li><li><p>tx_aligned,tx_bonded,tx_verify,rx_reset:与rx的对应接口相连</p><p>Only available in TX-only simplex dataflow mode and sideband as back channel core configuration.</p></li></ul><p>Only available in RX-only simplex dataflow mode and sideband as back channel core configuration.</p><h2 id="Status-and-Control-Ports-Cont’d"><a href="#Status-and-Control-Ports-Cont’d" class="headerlink" title="Status and Control Ports  (Cont’d)"></a>Status and Control Ports  <strong>(Cont’d)</strong></h2><p>暂空，和上节表对应</p><h2 id="Full-Duplex-Status-and-Control-Ports"><a href="#Full-Duplex-Status-and-Control-Ports" class="headerlink" title="Full-Duplex Status and Control Ports"></a><strong>Full-Duplex Status and Control Ports</strong></h2><p>Cont’d是续的意思，这里是续表</p><p>lane_up总线指示通道中的哪些车道已完成车道初始化过程。该信号可用于帮助调试多通道信道中的设备问题</p><p>channel_up只有在核心完成整个初始化过程后才会断言</p><p>在断言channel_up之前无法接收数据。只能使用用户界面上的m_axi_rx_tvalid信号来限定传入的数据。</p><p>channel_up可以倒置，用于重置驱动全双工通道TX侧的模块，因为直到channel_up之后才能发生传输</p><p>如果在数据接收前需要重置用户应用程序模块，则可以倒置并使用其中一个lane_up信号。在断言所有lane_up信号后才能接收数据</p><h2 id="Simplex-Cores"><a href="#Simplex-Cores" class="headerlink" title="Simplex Cores"></a><strong>Simplex Cores</strong></h2><h2 id="This-interface-includes-the-serial-I-O-ports-of-the-transceivers-and-the-control-and-status"><a href="#This-interface-includes-the-serial-I-O-ports-of-the-transceivers-and-the-control-and-status" class="headerlink" title="This interface includes the serial I/O ports of the transceivers, and the control and status"></a>This interface includes the serial I/O ports of the transceivers, and the control and status</h2>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>接口与协议</category>
      
      <category>aurora</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>fpga</tag>
      
      <tag>aurora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo的fluid主题的背景固定</title>
    <link href="/202110011100/%E9%80%9A%E7%9F%A5notify/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A/"/>
    <url>/202110011100/%E9%80%9A%E7%9F%A5notify/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="基于hexo的fluid主题的背景固定"><a href="#基于hexo的fluid主题的背景固定" class="headerlink" title="基于hexo的fluid主题的背景固定"></a>基于hexo的fluid主题的背景固定</h1><p>背景固定效果需要使用注入器，因此需要将hexo升至5.0版本以上</p><p>效果如本页所示，这种效果贯穿着整个博客。具体做法如下：使用<code>注入器</code>(如果没有<code>injector.js</code>文件，则在<code>scripts</code>文件夹下新建<code>injector.js</code>)，在<code>injector.js</code>中写下这些代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 全屏背景的需要导入这些js</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/&quot;</span> &#125; = hexo.config;<br>hexo.extend.injector.register(<span class="hljs-string">&quot;body_begin&quot;</span>, <span class="hljs-string">`&lt;div id=&quot;web_bg&quot;&gt;&lt;/div&gt;`</span>);<br>hexo.extend.injector.register(<br>  <span class="hljs-string">&quot;body_end&quot;</span>,<br>  <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/backgroundize.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;link defer rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>css/backgroundize.css&quot; /&gt;</span><br><span class="hljs-string">  `</span><br>);<br></code></pre></div></td></tr></table></figure><p>在<code>js</code>文件夹中新建<code>backgroundize.js</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bannerContainer = $(<span class="hljs-string">&quot;#banner&quot;</span>);<br><span class="hljs-keyword">const</span> viewBg = $(<span class="hljs-string">&quot;#web_bg&quot;</span>);<br><span class="hljs-keyword">const</span> bannerMask = $(<span class="hljs-string">&quot;#banner .mask&quot;</span>);<br><span class="hljs-keyword">const</span> bg = $(bannerContainer).css(<span class="hljs-string">&quot;background-image&quot;</span>);<br>$(viewBg).css(<span class="hljs-string">&quot;background-image&quot;</span>, bg);<br>$(bannerContainer).css(<span class="hljs-string">&quot;background-image&quot;</span>, <span class="hljs-string">&quot;url()&quot;</span>);<br><span class="hljs-keyword">const</span> color = $(bannerMask).css(<span class="hljs-string">&quot;background-color&quot;</span>);<br>$(bannerMask).css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">`rgba(0,0,0,0)`</span>);<br>$(viewBg).css(<span class="hljs-string">&quot;background-color&quot;</span>, color);<br></code></pre></div></td></tr></table></figure><p>在<code>css</code>文件夹中新增<code>backgroundize.css</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">#web_bg &#123;<br>  <span class="hljs-attr">position</span>: fixed;<br>  z-index: -<span class="hljs-number">999</span>;<br>  width: <span class="hljs-number">100</span>%;<br>  height: <span class="hljs-number">100</span>%;<br>  background-attachment: local;<br>  background-position: center;<br>  -webkit-background-size: cover;<br>  -moz-background-size: cover;<br>  background-size: cover;<br>  background-repeat: repeat;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意确认保存css的文件夹名称是css或是style，如果是style则需更改injector.js的导入文件地址</strong></p>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog可综合的语法</title>
    <link href="/202109272059/IC/%E7%9F%A5%E8%AF%86essay/ic/verilog%E5%AD%A6%E4%B9%A0/01Verilog%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <url>/202109272059/IC/%E7%9F%A5%E8%AF%86essay/ic/verilog%E5%AD%A6%E4%B9%A0/01Verilog%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="可综合的含义是"><a href="#可综合的含义是" class="headerlink" title="可综合的含义是"></a>可综合的含义是</h3><p>把语言描述变成电路网表，综合软件采用器件库提供的标准单元将RTL级描述转换成门级网表，具体综合过程如下：<br> <span id="more"></span></p><ol><li><p>综合软件读取RTL级代码（可综合的代码），将其转换成门级网表，确保门级的网表的输入输出关系与RTL代码描述的输入输出关系保持一致</p></li><li><p>对门级网表进行优化（局部优化）</p></li><li><p>采用器件库内标准的原件或者FPGA内部的逻辑单元实现优化后的门级网表</p></li></ol><p><a href="https://www.eefocus.com/initial_wei/blog/12-10/287444_c623b.html">而乐鑫2022数字IC实习类笔试最后一个多选题也考了关于Verilog可综合的语法，查阅了一下相关资料，这篇文章总结的很全</a></p><p>所有综合工具都支持的结构：<br>always，assign，begin，end，case，wire，tri，aupply0，supply1，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，buf，not，bufif0，bufif1，notif0，notif1，if，inout，input，instantitation，module，negedge，posedge，operators，output，parameter</p><h3 id="所有综合工具都不支持的结构："><a href="#所有综合工具都不支持的结构：" class="headerlink" title="所有综合工具都不支持的结构："></a>所有综合工具都不支持的结构：</h3><p>time，defparam，$finish，fork，join，initial，delays，UDP，wait</p><h3 id="有些工具支持有些工具不支持的结构："><a href="#有些工具支持有些工具不支持的结构：" class="headerlink" title="有些工具支持有些工具不支持的结构："></a>有些工具支持有些工具不支持的结构：</h3><p>casex，casez，wand，triand，wor，trior，real，disable，forever，arrays，memories，repeat，task，while</p><p>Verilog中提供了四种循环语句，可用于控制语句的执行次数，分别是for、while、repeat、forever</p><h3 id="关于while、repeat、forever："><a href="#关于while、repeat、forever：" class="headerlink" title="关于while、repeat、forever："></a>关于while、repeat、forever：</h3><p>while和repeat可以综合，但是循环次数需要在编译之前就确定，动态改变循环次数是不可综合的，forever是不可综合的，它主要用来产生各种激励</p><p>部分参考： <a href="http://xilinx.eetrend.com/content/2019/100045400.html">http://xilinx.eetrend.com/content/2019/100045400.html</a></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>microblaze运行linux方案探索</title>
    <link href="/202109131145/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1essay/projects/1/"/>
    <url>/202109131145/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1essay/projects/1/</url>
    
    <content type="html"><![CDATA[<h2 id="方案背景"><a href="#方案背景" class="headerlink" title="方案背景"></a>方案背景</h2><p>microblaze上跑linux的方案，包括如何启动和固化<br> <span id="more"></span></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案(1)"></a>解决方案(1)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912195221.png"/></p><h3 id="1-相关技术"><a href="#1-相关技术" class="headerlink" title="1 相关技术"></a>1 相关技术</h3><h4 id="1-1-microblaze运行linux可行性"><a href="#1-1-microblaze运行linux可行性" class="headerlink" title="1.1 microblaze运行linux可行性"></a>1.1 microblaze运行linux可行性</h4><ol><li>主要开发文档<br><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">ug1144</a></li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912221635.png"/></p><ol><li>microblaze官方wiki</li></ol><p>介绍mmu,处理器结构,microblaze with linux</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913101354.png"/></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842560/MicroBlaze">原文链接</a></p><ol><li>4种启动方案与一种实现案例(博客)</li></ol><p><span id="MicroBlaze处理器的PetaLinux操作系统移植"></p><p><a href="http://www.eepw.com.cn/article/191233.htm">MicroBlaze处理器的PetaLinux操作系统移植：</a>PetaLinux有4种启动方案：XMD下载启动、TFTP网络下载启动、Flash启动和SysACE CF卡启动。其中，XMD和TFTP网络下载启动方案，在每次系统上电后都必须重新下载，适用于系统调试；Flash启动方案在系统上电后自动从Flash中读取配置文件，但Flash烧写速度较慢，更改系统配置较为不便。因此，本系统选用SysACECF卡启动方案..</p><ol><li>mircoblaze的vivado搭建官方指南</li></ol><p><a href="https://www.xilinx.com/support/documentation-navigation/design-hubs/dh0020-microblaze-hub.html">相关文档大全</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913101955.png"/></p><p>《ug940》</p><h4 id="1-2固化bitstream文件"><a href="#1-2固化bitstream文件" class="headerlink" title="1.2固化bitstream文件?"></a>1.2固化bitstream文件?</h4><p>1.传统方法对Bitstream进行flash固化</p><p>需要说明的是，下载完比特流后，如果开发板断电，程序会丢失。如果想要程序断电不丢失的话，需要将程序固化至开发板中，这个需要在嵌入式 SDK 软件中完成， ZYNQ 芯片无法单独固化比特流文件(PL的配置文件)。这是由于 ZYNQ 非易失性存储器的引脚(如 SD 卡、QSPI Flash)是 ZYNQ PS 部分的专用引脚， 这些非易失性存储器由 PS 的 ARM 处理器进行驱动，需要将bit流文件和elf文件（软件程序的下载文件） 合成一个 BOOT.BIN，才能进行固化， 因此需要学习 ZYNQ 嵌入式 SDK 的开发流程。</p><ol><li><strong>尚不明确micrblaze软核是先进行固化后在完成镜像移植启动，还是在镜像移植</strong></li></ol><!--2.如果要实现Linux系统，是需要进行petalinux移植时固化？--><!--[参考文章：](#MicroBlaze处理器的PetaLinux操作系统移植)--><!--PetaLinux有4种启动方案：XMD下载启动、TFTP网络下载启动、Flash启动和SysACE CF卡启动。其中，XMD和TFTP网络下载启动方案，在每次系统上电后都必须重新下载，适用于系统调试；Flash启动方案在系统上电后自动从Flash中读取配置文件，但Flash烧写速度较慢，更改系统配置较为不便。因此，本系统选用SysACECF卡启动方案。--><!--在petalinux创建ps端linux系统时的hdf中包括microblaze软核及其周边外设--><h3 id="2-相关设计参考"><a href="#2-相关设计参考" class="headerlink" title="2 相关设计参考"></a>2 相关设计参考</h3><h4 id="2-1-启动-使用flash完成操作系统启动"><a href="#2-1-启动-使用flash完成操作系统启动" class="headerlink" title="2.1 启动(使用flash完成操作系统启动)"></a>2.1 启动(使用flash完成操作系统启动)</h4><p><a href="https://blog.csdn.net/weiaipan1314/article/details/110679080">参考启动流程：</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913105356.png"/></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842560/MicroBlaze">参考文章MicroBlaze 上的嵌入式软件堆栈概述：</a><br>MicroBlaze 的软件堆栈不像Xilinx的其他嵌入式设备那样从加固的BootROM开始。相反，初始引导代码必须包含在FPGA比特流中，通常通过初始化映射到MicroBlaze引导向量的一小块 BlockRAM来实现。对于某些系统，整个应用程序可能会驻留在这个BlockRAM 中。对于更复杂的系统（例如Linux），可以在BlockRAM中初始化第一阶段引导加载程序。Xilinx 提供了一个称为 FS-Boot的第一阶段引导加载程序，它在启动时执行并负责将第二阶段引导加载程序（通常是U-Boot，但可能是最终应用程序）从非易失性存储器复制到 MicroBlaze可以从中执行的存储器中，通常为DDR。FS-Boot 至少需要 8KB 的 BlockRAM。 </p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913105918.png"/></p><p>有关创建 FS-Boot 并将其合并到比特流中的更多信息，请参阅PetaLinux 工具指南。 </p><p><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">microblaze启动手册说明—《ug11440》:</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913112526.png"/></p><p><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">flash做uboot—《ug1144》:</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913110611.png"/></h2><p><a href="https://www.xilinx.com/support/answers/50991.html">zynq支持的flash容量</a></p><h4 id="2-2-BD设计结构参考"><a href="#2-2-BD设计结构参考" class="headerlink" title="2.2 BD设计结构参考"></a>2.2 BD设计结构参考</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912221254.png"/></p><h4 id="2-3-设计方案猜想"><a href="#2-3-设计方案猜想" class="headerlink" title="2.3 设计方案猜想"></a>2.3 设计方案猜想</h4><p>通过petalinux配置位于flash启动镜像并封装，使用jtag完成镜像启动？</p><h3 id="3-其他注意点"><a href="#3-其他注意点" class="headerlink" title="3 其他注意点"></a>3 其他注意点</h3><h4 id="3-1-ug1144-P17"><a href="#3-1-ug1144-P17" class="headerlink" title="3.1 ug1144,P17"></a>3.1 ug1144,P17</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913111726.png"/></p><!--正点原子zynq5pynq开发指南P99--><h2 id="解决方案-2-—还未研究"><a href="#解决方案-2-—还未研究" class="headerlink" title="解决方案(2)—还未研究"></a>解决方案(2)—还未研究</h2><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><h4 id="1-uclinux"><a href="#1-uclinux" class="headerlink" title="1 uclinux"></a>1 uclinux</h4><p>运行uclinux嵌入式系统uclinux表示micro-control linux</p><p><a href="http://www.doc88.com/p-1505465960626.html">在Microblaze处理器上进行uclinux移植</a><br><a href="https://www.zhihu.com/question/66072428">除了uclinux，在单片机上可以移植哪些版本的linux</a></p><p>无名无名 (提问者)2017-10-09<br>也就是说，在目前的嵌入式市场里面，不带mmu的系统已经占比特别少了，对吗？</p><p>jiangtao9999<br>jiangtao9999 (作者) 回复无名 (提问者)2017-10-12<br>所以我说放弃单片机这个概念。因为你用的东西也不一定就真的是通用 CPU 但也不一定就真的是几千个晶体管的只能当作 DPS 看待的玩意。现在技术提升了，很多功能溢出的 CPU 也不贵。很多人就会倾向于选择通用设备而方便开发。而且现在这种产品的需求量也是很大的，功能残缺的东西，也大有人用。这些东西，有的时候不是再跑个 uclinux 去浪费资源，而是直接写成运行功能的代码，不用操作系统直接运行的了。</p><p>怎么说呢。现在定义上，只要能实现一个芯片搞定，就叫单片机。但是随着技术发展，很多东西都能封装到一个芯片上，但是实际上内部设计，还是不同功能独立区分的。所以相对来说 ARM 更多的类似于多个芯片集成封装。更何况 ARM 内部集成的电路还有更多的功能。而不是传统的那种真的只有一个芯片设计的 CPU 了。你可以理解单片机就是为了一件任务做设计的，没有高级系统。而 ARM 跑 Linux ，属于通用 CPU 运行通用型操作系统。</p><p>印象里当初 uclinux 其实主要用在没有 mmu 的 arm 上，但是现在硬件基本都有 mmu ，甚至 arm 的 vfp/neon 都成标配了（当然也可以选择没有的，但是没有浮点运算现在这种什么都要求计算性能的地方用整数计算机很慢的）。</p><p>综上，现在最好放弃单片机这种概念了。比较容易乱。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p><strong>和普通单片机一样完成系统移植？</strong></p><!--## 解决方案(3)--还未研究--><!--#### 1 MicroBlaze V7 新添内存管理单元（MMU）--><!--[MicroBlaze V7 新添内存管理单元（MMU）part1(转)](http://blog.sina.com.cn/s/blog_538eef960100h7dc.html)--><!--[利用Vivado进行MicroBlaze处理器应用教程](https://blog.csdn.net/weiaipan1314/article/details/110674762)--><!--#### 2 全功能操作系统是Lynuxworks BlueCat Linux-->]]></content>
    
    
    <categories>
      
      <category>项目与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/202109071200/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/common_command/"/>
    <url>/202109071200/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/common_command/</url>
    
    <content type="html"><![CDATA[<p>…<br> <span id="more"></span></p><h2 id="1-hexo-目录分层"><a href="#1-hexo-目录分层" class="headerlink" title="1 hexo 目录分层"></a>1 hexo 目录分层</h2><ul><li>source :管理文件</li><li>about页面修改: \myblog\source\about\index.md<br>相关提示：<code>以下仅为页面顶部的基本信息，更多内容请在 ./pages/about.md 中编辑，支持 markdown 和 HTML</code></li></ul><h2 id="2-配置文件修改"><a href="#2-配置文件修改" class="headerlink" title="2 配置文件修改"></a>2 配置文件修改</h2><h3 id="有主题的情况下优先在主题的config文件里修改"><a href="#有主题的情况下优先在主题的config文件里修改" class="headerlink" title="有主题的情况下优先在主题的config文件里修改"></a>有主题的情况下优先在主题的config文件里修改</h3><p>本博客应用xx主题，修改目录为<br><strong>.\myblog\themes\fluid_config.yml</strong></p><p>修改完要clean才能正确渲染</p><h3 id="header-category-setting"><a href="#header-category-setting" class="headerlink" title="header category setting"></a>header category setting</h3><p><strong>.\myblog\themes\fluid_config.yml</strong></p><h2 id="3-hexo常用命令"><a href="#3-hexo常用命令" class="headerlink" title="3 hexo常用命令"></a>3 hexo常用命令</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>创建 hexo new “title”</li><li>某个目录下创建的基础命令为：<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">hexo <span class="hljs-keyword">new</span> --path ./essay/IC/<span class="hljs-number">02</span> <span class="hljs-string">&quot;02&quot;</span> <br><span class="hljs-meta"># 在\myblog\source\_posts\essay\IC下创建了一篇博客</span><br><span class="hljs-meta"># 同时会自动创建同名文件夹) </span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="4-header-与-category-的关系"><a href="#4-header-与-category-的关系" class="headerlink" title="4 header 与 category 的关系"></a>4 header 与 category 的关系</h2><p>.md文件下的，例如：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">title: 第一篇文章<br>date: 2020<span class="hljs-string">-03</span><span class="hljs-string">-07</span> 01:43:47<br><span class="hljs-keyword">tags:</span> 实用手册<br>categories: [实用手册]<br></code></pre></div></td></tr></table></figure><p>中的<code>categories: [实用手册]</code>对应生成于网站的/categories/下，在文章页用<code>categories: [A,B,C]</code>会<strong>生成</strong>并对应到该目录层级下</p><p>要想显示在页头，对应修改（已应用主题，有的主题会有页头索引，有的没有，所以此次修改的是个目录）</p><p>myblog\themes\fluid_config.yml</p><p>下的menu与header，例如</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">navbar:</span><br><span class="hljs-symbol">  blog_title:</span>  <span class="hljs-meta"># 导航栏左侧的标题，为空则按 hexo config.title 显示</span><br><span class="hljs-symbol">  menu:</span>  <span class="hljs-meta"># 可自行增减，若想减去某个入口，可以将值留空，显示文本关联 languages</span><br><span class="hljs-symbol">    home:</span> /<br><span class="hljs-symbol">    archive:</span> <span class="hljs-meta-keyword">/archives/</span><br><span class="hljs-symbol">    category:</span> <span class="hljs-meta-keyword">/categories/</span><br><span class="hljs-symbol">    tag:</span> <span class="hljs-meta-keyword">/tags/</span><br>    实用手册: <span class="hljs-meta-keyword">/categories/</span>实用手册<br>    项目与设计: <span class="hljs-meta-keyword">/categories/</span>program/<br><span class="hljs-symbol">    CS:</span> <span class="hljs-meta-keyword">/categories/</span>CS/<br><span class="hljs-symbol">    IC:</span> <span class="hljs-meta-keyword">/categories/</span>IC/<br><span class="hljs-symbol">    about:</span> <span class="hljs-meta-keyword">/about/</span><br>    <span class="hljs-meta">#links: /links/  # 友链页，把前面#去掉即可展示</span><br></code></pre></div></td></tr></table></figure><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h2><ul><li>[TOC]目录用不了，注意</li></ul>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开放评论、live2d与音乐盒!</title>
    <link href="/202011291125/%E9%80%9A%E7%9F%A5notify/notifyOpenMusicCommitLive2d/"/>
    <url>/202011291125/%E9%80%9A%E7%9F%A5notify/notifyOpenMusicCommitLive2d/</url>
    
    <content type="html"><![CDATA[<h1 id="开放评论、live2d与音乐盒！"><a href="#开放评论、live2d与音乐盒！" class="headerlink" title="开放评论、live2d与音乐盒！"></a>开放评论、live2d与音乐盒！</h1><h2 id="音乐盒基础设置"><a href="#音乐盒基础设置" class="headerlink" title="音乐盒基础设置"></a>音乐盒基础设置</h2><p><strong>‘.\source_data\fluid_config.yml’</strong></p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">aplayer:  # 音乐播放器<br>  enable: true<br>  order: <span class="hljs-string">&#x27;random&#x27;</span>  # 播放顺序，可选值: <span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-string">&#x27;random&#x27;</span><br>  song<span class="hljs-variable">s:</span>  # 歌曲列表，必须传入下列各参数，其中 url 与 cover 在本地需存于 <span class="hljs-keyword">source</span> 目录，更多参数见文档：http<span class="hljs-variable">s:</span>//aplayer.js.org/#/zh-Hans/?id=%E5%<span class="hljs-number">8</span>F%<span class="hljs-number">82</span>%E6%<span class="hljs-number">95</span>%B0<br>    - &#123; name: <span class="hljs-string">&#x27;The Sound of a Lost Generation&#x27;</span>, artis<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;Blitz Kids&#x27;</span>, ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;/music/Blitz Kids - The Sound of a Lost Generation.mp3&#x27;</span>, cover: <span class="hljs-string">&#x27;/music/The Sound of a Lost Generation.jpg&#x27;</span> &#125;<br>    - &#123; name: <span class="hljs-string">&#x27;シャナ&#x27;</span>, artis<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;Guiano,IA&#x27;</span>, ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;/music/Guiano,IA - シャナ.mp3&#x27;</span>, cover: <span class="hljs-string">&#x27;/music/シャナ.jpg&#x27;</span> &#125;<br></code></pre></div></td></tr></table></figure><h2 id="音乐盒自动播放"><a href="#音乐盒自动播放" class="headerlink" title="音乐盒自动播放"></a>音乐盒自动播放</h2><p><strong>.\themes\fluid\layout_partial\plugins\aplayer.ejs</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">&lt;<span class="hljs-meta">%-</span> js_ex(theme.static_prefix.aplayer, <span class="hljs-string">&#x27;APlayer.min.js&#x27;</span>) %&gt;<br>&lt;<span class="hljs-meta">%-</span> css_ex(theme.static_prefix.aplayer, <span class="hljs-string">&#x27;APlayer.min.css&#x27;</span>) %&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">const</span> ap = <span class="hljs-keyword">new</span> APlayer(</span></span><span class="xquery">&#123;</span><br><span class="xquery">    container:<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;aplayer&#x27;</span>),</span><br><span class="xquery">    fixed:<span class="hljs-built_in"> true</span>,</span><br><span class="xquery">    autoplay:<span class="hljs-built_in"> true</span>,</span><br><span class="xquery">    loop: <span class="hljs-string">&#x27;all&#x27;</span>,</span><br><span class="xquery">    order: <span class="hljs-string">&#x27;&lt;%= theme.aplayer.order %&gt;&#x27;</span>,</span><br><span class="xquery">    preload: <span class="hljs-string">&#x27;auto&#x27;</span>,</span><br><span class="xquery">    audio: &lt;<span class="hljs-meta">%-</span> JSON.stringify(theme.aplayer.songs || []) %&gt;</span><br><span class="xquery">  &#125;</span><span class="xml">);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GablrielGraph拓扑控制图的python图像实现</title>
    <link href="/202005081806/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C/WSNessay/projects/GablrielGraph%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%9A%84python%E5%9B%BE%E5%83%8F%E5%AE%9E%E7%8E%B0/"/>
    <url>/202005081806/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C/WSNessay/projects/GablrielGraph%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%9A%84python%E5%9B%BE%E5%83%8F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p><strong>拓扑控制（topology control）</strong><br>&emsp;是一种协调节点间各自传输范围的技术，用以构建具有某些期望的全局特性（如连通性）的网络拓扑结构，同时减少节点的能耗或增加网络的传输能力。<br>&emsp;选取一种拓扑控制算法(如 RNG、GG、DG、YG、MST、DRNG、 DLMST、DLSS，TopDisc 等)，编程实现该算法并用图形显示效果。要求有执行算法前后拓扑对比图、链路数量统计对比。节点数目最少 50 个，随机分布，其他如通信半径、部署区域大小等自行选取。考虑到连通性问题，要求应用拓扑控制的初始网络为全连通网络（即每个节点与其他任意节点至少存 在一条链路，随机生成节点位置时可多试几次或增加节点密度）。</p><p><img src="https://note.youdao.com/yws/api/personal/file/22D1B9E5C9FD401C9A9C05CC1596597D?method=download&amp;shareKey=d24dc172db07ec9b71163e6928e7bf71" alt="插入图片"></p><h2 id="拓扑算法的选择与原理"><a href="#拓扑算法的选择与原理" class="headerlink" title="拓扑算法的选择与原理"></a>拓扑算法的选择与原理</h2><p><strong>1.    UDG(Unit Disk Graph)</strong></p><p><strong>定义：</strong>假定网络中N个节点构成了二维平面中的节点V所有节点都以最大功率工作时所产生的拓扑成为UDG<br><strong>思路：</strong>每个节点遍历其余结点坐标，计算彼此距离(功率)，属于范围内的节点连接成边缘，将边缘加入列表</p><script type="math/tex; mode=display">u,v\in V dis(u,v)\leq D_{max}(u)</script><p><strong>2.    GG(Gabriel Graph)</strong></p><p><strong>定义：</strong>任意两个节点u和v，以边u、v为直径的圆内没有其他节点<br><strong>思路：</strong>每个节点遍历其余结点坐标，计算彼此距离(功率)，判断是否属于范围内，且彼此连接圆内只有目标节点一个，成功便将边缘加入列表</p><script type="math/tex; mode=display">w,u,v\in V dis(u,v)\leq D_{max}(u) \quad \forall w\ \neq u,v: d^2(u,v)<[d^2(u,w)+d^2(v,w)]</script><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><p><strong>config.py：</strong>定义了随机初始化节点函数<br><strong>util.py：</strong>定义了针对单个节点，利用udg或gg思想，遍历其余所有节点返回生成的边缘列表有关方法<br><strong>gg.py：</strong>gg图演示程序</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="gg-py"><a href="#gg-py" class="headerlink" title="gg.py"></a>gg.py</h3><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix"><span class="hljs-comment">#初始化节点</span><br><span class="hljs-attr">nodes</span> = node_init(<span class="hljs-attr">_num=50,_rad_max=300)</span><br><span class="hljs-comment"># edge1=edge_init(0,nodes[0],nodes[1])#初始化一条边</span><br><span class="hljs-comment">#计算所有边（gg）</span><br><span class="hljs-attr">edges=[]</span><br>for i <span class="hljs-keyword">in</span> range(len(nodes)):<br>    edges.append(trav2gg(nodes[i],nodes))<br><span class="hljs-comment">#将边缘对象转化为画图所需的边</span><br>for i <span class="hljs-keyword">in</span> edges:<br>    for j <span class="hljs-keyword">in</span> i:<br>        edgelist.append((j.node1_id,j.node2_id))<br><span class="hljs-comment">#画点</span><br><span class="hljs-attr">g_gg</span> = nx.Graph()<br>g_gg.add_nodes_from([i for i <span class="hljs-keyword">in</span> range(len(nodes))])<br><span class="hljs-attr">pos</span> = &#123;i:(nodes[i].x,nodes[i].y) for i <span class="hljs-keyword">in</span> range(len(nodes))&#125;<br>nx.draw_networkx_nodes(g_gg,<span class="hljs-attr">pos=pos,</span><br>    <span class="hljs-attr">node_color</span> = &#x27;black&#x27;,<span class="hljs-attr">node_size</span> = <span class="hljs-number">20</span>)<br>nx.draw_networkx_edges(g_gg,<span class="hljs-attr">pos</span> = pos,<span class="hljs-attr">edgelist=edgelist,</span><br>    <span class="hljs-attr">edge_color=&#x27;r&#x27;,width</span> =<span class="hljs-number">0.8</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><h3 id="config-py"><a href="#config-py" class="headerlink" title="config.py"></a>config.py</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#生成随机位置<br>def position<span class="hljs-constructor">_random(<span class="hljs-params">_wid</span>, <span class="hljs-params">_hei</span>)</span>:<br>    x = random.randint(<span class="hljs-number">0</span>, _wid)<br>    y = random.randint(<span class="hljs-number">0</span>, _hei)<br>    return <span class="hljs-literal">[<span class="hljs-identifier">x</span>, <span class="hljs-identifier">y</span>]</span><br>#生成指定数量节点<br>def node<span class="hljs-constructor">_init(<span class="hljs-params">_a</span>=[<span class="hljs-params">wid</span>, <span class="hljs-params">hei</span>], <span class="hljs-params">_rad_max</span>=<span class="hljs-params">rad_max</span>, <span class="hljs-params">_num</span>=<span class="hljs-params">node_num</span>)</span>:<br>    nodes = <span class="hljs-literal">[]</span><br>    positions = <span class="hljs-literal">[]</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(_num):<br>        pos = position<span class="hljs-constructor">_random(<span class="hljs-params">_a</span>[0], <span class="hljs-params">_a</span>[1])</span><br>        <span class="hljs-keyword">if</span> pos not <span class="hljs-keyword">in</span> positions:<br>            positions.append(pos)<br>            nodes.append(e.<span class="hljs-constructor">Node(<span class="hljs-params">i</span>, <span class="hljs-params">pos</span>[0], <span class="hljs-params">pos</span>[1], <span class="hljs-params">_rad_max</span>)</span>)<br>    return nodes<br></code></pre></div></td></tr></table></figure><h3 id="util-py"><a href="#util-py" class="headerlink" title="util.py"></a>util.py</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">def trav2gg(_node, _node_list):<br>    edge_list = <span class="hljs-literal">[]</span>#存放遍历后该节点的边界<br>    node_list=<span class="hljs-literal">[]</span>#存放遍历后的该节点的邻居节点<br>    #UDG算法计算该节点的全部邻居节点以及边缘<br>    <span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> enumerate(_node_list):<br>        _edge = edge<span class="hljs-constructor">_init(&#x27;<span class="hljs-params">edge</span>&#x27;, <span class="hljs-params">_node</span>, <span class="hljs-params">value</span>)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_edge</span>.</span></span>length &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_node</span>.</span></span>r <span class="hljs-keyword">and</span> value.id != <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_node</span>.</span></span>id:<br>            edge_list.append(_edge)<br>            node_list.append(value)<br>    # GG算法计算该在UDG子集中的边界<br>    edge_list_out=<span class="hljs-literal">[]</span>#存放gg算法该节点的边界<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> edge_list:<br>        # 判断是否只有目标节点一个，在其与源节点两点所成的圆上<br>        <span class="hljs-keyword">if</span> is<span class="hljs-constructor">_onemin(<span class="hljs-params">_node</span>,<span class="hljs-params">_node_list</span>[<span class="hljs-params">i</span>.<span class="hljs-params">node2_id</span>],<span class="hljs-params">node_list</span>)</span>:<br>            edge_list_out.append(i)<br>    return edge_list_out<br></code></pre></div></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="目标范围：1000-1000，节点数量：50，最大通信功率-距离-：250"><a href="#目标范围：1000-1000，节点数量：50，最大通信功率-距离-：250" class="headerlink" title="目标范围：1000*1000，节点数量：50，最大通信功率(距离)：250"></a>目标范围：1000*1000，节点数量：50，最大通信功率(距离)：250</h3><style>.box{width:300px; text-align:center; font-szie:18px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/CF1C9980F43A41C59752BDB836F8A7CE?method=download&shareKey=b8dba991e1fb41b51c2d76eaed103074" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/5046419210C34BF491DC651301DC0780?method=download&shareKey=fd1e6dead5d79855ca0f427514c4f179">      UDG      </div>    </td>  </tr></table><h3 id="目标范围：1000-1000，节点数量：100，最大通信功率-距离-：200"><a href="#目标范围：1000-1000，节点数量：100，最大通信功率-距离-：200" class="headerlink" title="目标范围：1000*1000，节点数量：100，最大通信功率(距离)：200"></a>目标范围：1000*1000，节点数量：100，最大通信功率(距离)：200</h3><style>.box{width:300px; text-align:center; font-szie:26px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/53849627B88A4BDFB889FB3390847843?method=download&shareKey=447dd4faf1ed0d9b835b23c12b19599b" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/139F559E69134EC49B5D9078A933CB51?method=download&shareKey=5cd3d9230e587555291d1aa1e1d1564e">      UDG      </div>    </td>  </tr></table><h3 id="目标范围：1000-1000，节点数量：20，最大通信功率-距离-：900"><a href="#目标范围：1000-1000，节点数量：20，最大通信功率-距离-：900" class="headerlink" title="目标范围：1000*1000，节点数量：20，最大通信功率(距离)：900"></a>目标范围：1000*1000，节点数量：20，最大通信功率(距离)：900</h3><style>.box{width:300px; text-align:center; font-szie:18px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/765C8073EA0E49DDBE692B100D041226?method=download&shareKey=4105687de2fad2f9301d84483150f0e9" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/EAE685E724904D8A92C6439E4E03F474?method=download&shareKey=73f041cf1dde57283bfba26879d50c35">      UDG      </div>    </td>  </tr></table><p><a href="https://hexo.io/docs/one-command-deployment.html">Markdown数学公式语法1</a></p><p><a href="https://hexo.io/docs/one-command-deployment.html">Markdown数学公式语法2</a></p><p><a href="https://www.zybuluo.com/codeep/note/163962">Markdown数学公式语法3</a></p><p><a href="https://blog.csdn.net/qq_43401552/article/details/104805466">Hexo+markdown之引用图片方法汇集</a></p><p><a href="https://blog.csdn.net/weixin_41010198/article/details/86639739">Markdwon中多张图片的并排显示（Mardown的灵动使用技巧）</a></p>]]></content>
    
    
    <categories>
      
      <category>项目与设计</category>
      
      <category>实验</category>
      
      <category>WSN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/1/"/>
    <url>/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/1/</url>
    
    <content type="html"><![CDATA[<p> 段落没有限制文字，那就直接上文字？<br> <span id="more"></span><br> 下面是相关不出现在首页的内容<br>预览草稿shell命令<br>hexo s —draft</p><h2 id="以下是引用块"><a href="#以下是引用块" class="headerlink" title="以下是引用块"></a>以下是引用块</h2><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><h2 id="以下是代码块"><a href="#以下是代码块" class="headerlink" title="以下是代码块"></a>以下是代码块</h2><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);</span><br></code></pre></div></td></tr></table></figure><h2 id="这里插入图片"><a href="#这里插入图片" class="headerlink" title="这里插入图片"></a>这里插入图片</h2><p><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&amp;shareKey=b7cf3fddbacf87de023fb7230df6a0e4" alt="插入图片"></p><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&shareKey=b7cf3fddbacf87de023fb7230df6a0e4" class="[123]" title="title text" alt="alt text"><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&shareKey=b7cf3fddbacf87de023fb7230df6a0e4" alt="" width="100px" height="100px"><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://hexo.io/docs/one-command-deployment.html">链接</a></p><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h2><div style="position: relative; width:100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?aid=62606177&cid=108789598&page=1&&high_quality=1" scrolling="no" border="0" framespacing="0" allowfullscreen="true" framespacing="0" style="position: absolute; width: 100%;height: 100%; left: 0; top: 0;"></iframe></div><h2 id="页面内容跳转"><a href="#页面内容跳转" class="headerlink" title="页面内容跳转"></a>页面内容跳转</h2><p>要利用markdown语法实现页内跳转，首先在跳转目的地创建一个html标签<span id="jump">跳转到的地方</span>，其后在点击跳转处创建markdown超链接<a href="#jump">点击跳转</a>。注意：id值需前后保持一致，区分大小写。最后，在需要跳转时按住Ctrl键，再点击超链接文字即可实现页内跳转。</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p><script type="math/tex">1u,v\in V dis(u,v)\leq D_{max}(u)</script> [comment]:行间公式<br>$ 2u,v\in V dis(u,v)\leq D_{max}(u) $ [comment]:行内公式</p><h2 id="隐藏页面链接"><a href="#隐藏页面链接" class="headerlink" title="隐藏页面链接"></a>隐藏页面链接</h2><p><a href="../../../page/">隐藏链接</a></p>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/hello-world/"/>
    <url>/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
