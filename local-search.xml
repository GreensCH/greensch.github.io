<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Chisel（一）：初步</title>
    <link href="/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/"/>
    <url>/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/</url>
    
    <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p2.jpg" alt=""></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p3.jpg" alt="96733090_p3"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96733090_p4.jpg" alt="96733090_p4"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Chiesl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala（二）：进阶篇</title>
    <link href="/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/"/>
    <url>/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/</url>
    
    <content type="html"><![CDATA[<h1 id="12-模式匹配"><a href="#12-模式匹配" class="headerlink" title="12 模式匹配"></a>12 模式匹配</h1><p>​        前一章提到过，Scala的内建控制结构里有一个<strong>match表达式，用于模式匹配或偏函数。</strong></p><p>​    模式匹配是Scala中一个强大的高级功能，<strong>模式匹配在Chisel中被用于硬件的参数化配置，可以快速地裁剪、配置不同规模的硬件电路。</strong>所以，尽管模式匹配不是很容易就能掌握并熟练运用，但是学会它将会对软、硬件编程都大有帮助。</p><p>​        本章介绍了功能强大的模式匹配，尽管概念比较容易理解，但是要熟练运用则比较难。</p><p>​        <del>偏函数，在Chisel里也会用到。</del></p><p>​        <del>在实际编写硬件时，模式匹配是用不上的。</del></p><h2 id="12-1-样例类与样例对象"><a href="#12-1-样例类与样例对象" class="headerlink" title="12.1 样例类与样例对象"></a>12.1 样例类与样例对象</h2><p><strong>（1）样例类：</strong></p><p>​        定义类时，若在最前面加上关键字“case”，那么这个类就被称为样例类。基本形式：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> 类名<br></code></pre></div></td></tr></table></figure><p>Scala的编译器会自动对样例类添加一些语法便利：</p><ul><li><p><strong>添加与类同名的工厂方法</strong>，使得可<strong>以通过<code>类名(参数)</code>来构造对象，而不需要<code>new 类名(参数)</code></strong>，<font color=gray>使得代码看起来更加自然</font></p></li><li><p><strong>参数列表的每个参数都隐式地获得了一个val前缀</strong>。也就是说，类内部会自动添加与参数同名的公有字段。</p></li><li><p><strong>自动实现toString、hashCode和equals方法</strong>，<font color=gray>会自动以“自然”的方式实现toString、hashCode和equals方法</font></p></li><li><p><strong>添加一个好用的copy方法，用于构造与旧对象只有某些字段不同的新对象</strong>，只需通过传入具名参数和缺省参数实现。比如objectA.copy(arg0 = 10)会创建一个只有arg0为10、其余成员与objectA完全一样的新对象。</p></li></ul><p><strong>（2）样例类定义示例：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义了一个样例类</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span></span>) </span><br><span class="hljs-comment">//defined class Students</span><br><br><span class="hljs-comment">//便利1，很方便的实例化</span><br>scala&gt; <span class="hljs-keyword">val</span> stu1 = <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">//stu1: Students = Students(Alice,100)</span><br><br><span class="hljs-comment">//便利2，形参获得val成为内部成员</span><br>scala&gt; stu1.name<br><span class="hljs-comment">//res0: String = Alice</span><br><br><span class="hljs-comment">//便利2</span><br>scala&gt; stu1.score<br><span class="hljs-comment">//res1: Int = 100</span><br><br><span class="hljs-comment">//便利4，很好用的copy</span><br>scala&gt; <span class="hljs-keyword">val</span> stu2 = stu1.copy()<br><span class="hljs-comment">//stu2: Students = Students(Alice,100)</span><br><span class="hljs-comment">//完全一样</span><br>scala&gt; stu2 == stu1<br><span class="hljs-comment">//res2: Boolean = true</span><br><br><span class="hljs-comment">//便利4</span><br>scala&gt; <span class="hljs-keyword">val</span> stu3 = stu1.copy(name = <span class="hljs-string">&quot;Bob&quot;</span>)<br><span class="hljs-comment">//stu3: Students = Students(Bob,100)</span><br><span class="hljs-comment">//完全一样</span><br>scala&gt; stu3 == stu1<br><span class="hljs-comment">//res3: Boolean = false</span><br></code></pre></div></td></tr></table></figure><p><strong>（3）样例类的好处</strong></p><p>​        样例类最大的好处是支持模式匹配。相关内容会在本章接下来的内容中介绍。</p><p><strong>（4）样例类与样例对象的其他特性</strong></p><p>​        <strong>样例对象与样例类很像，</strong>也是定义单例对象时在最前面加上关键字<code>case</code>。</p><p>​        <strong>样例对象和普通的单例对象一样，没有参数和构造方法，也是一个具体的实例，但是样例对象的实际形式更接近样例类</strong></p><p>​        <strong>前面说的样例类的特性，样例对象也具备</strong>，例如可用于模式匹配。从编译后的结果来比较，样例对象与一个无参、无构造方法的样例类是一样的。</p><h2 id="12-2-模式匹配"><a href="#12-2-模式匹配" class="headerlink" title="12.2 模式匹配"></a>12.2 模式匹配</h2><p><strong>形式：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">选择器 <span class="hljs-keyword">match</span> &#123; 可选分支 &#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>选择器</strong>是待匹配的对象，</li><li><strong>花括号里是一系列以关键字<code>case</code>开头的“可选分支”</strong><ul><li><strong>每个可选分支</strong>都包括一个模式以及一个或多个表达式<ul><li>如果模式匹配成功，就执行相应的表达式，最后返回结果。可选分支定义如下： </li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> 模式 =&gt; 表达式<br></code></pre></div></td></tr></table></figure><p><strong>match表达式/匹配模式与Java的switch语法的区别</strong>：</p><ul><li><strong>match是一个表达式，它可以返回一个值</strong></li><li>可选分支<strong>存在优先级</strong>，其<strong>匹配顺序也就是代码编写时的顺序</strong>，<font color=grey>并且只有第一个匹配成功的模式会被选中，然后对它的表达式求值并返回。如果表达式有多个，则按顺序执行直到下个case语句为止，并不会贯穿执行到末尾的case语句，所以多个表达式也可以不用花括号包起来</font></li><li><strong>要确保至少有一个模式匹配成功，否则会抛出MatchError异常</strong> </li></ul><h2 id="12-3-模式种类"><a href="#12-3-模式种类" class="headerlink" title="12.3 模式种类"></a>12.3 模式种类</h2><p>​        多样的模式种类，是模式匹配强大的原因</p><p><strong>主要种类有以下七种：</strong></p><ul><li>通配模式</li><li>常量模式</li><li>变量模式</li><li>构造方法模式</li><li>序列模式</li><li>元组模式</li><li>带类型的模式</li><li>变量绑定</li></ul><h3 id="（1）通配模式"><a href="#（1）通配模式" class="headerlink" title="（1）通配模式"></a>（1）通配模式</h3><p><strong>定义</strong>：</p><ul><li>用下划线<code>_</code>表示，匹配任何对象</li></ul><p><strong>使用位置</strong>：</p><ul><li>末尾<strong>用于缺省、捕获所有可选路径</strong>，相当于switch的default。</li><li>如果某个模式需要<strong>忽略局部特性</strong>，也可以用下划线代替。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//忽略局部特性的一个例子</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, _) =&gt; <span class="hljs-literal">true</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>         |  &#125;<br>test: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">Boolean</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment">//res0: Boolean = true</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment">//res1: Boolean = true</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment">//res2: Boolean = false</span><br></code></pre></div></td></tr></table></figure><blockquote><p>上述例子中，第一个case就是用下划线忽略了模式的局部特性：表明只有含有三个元素，且前两个为1和2、第三个元素任意的列表才能匹配该模式。不符合第一个case的对象，都会被通配模式捕获。</p></blockquote><hr><p><strong>特别注意：</strong></p><p>​        越具体的模式，可匹配的范围就越小；反之，越模糊的模式，覆盖的范围越大。<strong>具体的模式，应该定义在模糊的模式前面，</strong>否则如果具体模式的作用范围是模糊模式的子集，那写在后面的具体模式就<strong>永远不会被执行</strong>。像通配模式这种全覆盖的模式，一定要写在最后。</p><h3 id="（2）常量模式"><a href="#（2）常量模式" class="headerlink" title="（2）常量模式"></a>（2）常量模式</h3><p><strong>定义：</strong></p><ul><li>用一个常量、字面量作为模式，使得只能匹配自身</li></ul><p>​        任何<strong>字面量</strong>、任何<strong>val类型的变量或单例对象（样例对象也是一样的）</strong>可以作为常量模式，<strong>（<code>Nil</code>这个单例对象能且仅能匹配空列表）</strong>：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span> =&gt; <span class="hljs-string">&quot;five&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span> =&gt; <span class="hljs-string">&quot;truth&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> =&gt; <span class="hljs-string">&quot;hi!&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-string">&quot;the empty list&quot;</span>  <span class="hljs-comment">//用Nil这个单例对象匹配空列表</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;something else&quot;</span>     <br>         |  &#125;<br><span class="hljs-comment">//test2: (x: Any)String</span><br><br>scala&gt; test2(<span class="hljs-type">List</span>())<br><span class="hljs-comment">//res0: String = the empty list</span><br><br>scala&gt; test2(<span class="hljs-number">5</span>)<br><span class="hljs-comment">//res1: String = five</span><br><br>scala&gt; test2(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//res2: String = truth</span><br><br>scala&gt; test2(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">//res3: String = hi!</span><br><br>scala&gt; test2(<span class="hljs-number">233</span>)<br><span class="hljs-comment">//res4: String = something else</span><br></code></pre></div></td></tr></table></figure><h3 id="（3）变量模式"><a href="#（3）变量模式" class="headerlink" title="（3）变量模式"></a>（3）变量模式</h3><p><strong>定义：</strong></p><ul><li>变量模式一方面与通配模式一样，<strong>一个变量名，它可以匹配任何对象</strong></li><li>变量模式还会<strong>把该变量名与匹配成功的输入对象绑定</strong>，在表达式中可以通过这个变量名来进一步操作输入对象。变量模式还可以放在最后面代替通配模式。<strong>（可以理解为能当变量调用的通配符）</strong>例如： </li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |     <span class="hljs-keyword">case</span> somethingElse =&gt; <span class="hljs-string">&quot;Not Zero: &quot;</span> + somethingElse<br>         |  &#125;<br><span class="hljs-comment">//test3: (x: Any)String</span><br><br>scala&gt; test3(<span class="hljs-number">0</span>) <span class="hljs-comment">//匹配了常量0</span><br><span class="hljs-comment">//res0: String = Zero!</span><br><br>scala&gt; test3(<span class="hljs-type">List</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">//变量匹配了List(0)</span><br><span class="hljs-comment">//res1: String = Not Zero: List(0)</span><br></code></pre></div></td></tr></table></figure><p>​        <strong>与通配模式一样，变量模式的后面不能添加别的模式，否则编译器会警告无法到达变量模式后面的代码。</strong>例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> somethingElse =&gt; <span class="hljs-string">&quot;Not Zero: &quot;</span> + somethingElse<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//&lt;console&gt;:12: warning: patterns after a variable pattern cannot match (SLS 8.1.1)</span><br><span class="hljs-comment">//         case somethingElse =&gt; &quot;Not Zero: &quot; + somethingElse</span><br><span class="hljs-comment">//              ^</span><br><span class="hljs-comment">//&lt;console&gt;:13: warning: unreachable code due to variable pattern &#x27;somethingElse&#x27; on line //12</span><br><span class="hljs-comment">//         case 0 =&gt; &quot;Zero!&quot;</span><br><span class="hljs-comment">//                   ^</span><br><span class="hljs-comment">//&lt;console&gt;:13: warning: unreachable code</span><br><span class="hljs-comment">//         case 0 =&gt; &quot;Zero!&quot;</span><br><span class="hljs-comment">//                   ^</span><br><br>test3: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">String</span><br></code></pre></div></td></tr></table></figure><p><strong>区分常量和变量的规则</strong>：        </p><p>​        <strong>常量模式有时候看上去也是一个变量名</strong>，比如“Nil”就是引用空列表这个常量模式。</p><p>​        Scala有一个简单的词法区分规则：</p><ul><li><p><strong>小写字母开头的简单名称会被当做变量模式</strong>，其他引用都是常量模式。<strong>即使以小写字母开头的简单名称是某个常量的别名，也会被当成变量模式。</strong></p><p>如果想绕开这个规则，有两种方法：</p></li><li><p>如果常量是某个对象的字段，可以加上限定词如this.a或object.a等来表示这是一个常量。</p></li><li><p>用反引号把名称包起来，编译器就会把它解读成常量，这也是绕开关键字与自定义标识符冲突的方法。例如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> somethingElse = <span class="hljs-number">1</span><br>somethingElse: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> `somethingElse` =&gt; <span class="hljs-string">&quot;A constant!&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something else!&quot;</span><br>         |  &#125;<br>test4: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">String</span><br><br>scala&gt; test4(somethingElse)<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">A</span> constant!<br></code></pre></div></td></tr></table></figure><h3 id="（4）构造方法模式-样例类"><a href="#（4）构造方法模式-样例类" class="headerlink" title="（4）构造方法模式(样例类)"></a>（4）构造方法模式(样例类)</h3><p><strong>定义：</strong></p><ul><li>把<strong>样例类的构造方法作为模式</strong>，其形式为<code>名称(模式)</code>，即需要小括号</li></ul><p><strong>特性：</strong></p><ul><li>（假设这里的“名称”指定的是<strong>一个样例类的名字</strong>）那么该模式将<strong>首先检查待匹配的对象是不是以这个名称命名的样例类的实例</strong>，然后<strong>再检查待匹配的对象的构造方法参数是不是匹配括号里的“模式”</strong></li><li><strong>Scala的模式支持深度匹配，</strong>也就是说，<strong>括号里的模式可以是任何一种模式</strong>，包括构造方法模式。嵌套的构造方法模式会进一步展开匹配。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义样例类A</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-comment">//defined class A</span><br><br><span class="hljs-comment">//定义样例类B</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">x: <span class="hljs-type">String</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">A</span></span>)</span><br><span class="hljs-comment">//defined class B</span><br><br><span class="hljs-comment">//构造方法模式匹配B构造参数，同时深度匹配A</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test5</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, e, <span class="hljs-type">A</span>(<span class="hljs-number">10</span>)) =&gt; e + <span class="hljs-number">1</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt;<br>         |  &#125;<br><span class="hljs-comment">//test5: (x: Any)AnyVal</span><br></code></pre></div></td></tr></table></figure><blockquote><p>“abc”是常量模式，只能匹配字符串“abc”</p><p>e是变量模式，绑定B的第二个构造参数，然后在表达式里加1并返回</p><p>A(10)是构造方法模式，B的第三个参数必须是以10为参数构造的A的对象</p></blockquote><p>上述构造方法模式的实际匹配：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-type">A</span>(<span class="hljs-number">10</span>))<br><span class="hljs-comment">//a: B = B(abc,1,A(10))</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-type">A</span>(<span class="hljs-number">1</span>))<br><span class="hljs-comment">//b: B = B(abc,1,A(1))</span><br><br>scala&gt; test5(a)<br><span class="hljs-comment">//res0: AnyVal = 2</span><br><br>scala&gt; test5(b)<br><span class="hljs-comment">//res1: AnyVal = ()</span><br></code></pre></div></td></tr></table></figure><h3 id="（5）-序列模式-List或Array"><a href="#（5）-序列模式-List或Array" class="headerlink" title="（5） 序列模式(List或Array)"></a>（5） 序列模式(List或Array)</h3><p><strong>定义：</strong></p><ul><li>序列类型也可以用于模式匹配，比如List或Array。<ul><li>下划线<code>_</code>或变量模式可以<strong>指出不关心的元素</strong></li><li>把<code>_*</code>放在最后可以<strong>匹配任意元素个数</strong>。例如：</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test6</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, _*) =&gt; <span class="hljs-string">&quot;OK!&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Oops!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//test6: (x: Any)String</span><br><br>scala&gt; test6(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment">//res0: String = OK!</span><br><br>scala&gt; test6(<span class="hljs-number">1</span>)<br><span class="hljs-comment">//res1: String = Oops!</span><br></code></pre></div></td></tr></table></figure><h3 id="（6）元组模式-a-b-c-…"><a href="#（6）元组模式-a-b-c-…" class="headerlink" title="（6）元组模式(a,b,c,…)"></a>（6）元组模式(a,b,c,…)</h3><p><strong>定义：</strong></p><ul><li>元组也可以用于模式匹配</li><li>在圆括号里可以包含任意模式，<strong>即通过元组匹配多个其他模式</strong><ul><li>形如(a, b, c)的模式可以匹配任意的三元组，注意<strong>里面是三个变量模式，不是三个字母常量。</strong></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test7</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> (<span class="hljs-number">1</span>, e, <span class="hljs-string">&quot;OK&quot;</span>) =&gt; <span class="hljs-string">&quot;OK, e = &quot;</span> + e<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Oops!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//test7: (x: Any)String</span><br><br>scala&gt; test7(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br><span class="hljs-comment">//res0: String = OK, e = 10</span><br></code></pre></div></td></tr></table></figure><h3 id="（7）带类型的模式"><a href="#（7）带类型的模式" class="headerlink" title="（7）带类型的模式"></a>（7）带类型的模式</h3><p><strong>定义：</strong>模式定义时，也可以<strong>声明具体的数据类型</strong>。</p><p><strong>用途：</strong>用带类型的模式可以<strong>代替类型测试和类型转换</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test8</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; s.length<br>         |     <span class="hljs-keyword">case</span> m: <span class="hljs-type">Map</span>[_, _] =&gt; m.size<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">-1</span><br>         |  &#125;<br><span class="hljs-comment">//test8: (x: Any)Int</span><br></code></pre></div></td></tr></table></figure><ul><li><p>带类型的变量模式<code>s: String</code><strong>将匹配每个非空的String实例</strong></p></li><li><p><code>m: Map[_, _]</code><strong>将匹配任意映射实例</strong>。</p></li></ul><p><strong>调用变量时候：</strong>入参x的类型是Any，而s的类型是String，所以表达式里可以写s.length而不能写x.length，因为Any类没有叫length的成员。m.size同理。</p><p><strong>无法进行深度指明：</strong></p><p>​        在带类型的模式中，虽然可以像上个例子那样指明对象类型为笼统的映射“Map[<em>, </em>]”，但是无法更进一步指明映射的键-值分别是什么类型。前面曾说过，这是因为Scala采用了擦除式的泛型，即运行时并不会保留类型参数的信息，所以程序在运行时无法判断某个映射的键-值具体是哪两种类型。唯一例外的是数组，因为数组的元素类型跟数组保存在一起。</p><h3 id="（8）变量绑定-除变量模式外的添加变量手段"><a href="#（8）变量绑定-除变量模式外的添加变量手段" class="headerlink" title="（8）变量绑定(除变量模式外的添加变量手段)"></a>（8）变量绑定(除变量模式外的添加变量手段)</h3><p><strong>用途：</strong>除了变量模式可以使用变量外，还可以对任何其他模式添加变量，构成变量绑定模式。</p><p><strong>定义：</strong></p><ul><li>其形式为<code>变量名 @ 模式</code>。</li></ul><p><strong>特性：</strong></p><ul><li>变量绑定模式执行模式匹配的规则与原本模式一样，但是<strong>在匹配成功后会把输入对象的相应部分与添加的变量进行绑定</strong>，通过该变量就能<strong>在表达式中进行额外的操作</strong>。例如下面为一个常量模式绑定了变量e：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test9</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, e @ <span class="hljs-number">3</span>) =&gt; e<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span><br>         |  &#125;<br><span class="hljs-comment">//test9: (x: Any)Int</span><br><br>scala&gt; test9(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">//res0: Int = 3</span><br></code></pre></div></td></tr></table></figure><h2 id="12-4-守卫模式"><a href="#12-4-守卫模式" class="headerlink" title="12.4 守卫模式"></a>12.4 守卫模式</h2><blockquote><p>​        模式守卫出现在模式之后，是一条用if开头的语句。模式守卫可以是任意的布尔表达式，通常会引用到模式中的变量。如果存在模式守卫，那么必须模式守卫返回true，模式匹配才算成功。</p><p>​        Scala要求模式都是线性的，即一个模式内的两个变量不能同名。如果想指定模式的两个部分要相同，不是定义两个同名的变量，而是通过模式守卫来解决。</p></blockquote><p><strong>形式：</strong></p><ul><li>case后面加个If</li><li>通常引用到模式中的变量</li><li>返回true才算成功</li></ul><p><strong>通俗解释：</strong></p><p>​        用于匹配成功后的进一步限定</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 只匹配正整数</span><br><span class="hljs-keyword">case</span> i: <span class="hljs-type">Int</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> =&gt; ???  <br><span class="hljs-comment">// 只匹配以字母&#x27;a&#x27;开头的字符串</span><br><span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> <span class="hljs-keyword">if</span> s(<span class="hljs-number">0</span>) == &#x27;a&#x27; =&gt; ???  <br><span class="hljs-comment">// 只匹配两个元素相等的二元组</span><br><span class="hljs-keyword">case</span> (x, y) <span class="hljs-keyword">if</span> x == y =&gt; ??? <br></code></pre></div></td></tr></table></figure><h2 id="12-5-密封类Sealed"><a href="#12-5-密封类Sealed" class="headerlink" title="12.5 密封类Sealed"></a>12.5 密封类Sealed</h2><p><strong>形式：</strong></p><ul><li><code>sealed class</code></li><li>如果在“class”前面加上关键字“sealed”，那么这个类就称为密封类。</li></ul><p><strong>特性：</strong></p><ul><li><strong>作用区域：</strong>密封类只能在同一个文件中定义子类，不能在文件之外被别的类继承</li></ul><blockquote><ul><li><ul><li>这有助于编译器检查模式匹配的完整性，因为这样确保了不会有新的模式随意出现，而只需要关心本文件内已有的样例类。所以，要使用模式匹配，最好把最顶层的基类做成密封类。</li></ul></li></ul></blockquote><ul><li><strong>继承自密封类的样例类做匹配：</strong>对继承自密封类的样例类做<strong>匹配</strong>，<strong>编译器会用警告信息</strong>标示出缺失的组合。<font color=grey>如果确实不需要覆盖所有组合，又不想用通配模式来避免编译器发出警告</font>，<strong>可以在选择器后面添加<code>@unchecked</code>注解</strong>，这样编译器对后续模式分支的覆盖完整性检查就会被压制。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义一个密封类</span><br>scala&gt; <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Var</span>(<span class="hljs-params">name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为Double</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span>(<span class="hljs-params">num: <span class="hljs-type">Double</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String, Expr</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnOp</span>(<span class="hljs-params">operator: <span class="hljs-type">String</span>, arg: <span class="hljs-type">Expr</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String, Expr， Expr</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinOp</span>(<span class="hljs-params">operator: <span class="hljs-type">String</span>, left: <span class="hljs-type">Expr</span>, right: <span class="hljs-type">Expr</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//匹配一个继承自密封类的样例类，结果报错</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = e <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//&lt;console&gt;:16: warning: match may not be exhaustive.</span><br><span class="hljs-comment">//It would fail on the following inputs: BinOp(_, _, _), UnOp(_, _)</span><br><span class="hljs-comment">//       def describe(e: Expr): String = e match &#123;undefined</span><br><span class="hljs-comment">//                                       ^</span><br><span class="hljs-comment">//describe: (e: Expr)String</span><br><br><span class="hljs-comment">//通过通配符匹配继承自密封类的样例类</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = e <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>  <span class="hljs-comment">// Should not happen</span><br>         |  &#125;<br><span class="hljs-comment">//describe: (e: Expr)String</span><br><br><span class="hljs-comment">//使用@unchecked，完成继承自密封类的样例类的匹配</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = (e: <span class="hljs-meta">@unchecked</span>) <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//describe: (e: Expr)String</span><br></code></pre></div></td></tr></table></figure><p>​        <strong>有关注解的内容，本教程不会讲解。需要深入了解的读者，请自行查阅资料。Chisel源码使用了注解。</strong></p><h2 id="12-6-可选值Option-T"><a href="#12-6-可选值Option-T" class="headerlink" title="12.6 可选值Option[T]"></a>12.6 可选值Option[T]</h2><p><strong>（1）解决的问题：</strong></p><p>从上面很多例子中，我们发现两个问题：</p><ul><li>一是<strong>每条case分支可能返回不同类型的值</strong>，导致函数的返回值或变量的类型不好确定，该如何把它们统一起来？</li><li>二是<strong>通配模式下，常常不需要返回一个值，但什么都不写又不太好</strong></li></ul><p>要解决这两个问题，Scala提供了一个新的语法——<strong>可选值Option[T]</strong></p><p><strong>（2）定义</strong></p><p><strong>定义：可选值就是类型为Option[T]的一个值</strong></p><ul><li><strong>Option</strong>：是标准库里的一个密封抽象类</li><li><strong>T</strong>：可以是任意的类型，例如标准类型或自定义的类（并且T是协变的，简单来说，就是如果类型T是类型U的超类，那么Option[T]也是Option[U]的超类）</li></ul><p><strong>（3）Some类和None对象</strong></p><ul><li><p>Option类有一个子类：<strong>Some类</strong></p><ul><li><p><code>Some(x)</code>可以构造一个Some的对象</p></li><li><p><strong>参数x</strong>：是一个具体的值，根据x的类型，可选值的类型会发生改变。例如，Some(10)的类型是Option[Int]，Some(“10”)的类型是Option[String]</p></li><li><p><strong>作用：</strong>由于Some对象需要一个具体的参数值，所以这部分可选值用于表示“有值”。<strong>Some(x)常作为case语句的返回值。</strong></p></li></ul></li><li><p>Option类还有一个子对象：<strong>None</strong></p><ul><li>它的类型是<code>Option[Nothing]</code>，是所有Option[T]类型的子类，代表“无值”。<strong>None常作为通配模式的返回值。</strong></li></ul></li></ul><p>​        也就是说，<strong>Option类型代表要么是一个具体的值，要么无值</strong>。Some(x)常作为case语句的返回值，而None常作为通配模式的返回值。<strong>需要注意的是，Option[T]和T是两个完全没有关系的类型，赋值时不要混淆。</strong></p><p>​        <strong>None对象的意义：</strong>如果没有可选值语法，要表示“无值”可能会选用null，这就必须对变量进行判空操作。在Java里，判空是一个运行时的动作，如果忘记判空，编译时并不会报错，但是<strong>在运行时可能会抛出空指针异常</strong>，进而引发严重的错误。有了可选值之后，首先从字面上提醒读者这是一个可选值，存在无值和有值两种情况；其次，最重要的是，由于Option[T]类型与T类型不一样，赋值时就可能需要先做相应的类型转换。类型转换最常见的方式就是模式匹配，<strong>在这期间可以把无值None过滤掉。如果不进行类型转换，编译器就会抛出类型错误，这样在编译期就进行判空处理进而防止运行时出现更严重的问题。</strong> </p><p><strong>（4）判断Some和None的方法</strong></p><ul><li><p>Option可选值提供了一个方法<strong>isDefined</strong></p><ul><li><p>如果调用对象是None，则返回false</p></li><li><p>Some对象都会返回true</p></li></ul></li><li><p>还有一个方法<strong>get</strong>，</p><ul><li>用于把Some(x)中的x返回</li><li>如果调用对象是None则报错</li></ul></li></ul><h2 id="12-7-另类用法——定义变量时的模式匹配"><a href="#12-7-另类用法——定义变量时的模式匹配" class="headerlink" title="12.7 另类用法——定义变量时的模式匹配"></a>12.7 另类用法——定义变量时的模式匹配</h2><blockquote><p>原文：对于提取器(这里不用关心提取器是什么)，可以通过“val/var 对象名(模式) = 值”的方式来使用模式匹配，常常用于定义变量。这里的“对象名”是指提取器，即某个单例对象，列表、数组、映射、元组等常用集合的伴生对象都是提取器。</p></blockquote><p>定义：提取器通过val/var来进行模式匹配，形式如下，<strong>常用于定义变量</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> 对象名(模式) = 值<br></code></pre></div></td></tr></table></figure><ul><li><strong>“对象名”是指提取器</strong>，某个单例对象，列表、数组、映射、元组<strong>等常用集合的伴生对象都是提取器</strong></li></ul><p>实例代码：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//实现变量x,y的定义和初始化</span><br>scala&gt; <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(x, y, _*) = <span class="hljs-type">Array</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">233</span>)<br><span class="hljs-comment">//x: Int = -1</span><br><span class="hljs-comment">//y: Int = 1</span><br><br><span class="hljs-comment">//实现变量的定义和初始化</span><br>scala&gt; <span class="hljs-keyword">val</span> a :: <span class="hljs-number">10</span> :: _ = <span class="hljs-type">List</span>(<span class="hljs-number">999</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">//a: Int = 999</span><br><br>scala&gt; <span class="hljs-keyword">val</span> capitals = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;China&quot;</span> -&gt; <span class="hljs-string">&quot;Beijing&quot;</span>, <span class="hljs-string">&quot;America&quot;</span> -&gt; <span class="hljs-string">&quot;Washington&quot;</span>, <span class="hljs-string">&quot;Britain&quot;</span> -&gt; <span class="hljs-string">&quot;London&quot;</span>)<br><span class="hljs-comment">//capitals: scala.collection.immutable.Map[String,String] = Map(China -&gt; Beijing, America -&gt; Washington, Britain -&gt; London)</span><br><br>scala&gt; <span class="hljs-keyword">for</span>((country, city) &lt;- capitals)<br>         |    println(<span class="hljs-string">&quot;The capital of &quot;</span> + country + <span class="hljs-string">&quot; is &quot;</span> + city)<br><span class="hljs-comment">//The capital of China is Beijing</span><br><span class="hljs-comment">//The capital of America is Washington</span><br><span class="hljs-comment">//The capital of Britain is London</span><br><br></code></pre></div></td></tr></table></figure><h2 id="12-8-偏函数"><a href="#12-8-偏函数" class="headerlink" title="12.8 偏函数"></a>12.8 偏函数</h2><blockquote><p>​        前面说过，在Scala里，万物皆对象。函数是一等值，与整数、浮点数、字符串等等相同，所以函数也是一种对象。既然函数也是一个对象，那么必然属于某一种类型。为了标记函数的类型，Scala提供了一系列特质：Function0、Function1、Function2……Function22来表示参数为0、1、2……22个的函数。与元组很像，因此函数的参数最多只能有22个。当然也可以自定义含有更多参数的FunctionX，但是Scala标准库没有提供，也没有必要。</p></blockquote><p>还有一个特殊的函数特质：<strong>偏函数PartialFunction</strong></p><p><strong>偏函数的作用</strong>：划分一个输入参数的可行域，在可行域内对入参执行一种操作，在可行域之外对入参执行其他操作</p><p>偏函数要实现的两个抽象方法——<strong>apply和isDefinedAt</strong>：</p><ul><li><strong>isDefinedAt</strong>用于判断入参是否在可行域内，是的话就返回true，否则返回false</li><li><strong>apply</strong>是偏函数的函数体（<strong>隐式调用</strong>），用于对入参执行操作。使用偏函数之前，应该先用isDefinedAt判断入参是否合法，否则可能会出现异常。</li></ul><p><strong>定义偏函数</strong>：一种简便方法就是<strong>使用case语句组</strong>。广义上讲，case语句就是一个偏函数，所以才可以用于模式匹配。一个case语句就是函数的一个入口，多个case语句就有多个入口，每个case语句又可以有自己的参数列表和函数体。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> isInt1: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">String</span>] = &#123;<br>  <span class="hljs-keyword">case</span> x: <span class="hljs-type">Int</span> =&gt; x + <span class="hljs-string">&quot; is a Int.&quot;</span><br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">val</span> isInt2 = <span class="hljs-keyword">new</span> <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">String</span>] &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">Any</span>) = x.asInstanceOf[<span class="hljs-type">Int</span>] + <span class="hljs-string">&quot; is a Int.&quot;</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isDefinedAt</span></span>(x: <span class="hljs-type">Any</span>) = x.isInstanceOf[<span class="hljs-type">Int</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong>apply方法可以隐式调用</strong></p></li><li><p><strong>x.isInstanceOf[T]</strong>：判断x是不是T类型(及其超类)的对象，是的话就返回true</p></li><li><strong>x.asInstanceOf[T]</strong>：则把x转换成T类型的对象，如果不能转换则会报错</li><li><strong>偏函数PartialFunction[Any, Any]</strong>：是Function1[Any, Any]的子特质，因为case语句只有一个参数。[Any, Any]中的第一个Any是输入参数的类型，第二个Any是返回结果的类型。如果确实需要输入多个参数，则可以用元组、列表或数组等把多个参数变成一个集合。</li><li><p><strong>在用case语句定义偏函数时，前述的各种模式类型、模式守卫都可以使用。最后的通配模式可有可无，但是没有时，要保证运行不会出错</strong></p><p><strong>上述代码运行如下：</strong></p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; isInt1(<span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">String</span> = <span class="hljs-number">1</span> is a <span class="hljs-type">Int</span>.<br><br>scala&gt; isInt2(<span class="hljs-number">1</span>)<br>res1: <span class="hljs-type">String</span> = <span class="hljs-number">1</span> is a <span class="hljs-type">Int</span>.<br><br>scala&gt; isInt1.isDefinedAt(&#x27;<span class="hljs-number">1</span>&#x27;)<br>res2: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; isInt2.isDefinedAt(&#x27;<span class="hljs-number">1</span>&#x27;)<br>res3: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; isInt1(&#x27;<span class="hljs-number">1</span>&#x27;)<br>scala.<span class="hljs-type">MatchError</span>: <span class="hljs-number">1</span> (of <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Character</span>)</span><br>  at scala.<span class="hljs-type">PartialFunction</span>$ $anon$<span class="hljs-number">1.</span>apply(<span class="hljs-type">PartialFunction</span>.scala:<span class="hljs-number">255</span>)<br>  at scala.<span class="hljs-type">PartialFunction</span>$ $anon$<span class="hljs-number">1.</span>apply(<span class="hljs-type">PartialFunction</span>.scala:<span class="hljs-number">253</span>)<br>  at $anonfun$<span class="hljs-number">1.</span>applyOrElse(&lt;console&gt;:<span class="hljs-number">12</span>)<br>  at scala.runtime.<span class="hljs-type">AbstractPartialFunction</span>.apply(<span class="hljs-type">AbstractPartialFunction</span>.scala:<span class="hljs-number">34</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; isInt2(&#x27;<span class="hljs-number">1</span>&#x27;)<br>java.lang.<span class="hljs-type">ClassCastException</span>: java.lang.<span class="hljs-type">Character</span> cannot be cast to java.lang.<span class="hljs-type">Integer</span><br>  at scala.runtime.<span class="hljs-type">BoxesRunTime</span>.unboxToInt(<span class="hljs-type">BoxesRunTime</span>.java:<span class="hljs-number">101</span>)<br>  at $anon$<span class="hljs-number">1.</span>apply(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at $anon$<span class="hljs-number">1.</span>apply(&lt;console&gt;:<span class="hljs-number">12</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br></code></pre></div></td></tr></table></figure><h1 id="13-类型参数化（泛型）"><a href="#13-类型参数化（泛型）" class="headerlink" title="13 类型参数化（泛型）"></a>13 类型参数化（泛型）</h1><blockquote><p>​        在面向对象的编程里，提高代码复用率的一个重要方法就是泛型。泛型是一种重要的多态，称为“全类型多态”或“参数多态”。在某些容器类里，通常需要存储其它类型的对象，但是具体是什么类型，事先并不知道。倘若对每种可能包含的类型都编写一个新类，那么这完全不现实。一是工作量巨大，二是自定义类型是什么完全无法预知。例如，列表的元素可以是基本类型，也可以是自定义的类型，不可能在编写列表类时把自定义类型也考虑进去。更重要的是，这些容器类仅仅需要知道一个具体的类型，其它成员完全是一样的。既然这样，那完全可以编写一个泛型的类，它独立于成员的类型存在，然后把类型也作为一个参数，实例化生成不同的类对象。</p><p>​        既然与定义类型相关，那么可以泛型的自然是类和特质。</p></blockquote><p>​        在前面讲解集合时，就已经初步了解了这样的类和特质。例如，Array[T]、List[T]、Map[T, U]等等。<strong>本章将深入讲解Scala有关类型参数化的内容。</strong></p><p>​        本章的内容也是比较抽象、难理解。<strong>其应用在于阅读Chisel的源码，理解语言的工作机制，读懂API</strong>。如果是实<strong>际编写硬件电路用不到这些语法</strong></p><h2 id="13-1-深入解析，类内部的变量"><a href="#13-1-深入解析，类内部的变量" class="headerlink" title="13.1 深入解析，类内部的变量"></a>13.1 深入解析，类内部的变量</h2><blockquote><p>​        对于可重新赋值的字段，可执行两个基本操作：获取字段值或者设置为一个新值。在JavaBeans库里，这两个操作分别由名为“getter”和“setter”的方法来完成。Scala遵循了Java的惯例，只不过实现两个基本操作的方法的名字不一样：</p></blockquote><p>​    Scala如果在类中定义了一个var类型的字段：</p><ul><li>编译器会隐式地把这个变量限制成private[this]的访问权限</li><li>隐式地定义一个名为<strong>“变量名”的getter方法</strong>，默认返回变量的值</li><li>隐式地定义一个名为<strong>“变量名_=”的setter方法</strong>，默认接收外部传入的参数来直接赋给变量。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> = _<br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-comment">// 这个变量名“a”是随意取的，只要不与两个方法名冲突即可</span><br>  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = _<br>  <span class="hljs-comment">// getter，方法名与原来的变量名相同</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aInt</span></span>: <span class="hljs-type">Int</span> = a<br>  <span class="hljs-comment">// setter，注意名字里的“_=”</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aInt_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>字段必须被初始化<ul><li>这里的“=  _”，它将字段初始化为零值(具体零值是什么取决于字段的类型，数值类型的零值是0，布尔类型是false，引用类型是null)</li><li>也可以初始化为某个具体值。如果不初始化，就是一个抽象字段。</li></ul></li><li>private[this]，表明该成员只能用“this.a”或“a”来访问，句点前面不能是其它任何对象（下面一堆废话）<ul><li><font color=grey>实际上定义的var类型字段并不是用**private[this]**修饰的，只不过被编译器隐式转换了，所以外部仍然可以读取和修改该字段，但编译器会自动转换成对getter和setter方法的调用</font></li><li><font color=grey>也就是说，“对象.变量”会调用getter方法，而“对象.变量 = 新值”会调用setter方法。而且，这两个方法的权限与原本定义的var字段的权限相同，如果原本的var字段是公有的，那么这两个方法就是公有的；如果原本的var字段是受保护的，那么这两个方法也是受保护的；依此类推。当然，也可以逆向操作，自定义getter和setter方法，以及一个private[this]修饰的var类型字段，只要注意方法与字段的名字不冲突</font></li></ul></li></ul><p><strong>字段与方法没有必然联系：</strong></p><p>​        如果<strong>定义了“var a”这样的语句</strong>，那么必然有隐式的“a”和“a_=”方法，并且无法显式修改这两个方法(名字冲突)；</p><p>​        如果<strong>自定义了“b”和“b_=”这样的方法</strong>，却不一定要相应的var字段与之对应，这两个方法也可以操作类内的其他成员，而且仍然可以通过“object.b”和“object.b = value”来调用。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = _<br>  <span class="hljs-comment">// 默认的getter和setter</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">originalValue</span></span>: <span class="hljs-type">Int</span> = a<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">originalValue_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x<br>  <span class="hljs-comment">// 自定义的getter和setter，且没有对应的var字段</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tenfoldValue</span></span>: <span class="hljs-type">Int</span> = a * <span class="hljs-number">10</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tenfoldValue_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x / <span class="hljs-number">10</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br><span class="hljs-comment">//a: A = A@19dac2d6</span><br><br>scala&gt; a.originalValue = <span class="hljs-number">1</span><br><span class="hljs-comment">//a.originalValue: Int = 1</span><br><br>scala&gt; a.originalValue<br><span class="hljs-comment">//res0: Int = 1</span><br><br>scala&gt; a.tenfoldValue<br><span class="hljs-comment">//res1: Int = 10</span><br><br>scala&gt; a.tenfoldValue = <span class="hljs-number">1000</span><br><span class="hljs-comment">//a.tenfoldValue: Int = 1000</span><br><br>scala&gt; a.originalValue<br><span class="hljs-comment">//res2: Int = 100</span><br></code></pre></div></td></tr></table></figure><h2 id="13-2-泛型初步：类型构造器"><a href="#13-2-泛型初步：类型构造器" class="headerlink" title="13.2 泛型初步：类型构造器"></a>13.2 泛型初步：类型构造器</h2><p><strong>定义：</strong>使用方括号进行限定</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> a: <span class="hljs-type">T</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span><br></code></pre></div></td></tr></table></figure><ul><li>A类型构造器、一个泛型的类</li></ul><blockquote><p>​        “A”是一个类，但它不是一个类型，因为它接收一个类型参数。A也被称为“类型构造器”，因为它可以接收一个类型参数来构造一个类型，就像普通类的构造方法接收值参数构造实例对象一样。</p><p>​        A[Int]是一种类型，A[String]是另一种类型，等等。也可以说A是一个泛型的类。在指明类型时，不能像普通类那样只写一个类名，而必须在方括号里给出具体的类型参数。例如：</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesNotCompile</span></span>(x: <span class="hljs-type">A</span>) = &#123;&#125;<br><span class="hljs-comment">//&lt;console&gt;:12: error: class A takes type parameters</span><br><span class="hljs-comment">//       def doesNotCompile(x: A) = &#123;&#125;</span><br><span class="hljs-comment">//                             ^</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesCompile</span></span>(x: <span class="hljs-type">A</span>[<span class="hljs-type">AnyRef</span>]) = &#123;&#125;<br><span class="hljs-comment">//doesCompile: (x: A[AnyRef])Unit</span><br></code></pre></div></td></tr></table></figure><p><strong>方括号和参数类型添加位置：</strong></p><ul><li><p><strong>泛型的类和特质</strong>需要在名字后面加上方括号和类型参数，</p></li><li><p><strong>成员方法的具有泛型参数</strong>需要在方法名后面也必须加上方括号和类型参数</p></li><li><strong>字段则不需要</strong>，只要直接用类型参数指明类型即可</li></ul><h2 id="13-3-型变注解"><a href="#13-3-型变注解" class="headerlink" title="13.3 型变注解"></a>13.3 型变注解</h2><p><strong>定义：</strong></p><p>​        像A[T]这样的类型构造器，它们的类型参数T可以是<strong>协变的、逆变的或者不变的</strong>，这被称为<strong>类型参数的“型变”</strong></p><p>​        类型参数的前缀“+”和“-”被称为<strong>型变注解</strong></p><ul><li><strong>“A[+T]”</strong>表示类A在类型参数T上是协变的</li><li>“<strong>A[-T]”</strong>表示类A在类型参数T上是逆变的</li><li>没有型变参数就是不变的。</li></ul><p>如果类型S是类型T的子类型：</p><ul><li>那么协变表示A[S]也是A[T]的子类型</li><li>而逆变表示A[T]反而是A[S]的子类型</li><li>不变则表示A[S]和A[T]是两种没有任何关系的不同类型。</li></ul><h2 id="13-4-检查型变注解"><a href="#13-4-检查型变注解" class="headerlink" title="13.4 检查型变注解"></a>13.4 检查型变注解</h2><p>​        标注了型变注解的类型参数不能随意使用，类型系统设计要满足“里氏替换原则”：在任何需要类型为T的对象的地方，都能用类型为T的子类型的对象替换。里氏替换原则的依据是子类型多态。类型为超类的变量是可以指向类型为子类的对象，因为子类继承了超类所有非私有成员，能在超类中使用的成员，一般在子类中均可用。有关里氏替换原则的详细解释，这里不再展开。</p><p>​        假设类型T是类型S的超类，如果类型参数是协变的，导致A[T]也是A[S]的超类，那么“val a: A[T] = new A[S]”就合法。此时，如果类A内部的某个方法funcA的入参的类型也是这个协变类型参数，那么方法调用“a.funcA(b: T)”就会出错，因为a实际指向的是一个子类对象，子类对象的方法funcA接收的入参的类型是S，而子类S不能指向超类T，所以传入的b不能被接收。但是a的类型是A[T]又隐式地告诉使用者，可以传入类型是T的参数，这就产生了矛盾。相反，funcA的返回类型是协变类型参数就没有问题，因为子类对象的funcA的返回值的类型虽然是S，但是能被T类型的变量接收，即“val c: T = a.funcA()”合法。a的类型A[T]隐式地告诉使用者应该用T类型的变量接收返回值，虽然实际返回的值是S类型，但是子类型多态允许这样做。也就是说，要保证不出错，生产者产生的值的类型应该是子类，消费者接收的值的类型应该是超类(接收者本来只希望使用超类的成员，但是实际给出的子类统统都具备，接收者也不会去使用多出来的成员，所以子类型多态才正确)。基于此，方法的入参的类型应该是逆变类型参数，逆变使得“val a: A[S] = new A[T]”合法，也就是实际引用的对象的方法想要一个T类型的参数，但传入了子类型S的值，符合里氏替换原则。同理，方法的返回类型应该是协变的。</p><p>​        既然类型参数的使用有限制，那么就应该有一个规则来判断该使用什么类型参数。Scala的编译器把类或特质中任何出现类型参数的地方都当作一个“点”，点有协变点、逆变点和不变点之分，以声明类型参数的类和特质作为顶层开始，逐步往内层深入，对这些点进行归类。在顶层的点都是协变点，例如顶层的方法的返回类型就在协变点。默认情况下，在更深一层的嵌套的点与在包含嵌套的外一层的点被归为一类。该规则有一些例外：①方法的值参数所在的点会根据方法外的点进行一次翻转，也就是把协变点翻转成逆变点、逆变点翻转成协变点、不变点仍然保持不变。②方法的类型参数(即方法名后面的方括号)也会根据方法外的点进行一次翻转。③如果类型也是一个类型构造器，比如以C[T]为类型，那么，当T有“-”注解时就根据外层进行翻转，有“+”注解时就保持与外层一致，否则就变成不变点。</p><p>​        协变点只能用“+”注解的类型参数，逆变点只能用“-”注解的类型参数。没有型变注解的类型参数可以用在任何点，也是唯一一种能用在不变点的类型参数。所以对于类型Q[+U, -T, V]而言，U处在协变点，T处在逆变点，而V处在不变点。</p><p>以如下例子为例进行解释：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>[-<span class="hljs-type">T</span>, +<span class="hljs-type">U</span>] </span>&#123;undefined<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">meow</span></span>[<span class="hljs-type">W</span>ˉ](volume: <span class="hljs-type">T</span>ˉ, listener: <span class="hljs-type">Cat</span>[<span class="hljs-type">U</span>+, <span class="hljs-type">T</span>ˉ]ˉ): <span class="hljs-type">Cat</span>[<span class="hljs-type">Cat</span>[<span class="hljs-type">U</span>+, <span class="hljs-type">T</span>ˉ]ˉ, <span class="hljs-type">U</span>+]+<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        右上角的正号表示协变点，负号表示逆变点。首先，Cat类声明了类型参数，所以它是顶层。方法meow的返回值属于顶层的点，所以返回类型的最右边是正号，表示协变点。因为方法的返回类型也是类型构造器Cat，并且第一个类型参数是逆变的，所以这里相对协变翻转成了逆变，而第二个类型参数是协变的，所以保持协变属性不变。继续往里归类，返回类型嵌套的Cat处在逆变点，所以第一个类型参数的位置相对逆变翻转成协变，第二个类型参数的位置保持逆变属性不变。两个值参数volume和listener都相对协变翻转成了逆变点，并且listener的类型是Cat，所以和返回类型嵌套的Cat一样。方法的类型参数W，也相对协变翻转成了逆变点。</p><p>​        虽然型变注解的检查很麻烦，但这些工作都被编译器自动完成了。编译器的检查方法也很直接，就是查看顶层声明的类型参数是否出现在正确的位置。比如，上例中，T都出现在逆变点，U都出现在协变点，所以可以通过检查。至于W是什么，则不关心。</p><h3 id="13-5-类型构造器的继承关系"><a href="#13-5-类型构造器的继承关系" class="headerlink" title="13.5 类型构造器的继承关系"></a>13.5 类型构造器的继承关系</h3><p>​        因为类型构造器需要根据类型参数来确定最终的类型，所以在判断多个类型构造器之间的继承关系时，也必须依赖类型参数。对于只含单个类型参数的类型构造器而言，继承关系很好判断，只需要看型变注解是协变、逆变还是不变。当类型参数不止一个时，该如何判断呢？尤其是函数的参数是一个函数时，更需要确定一个函数的子类型是什么样的函数。</p><p>​        以常用的单参数函数为例，其特质Function1的部分定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Function1</span>[-<span class="hljs-type">S</span>, +<span class="hljs-type">T</span>] </span>&#123;undefined<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">S</span>): <span class="hljs-type">T</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        类型参数S代表函数的入参的类型，很显然应该是逆变的。类型参数T代表函数返回值的类型，所以是协变的。</p><p>​        假设类A是类a的超类，类B是类b的超类，并且定义了一个函数的类型为Function1[a, B]。那么，这个函数的子类型应该是Function1[A, b]。解释如下：假设在需要类型为Function1[a, B]的函数的地方，实际用类型为Function1[A, b]的函数代替了。那么，本来会给函数传入a类型的参数，但实际函数需要A类型的参数，由于类A是类a的超类，这符合里氏替换原则；本来会用类型为B的变量接收函数的返回值，但实际函数返回了b类型的值，由于类B是类b的超类，这也符合里氏替换原则。综上所述，用Function1[A, b]代替Function1[a, B]符合里氏替换原则，所以Function1[A, b]是Function1[a, B]的子类型。</p><p>​        因此，对于含有多个类型参数的类型构造器，要构造子类型，就是把逆变类型参数由子类替换成超类、把协变类型参数由超类替换成子类</p><h2 id="13-6-上界和下界"><a href="#13-6-上界和下界" class="headerlink" title="13.6 上界和下界"></a>13.6 上界和下界</h2><p>​        对于类型构造器A[+T]，倘若没有别的手段，很显然它的方法的参数不能泛化，因为协变的类型参数不能用作函数的入参类型。如果要泛化参数，必须借助额外的类型参数，那么这个类型参数该怎么定义呢？因为可能存在“val x: A[超类] = new A[子类]”这样的定义，导致方法的入参类型会是T的超类，所以，额外的类型参数必须是T的超类。Scala提供了一个语法——下界，其形式为“U &gt;: T”，表示U必须是T的超类，或者是T本身(一个类型既是它自身的超类，也是它自身的子类)。</p><p>​        通过使用下界标定一个新的类型参数，就可以在A[+T]这样的类型构造器里泛化方法的入参类型。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>): <span class="hljs-type">U</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure><p>​        现在，编译器不会报错，因为下界的存在，导致编译器预期参数x的类型是T的超类。实际运行时，会根据传入的实际入参确定U是什么。返回类型定义成了U，当然也可以是T，但是动态地根据U来调整类型显得更自然。</p><p>​        与下界对应的是上界，其形式为“U &lt;: T”，表示U必须是T的子类或本身。通过上界，就能在A[-T]这样的类型构造器里泛化方法的返回类型。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>): <span class="hljs-type">U</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure><p>​        注意，编写上、下界时，不能写错类型的位置和开口符号</p><h2 id="13-7-方法的类型参数"><a href="#13-7-方法的类型参数" class="headerlink" title="13.7 方法的类型参数"></a>13.7 方法的类型参数</h2><p>​        除了类和特质能一开始声明类型参数外，方法也可以带有类型参数。如果方法仅仅使用了包含它的类或特质已声明的类型参数，那么方法自己就没必要写出类型参数。如果出现了包含它的类或特质未声明的类型参数，则必须写在方法的类型参数里。注意，方法的类型参数不能有型变注解。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: not found: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">U</span></span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>                            ^<br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span>](x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure><p>​        方法的类型参数不能与包含它的类和特质已声明的类型参数一样，否则会把它们覆盖掉。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"> scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>) = x.getClass<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>[<span class="hljs-type">Int</span>]<br>a: <span class="hljs-type">A</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">A</span>@<span class="hljs-number">3217</span>aada<br><br>scala&gt; a.funcA(<span class="hljs-string">&quot;Hello&quot;</span>)<br>res0: <span class="hljs-type">Class</span>[_ &lt;: <span class="hljs-type">String</span>] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br></code></pre></div></td></tr></table></figure><h2 id="13-8-对象私有化"><a href="#13-8-对象私有化" class="headerlink" title="13.8 对象私有化"></a>13.8 对象私有化</h2><p>​        var类型的字段，其类型参数不能是协变的，因为隐式的setter方法需要一个入参，这就把协变类型参数用作入参。其类型参数也不能是逆变的，因为隐式的getter方法的返回类型就是字段的类型。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: contravariant <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> <span class="hljs-title">occurs</span> <span class="hljs-title">in</span> <span class="hljs-title">covariant</span> <span class="hljs-title">position</span> <span class="hljs-title">in</span> <span class="hljs-title">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">T</span> <span class="hljs-title">of</span> <span class="hljs-title">variable</span> <span class="hljs-title">a</span></span><br>         <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>             ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: covariant <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> <span class="hljs-title">occurs</span> <span class="hljs-title">in</span> <span class="hljs-title">contravariant</span> <span class="hljs-title">position</span> <span class="hljs-title">in</span> <span class="hljs-title">type</span> <span class="hljs-title">T</span> <span class="hljs-title">of</span> <span class="hljs-title">value</span> <span class="hljs-title">a_=</span></span><br>         <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>             ^<br></code></pre></div></td></tr></table></figure><p>​        但是也有例外，如果var字段是对象私有的，即用private[this]修饰，那么它只能在定义该类或特质时被访问。由于外部无法直接访问，也就不可能在运行时违背里氏替换原则。因此隐式的getter和setter方法可以忽略对型变注解的检查。如果想在内部自定义getter或setter方法来产生一个错误，假设当前类型参数T是协变的，尽管可以通过下界来避免setter方法的型变注解错误，但是赋值操作又会发生类型匹配错误。连类型检查都无法通过，更不可能在运行时发生错误。同样，逆变类型参数也是如此。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>) = a = x<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found    : x.<span class="hljs-keyword">type</span> (<span class="hljs-keyword">with</span> underlying <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">U</span>)</span><br> required: <span class="hljs-type">T</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>) = a = x<br>                                      ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125; <br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](): <span class="hljs-type">U</span> = a<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found    : <span class="hljs-type">T</span><br> required: <span class="hljs-type">U</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](): <span class="hljs-type">U</span> = a<br>                                ^<br></code></pre></div></td></tr></table></figure><p>​        所以，Scala的编译器会忽略对private[this] var类型的字段的检查。</p><h2 id="14-抽象成员"><a href="#14-抽象成员" class="headerlink" title="14 抽象成员"></a>14 抽象成员</h2><p>​        对于本章内容不感兴趣或理解不深的读者，<strong>完全可以跳过</strong></p><p>​        因为这些内容也仅仅是<strong>帮助理解Chisel标准库的工作机制</strong>。实际的电路不可能会有这样的抽象成员。</p><h2 id="14-1-抽象成员"><a href="#14-1-抽象成员" class="headerlink" title="14.1 抽象成员"></a>14.1 抽象成员</h2><p>​        类可以用“<a href="https://so.csdn.net/so/search?q=abstract&amp;spm=1001.2101.3001.7020">abstract</a>”修饰变成抽象的，特质天生就是抽象的，所以抽象类和特质里可以包含抽象成员，也就是没有完整定义的成员。Scala有四种抽象成员：抽象val字段、抽象var字段、抽象方法和抽象类型，它们的声明形式如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Abstract</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span>                          <span class="hljs-comment">// 抽象类型</span></span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">T</span>  <span class="hljs-comment">// 抽象方法</span><br>  <span class="hljs-keyword">val</span> initial: <span class="hljs-type">T</span>                  <span class="hljs-comment">// 抽象val字段</span><br>  <span class="hljs-keyword">var</span> current: <span class="hljs-type">T</span>              <span class="hljs-comment">// 抽象var字段</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        因为定义不充分，存在不可初始化的字段和类型，或者没有函数体的方法，所以抽象类和特质不能直接用new构造实例。抽象成员的本意，就是让更具体的子类或子对象来实现它们。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Concrete</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Abstract</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> </span>= <span class="hljs-type">String</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span></span>(x: <span class="hljs-type">String</span>) = x + x<br>  <span class="hljs-keyword">val</span> initial = <span class="hljs-string">&quot;hi&quot;</span><br>  <span class="hljs-keyword">var</span> current = initial<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        抽象类型指的是用type关键字声明的一种类型——它是某个类或特质的成员但并未给出定义。虽然类和特质都定义了一种类型，并且它们可以是抽象的，但这不意味着抽象类或特质就叫抽象类型，抽象类型永远都是类和特质的成员。在使用抽象类型进行定义的地方，最后都要被解读成抽象类型的具体定义。而使用抽象类型的原因，一是给名字冗长或含义不明的类型起一个别名，二是声明子类必须实现的抽象类型。</p><p>​        在不知道某个字段正确的值，但是明确地知道在当前类的每个实例中，该字段都会有一个不可变更的值时，就可以使用抽象val字段。抽象val字段与抽象无参方法类似，而且访问方式完全一样。但是，抽象val字段保证每次使用时都返回一个相同的值，而抽象方法的具体实现可能每次都返回不同的值。另外，抽象val字段只能实现成具体的val字段，不能改成var字段或无参方法；而抽象无参方法可以实现成具体的无参方法，也可以是val字段。</p><p>​        抽象var字段与抽象val字段类似，但是是一个可被重新赋值的字段。与前一章讲解的具体var字段类似，抽象var字段会被编译器隐式地展开成抽象setter和抽象getter方法，但是不会在当前抽象类或特质中生成一个“private[this] var”字段。这个字段会在定义了其具体实现的子类或子对象当中生成。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AbstractTime</span> </span>&#123;undefined<br>  <span class="hljs-keyword">var</span> hour: <span class="hljs-type">Int</span><br>  <span class="hljs-keyword">var</span> minute: <span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AbstractTime</span> </span>&#123;undefined<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hour</span></span>: <span class="hljs-type">Int</span>             <span class="hljs-comment">// hour的getter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hour_=</span></span>(x: <span class="hljs-type">Int</span>)    <span class="hljs-comment">// hour的setter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minute</span></span>: <span class="hljs-type">Int</span>         <span class="hljs-comment">// minute的getter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minute_=</span></span>(x: <span class="hljs-type">Int</span>) <span class="hljs-comment">// minute的setter方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="14-2-初始化抽象val字段"><a href="#14-2-初始化抽象val字段" class="headerlink" title="14.2 初始化抽象val字段"></a>14.2 初始化抽象val字段</h2><p>​        抽象val字段有时会承担超类参数的职能：它们允许程序员在子类中提供那些在超类中缺失的细节。这对特质尤其重要，因为特质没有构造方法，参数化通常都是通过子类实现抽象val字段来完成。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>  <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>  <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        要在具体的类中混入这个特质，就必须实现它的两个抽象val字段。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">RationalTrait</span> &#123;undefined<br>    <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        注意，前面说过，这不是直接实例化特质，而是隐式地用一个匿名类混入了该特质，并且花括号里的内容属于隐式的匿名类。</p><p>​        构造子类的实例对象时，首先构造超类/超特质的组件，然后才轮到子类的剩余组件。因为花括号里的内容不属于超类/超特质，所以在构造超类/超特质的组件时，花括号里的内容其实是无用的。并且在这个过程中，如果需要访问超类/超特质的抽象val字段，会交出相应类型的默认值(比如Int类型的默认值是0)，而不是花括号里的定义。只有轮到构造子类的剩余组件时，花括号里的子类定义才会派上用场。所以，在构造超类/超特质的组件时，尤其是特质还不能接收子类的参数，如果默认值不满足某些要求，构造就会出错。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>         |    require(denomArg != <span class="hljs-number">0</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalTrait</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>         |  &#125;<br>java.lang.<span class="hljs-type">IllegalArgumentException</span>: requirement failed<br>  at scala.<span class="hljs-type">Predef</span>$.require(<span class="hljs-type">Predef</span>.scala:<span class="hljs-number">264</span>)<br>  at <span class="hljs-type">RationalTrait</span>.$init$(&lt;console&gt;:<span class="hljs-number">14</span>)<br>  ... <span class="hljs-number">32</span> elided<br></code></pre></div></td></tr></table></figure><p>​        在这个例子中，require函数会在参数为false时报错。该特质是用默认值0去初始化两个抽象字段的，花括号里的定义只有等超特质构造完成才有用，所以require函数无法通过。为此，Scala提供了两种方法解决这种问题。</p><p> <strong>（1）预初始化字段</strong><br>        如果能让花括号里的代码在最开始执行，那么就能避免该问题，这个方法被称作“预初始化字段”。其形式为：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> &#123; 定义 &#125; <span class="hljs-keyword">with</span> 超类/超特质 <br></code></pre></div></td></tr></table></figure><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">new</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>res0: <span class="hljs-type">RationalTrait</span> = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">1</span>a01ffff <br></code></pre></div></td></tr></table></figure><p>​        除了匿名类可以这样使用，单例对象或具名子类也可以，其形式是把花括号里的代码与单例对象名或类名用extends隔开，最后用with连接想要继承的类或混入的特质。例如： </p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, d: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg = n<br>         |    <span class="hljs-keyword">val</span> denomArg = d<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>java.lang.<span class="hljs-type">IllegalArgumentException</span>: requirement failed<br>  at scala.<span class="hljs-type">Predef</span>$.require(<span class="hljs-type">Predef</span>.scala:<span class="hljs-number">264</span>)<br>  at <span class="hljs-type">RationalTrait</span>.$init$(&lt;console&gt;:<span class="hljs-number">14</span>)<br>  ... <span class="hljs-number">29</span> elided<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, d: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg = n<br>         |    <span class="hljs-keyword">val</span> denomArg = d<br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">RationalClass</span> = <span class="hljs-type">RationalClass</span>@<span class="hljs-number">6</span>f26e775<br></code></pre></div></td></tr></table></figure><p>​        这个语法有一个瑕疵，就是由于预初始化字段发生得比构造超类/超特质更早，导致预初始化字段时实例对象其实还未被构造，所以花括号里的代码不能通过“this”来引用正在构造的对象本身。如果代码里出现了this，那么这个引用将指向包含当前被构造的类或对象的对象，而不是被构造的对象本身。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">new</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-keyword">this</span>.numerArg * <span class="hljs-number">2</span><br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>&lt;console&gt;:<span class="hljs-number">15</span>: error: value numerArg is not a member of <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">$iw</span></span><br>         <span class="hljs-keyword">val</span> denomArg = <span class="hljs-keyword">this</span>.numerArg * <span class="hljs-number">2</span><br>                             ^ <br></code></pre></div></td></tr></table></figure><p>​        这个代码无法通过编译，因为this指向了包含用new构造的对象的那个对象，在本例中是名为“$iw”的合成对象，该合成对象是Scala的编译器用于存放用户输入的代码的地方。由于$iw没有叫numerArg的成员，所以编译器产生了错误。</p><p><strong>（2）惰性的val字段</strong><br>        预初始化字段是人为地调整初始化顺序，而把val字段定义成惰性的，则可以让程序自己确定初始化顺序。如果在val字段前面加上关键字“lazy”，那么该字段只有首次被使用时才会进行初始化。如果是用表达式进行初始化，那就对表达式求值并保存，后续使用字段时都是复用保存的结果而不是每次都求值表达式。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LazyRationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> numer = numerArg / g<br>         |    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> denom = denomArg / g<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= numer + <span class="hljs-string">&quot;/&quot;</span> + denom<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> g = &#123;undefined<br>         |       require(denomArg != <span class="hljs-number">0</span>)<br>         |       gcd(numerArg, denomArg)<br>         |    &#125;<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> =<br>         |       <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) a <span class="hljs-keyword">else</span> gcd(b, a % b)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LazyRationalTrait</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-number">2</span><br>x: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">LazyRationalTrait</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span> * x<br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span> * x<br>         |  &#125;<br>res0: <span class="hljs-type">LazyRationalTrait</span> = <span class="hljs-number">1</span>/<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>​        首先仍然是先构造超特质的组件，但是需要初始化的非抽象字段都被lazy修饰，所以没有执行任何操作。并且由于require函数在字段g内部，而g没有初始化，所以不会出错。然后开始构造子类的组件，先对1 <em> x和2 </em> x两个表达式进行求值，得到2和4后把两个抽象字段初始化了。最后，解释器需要调用toString方法进行信息输出，该方法要访问numer，此时才对numer右侧的初始化表达式进行求值，且numerArg已经初始化为2；在numer初始化时要访问g，所以才对g进行初始化，但denomArg已满足require的要求，求得g为2并保存；等到toString方法要访问denom时，才初始化denom，并且g不用再次求值。至此，对象构造完成。 </p><h2 id="14-3-抽象类型"><a href="#14-3-抽象类型" class="headerlink" title="14.3 抽象类型"></a>14.3 抽象类型</h2><p>​        假设要编写一个Food类，用各种子类来表示各种食物。要编写一个抽象的Animal类，有一个eat方法，接收Food类型的参数。那么可能会写成如下形式：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Food</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br></code></pre></div></td></tr></table></figure><p>​        如果用不同的Animal子类来代表不同的动物，并且食物类型也会根据动物的习性发生改变。比如定义一头吃草的牛，那么可能定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125; <br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-title">needs</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">abstract</span>, <span class="hljs-title">since</span> <span class="hljs-title">method</span> <span class="hljs-title">eat</span> <span class="hljs-title">in</span> <span class="hljs-title">class</span> <span class="hljs-title">Animal</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> (<span class="hljs-params">food: <span class="hljs-type">Food</span></span>)<span class="hljs-title">Unit</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span></span><br>(<span class="hljs-type">Note</span> that <span class="hljs-type">Food</span> does not <span class="hljs-keyword">match</span> <span class="hljs-type">Grass</span>: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">subclass</span> <span class="hljs-title">of</span> <span class="hljs-title">class</span> <span class="hljs-title">Food</span>, <span class="hljs-title">but</span> <span class="hljs-title">method</span> <span class="hljs-title">parameter</span> <span class="hljs-title">types</span> <span class="hljs-title">must</span> <span class="hljs-title">match</span> <span class="hljs-title">exactly</span>.)</span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>             ^<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: method eat overrides nothing.<br><span class="hljs-type">Note</span>: the <span class="hljs-keyword">super</span> classes of <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-title">contain</span> <span class="hljs-title">the</span> <span class="hljs-title">following</span>, <span class="hljs-title">non</span> <span class="hljs-title">final</span> <span class="hljs-title">members</span> <span class="hljs-title">named</span> <span class="hljs-title">eat</span></span>:<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Food</span>): <span class="hljs-type">Unit</span><br>       <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125;<br>                    ^<br></code></pre></div></td></tr></table></figure><p>​        奇怪的是，编译器并不允许这么做。问题出在“override def eat(food: Grass) = {}”这句代码并不会被编译。实现超类的抽象方法其实相当于重写，但是重写要保证参数列表完全一致，否则就是函数重载。在这里，超类的方法eat的参数类型是Food，但是子类的版本改成了Grass。Scala的编译器执行严格的类型检查，尽管Grass是Food的子类，但是出现在函数的参数类型上，并不能简单地套用子类型多态，就认为Grass等效于Food。所以，错误信息显示Cow类一是没有实现Animal类的抽象eat方法，二是Cow类的eat方法并未重写任何东西。</p><p>​        如果有读者认为这种规则过于严厉，应该放松，那么就会出现如下不符合常识的情况：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br><br><span class="hljs-keyword">val</span> bessy: <span class="hljs-type">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br><br>bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br></code></pre></div></td></tr></table></figure><p>​        假设编译器放开对eat方法的参数类型的限制，使得任何Food类型都能通过编译，那么Fish类作为Food的子类，也就能被Cow类的eat方法所接受。但是，给一头牛喂鱼，而不是吃草，显然与事实不符。</p><p>​        要达到上述目的，就需要更精确的编程模型。一种办法就是借助抽象类型及上界，例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |     <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> <span class="hljs-title">&lt;</span></span>: <span class="hljs-type">Food</span><br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">SuitableFood</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span><br></code></pre></div></td></tr></table></figure><p>​        在这里，引入了一个抽象类型。由于方法eat的参数设定为抽象类型，在编译时会被解读成具体的SuitableFood实现，所以不同的Animal子类可以通过更改具体的SuitableFood来达到改变食物类型的目的，并且这符合严格的规则检查。其次，上界保证了在子类实现SuitableFood时，必须是Food的某个子类，即不会喂给动物吃非食物类的东西。此时的Cow类如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span><br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125;<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span></span><br></code></pre></div></td></tr></table></figure><p>​        如果现在给吃草的牛喂一条鱼，那么就会发生类型错误：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> bessy: <span class="hljs-type">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br>bessy: <span class="hljs-type">Animal</span> = <span class="hljs-type">Cow</span>@<span class="hljs-number">2442</span>f36d<br><br>scala&gt; bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Fish</span><br> required: bessy.<span class="hljs-type">SuitableFood</span><br>       bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br>                  ^ <br></code></pre></div></td></tr></table></figure><h2 id="14-4-路径依赖类型"><a href="#14-4-路径依赖类型" class="headerlink" title="14.4 路径依赖类型"></a>14.4 路径依赖类型</h2><p>​        在前面给牛喂鱼的例子中，可以发现错误信息里有一个有趣的现象：方法eat要求的参数类型是bessy.SuitableFood。关于类型“bessy.SuitableFood”，比普通的类型描述多了一个对象。这说明类型可以是对象的成员，bessy.SuitableFood表示SuitableFood是由bessy引用的对象的成员，或者说bessy引用对象的专属食物。像这样的类型称为路径依赖类型，尽管最后的类型是相同的，但若是前面的路径不同，那就是不同的类型。“路径”就是指对象的引用，它可以是单名，也可以是更长的路径。</p><p>​        比如，狗吃狗粮，一条狗能吃另一条狗的狗粮，但牛怎么都不能吃狗粮：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogFood</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogFood</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">DogFood</span><br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">DogFood</span>) = &#123;&#125;<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> lassie = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span><br>lassie: <span class="hljs-type">Dog</span> = <span class="hljs-type">Dog</span>@<span class="hljs-number">2655</span>ad3b<br><br>scala&gt; <span class="hljs-keyword">val</span> bessy = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br>bessy: <span class="hljs-type">Cow</span> = <span class="hljs-type">Cow</span>@<span class="hljs-number">663e2</span>cfd<br><br>scala&gt; lassie eat (<span class="hljs-keyword">new</span> bessy.<span class="hljs-type">SuitableFood</span>)<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Grass</span><br> required: <span class="hljs-type">DogFood</span><br>       lassie eat (<span class="hljs-keyword">new</span> bessy.<span class="hljs-type">SuitableFood</span>)<br>                   ^<br><br>scala&gt; <span class="hljs-keyword">val</span> bootsie = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span><br>bootsie: <span class="hljs-type">Dog</span> = <span class="hljs-type">Dog</span>@<span class="hljs-number">456454e0</span><br><br>scala&gt; lassie eat (<span class="hljs-keyword">new</span> bootsie.<span class="hljs-type">SuitableFood</span>)<br><br>scala&gt;<br></code></pre></div></td></tr></table></figure><p>​        因为bessy.SuitableFood和lassie.SuitableFood的路径不同，所以它们是不同的类型。而lassie.SuitableFood和bootsie.SuitableFood尽管有不同的路径，似乎是不同的类型，但其实这两个都是实际类型DogFood的别名，所以实质上是同一个类型。</p><p>​        Scala的“路径依赖类型”很像Java的“内部类类型”，但是两者有重要区别：路径依赖类型的路径表明了外部类的对象，而内部类类型仅表明了外部类。</p><p>​        Scala也可以表示Java的内部类，但是语法稍有不同。Scala定义一个内部类只需这样写：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        内部类Inner可以通过“Outer#Inner”来寻址，而不是Java的“Outer.Inner”，因为Scala把句点符号作为对象访问成员的专属符号，而类访问成员则是通过井号。比如有如下两个对象：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span><br><span class="hljs-keyword">val</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span><br></code></pre></div></td></tr></table></figure><p>​        那么，o1.Inner和o2.Inner就是两个路径依赖类型，并且是两个不同的类型。这两个路径依赖类型都是Outer#Inner的子类型，因为Outer#Inner其实是用任意的Outer对象来表示Inner类型。相比之下，o1.Inner是通过一个被o1引用的具体对象来表示的类型。o2.Inner也是如此。</p><p>​        与Java一样，Scala的内部类的实例持有包含它的外部类的实例的引用，这使得内部类可以访问包含它的外部类的成员。也正因此，在没有给出某个外部类的具体实例时，不能直接实例化内部类，因为光有内部类实例，没有相应的外部类实例，就无法访问外部类实例的成员。有两种途径实例化内部类：一是在外部类的花括号内部通过“this.Inner”来实例化，让this引用正在构造的外部类实例；二是给出具体的外部类实例，比如o1.Inner，就可以通过“new o1.Inner”来实例化。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i1 = <span class="hljs-keyword">new</span> o1.<span class="hljs-type">Inner</span><br>i1: o1.<span class="hljs-type">Inner</span> = <span class="hljs-type">Outer</span>$<span class="hljs-type">Inner</span>@<span class="hljs-number">5464</span>a18<br><br> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span>是不能直接实例化的，因为没有具体的外部类实例：<br><br>scala&gt; <span class="hljs-keyword">val</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: <span class="hljs-type">Outer</span> is not a legal prefix <span class="hljs-keyword">for</span> a constructor<br>       <span class="hljs-keyword">val</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span><br>                          ^<br></code></pre></div></td></tr></table></figure><h2 id="14-5-细化类型"><a href="#14-5-细化类型" class="headerlink" title="14.5 细化类型"></a>14.5 细化类型</h2><p>​        当一个类继承自另一个类时，就称前者是后者的名义子类型。Scala还有一个结构子类型，表示两个类型只是有某些兼容的成员，而不是常规的那样继承来的关系。结构子类型通过细化类型来表示。</p><p>​        比如，要做一个食草动物的集合。一种方法是定义一个食草的特质，让所有的食草动物类都混入该特质。但是这样会让食草动物与最基本的动物的关系不那么紧密。如果按前面定义食草牛那样继承自Animal类，那么食草动物集合的元素类型就可以表示为Animal类型，但这样又可能把食肉动物或杂食动物也包含进集合。此时，就可以使用结构子类型，其形式如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Animal</span> &#123; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span> &#125; <br></code></pre></div></td></tr></table></figure><p>​        最前面是基类Animal的声明，花括号里是想要兼容的成员。这个成员声明得比基类Animal更具体、更精细，表示食物类型必须是草。当然，并不一定要更加具体。那么，用这样一个类型指明集合元素得类型，就可以只包含食草动物了：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> animals: <span class="hljs-type">List</span>[<span class="hljs-type">Animal</span> &#123; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span> &#125;] = ??? <br></code></pre></div></td></tr></table></figure><h2 id="14-6-Scala的枚举"><a href="#14-6-Scala的枚举" class="headerlink" title="14.6 Scala的枚举"></a>14.6 Scala的枚举</h2><p>​        Scala没有特定的语法表示枚举，而是在标准类库中提供一个枚举类——scala.Enumeration。通过创建一个继承自这个类的子对象可以创建枚举。例如： </p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">Red</span>, <span class="hljs-type">Green</span>, <span class="hljs-type">Blue</span> = <span class="hljs-type">Value</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Color</span></span><br></code></pre></div></td></tr></table></figure><p>​        对象Color和普通的单例对象一样，可以通过“Color.Red”这样的方式来访问成员，或者先用“import Color._”导入。</p><p>​        Enumeration类定义了一个名为Value的内部类，以及同名的无参方法。该方法每次都返回内部类Value的全新实例，也就是说，枚举对象Color的三个枚举值都分别引用了一个Value类型的实例对象。并且，因为Value是内部类，所以它的对象的具体类型还与外部类的实例对象有关。在这里，外部类的对象就是自定义的Color，所以三个枚举值引用的对象的真正类型应该是Color.Value。</p><p>​        假如还有别的枚举对象，例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">North</span>, <span class="hljs-type">East</span>, <span class="hljs-type">South</span>, <span class="hljs-type">West</span> = <span class="hljs-type">Value</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span></span><br></code></pre></div></td></tr></table></figure><p>​        根据路径依赖类型的规则，Color.Value和Direction.Value是两个不同类型，所以两个枚举对象分别创造了两种不同类型的枚举值。</p><p>​        方法Value有一个重载的版本，可以接收一个字符串参数来给枚举值关联特定的名称。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">North</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;N&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">East</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;E&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">South</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;S&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">West</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;W&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> </span><br></code></pre></div></td></tr></table></figure><p>​        方法values返回枚举值的名称的集合。优先给出特定名称，否则就给字段名称。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Color</span>.values<br>res0: <span class="hljs-type">Color</span>.<span class="hljs-type">ValueSet</span> = <span class="hljs-type">Color</span>.<span class="hljs-type">ValueSet</span>(<span class="hljs-type">Red</span>, <span class="hljs-type">Green</span>, <span class="hljs-type">Blue</span>)<br><br>scala&gt; <span class="hljs-type">Direction</span>.values<br>res1: <span class="hljs-type">Direction</span>.<span class="hljs-type">ValueSet</span> = <span class="hljs-type">Direction</span>.<span class="hljs-type">ValueSet</span>(<span class="hljs-type">N</span>, <span class="hljs-type">E</span>, <span class="hljs-type">S</span>, <span class="hljs-type">W</span>)<br></code></pre></div></td></tr></table></figure><p>​        枚举值从0开始编号。内部类Value有一个方法id返回相应的编号，也可以通过“对象名(编号)”来返回相应的枚举值的名称。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Color</span>.<span class="hljs-type">Red</span>.id<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Color</span>(<span class="hljs-number">2</span>)<br>res3: <span class="hljs-type">Color</span>.<span class="hljs-type">Value</span> = <span class="hljs-type">Blue</span><br><br>scala&gt; <span class="hljs-type">Color</span>(<span class="hljs-number">3</span>)<br>java.util.<span class="hljs-type">NoSuchElementException</span>: key not found: <span class="hljs-number">3</span><br>  at scala.collection.<span class="hljs-type">MapLike</span>.<span class="hljs-keyword">default</span>(<span class="hljs-type">MapLike</span>.scala:<span class="hljs-number">231</span>)<br>  at scala.collection.<span class="hljs-type">MapLike</span>.<span class="hljs-keyword">default</span>$(<span class="hljs-type">MapLike</span>.scala:<span class="hljs-number">230</span>)<br>  at scala.collection.<span class="hljs-type">AbstractMap</span>.<span class="hljs-keyword">default</span>(<span class="hljs-type">Map</span>.scala:<span class="hljs-number">59</span>)<br>  at scala.collection.mutable.<span class="hljs-type">HashMap</span>.apply(<span class="hljs-type">HashMap</span>.scala:<span class="hljs-number">65</span>)<br>  at scala.<span class="hljs-type">Enumeration</span>.apply(<span class="hljs-type">Enumeration</span>.scala:<span class="hljs-number">142</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; <span class="hljs-type">Direction</span>.<span class="hljs-type">North</span>.id<br>res4: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Direction</span>(<span class="hljs-number">0</span>)<br>res5: <span class="hljs-type">Direction</span>.<span class="hljs-type">Value</span> = <span class="hljs-type">N</span><br></code></pre></div></td></tr></table></figure><h1 id="15-隐式转换与隐式参数"><a href="#15-隐式转换与隐式参数" class="headerlink" title="15 隐式转换与隐式参数"></a>15 隐式转换与隐式参数</h1><p>​        隐式定义是一个很常用的Scala高级语法</p><p>​        尤其是在阅读、理解Chisel这样的DSL语言时，就不得不彻底搞明白自定义的隐式定义是如何工作的。</p><p>​        <strong>编写实际的硬件电路，像RocketChip的快速裁剪、配置功能，就是通过模式匹配加上隐式参数实现的</strong>（配置机制会在后续章节讲解。<strong>对于想掌握Chisel高级功能的读者，本章是学习的重点</strong>）</p><h2 id="15-1-隐式定义的规则"><a href="#15-1-隐式定义的规则" class="headerlink" title="15.1 隐式定义的规则"></a>15.1 隐式定义的规则</h2><ul><li><p><strong>标记规则：</strong>只有用关键字<strong>“implicit”标记</strong>的定义才能被编译器隐式使用，任何<strong>函数、变量或单例对象</strong>都可以被标记。</p><ul><li><strong>隐式的变量和单例对象</strong>常用作<mark>隐式参数</mark></li><li><strong>隐式的函数</strong>常用于<mark>隐式转换</mark>。比如，代码“x + y”因为调用对象x的类型错误而不能通过编译，那么编译器会尝试把代码改成“convert(x) + y”，其中convert是某种可用的隐式转换。如果convert能将x改成某种支持“+”方法的对象，那么这段代码就可能通过类型检查</li></ul></li><li><p><strong>作用域规则：</strong></p><ul><li><strong>Scala编译器只会考虑在当前作用域内的隐式定义</strong>（否则，所有隐式定义都是全局可见的将会使得程序异常复杂甚至出错）</li><li>隐式定义在当前作用域<strong>必须是“单个标识符”</strong><ul><li>编译器不会展开成<u>“A.convert(x) + y”</u>的形式</li><li>如果想用A.convert，那么必须先用<u>“import A.convert”导入才行</u>，然后被展开成“convert(x) + y”的形式。</li><li>单个标识符规则有一个例外，就是<strong>编译器会在与隐式转换相关的源类型和目标类型的伴生对象里查找隐式定义</strong>。因此，常在伴生对象中定义隐式转换，而不用在需要时显式导入。</li></ul></li></ul></li><li><p><strong>每次一个规则</strong>：</p><ul><li>编译器<strong>只会插入一个隐式定义</strong>，不会出现“convert1(convert2(x)) + y”这种嵌套的形式，但是可以让隐式定义包含隐式参数来绕开这个限制。</li></ul></li><li><p><strong>显式优先原则</strong>：</p><ul><li>如果显式定义能通过类型检查，就不必进行隐式转换。因此，总是可以把隐式定义变成显式的，这样代码变长但是歧义变少。用显式还是隐式，需要取舍</li></ul></li></ul><hr><p><strong>命名规则：</strong>隐式转换可以用任意合法的标识符来命名。有了名字后，一是可以显式地把隐式转换函数写出来，二是明确地导入具体的隐式转换而不是导入所有的隐式定义。</p><p><strong>隐式定义使用位置：</strong></p><ul><li>转换到一个预期的类型</li><li>转换某个选择接收端(即调用方法或字段的对象)</li><li>隐式参数。</li></ul><h2 id="15-2-（位置一）隐式地转换到期望类型——右边的转为能用的"><a href="#15-2-（位置一）隐式地转换到期望类型——右边的转为能用的" class="headerlink" title="15.2 （位置一）隐式地转换到期望类型——右边的转为能用的"></a>15.2 （位置一）隐式地转换到期望类型——右边的转为能用的</h2><p><strong>使用方法：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">隐式函数名</span></span>(原始类型) = 期望类型.返回期望类型的转换方法<br><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">隐式函数名</span></span>(原始类型) = 返回期望类型的转换函数<br></code></pre></div></td></tr></table></figure><hr><p>​        Scala的编译器对于类型检查比较严格，比如把一个浮点数赋值给整数变量，通常情况下人们可能希望通过截断小数部分来完成赋值，但是Scala在默认情况下是不允许这种丢失精度的转换的，<strong>这会造成类型匹配错误</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Double</span>(<span class="hljs-number">1.5</span>)<br> required: <span class="hljs-type">Int</span><br>       <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>                    ^<br></code></pre></div></td></tr></table></figure><p>​        可以通过定义一个<strong>隐式转换来完成</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> scala.language.implicitConversions<br><span class="hljs-keyword">import</span> scala.language.implicitConversions<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleToInt</span></span>(x: <span class="hljs-type">Double</span>) = x.toInt<br>doubleToInt: (x: <span class="hljs-type">Double</span>)<span class="hljs-type">Int</span><br><br>scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>i: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span> <br></code></pre></div></td></tr></table></figure><p>​        隐式转换也可以<strong>显式地调用：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = doubleToInt(<span class="hljs-number">2.33</span>)<br>i: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span> <br></code></pre></div></td></tr></table></figure><h2 id="15-2-补充：Scala全局层次中隐式插入的用于类型转换的三个包"><a href="#15-2-补充：Scala全局层次中隐式插入的用于类型转换的三个包" class="headerlink" title="15.2 补充：Scala全局层次中隐式插入的用于类型转换的三个包"></a>15.2 补充：Scala全局层次中隐式插入的用于类型转换的三个包</h2><p>​        第七章讲解类继承时，最后提到了Scala的全局类层次，其中就有七种基本值类的转换，比如Int可以赋值给Double。这其实也是隐式转换在起作用，只是这个隐式转换定义在scala包里的单例对象Predef里。</p><p>​        <strong>所有的Scala文件都会被编译器隐式地在开头按顺序插入：</strong></p><ul><li>“import java.lang._”</li><li>“import scala._”</li><li>“import Predef._”</li></ul><p>​        三条语句，所以标准库里的隐式转换会以不被察觉的方式工作</p><h2 id="15-3-（位置二）隐式地转换接收端——转换左边的"><a href="#15-3-（位置二）隐式地转换接收端——转换左边的" class="headerlink" title="15.3 （位置二）隐式地转换接收端——转换左边的"></a>15.3 （位置二）隐式地转换接收端——转换左边的</h2><p><strong>接收端</strong>：指调用方法或字段的那个对象，也就是调用对象在非法的情况下，被隐式转换变成了合法的对象，这是隐式转换最常用的地方。</p><p><strong>使用方法：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">隐式函数名</span></span>(左边/接收端类型) = 一个类<br></code></pre></div></td></tr></table></figure><p>​        例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span>(<span class="hljs-params">val i: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span></span><br><br>scala&gt; <span class="hljs-number">1.</span>i<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: value i is not a member of <span class="hljs-type">Int</span><br>       <span class="hljs-number">1.</span>i<br>         ^<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToMy</span></span>(x: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt</span>(x)<br>intToMy: (x: <span class="hljs-type">Int</span>)<span class="hljs-type">MyInt</span><br><br>scala&gt; <span class="hljs-number">1.</span>i<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>​        在上个例子中，标准值类Int是没有叫“i”的字段的，在定义隐式转换前，“1.i”是非法的。有了隐式转换后，把一个Int对象作为参数构造了一个新的MyInt对象，而MyInt对象就有字段i。所以“1.i”被编译器隐式地展开成了“intToMy(1).i”。这就使得已有类型可以通过“自然”的方式与新类型进行互动。</p><p>​        此外，隐式转换的这个作用还经常被用于模拟新的语法，尤其是在构建DSL语言时用到。因为DSL语言含有大量的自定义类型，这些自定义类型可能要频繁地与已有类型交互，有了隐式转换之后就能让代码的语法更加自然。比如Chisel就是这样的DSL语言，如果读者仔细研究Chisel的源码，就会发现大量的隐式定义。</p><p>​        前面说过，映射的键-值对语法“键 -&gt; 值”其实是一个对偶“(键, 值)”。这并不是什么高深的技巧，就是隐式转换在起作用。Scala仍然是在Predef这个单例对象里定义了一个箭头关联类ArrowAssoc，该类有一个方法“-&gt;”，接收一个任意类型的参数，把调用对象和参数构成一个二元组来返回。同时，单例对象里还有一个隐式转换any2ArrowAssoc，该转换也接收一个任意类型的参数，用这个参数构造一个ArrowAssoc类的实例对象。所以，“键 -&gt; 值”会被编译器隐式地展开成“any2ArrowAssoc(键).-&gt;(值)”。因此，严格来讲没有“键 -&gt; 值”这个语法，只不过是用隐式转换模拟出来的罢了。</p><h2 id="14-4-（位置二）隐式类"><a href="#14-4-（位置二）隐式类" class="headerlink" title="14.4 （位置二）隐式类"></a>14.4 （位置二）隐式类</h2><p><strong>隐式类：</strong>是一个以关键字<strong>“implicit”开头的类</strong></p><ul><li>用于简化富包装类的编写。</li><li>它不能是样例类，并且主构造方法有且仅有一个参数。</li><li>此外，隐式类只能位于某个单例对象、类或特质里，不能单独出现在顶层。</li><li>隐式类的特点就是让编译器在相同层次下自动生成一个与类名相同的隐式转换，该转换接收一个与隐式类的主构造方法相同的参数，并用这个参数构造一个隐式类的实例对象来返回。</li></ul><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">width: <span class="hljs-type">Int</span>, height: <span class="hljs-type">Int</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Rec</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectangleMaker</span>(<span class="hljs-params">width: <span class="hljs-type">Int</span></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>(height: <span class="hljs-type">Int</span>) = <span class="hljs-type">Rectangle</span>(width, height)<br>  &#125;<br>  <span class="hljs-comment">// 自动生成的</span><br>  <span class="hljs-comment">// implicit def RectangleMaker(width: Int) = new RectangleMaker(width)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        将该文件编译后，就可以在解释器里用“import Rec._”或“import Rec.RectangleMaker”来引入这个隐式转换，然后用“1 x 10”这样的语句来构造一个长方形。实际上，Int类并不存在方法“x”，但是隐式转换把Int对象转换成一个RectangleMaker类的对象，转换后的对象有一个构造Rectangle的方法“x”。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: value x is not a member of <span class="hljs-type">Int</span><br>       <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>         ^<br><br>scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">Rec</span>.<span class="hljs-type">RectangleMaker</span><br><span class="hljs-keyword">import</span> <span class="hljs-type">Rec</span>.<span class="hljs-type">RectangleMaker</span><br><br>scala&gt; <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>res0: <span class="hljs-type">Rectangle</span> = <span class="hljs-type">Rectangle</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br></code></pre></div></td></tr></table></figure><p>​        隐式类需要单参数主构造方法的原因很简单，因为用于转换的调用对象只有一个，并且自动生成的隐式转换不会去调用辅助构造方法。隐式类不能出现在顶层是因为自动生成的隐式转换与隐式类在同一级，如果不用导入就能直接使用，那么顶层大量的隐式类就会使得代码变得复杂且容易出错。</p><h2 id="15-5-（位置三）隐式参数"><a href="#15-5-（位置三）隐式参数" class="headerlink" title="15.5 （位置三）隐式参数"></a>15.5 （位置三）隐式参数</h2><p>​        函数最后一个参数列表可以用关键字“implicit”声明为隐式的，这样整个参数列表的参数都是隐式参数。注意，是整个参数列表，即使括号里有多个参数，也只需要开头写一个“implicit”。而且每个参数都是隐式的，不存在部分隐式部分显式。</p><p>​        当调用函数时，若缺省了隐式参数列表，则编译器会尝试插入相应的隐式定义。当然，也可以显式给出参数，但是要么全部缺省，要么全部显式给出，不能只写一部分。</p><p>​        要让编译器隐式插入参数，就必须事先定义好符合预期类型的隐式变量(val和var可以混用，关键在于类型)、隐式单例对象或隐式函数(别忘了函数也能作为函数的参数进行传递)，这些隐式定义也必须用“implicit”修饰。隐式变量、单例对象、函数在当前作用域的引用也必须满足“单标识符”原则，即不同层次之间需要用“import”来解决。</p><p>​        隐式参数的类型应该是“稀有”或“特定”的，类型名称最好能表明该参数的作用。如果直接使用Int、Boolean、String等常用类型，容易引发混乱。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreferredPrompt</span>(<span class="hljs-params">val preference: <span class="hljs-type">String</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreferredDrink</span>(<span class="hljs-params">val preference: <span class="hljs-type">String</span></span>)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span></span>(name: <span class="hljs-type">String</span>)(<span class="hljs-keyword">implicit</span> prompt: <span class="hljs-type">PreferredPrompt</span>,<br>      drink: <span class="hljs-type">PreferredDrink</span>) = &#123;<br>    println(<span class="hljs-string">&quot;Welcome, &quot;</span> + name + <span class="hljs-string">&quot;. The system is ready.&quot;</span>)<br>    print(<span class="hljs-string">&quot;But while you work, &quot;</span>)<br>    println(<span class="hljs-string">&quot;why not enjoy a cup of &quot;</span> + drink.preference + <span class="hljs-string">&quot;?&quot;</span>)<br>    println(prompt.preference)<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">JoesPrefs</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> prompt = <span class="hljs-keyword">new</span> <span class="hljs-type">PreferredPrompt</span>(<span class="hljs-string">&quot;Yes, master&gt; &quot;</span>)<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> drink = <span class="hljs-keyword">new</span> <span class="hljs-type">PreferredDrink</span>(<span class="hljs-string">&quot;tea&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: could not find <span class="hljs-keyword">implicit</span> value <span class="hljs-keyword">for</span> parameter prompt: <span class="hljs-type">PreferredPrompt</span><br>       <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br>                    ^<br><br>scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">JoesPrefs</span>._<br><span class="hljs-keyword">import</span> <span class="hljs-type">JoesPrefs</span>._<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br><span class="hljs-type">Welcome</span>, <span class="hljs-type">Joe</span>. <span class="hljs-type">The</span> system is ready.<br><span class="hljs-type">But</span> <span class="hljs-keyword">while</span> you work, why not enjoy a cup of tea?<br><span class="hljs-type">Yes</span>, master&gt;<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt, drink)<br><span class="hljs-type">Welcome</span>, <span class="hljs-type">Joe</span>. <span class="hljs-type">The</span> system is ready.<br><span class="hljs-type">But</span> <span class="hljs-keyword">while</span> you work, why not enjoy a cup of tea?<br><span class="hljs-type">Yes</span>, master&gt;<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt)<br>&lt;console&gt;:<span class="hljs-number">15</span>: error: not enough arguments <span class="hljs-keyword">for</span> method greet: (<span class="hljs-keyword">implicit</span> prompt: <span class="hljs-type">PreferredPrompt</span>, <span class="hljs-keyword">implicit</span> drink: <span class="hljs-type">PreferredDrink</span>)<span class="hljs-type">Unit</span>.<br><span class="hljs-type">Unspecified</span> value parameter drink.<br>       <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt)<br></code></pre></div></td></tr></table></figure><h2 id="15-6-含有隐式参数的主构造方法"><a href="#15-6-含有隐式参数的主构造方法" class="headerlink" title="15.6 含有隐式参数的主构造方法"></a>15.6 含有隐式参数的主构造方法</h2><p>​        不仅是普通的函数可以有隐式参数，类的主构造方法也可以包含隐式参数，辅助构造方法是不允许出现隐式参数的。但有一个问题需要注意，假设类A仅有一个参数列表，并且该列表是隐式的，那么A的实际定义形式是“A()(implicit 参数)”，也就是比字面上的代码多了一个空括号。不管是用new实例化类A，还是被其它类继承，若调用主构造方法时显式给出隐式参数，就必须写出这个空括号。若隐式参数由编译器自动插入，则空括号可有可无。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-number">1</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: no arguments allowed <span class="hljs-keyword">for</span> nullary constructor <span class="hljs-type">A</span>: ()(<span class="hljs-keyword">implicit</span> x: <span class="hljs-type">Int</span>)<span class="hljs-type">A</span><br>       <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-number">1</span>)<br>                     ^<br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()(<span class="hljs-number">1</span>)<br>a: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7</span>cf8f45a<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">ORZ</span> = <span class="hljs-number">233</span><br><span class="hljs-type">ORZ</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>b: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7</span>d977a20<br><br>scala&gt; b.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>c: <span class="hljs-type">A</span> = <span class="hljs-type">A</span><span class="hljs-meta">@de</span>0c402<br><br>scala&gt; c.x<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> &#123; <span class="hljs-keyword">val</span> y = x &#125;<br>d: <span class="hljs-type">A</span>&#123;<span class="hljs-keyword">val</span> y: <span class="hljs-type">Int</span>&#125; = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">5</span>c5c7cc4<br><br>scala&gt; d.x<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">import</span> scala.language.reflectiveCalls<br><span class="hljs-keyword">import</span> scala.language.reflectiveCalls<br><br>scala&gt; d.y<br>res3: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br></code></pre></div></td></tr></table></figure><p>​        如果类A有多个参数列表，且最后一个是隐式的参数列表，则主构造方法没有额外的空括号。</p><h2 id="15-7-上下文界定"><a href="#15-7-上下文界定" class="headerlink" title="15.7 上下文界定"></a>15.7 上下文界定</h2><p>​        排序是一个常用的操作，Scala提供了一个特质Ordering[T]，方便用户定义特定的排序行为。该特质有一个抽象方法compare，接收两个T类型的参数，然后返回一个Int类型的结果。如果第一个参数“大于”第二个参数，则应该返回正数，反之应该返回负数，相等则返回0。这里的“大于”、“小于”和“等于”是可以自定义的，完全取决于compare的具体定义，并不一定就是常规的逻辑，比如可以和正常逻辑相反。此外，该特质还有方法gt、gteq、lt和lteq，用于表示大于、大于等于、小于和小于等于，分别根据compare的结果来返回相应的布尔值。换句话说，如果一个对象里混入了Ordering[T]特质，并实现了自己需要的compare方法，就能省略定义很多其它相关的方法。</p><p>​        假设现在需要编写一个方法寻找“最大”的列表元素，并且具体行为会根据某个隐式Ordering[T]对象发生改变，那么可能定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>])(<span class="hljs-keyword">implicit</span> ordering: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)(ordering)  <span class="hljs-comment">// 参数ordering被显式传递</span><br>           <span class="hljs-keyword">if</span> (ordering.gt(x, maxRest)) x   <span class="hljs-comment">// 参数ordering被显式使用 </span><br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure><p>​        在这里，读者只需关心两行带注释的代码。注意，函数maxList的第二个参数列表是隐式的，这就会让编译器在缺省给出时，自动在当前作用域下寻找一个Ordering[T]类型的对象。在第一行注释处，函数内部进行了自我调用，并且第二个参数仅仅只是传递了ordering，此时就可以利用隐式参数的特性，不必显式给出第二个参数的传递。</p><p>隐式导入的Predef对象里定义了下面这样一个函数：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">implicitly</span></span>[<span class="hljs-type">T</span>](<span class="hljs-keyword">implicit</span> t: <span class="hljs-type">T</span>) = t <br></code></pre></div></td></tr></table></figure><p>​        想要使用这个函数，可以只写成“implicitly[T]”的形式。只需要指明T是什么具体类型，在缺省参数的情况下，编译器会在当前作用域下自动寻找一个T类型的隐式对象传递给参数t，然后把这个对象返回。例如，implicitly[ORZ]就会把当前作用域下的隐式ORZ对象返回。既然函数maxList的第二个参数是编译器隐式插入的，那么第二行注释处也就没必要显式写出ordering，而可以改成“implicitly[Ordering[T]]”。</p><p>所以，一个更精简的maxList如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>])(<span class="hljs-keyword">implicit</span> ordering: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)  <br>           <span class="hljs-keyword">if</span> (implicitly[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]].gt(x, maxRest)) x <br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure><div class="hljs code-wrapper"><pre><code>     现在，函数maxList的定义里已经完全不需要显式写出隐式参数的名字了，所以隐式参数可以改成任意名字，而函数体仍然保持不变。由于这个模式很常用，所以Scala允许省掉这个参数列表并改用上下文界定。形如“[T : Ordering]”的函数的类型参数就是一个上下文界定，它有两层含义：①和正常情况一样，先在函数中引入一个类型参数T。②为函数添加一个类型为Ordering[T]的隐式参数。例如：</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span> : <span class="hljs-type">Ordering</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)  <br>           <span class="hljs-keyword">if</span> (implicitly[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]].gt(x, maxRest)) x <br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure><p>​        上下文界定与前面讲的上界和下界很像，但[T &lt;: Ordering[T]]表明T是Ordering[T]的子类型并且不会引入隐式参数，[T : Ordering]则并没有标定类型T的范围，而是说类型T与某种形式的排序相关，并且会引入隐式参数。</p><p>​        上下文界定是一种很灵活的语法，配合像Ordering[T]这样的特质以及隐式参数，可以实现各种功能而不需要改变定义的T类型。</p><h2 id="15-8-多个匹配的隐式定义"><a href="#15-8-多个匹配的隐式定义" class="headerlink" title="15.8 多个匹配的隐式定义"></a>15.8 多个匹配的隐式定义</h2><p>​        当多个隐式定义都符合条件时，编译器会发出定义模棱两可错误。但是如果其中一个比别的更加具体，那么编译器会自动选择定义更具体的隐式定义，且不会发出错误。所谓“具体”，只要满足两个条件之一便可：①更具体的定义，其类型是更模糊的定义的子类型。如果是隐式转换，比较的是参数类型，不是返回结果的类型。②子类中的隐式定义比超类中的隐式定义更具体。</p><p>定义模棱两可：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>z: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz = <span class="hljs-number">100</span><br>zz: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: ambiguous <span class="hljs-keyword">implicit</span> values:<br> both value z of <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">Int</span></span><br> and value zz of <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">Int</span></span><br> <span class="hljs-keyword">match</span> expected <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Int</span></span><br>       <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>               ^<br></code></pre></div></td></tr></table></figure><p> 条件①：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>z: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz: <span class="hljs-type">Any</span> = <span class="hljs-number">100</span><br>zz: <span class="hljs-type">Any</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>a: <span class="hljs-type">A</span> = <span class="hljs-type">A</span><span class="hljs-meta">@fee</span>881<br><br>scala&gt; a.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>条件②：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sup</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sup</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sup</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz = <span class="hljs-number">100</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Sup</span><br>a: <span class="hljs-type">Sup</span> = <span class="hljs-type">Sup</span>@<span class="hljs-number">789</span>dd6bf<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">Sub</span><br>b: <span class="hljs-type">Sub</span> = <span class="hljs-type">Sub</span>@<span class="hljs-number">772</span>cf46b<br><br>scala&gt; <span class="hljs-keyword">import</span> a._<br><span class="hljs-keyword">import</span> a._<br><br>scala&gt; <span class="hljs-keyword">import</span> b._<br><span class="hljs-keyword">import</span> b._<br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>c: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">352</span>bea0e<br><br>scala&gt; c.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure><p>九、总结<br>隐式定义是一个很常用的Scala高级语法，尤其是在阅读、理解Chisel这样的DSL语言时，就不得不彻底搞明白自定义的隐式定义是如何工作的。即使是编写实际的硬件电路，像RocketChip的快速裁剪、配置功能，就是通过模式匹配加上隐式参数实现的。配置机制会在后续章节讲解。对于想掌握Chisel高级功能的读者，本章是学习的重点。</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96717167_p0.jpg" alt="背景图pixivid：96717167"></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习材料</title>
    <link href="/202202281650/CS/Scalaessay/cs/scala/Scala2/"/>
    <url>/202202281650/CS/Scalaessay/cs/scala/Scala2/</url>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#scala%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8">Scala语言入门</a><ul><li><a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">环境配置</a></li><li><a href="#idea%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">IDEA环境配置</a></li><li><a href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">变量与数据类型</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E6%B5%81">控制流</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a></li><li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86">包管理</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a></li><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li><li><a href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">隐式转换</a></li><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li><li><a href="#style-guide">Style Guide</a></li><li><a href="#sbt">sbt</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E6%A1%88%E4%BE%8B%E5%85%A5%E9%97%A8sbt">通过案例入门sbt</a></li><li><a href="#sbt%E4%BD%BF%E7%94%A8">sbt使用</a></li><li><a href="#buildsbt">build.sbt</a></li><li><a href="#%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">多项目构建</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E5%9B%BE">任务图</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">更多内容</a></li></ul></li><li><a href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1 id="Scala语言入门"><a href="#Scala语言入门" class="headerlink" title="Scala语言入门"></a>Scala语言入门</h1><p>Scala（发音为/ˈskɑːlə, ˈskeɪlə/）是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。洛桑联邦理工学院的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Java平台的Scala于2003年底/2004年初发布。</p><p>特点：</p><ul><li>同样运行在JVM上，可以与现存程序同时运行。</li><li>可直接使用Java类库。</li><li>同Java一样静态类型。</li><li>语法和Java类似，比Java更加简洁（简洁而并不是简单），表达性更强。</li><li>同时支持面向对象、函数式编程。</li><li>比Java更面向对象。</li></ul><p>关注点：</p><ul><li>类型推断、不变量、函数式编程、高级程序构造。</li><li>并发：actor模型。</li><li>和现有Java代码交互、相比Java异同和优缺。</li></ul><p>和Java关系：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">        javac               java<br><span class="hljs-string">.java</span> <span class="hljs-params">--------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br><span class="hljs-string">.scala</span> <span class="hljs-params">-------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br>        scalac              scala<br></code></pre></div></td></tr></table></figure></p><p>测试代码：<a href="../../tree/Scala/">Scala分支</a></p><p>阅读：</p><ul><li><a href="https://www.bilibili.com/video/BV1Xh411S7bP">尚硅谷大数据技术之Scala入门到精通教程</a>（本文参考）</li><li><a href="https://docs.scala-lang.org/zh-cn/cheatsheets/index.html">Scala官网语法速查</a></li><li><a href="https://docs.scala-lang.org/zh-cn/tour/tour-of-scala.html">Scala官方文档 Tour Of Scala</a></li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>Scala需要依赖Java，访问<a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">这里</a>查看特定Scala版本依赖的Java版本。这里选择，最新的JDK17配合Scala2.13.6。</p><p>Windows中下载安装配置环境变量：</p><ul><li>类似于java配置<code>SCALA_HOME</code>为安装目录。</li><li>添加<code>%SCALA_HOME%\bin</code>到path环境变量。</li></ul><p>Linux中类似，可以使用包管理器，但如果依赖版本不严格一致的话，需要官网下载对应版本安装即可。</p><p>也有交互式执行环境：<br><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">scala</span><br></code></pre></div></td></tr></table></figure></p><p>交互式执行环境中的传统艺能：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br></code></pre></div></td></tr></table></figure></p><p>暂时不管项目配置，还是单文件编译执行为主，项目开发肯定要以包的形式组织可以使用IntelliJ IDEA开发，使用maven或者sbt进行项目配置。</p><p>使用VSCode编辑器，安装插件Scala Syntax (official)和Scala (Mentals)。</p><p>新建文件<code>HelloScala.scala</code>。<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloScala</span> </span>&#123; <span class="hljs-comment">// HelloScala is a object, not a class, will create a </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args : <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) : <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;hello,world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>可以使用插件CodeRunner直接快捷键运行。也可以在命令行编译为字节码后再运行：<br><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>HelloScala.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>helloScala<br></code></pre></div></td></tr></table></figure><br>或者直接运行scala源文件：<br><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">scala <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloScala</span>.</span></span>scala<br></code></pre></div></td></tr></table></figure><br>和java如出一辙。</p><p>如果编译的话会生成2个<code>.class</code>字节码文件，<code>HelloScala.class</code>和<code>HelloScala$.class</code>。都是字节码但是不能通过<code>java</code>直接运行。但对于HelloWorld这个例子来说，java源代码编译而成的字节码是可以通过<code>scala</code>命令运行的。</p><p>原因是没有引入Scala的库，添加<code>classpath</code>就可以通过java执行scala编译成的字节码了：<br><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">java -cp %SCALA_HOME%<span class="hljs-regexp">/lib/</span>scala-library.jar; HelloScala<br></code></pre></div></td></tr></table></figure><br>使用<a href="http://java-decompiler.github.io/">Java Decompiler</a>反编译字节码到java源文件可以看到引入Scala库的逻辑。并且：</p><ul><li>scala源文件中的<code>HelloScala</code>对象编译后成为了一个类，但对象本身编译后就是生成的另一个类<code>HelloScala$</code>类的单例对象<code>HelloScala$.MODULE$</code>，称之为伴生对象。</li><li><code>HelloScala$</code>有一个<code>main</code>实例方法，<code>HelloScala</code>类的静态方法通过这个单例对象转调这个实例方法。完成打印。</li><li>Scala比Java更面向对象。</li></ul><h2 id="IDEA环境配置"><a href="#IDEA环境配置" class="headerlink" title="IDEA环境配置"></a>IDEA环境配置</h2><p>使用IntelliJ IDEA：</p><ul><li>创建Maven项目，JDK版本17。</li><li>安装插件：Scala。一般默认都已经装了。</li><li>Maven项目默认用Java写，在<code>main/</code>目录下新建目录<code>scala/</code>，然后将目录标记为Source Root。</li><li>这样甚至可以在同一个项目中混用Scala和Java源文件，并互相调用。</li><li>需要能够添加scala源文件，右键项目，添加框架支持，配置Scala SDK，选择，然后就可以右键添加Scala源文件了。</li><li>添加包，添加Scala类，选择对象，编辑源码。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-type">VeryStarted</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span>= &#123;<br>    println(<span class="hljs-string">&quot;Hello,world!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>Ctrl + Shift + F10运行。</li><li>可以看到执行的命令是<code>java</code>在<code>classpath</code>中引入了Scala的<code>jar</code>包形式的库。</li><li>调用java的类库：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-type">VeryStarted</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span>= &#123;<br>    println(<span class="hljs-string">&quot;Hello,world!&quot;</span>)<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Hello,world! from java&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>语法含义：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SingletonObject</span> </span>&#123; body &#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MethodName</span></span>(<span class="hljs-type">ArgName</span>: <span class="hljs-type">ArgType</span>): <span class="hljs-type">RetType</span> = &#123; body &#125;<br></code></pre></div></td></tr></table></figure></p><p><code>object</code>关键字创建的伴生对象，可以理解为替代Java的<code>static</code>关键字的方式，将静态方法用单例对象的实例方法做了替代，做到了更纯粹的面向对象。</p><p>仅仅测试理解语法既可以单文件编写VSCode编译执行也可以用IDEA管理项目，影响不大。</p><p>再用一个等价的类定义来认识和区别一下Scala和Java：</p><p>java:<br><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String school = <span class="hljs-string">&quot;XDU&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.age + <span class="hljs-string">&quot; &quot;</span> + Student.school);<br>    &#125;<br><br>    <span class="hljs-comment">// psvm</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student tch = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tch&quot;</span>, <span class="hljs-number">20</span>);<br>        tch.printInfo();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>scala:<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-type">VeryStarted</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printInfo</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    println(name + <span class="hljs-string">&quot; &quot;</span> + age + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-type">Student</span>.school)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 引入伴生对象，名称一致，同一个文件</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> school: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;XDU&quot;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> tch = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;tch&quot;</span>, <span class="hljs-number">20</span>)<br>    tch.printInfo()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>Scala库源码与API文档：</p><ul><li>官网上下载下载Scala源码，解压到Scala安装目录或任意位置。</li><li>IntelliJ IDEA进入反编译的源码后选择右上角附加源码，选择源码的<code>src/</code>目录。</li><li>安装包里面已经有了文档，没有的话可以单独下载。</li><li>Scala依赖Java，某些类型就是Java的包装，库中有一部分java源码。</li></ul><h2 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h2><p>注释：</p><ul><li>和java一样</li><li><code>//</code> 单行</li><li><code>/* */</code> 多行</li><li><code>/** */</code> 文档，方法或者类前面，便于<code>scaladoc</code>生成文档。</li></ul><p>变量和常量：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> name [:<span class="hljs-type">VariableType</span>] = value <span class="hljs-comment">// variable</span><br><span class="hljs-keyword">val</span> name [:<span class="hljs-type">ConstantType</span>] = value <span class="hljs-comment">// constant</span><br></code></pre></div></td></tr></table></figure><br>因为Scala的函数式编程要素，所以一个指导意见就是能用常量就不要用变量。</p><ul><li>声明变量时，类型可以省略，编译器会自动推导。</li><li>静态类型，类型经过给定或推导确定后就不能修改。</li><li>变量和常量声明时，必须有初始值。</li><li>变量可变，常量不可变。</li><li>引用类型常量，不能改变常量指向的对象，可以改变对象的字段。</li><li>不以<code>;</code>作为语句结尾，scala编译器自动识别语句结尾。</li></ul><p>标识符命名规范：</p><ul><li>字母下划线开头，后跟字母数字下划线，和C/C++/Java一样。</li><li>操作符开头，且只包含(+-*/#!等)，也是有效的标识符。这样用会用什么奇怪的好处吗？答案是灵活到天顶星的运算符重载。</li><li>用反引号包括的任意字符串，即使是同39个Scala关键字同名也可以。有点奇怪的用法，尚不知道为什么。</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> _abc:<span class="hljs-type">String</span> = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">val</span> -+/%# = <span class="hljs-number">10</span><br><span class="hljs-keyword">val</span> `<span class="hljs-keyword">if</span>` = <span class="hljs-number">10</span><br>println(_abc)<br>println(-+/%#)<br>println(`<span class="hljs-keyword">if</span>`)<br></code></pre></div></td></tr></table></figure><p>关键字：</p><ul><li><code>package import class obejct trait extends with type for</code></li><li><code>private protected abstract sealed final implicit lazy override</code></li><li><code>try catch finlly throw</code></li><li><code>if else match case do while for return yield</code></li><li><code>def var val</code></li><li><code>this super</code></li><li><code>new</code></li><li><code>true false null</code></li><li>其中Java没有的关键字：<code>object trait with implicit match yield def val var</code></li></ul><p>字符串：</p><ul><li>类型：<code>String</code></li><li><code>+</code>号连接</li><li><code>*</code>字符串乘法，复制一个字符串多次</li><li><code>printf</code>格式化输出</li><li>字符串插值：<code>s&quot;xxx$&#123;varname&#125;&quot;</code>前缀<code>s</code>模板字符串，前缀<code>f</code>格式化模板字符串，通过<code>$</code>获取变量值，<code>%</code>后跟格式化字符串。</li><li>原始字符串：<code>raw&quot;rawstringcontents$&#123;var&#125;&quot;</code>，不会考虑后跟的格式化字符串。</li><li>多行字符串：<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>。</li><li>输出：<code>print printf println ...</code><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Pyrrha&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;Nikos&quot;</span><br><span class="hljs-keyword">val</span> age = <span class="hljs-number">17</span><br>println((name + <span class="hljs-string">&quot; &quot;</span>) * <span class="hljs-number">3</span>)<br>printf(<span class="hljs-string">&quot;%s : dead in %d\n&quot;</span>, name, age)<br>print(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span> : dead in <span class="hljs-subst">$&#123;age&#125;</span>&quot;</span>)<br><span class="hljs-keyword">val</span> power = <span class="hljs-number">98.9072</span><br>println(<span class="hljs-string">f&quot; : power <span class="hljs-subst">$&#123;power&#125;</span>%.2f.&quot;</span>)<br><br><span class="hljs-keyword">var</span> sql = <span class="hljs-string">s&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    |Select *</span><br><span class="hljs-string">    |from </span><br><span class="hljs-string">    |   Student</span><br><span class="hljs-string">    |Where</span><br><span class="hljs-string">    |   name = $&#123;name&#125;</span><br><span class="hljs-string">    |and</span><br><span class="hljs-string">    |   age &gt;= $&#123;age&#125;</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span>.stripMargin <span class="hljs-comment">// strip | and whitespaces before |</span><br>println(sql)<br></code></pre></div></td></tr></table></figure></li></ul><p>输入：</p><ul><li><code>StdIn.readLine()</code></li><li><code>StdIn.readShort() StdIn.readDouble</code></li><li><code>import scala.io.StdIn</code><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">println(<span class="hljs-string">&quot;input name:&quot;</span>)<br><span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-type">StdIn</span>.readLine()<br>println(<span class="hljs-string">&quot;input age:&quot;</span>)<br><span class="hljs-keyword">val</span> age:<span class="hljs-type">Int</span> = <span class="hljs-type">StdIn</span>.readInt()<br>println(name + <span class="hljs-string">&quot; : &quot;</span> + age)<br></code></pre></div></td></tr></table></figure></li></ul><p>读写文件：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">Source</span><br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">PrintWriter</span><br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">File</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FileIO</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> =&#123;<br>        <span class="hljs-comment">// read from file</span><br>        <span class="hljs-type">Source</span>.fromFile(<span class="hljs-string">&quot;FileIO.txt&quot;</span>).foreach(print)<br><br>        <span class="hljs-comment">// write to file</span><br>        <span class="hljs-comment">// call java API to write</span><br>        <span class="hljs-keyword">val</span> writer = <span class="hljs-keyword">new</span> <span class="hljs-type">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">File</span>(<span class="hljs-string">&quot;WFile.txt&quot;</span>))<br>        writer.write(<span class="hljs-string">&quot;Nephren!&quot;</span>)<br>        writer.close()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>数据类型：</p><ul><li>java基本类型<code>char byte short int long float double boolean</code>。</li><li>java基本类型对应包装类型：<code>Charater Byte Short Integer Long Float Double Boolean</code>。</li><li>java中不是纯粹的面向对象。</li><li>Scala吸取了这一点，所有数据都是对象，都是<code>Any</code>的子类。</li><li><code>Any</code>有两个子类：<code>AnyVal</code>值类型 <code>AnyRef</code>引用类型。</li><li>数值类型都是<code>AnyVal</code>子类，和Java数值包装类型都一样，只有整数在scala中是<code>Int</code>、字符是<code>Char</code>有点区别。</li><li><code>StringOps</code>是java中<code>String</code>类增强，<code>AnyVal</code>子类。</li><li><code>Unit</code>对应java中的<code>void</code>，<code>AnyVal</code>子类。用于方法返回值的位置，表示方法无返回值，<code>Unit</code>是一个类型，只有一个单例的对象，转成字符串打印出来为<code>()</code>。</li><li><code>Void</code>不是数据类型，只是一个关键字。</li><li><code>Null</code>是一个类型，只有一个单例对象<code>null</code>就是空引用，所有引用类型<code>AnyRef</code>的子类，这个类型主要用途是与其他JVM语言互操作，几乎不在Scala代码中使用。</li><li><code>Nothing</code>所有类型的子类型，也称为底部类型。它常见的用途是发出终止信号，例如抛出异常、程序退出或无限循环。</li></ul><p>整数类型：都是有符号整数，标准补码表示。</p><ul><li><code>Byte</code> 1字节</li><li><code>Short</code> 2字节</li><li><code>Int</code> 4字节</li><li><code>Long</code> 8字节</li><li>整数赋初值超出表示范围报错。</li><li>自动类型推断，整数字面值默认类型<code>Int</code>，长整型字面值必须加<code>L</code>后缀表示。</li><li>直接向下转换会失败，需要使用强制类型转换，<code>(a + 10).toByte</code>。</li></ul><p>浮点类型：</p><ul><li><code>Float</code> IEEE 754 32位浮点数</li><li><code>Double</code> IEEE 754 64位浮点数</li><li>字面值默认<code>Double</code></li></ul><p>字符类型：</p><ul><li>同java的<code>Character</code>，2字节，UTF-16编码的字符。</li><li>字符常量：<code>&#39;&#39;</code></li><li>类型<code>Char</code></li><li>转义：<code>\t \n \r \\ \&quot; \&#39;</code>etc</li></ul><p>布尔类型：<code>true false</code></p><p>空类型：</p><ul><li><code>Unit</code> 无值，只有一个实例，用于函数返回值。</li><li><code>Null</code> 只有一个实例<code>null</code>，空引用。</li><li><code>Nothing</code> 确定没有正常的返回值，可以用Nothing来指定返回值类型。好像意思是抛异常时返回Nothing，不是特别懂。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NullType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(arg : <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) : <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// Unit</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>            println(<span class="hljs-string">&quot;just nothing!&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">val</span> a = f1()<br>        println(a) <span class="hljs-comment">// ()</span><br><br>        <span class="hljs-comment">// null only used for AnyRef</span><br>        <span class="hljs-comment">// val n:Int = null // invalid</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>数据类型转换：</p><ul><li>自动类型提升：多种数据类型混合运算，自动提升到精度最大的数据类型。</li><li>高精度赋值到低精度，直接报错。</li><li>除了图中的隐式类型转换，都需要强制类型转换。</li><li><code>Byte Short Char</code>计算时会直接提升为<code>Int</code>。</li><li><code>Boolean</code>不能参与整数浮点运算，不能隐式转换为整数。<br><img src="Images/Scala_implicit_datatype_cast.jpg" alt="Scala中的数据类型转换"></li></ul><p>强制类型转换：</p><ul><li><code>toByte toInt toChar toXXXX</code></li><li><code>&#39;a&#39;.toInt</code> <code>2.7.toInt</code></li><li>数值与String的转换：<code>&quot;&quot; + n</code> <code>&quot;100&quot;.toInt</code> <code>&quot;12.3&quot;.toFloat</code> <code>12.3&quot;.toDouble.toInt</code></li><li>整数强转是二进制截取，整数高精度转低精度可能会溢出，比如<code>128.toByte</code>。</li></ul><p>Scala标准库：</p><ul><li><code>Int</code> <code>Double</code>这些数据类型对应于Java中的原始数据类型，在底层的运行时不是一个对象，但Scala提供了从这些类型到<code>scala.runtime.RichInt/RichDouble/...</code>的（低优先级）隐式类型转换（在<code>Perdef</code>中定义），从而提供了非原始类型具有的对象操作。</li><li>基本类型都是默认导入的，不需要显式导入，位于包<code>scala</code>中。还有<code>scala.Predef</code>对象也是自动导入。</li><li>其他需要导入的包：<ul><li><code>scala.collection</code>集合。</li><li><code>scala.collection.immutable</code>不可变数据结构，比如数组、列表、范围、哈希表、哈希集合。</li><li><code>scala.collection.mutable</code>可变数据结构，数组缓冲、字符串构建器、哈希表、哈希集合。</li><li><code>scala.collection.concurrent</code>可变并发数据结构，比如字典树。</li></ul></li><li><code>scala.concurrent</code>原始的并发编程。</li><li><code>scala.io</code>输入输出。</li><li><code>scala.math</code>基本数学操作。</li><li><code>scala.sys</code>操作系统交互。</li><li><code>scala.util.matching</code>正则。</li><li>标准库中的其他部分被放在独立的分开的库中。可能需要单独安装，包括：</li><li><code>scala.reflect</code>反射API。</li><li><code>scala.xml</code>xml解析、操作、序列化。</li><li><code>scala.collection.parallel</code>并行集合。</li><li><code>scala.util.parsing</code> parser的组合子，什么东西？</li><li><code>scala.swing</code>java的GUI框架Swing的封装。</li><li>定义了一些别名给常用的类，比如<code>List</code>是<code>scala.collection.immutable.List</code>的别名，也可以理解为默认导入？</li><li>其他别名可能是底层平台JVM提供的，比如<code>String</code>是<code>java.lang.String</code>的别名。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符：</p><ul><li>和Java基本相同。</li><li>算术运算：<code>+ - * / %</code> ，<code>+</code>可以用于一元正号，二元加号，还可以用作字符串加法，取模也可用于浮点数。没有自增和自减语法<code>++ --</code>。</li><li>关系运算：<code>== != &lt; &gt; &lt;= &gt;=</code></li><li>逻辑运算：<code>&amp;&amp; || !</code>， <code>&amp;&amp; ||</code>所有语言都支持短路求值，scala也不例外。</li><li>赋值运算：<code>= += -= *= /= %=</code></li><li>按位运算：<code>&amp; | ^ ~</code></li><li>移位运算：<code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code>，其中<code>&lt;&lt; &gt;&gt;</code>是有符号左移和右移，<code>&gt;&gt;&gt;</code>无符号右移。</li><li>scala中所有运算符本质都是对象的方法调用，拥有比C++更灵活的运算符重载。</li></ul><p>自定义运算符：</p><ul><li>Scala中运算符即是方法，任何具有单个参数的方法都可以用作<strong>中缀运算符</strong>，写作中缀表达式的写法。<code>10.+(1)</code>即是<code>10 + 1</code>。</li><li>定义时将合法的运算符（只有特殊符号构成的标识符）作为函数名称即可定义。</li></ul><p>运算符优先级：</p><ul><li>当一个表达式使用多个运算符时，将<strong>根据运算符的第一个字符来评估优先级</strong>。内置的运算符和自定义运算符都是函数，遵守同样的规则。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(characters not shown below)<br>* / %<br>+ -<br>:<br>= !<br>&lt; &gt;<br>&amp;<br>^<br>|<br>(all letters, $, _)<br></code></pre></div></td></tr></table></figure></li><li>比如下面两个表示等价：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">a + b ^? c ?^ d less a ==&gt; b | c<br>((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | c)<br></code></pre></div></td></tr></table></figure></li></ul><p>上面都是粗浅的理解，以下引用自<a href="https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#prefix-infix-and-postfix-operations">Scala2.13标准 - 06表达式 - 12前缀中缀和后缀操作</a>一节：</p><p>词法：<br><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">PostfixExpr     ::=  InfixExpr [id [nl]]<br>InfixExpr       ::=  PrefixExpr<br>                  |  InfixExpr id [nl] InfixExpr<br>PrefixExpr      ::=  [<span class="hljs-string">&#x27;-&#x27;</span> | <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;!&#x27;</span> | <span class="hljs-string">&#x27;~&#x27;</span>] SimpleExpr<br></code></pre></div></td></tr></table></figure></p><ul><li>可以看到前缀运算符只有<code>- + ! ~</code>含义是正负号、逻辑非、按位取反。</li><li>表达式是通过运算符和操作数构建的。</li></ul><p>前缀运算：</p><ul><li>仅有<code>+ - ! ~</code>，等价于后缀的方法调用<code>.+() .-() .!() .~()</code></li><li>前缀运算符的操作数是<strong>原子</strong>的，比如<code>-sin(x)</code>被解析为<code>-(sin(x))</code>。这不同于一般的函数，如果定义一个相同含义的<code>negate</code>函数，那么<code>negate sin(x)</code>会被解析为<code>sin</code>是操作符，而<code>negate</code>和<code>(x)</code>是它的操作数。</li></ul><p>后缀运算：</p><ul><li>后缀的运算符可以是任意的标识符，所有的<code>e op</code>被解释为<code>e.op</code>。原来还可以这样！</li></ul><p>中缀运算：</p><ul><li>一个中缀运算符可以是任意的标识符，中缀运算符</li><li>中缀运算符的优先级定义如下：递增顺序，优先级由运算符首字符确定，同一行拥有同等优先级。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(all letters, as defined in [chapter <span class="hljs-number">1</span>], including `_` and `$`)<br>|<br>^<br>&amp;<br>= !<br>&lt; &gt;<br>:<br>+ -<br>* / %<br>(other operator characters, as defined in [chapter <span class="hljs-number">1</span>], including <span class="hljs-type">Unicode</span> categories `<span class="hljs-type">Sm</span>` and `<span class="hljs-type">So</span>`)<br></code></pre></div></td></tr></table></figure></li><li>运算符的结合性由运算符的尾字符确定，以<code>:</code>结尾的字符为右结合，其他的都是左结合。后面的集合操作运算符中有例子。</li><li>优先级和结合性决定了一个表达式的语义，也即是它的组合方式。具体规则：<ul><li>多个中缀运算符同时出现，优先级更高的更显绑定到操作数。</li><li>如果有多个连续的同一优先级的中缀运算符（同一优先级结合性必定相同），那么按照结合性绑定，左结合从左往右，右结合从右往左。</li><li>后缀运算符总是比中缀运算符优先级更低。比如<code>e1 op1 e2 op2</code>总是解释为<code>(e1 op1 e2) op2</code>。</li></ul></li><li>中缀的左结合的运算符可能包含多个参数，<code>e op (e1, e2, ..., en)</code>总是被解释为<code>e.op(e1, e2, ..., en)</code>。</li><li>对于中缀表达式<code>e1 op e2</code>，如果<code>op</code>左结合那么被解释为<code>e1.op(e2)</code>，如果右结合并且是它的参数是传名参数那么被解释为<code>e2.op(e1)</code>，如果参数是值传递，那么解释为<code>&#123;val x = e2; e2.op(x)&#125;</code>，其中x是一个新名称。后面的集合操作有例子。</li><li>前面所说的前缀运算、后缀运算、中缀运算对应的运算符分别是一元前置运算符、一元后置运算符、二元后置运算符，不存在其他类型，比如三元的条件运算符。</li></ul><p>赋值运算符：</p><ul><li>赋值运算符是指以<code>=</code>结尾的运算符。除了同样以<code>=</code>开始，和<code>&gt;= &lt;= !=</code>之外。</li><li>赋值运算符在当其他的解释都非法时会有特殊对待。</li><li>比如说<code>l += r</code>，如果没有显式定义的<code>+=</code>运算符，那么会被解释为<code>l = l + r</code>。</li><li>这种重新解释发生在满足以下两个条件的情况下：<ul><li><code>l</code>没有<code>+=</code>运算符。</li><li><code>l = l + r</code>是类型正确的，通常情况下这意味着<code>l</code>是一个左值，并且<code>l + r</code>是合法的（定义了<code>+</code>或者可隐式转换为定义了<code>+</code>的类型）。</li></ul></li></ul><p>试验与总结：</p><ul><li>内置前缀运算符有<code>+ - ! ~</code>对少量内置类型提供支持，自定义一元前缀请使用<code>unary_</code>加上要定义的运算符名称，并且不要加参数列表<code>()</code>。而且这东西真的可以加参数列表，但我并没有找到用运算符形式调用的方式。</li><li>自定义一元后置运算符（即定义为空参数列表）需要引入<code>scala.language.postfixOps</code>才能使用后缀运算符形式调用。当然用函数调用形式调用总是没有语法问题的。同样去掉参数列表后就可以后置使用。</li><li>二元后置运算符，是最常用的自定义运算符。优先级上面有，结合性以是否<code>:</code>结尾确定。需要特别注意的是右结合和比如C++中重载赋值运算符是有区别的，需要了解。</li><li>Scala中内置的赋值运算符返回空<code>()</code>，所以其实是不能连续赋值的，赋值类运算符算是被特殊对待了。并且因为推崇函数式编程风格，能定义为<code>val</code>则定义为<code>val</code>也就不能连续赋值。因为变量都是引用变量，定义<code>=</code>变成了没有道理也不可能的一件事情，所以实践中也只能一条语句只做一次赋值。</li><li>Scala不能定义<code>=</code>运算符，但可以定义复合赋值，并且做了处理，某些情况下只要类设计得好定义了运算类运算符就不需要多去定义复合赋值了。所以说如果真要定义复合赋值返回值也应该返回<code>()</code>吗？也许是的。</li><li>多参数的方法其实也可以写成中缀形式，<code>e op (e1, e2, ..., en)</code>。</li><li>对于类方法来说，<strong>运算符是函数，函数也是运算符</strong>。</li></ul><p>例子：可窥见其灵活程度。<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.language.postfixOps<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserDefindOps</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> v = <span class="hljs-type">Vector2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">val</span> v2 = <span class="hljs-type">Vector2</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br><br>        println(v)<br>        <span class="hljs-comment">// prefix unary</span><br>        println(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        println(+v)<br>        println(-v)<br>        println(v.unary_-(<span class="hljs-string">&quot;hello&quot;</span>))<br><br>        <span class="hljs-comment">// binary</span><br>        println(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        println(v * <span class="hljs-number">3</span>)<br>        println(v * v2)<br>        println(v + v2)<br>        println(v - v2)<br>        <br>        <span class="hljs-comment">// postfix unary, just for test, no meaning</span><br>        println(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        println(v-)<br>        println((v-)-)<br><br>        <span class="hljs-comment">// multiple</span><br>        println(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        println(v hello (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>))<br>        println(v + (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br>        println(v - (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br><br>        <span class="hljs-comment">// assignment operator</span><br>        println(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        <span class="hljs-keyword">var</span> v3 = <span class="hljs-type">Vector2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br>        println(v3 *= <span class="hljs-number">3</span>) <span class="hljs-comment">// ()</span><br>        println(v3) <span class="hljs-comment">// Vector2(30.0, 15.0)</span><br>        v3 /= <span class="hljs-number">3</span><br>        println(v3)<br>        v3 += v2<br>        println(v3)<br>        v3 += (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        println(v3)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector2</span>(<span class="hljs-params">val x: <span class="hljs-type">Double</span>, val y: <span class="hljs-type">Double</span></span>) </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-string">s&quot;Vector2(<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&quot;</span><br>    <span class="hljs-comment">// prefix unary</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_-</span> </span>= <span class="hljs-keyword">this</span>.- <span class="hljs-comment">// call postfix -</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_+</span> </span>= <span class="hljs-type">Vector2</span>(x, y)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_-</span></span>(str: <span class="hljs-type">String</span>) = <span class="hljs-string">s&quot;unary - with a string parameter: <span class="hljs-subst">$str</span>&quot;</span> <span class="hljs-comment">// can not call this through operator format</span><br>    <span class="hljs-comment">// binary</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>(v: <span class="hljs-type">Vector2</span>) = <span class="hljs-type">Vector2</span>(x + v.x, y + v.y)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">-</span></span>(v: <span class="hljs-type">Vector2</span>) = <span class="hljs-type">Vector2</span>(x - v.x, y - v.y)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">*</span></span>(v: <span class="hljs-type">Vector2</span>) = x * v.x + y * v.y <span class="hljs-comment">// Inner product </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">*</span></span>(d: <span class="hljs-type">Double</span>) = <span class="hljs-type">Vector2</span>(d * x, d * y) <span class="hljs-comment">// multiply</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">/</span></span>(d: <span class="hljs-type">Double</span>) = <span class="hljs-type">Vector2</span>(x / d, y / d)<br>    <span class="hljs-comment">// postfix unary</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">-</span> </span>= <span class="hljs-type">Vector2</span>(-x, -y)<br>    <span class="hljs-comment">// multiple</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>) = <span class="hljs-string">s&quot;<span class="hljs-subst">$a</span>, <span class="hljs-subst">$b</span>, <span class="hljs-subst">$&#123;toString()&#125;</span>&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>(_x: <span class="hljs-type">Double</span>, _y: <span class="hljs-type">Double</span>): <span class="hljs-type">Vector2</span> = <span class="hljs-keyword">this</span> + <span class="hljs-type">Vector2</span>(_x, _y)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">-</span></span>(_x: <span class="hljs-type">Double</span>, _y: <span class="hljs-type">Double</span>): <span class="hljs-type">Vector2</span> = <span class="hljs-type">Vector2</span>(x - _x, y - _y)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Vector2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">Double</span>, y: <span class="hljs-type">Double</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Vector2</span>(x, y)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>实践指南：</p><ul><li>一元前缀和一元后缀运算符定义时不加参数列表，运算符形式使用。</li><li>在复杂表达式中使用一元前缀和后缀运算符使用时最好加括号表明优先级，不然在复杂表达式中编译器可能难以区分这是一元的还是二元的。至少定义了一元前置和后置<code>-</code>的类中无法像<code>a - -</code>和<code>- - a</code>这样来用。</li><li>二元运算符定义只给一个参数，运算符形式使用。</li><li>参数多于1个时不要通过运算符形式使用，但如果很清晰的话其实也无妨。</li><li>函数也是运算符，非特殊符号运算符形式使用也可以很有用，表达能力很强，比如<code>1 to 10</code>。</li><li>不要滥用，用到都搞不清谁是运算符谁是操作数就不好了。</li><li>经验尚浅，还需多实践。</li></ul><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><code>if-else</code>：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">if</span> (condition) &#123;<br>    xxx<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition) &#123;<br>    xxx<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    xxx<br>&#125;<br></code></pre></div></td></tr></table></figure></p><ul><li>scala中特殊一点，<code>if-else</code>语句也有返回值，也就是说也可以作为表达式，定义为执行的最后一个语句的返回值。</li><li>可以强制要求返回<code>Unit</code>类型，此时忽略最后一个表达式的值，得到<code>()</code>。</li><li>多种返回类型的话，赋值的目标变量类型需要指定为具体公共父类，也可以自动推断。</li><li>scala中没有三元条件运算符，可以用<code>if (a) b else c</code> 替代<code>a ? b : c</code>。</li><li>嵌套条件同理。</li></ul><p><code>for</code>循环，也叫<code>for</code>推导式：</p><ul><li>范围遍历：<code>for(i &lt;- 1 to 10) &#123;&#125;</code>，其中<code>1 to 10</code>是<code>Int</code>一个方法调用，返回一个<code>Range</code>。</li><li>范围<code>1 to 10</code> <code>1 until 10</code>是包含右边界和不包含右边界的范围，也可以直接用<code>Range</code>类。</li><li>范围步长<code>1 to 10 by 2</code>。</li><li>范围也是一个集合，也可以遍历普通集合：<code>for(i &lt;- collection) &#123;&#125;</code></li><li>循环守卫：即循环保护式，或者叫条件判断式，循环守卫为<code>true</code>则进入循环体内部，为<code>fasle</code>则跳过，类似于<code>continue</code>。<ul><li>写法：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(i &lt;- collection <span class="hljs-keyword">if</span> condition) &#123;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>等价于：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">if</span> (i &lt;- collection) &#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li>嵌套循环同理。嵌套循环可以将条件合并到一个<code>for</code>中：<ul><li>标准写法：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">for</span> (j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>            println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li>等价写法：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">4</span>; j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>        println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li>典型例子，乘法表：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">9</span>; j &lt;- <span class="hljs-number">1</span> to i) &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$j</span> * <span class="hljs-subst">$i</span> = <span class="hljs-subst">$&#123;i * j&#125;</span> \t&quot;</span>)<br>    <span class="hljs-keyword">if</span> (j == i) println()<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li>循环中的引入变量，但不是循环变量：  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>; j = <span class="hljs-number">10</span> - i) &#123;<br>    println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>循环条件也可以用<code>&#123;&#125;</code><ul><li>上面的引入变量循环等价于：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> &#123;<br>    i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span><br>    j = <span class="hljs-number">10</span> - i<br>&#125; &#123;<br>    println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li>循环同样有返回值，返回值都是空，也就是<code>Unit</code>实例<code>()</code>。</li><li>循环中同样可以用<code>yield</code>返回，外面可以接住用来操作，循环暂停，执行完后再继续循环。就像Ruby/Python。  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> v = <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) <span class="hljs-keyword">yield</span> i * i <span class="hljs-comment">// default implementation is Vector, Vector(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)</span><br></code></pre></div></td></tr></table></figure></li></ul><p><code>while</code>和<code>do while</code>：</p><ul><li>为了兼容java，不推荐使用，结果类型是<code>Unit</code>。</li><li>不可避免需要声明变量在循环外部，等同于循环内部对外部变量造成了影响，所以不推荐使用。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">while</span> (condition) &#123;<br>&#125;<br>do &#123;<br>&#125; <span class="hljs-keyword">while</span> (condition)<br></code></pre></div></td></tr></table></figure></li></ul><p>循环中断：</p><ul><li>Scala内置控制结构去掉了<code>break continue</code>关键字，为了更好适应函数式编程，推荐使用函数式风格解决。</li><li>使用<code>breakable</code>结构来实现<code>break continue</code>功能。</li><li>循环守卫可以一定程度上替代<code>continue</code>。</li><li>可以用抛出异常捕获的方式退出循环，替代<code>break</code>。  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> to <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span><br>        println(i)<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-type">Exception</span> =&gt; <span class="hljs-comment">// do nothing</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>可以使用Scala中的<code>Breaks</code>类中的<code>break</code>方法（只是封装了异常捕获），实现异常抛出和捕获。  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">Breaks</span><br><span class="hljs-type">Breaks</span>.breakable(<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> to <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>            <span class="hljs-type">Breaks</span>.<span class="hljs-keyword">break</span>()<br>        println(i)<br>    &#125;<br>)<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>不同范式对比：</p><ul><li>面向过程：按照步骤解决问题。</li><li>面向对象：分解对象、行为、属性，通过对象关系以及行为调用解决问题。耦合低，复用性高，可维护性强。</li><li>函数式编程：面向对象和面向过程都是命令式编程，但是函数式编程不关心具体运行过程，而是关心数据之间的映射。纯粹的函数式编程语言中没有变量，所有量都是常量，计算过程就是不停的表达式求值的过程，每一段程序都有返回值。不关心底层实现，对人来说更好理解，相对地编译器处理就比较复杂。</li><li>函数式编程优点：编程效率高，函数式编程的不可变性，对于函数特定输入输出是特定的，与环境上下文等无关。函数式编程无副作用，利于并行处理，所以Scala特别利于应用于大数据处理，比如Spark，Kafka框架。</li></ul><p>函数定义：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span></span>(arg1: <span class="hljs-type">TypeOfArg1</span>, arg2: ...): <span class="hljs-type">RetType</span> = &#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></p><ul><li>函数式编程语言中，函数是一等公民（可以像对象一样赋值、作为参数返回值），可以在任何代码块中定义函数。</li><li>一般将定义在类或对象中（最外层）的函数称为方法，而定义在方法中（内层）的称为函数。广义上都是函数。</li><li>返回值用<code>return</code>返回，不写的话会使用最后一行代码作为返回值。</li><li>无返回值<code>Unit</code>时可以用<code>return</code>可以用<code>return ()</code>可以不返回。</li><li>其他时候只需要返回值是返回值类型的子类对象就行。</li></ul><p>术语说明：</p><ul><li>java中不提函数的说法，而是说类或者实例方法，不涉及一般化的函数。</li><li>函数式编程中的函数二字来源于数学上的函数，也就是映射，集合和集合之间的关系，强调数据之间的映射关系。</li><li>而编程语言中的函数，也包括scala中的函数定义都是指的一个完成特定功能的子程序（subroutine），并不等同于数学意义上的函数。</li></ul><p>函数参数：</p><ul><li>可变参数，类似于Java，使用数组包装。<ul><li><code>def f4(str:String*): Unit = &#123;&#125;</code>。</li><li>如果除了可变参数还有其他参数，需要将可变参数放在末尾。</li><li>可变参数当做数组来使用。</li></ul></li><li>参数默认值:<ul><li><code>def f5(name: String = &quot;alice&quot;): Unit = &#123;&#125;</code></li><li>和C++一样，默认参数可以不传，默认参数必须全部放在末尾。</li></ul></li><li>带名称传参：<ul><li>调用时带名称。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f6</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>, loc: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;BeiJing&quot;</span>): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">s&quot;name <span class="hljs-subst">$&#123;name&#125;</span>, age <span class="hljs-subst">$&#123;age&#125;</span>, location <span class="hljs-subst">$&#123;loc&#125;</span>&quot;</span>)<br>&#125;<br>f6(<span class="hljs-string">&quot;Bob&quot;</span>)<br>f6(<span class="hljs-string">&quot;Alice&quot;</span>, loc = <span class="hljs-string">&quot;Xi&#x27;An&quot;</span>)<br>f6(<span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-number">30</span>)<br></code></pre></div></td></tr></table></figure></li><li>不给名称的就是按顺序赋值。</li><li>调用时带名参数必须位于实参列表末尾。</li><li>和默认参数一起使用会很方便，比如有多个默认参数，但只想覆盖其中一个。</li></ul></li></ul><p>函数至简原则：</p><ul><li>能省则省。</li><li>最后一行代码会作为返回值，可以省略<code>return</code>。</li><li>函数体只有一行代码的话，可以省略花括号。</li><li>如果返回值类型能够自动推断那么可以省略。</li><li>如果函数体中用<code>return</code>做返回，那么返回值类型必须指定。</li><li>如果声明返回<code>Unit</code>，那么函数体中使用<code>return</code>返回的值也不起作用。</li><li>如果期望是无返回值类型，那么可以省略<code>=</code>。这时候没有返回值，函数也可以叫做过程。【2.13.0已废弃，能编过不过会提示。】</li><li>无参函数如果声明时没有加<code>()</code>，调用时可以省略<code>()</code>。【如果声明时有<code>()</code>调用也可以省略，不过2.13.3废弃了。】</li><li>不关心函数名称时，函数名称和<code>def</code>也可以省略，去掉返回值类型，将<code>=</code>修改为<code>=&gt;</code>定义为匿名函数。  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> fun = (name: <span class="hljs-type">String</span>) =&gt; &#123; println(<span class="hljs-string">&quot;name&quot;</span>) &#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>匿名函数：</p><ul><li>没有名称的函数，可以被赋值给一个量。也叫lambda表达式</li><li><code>val fun = (name: String) =&gt; &#123; println(&quot;name&quot;) &#125;</code></li><li>匿名函数定义时不能有函数的返回值类型。</li><li>简化原则：<ul><li>参数的类型可以省略，如果可以根据高阶函数形参自动推导。</li><li>类型省略之后如果只有一个参数，那么可以省略参数列表的<code>()</code>，<code>name =&gt; println(name)</code>。</li><li>匿名函数函数体只要一行，那么<code>&#123;&#125;</code>可以省略。</li><li>如果参数只出现一次，则参数可以省略，后面出现的参数用<code>_</code>代替，<code>println(_)</code>也是一个lambda，表示<code>name =&gt; &#123;println(name)&#125;</code>。</li><li>如果可以推断出当前传入的<code>println</code>是一个函数体，而不是函数调用语句，那么可以省略下划线。也就是省略了转调，直接将函数名称作为参数传递。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(func: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = &#123;<br>    func(<span class="hljs-string">&quot;alice&quot;</span>)<br>&#125;<br>f((name: <span class="hljs-type">String</span>) =&gt; &#123; println(name) &#125;)<br>f((name) =&gt; println(name))<br>f(println(_))<br>f(println)<br></code></pre></div></td></tr></table></figure></li></ul></li><li>例子：省得太极端就没有可读性了。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dualOp</span></span>(func: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>&#125;<br>println(dualOp((a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) =&gt; a + b))<br>println(dualOp((a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) =&gt; a - b))<br>println(dualOp((a, b) =&gt; a - b))<br>println(dualOp(_ + _)) <span class="hljs-comment">// a + b</span><br>println(dualOp(-_ + _)) <span class="hljs-comment">// -a + b</span><br></code></pre></div></td></tr></table></figure></li></ul><p>高阶函数：</p><ul><li>三种形式：函数作为值传递、函数作为参数、函数作为返回值。</li><li>作为值传递：经过赋值之后在底层变成一个lambda对象。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// define function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    n + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-comment">// function assign to value, also a object</span><br><span class="hljs-keyword">val</span> func = foo _ <span class="hljs-comment">// represent the function foo, not function call</span><br><span class="hljs-keyword">val</span> func1: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = foo <span class="hljs-comment">// specify the type of func1</span><br>println(func) <span class="hljs-comment">// Main$$$Lambda$674/0x000000080103c588@770beef5</span><br>println(func == func1) <span class="hljs-comment">// false, not a same object</span><br></code></pre></div></td></tr></table></figure></li><li>函数作为参数，上面展示过了。可以传匿名函数、函数名称、lambda对象。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// function as arguments</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dualEval</span></span>(op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = &#123;<br>    op(a, b)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = a + b<br>println(dualEval(add, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>))<br><span class="hljs-keyword">val</span> mul:(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = _ * _<br>println(dualEval(mul, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>))<br>println(dualEval((a, b) =&gt; a + b, <span class="hljs-number">1000</span>, <span class="hljs-number">24</span>))<br></code></pre></div></td></tr></table></figure></li><li>函数作为返回值：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// function as return value</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outerFunc</span></span>(): <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span></span>(a: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;call inner with argument <span class="hljs-subst">$&#123;a&#125;</span>&quot;</span>)<br>    &#125;<br>    inner <span class="hljs-comment">// return a function</span><br>&#125;<br>println(outerFunc()(<span class="hljs-number">10</span>)) <span class="hljs-comment">// inner return ()</span><br></code></pre></div></td></tr></table></figure></li><li>现在就可以套娃了，比如定义一个返回一个返回函数的函数的函数。</li></ul><p>高阶函数举例：</p><ul><li>使用特定操作处理数组元素，得到新数组。也就是集合处理的map（映射）操作。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// deal with an array, get a new array</span><br><span class="hljs-comment">// map operation of array</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arrayOp</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">for</span> (elem &lt;- arr) <span class="hljs-keyword">yield</span> op(elem) <span class="hljs-comment">// the whole for expression get a new array</span><br>&#125;<br><span class="hljs-keyword">val</span> arr = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addOne</span></span>(elem: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = elem + <span class="hljs-number">1</span><br>println(arrayOp(arr, addOne _).mkString(<span class="hljs-string">&quot;, &quot;</span>)) <span class="hljs-comment">// pass addOne also work</span><br>println(arrayOp(arr, elem =&gt; elem * <span class="hljs-number">2</span>).mkString(<span class="hljs-string">&quot;, &quot;</span>))<br>println(arrayOp(arr, _ * <span class="hljs-number">3</span>).mkString(<span class="hljs-string">&quot;, &quot;</span>))<br></code></pre></div></td></tr></table></figure></li><li>套娃：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span></span>(a: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> =&gt; (<span class="hljs-type">Char</span> =&gt; <span class="hljs-type">Boolean</span>) = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Char</span> =&gt; <span class="hljs-type">Boolean</span> = &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(c: <span class="hljs-type">Char</span>): <span class="hljs-type">Boolean</span> = &#123; <br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == &#x27;<span class="hljs-number">0</span>&#x27;) <span class="hljs-literal">false</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">true</span><br>        &#125;<br>        f2<br>    &#125;<br>    f1<br>&#125;<br>println(func(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(&#x27;<span class="hljs-number">0</span>&#x27;)) <span class="hljs-comment">// false</span><br>println(func(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(&#x27;c&#x27;)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure></li><li>上面的例子经过极致简写：只能说类型推导也太强大了。<strong>内层函数可以使用外层函数的参数</strong>。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// simplify to anonymous function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span></span>(a: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> =&gt; (<span class="hljs-type">Char</span> =&gt; <span class="hljs-type">Boolean</span>) = &#123;<br>    s =&gt; c =&gt; !(a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == &#x27;<span class="hljs-number">0</span>&#x27;)<br>&#125;<br>println(func1(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(&#x27;<span class="hljs-number">0</span>&#x27;)) <span class="hljs-comment">// false</span><br>println(func1(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(&#x27;c&#x27;)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure></li><li>柯里化之后：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Currying </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span></span>(a: <span class="hljs-type">Int</span>)(s: <span class="hljs-type">String</span>)(c: <span class="hljs-type">Char</span>): <span class="hljs-type">Boolean</span> = !(a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == &#x27;<span class="hljs-number">0</span>&#x27;)<br>println(func2(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(&#x27;<span class="hljs-number">0</span>&#x27;)) <span class="hljs-comment">// false</span><br>println(func2(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(&#x27;c&#x27;)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure></li></ul><p><strong>函数柯里化</strong>和<strong>闭包</strong>：<strong>重点</strong>。</p><p>闭包：如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包。</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">闭包</a>)的定义：<blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a>的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。</p></blockquote></li><li>因为外层调用结束返回内层函数后，经过堆栈调整(比如在C中主调或者被调清理)，外层函数的参数已经被释放了，所以内层是获取不到外层的函数参数的。为了能够将环境（函数中用到的并非该函数参数的变量和他们的值）保存下来（需要考虑释放问题，可以通过GC可以通过对象生命周期控制，GC是一个常见选择），这时会将执行的环境打一个包保存到堆里面。</li></ul><p>函数<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>（Currying）：将一个参数列表的多个参数，变成多个参数列表的过程。也就是将普通多参数函数变成高阶函数的过程。</p><ul><li>定义：<blockquote><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。柯里化是一种处理函数中附有多个参数的方法，并在只允许单一参数的框架中使用这些函数。</p></blockquote></li><li>scala中的柯里化函数定义：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Currying </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>)(b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = a + b<br>println(add(<span class="hljs-number">4</span>)(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">val</span> addFour = add(<span class="hljs-number">4</span>) _<br><span class="hljs-comment">// val addFour: Int =&gt; int = add(4)</span><br>println(addFour(<span class="hljs-number">3</span>))<br></code></pre></div></td></tr></table></figure></li></ul><p>递归：</p><ul><li>太常见了，不用过多介绍。</li><li>方法调用自身。</li><li>递归要有结束逻辑。</li><li>调用自身时，传递参数要有规律。</li><li>scala中递归定义函数必须声明返回值类型，因为无法通过推导获得。</li><li>纯函数式语言比如Haskell，连循环都没有，很多操作都需要通过递归来做，性能比较依赖尾递归优化。</li><li>scala中的尾递归优化例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span></span>(n: <span class="hljs-type">Int</span>) : <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <br>    factorial(n<span class="hljs-number">-1</span>) * n<br>&#125;<br><span class="hljs-comment">// tail recusion implementation of factorial</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tailFact</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-meta">@annotation</span>.tailrec<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span></span>(n: <span class="hljs-type">Int</span>, curRes: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> curRes<br>        loop(n - <span class="hljs-number">1</span>, curRes * n)<br>    &#125;<br>    loop(n, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>控制抽象：</p><ul><li>值调用：按值传递参数，计算值后再传递。多数语言中一般函数调用都是这个方式，C++还存在引用传递。</li><li>名调用：按名称传递参数，直接用实参替换函数中使用形参的地方。能想到的只有C语言中的带参宏函数，其实并不是函数调用，预处理时直接替换。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// pass by value</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f0</span></span>(a: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;a: &quot;</span> + a)<br>    println(<span class="hljs-string">&quot;a: &quot;</span> + a)<br>&#125;<br>f0(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// pass by name, argument can be a code block that return to Int</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(a: =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;a: &quot;</span> + a)<br>    println(<span class="hljs-string">&quot;a: &quot;</span> + a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;call f2()&quot;</span>)<br>    <span class="hljs-number">10</span><br>&#125;<br>f1(<span class="hljs-number">10</span>)<br>f1(f2()) <span class="hljs-comment">// pass by name, just replace a with f2(), then will call f2() twice</span><br>f1(&#123;<br>    println(<span class="hljs-string">&quot;code block&quot;</span>) <span class="hljs-comment">// print twice</span><br>    <span class="hljs-number">30</span><br>&#125;)<br></code></pre></div></td></tr></table></figure></li><li>应用：使用传名参数实现一个函数相当于while的功能。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// built-in while</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$n</span> &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br>println()<br><br><span class="hljs-comment">// application: self-defined while, implement a function just like while keyword</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myWhile</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>): (=&gt; <span class="hljs-type">Unit</span>) =&gt; <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doLoop</span></span>(op: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">if</span> (condition) &#123;<br>            op<br>            myWhile(condition)(op)<br>        &#125;<br>    &#125;<br>    doLoop _<br>&#125;<br>n = <span class="hljs-number">10</span><br>myWhile (n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$n</span> &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br>println()<br><br><span class="hljs-comment">// simplfy</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myWhile2</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>): (=&gt; <span class="hljs-type">Unit</span>) =&gt; <span class="hljs-type">Unit</span> = &#123;<br>    op =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (condition) &#123;<br>            op<br>            myWhile2(condition)(op)<br>        &#125;<br>    &#125;<br>&#125;<br>n = <span class="hljs-number">10</span><br>myWhile (n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$n</span> &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br>println()<br><br><span class="hljs-comment">// use currying</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myWhile3</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>)(op: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        op<br>        myWhile3(condition)(op)<br>    &#125;<br>&#125;<br>n = <span class="hljs-number">10</span><br>myWhile3 (n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$n</span> &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br>println()<br></code></pre></div></td></tr></table></figure></li></ul><p>惰性加载：</p><ul><li>当函数返回值被声明为<code>lazy</code>时，函数的执行将会被推迟，知道我们首次对此取值，该函数才会被执行。这种函数成为惰性函数。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// just like pass by name</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> result: <span class="hljs-type">Int</span> = sum(<span class="hljs-number">13</span>, <span class="hljs-number">47</span>)<br>    println(<span class="hljs-string">&quot;before lazy load&quot;</span>)<br>    println(<span class="hljs-string">s&quot;result = <span class="hljs-subst">$&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment">// first call sum(13, 47)</span><br>    println(<span class="hljs-string">s&quot;result = <span class="hljs-subst">$&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment">// result has been evaluated</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;call sum&quot;</span>)<br>    a + b<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>有点像传名参数，但懒加载只是推迟求值到第一次使用时，而不是单纯替换。</li></ul><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>关于Scala面向对象：</p><ul><li>Scala的面向对象思想源自Java，很多概念是一致的。</li><li>语法和java不同，补充了更多功能。</li></ul><p>包：</p><ul><li><code>package name</code></li><li>作用：<ul><li>区分相同名字类，避免名称冲突。</li><li>类很多时，分模块管理。</li><li>访问权限控制。</li></ul></li><li>命名：包名称只能是常规的标识符（字母数字下划线，数字不能开头）。同样<code>.</code>作为不同层级分割符，整体作为包名。</li><li>命名规范：一般情况下按照如下规则命名<code>com.company.projectname.modulename</code>，视项目规定而定，只是一个名称而已。</li><li>scala中的两种包管理方式：<ul><li>第一种，java风格，每个源文件声明一个包，写在源文件最上方。但源文件位置不需要和包名目录层级一致，只代表逻辑层级关系，不像java一样源文件也必须按照包名目录层级关系放置。当然惯例是和java一样按照包名目录层级来放置。</li><li>第二种，用<code>&#123;&#125;</code>嵌套风格定义包：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br>    <span class="hljs-comment">// code in com package</span><br>    <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Outer</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Outer&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">package</span> inner &#123;<br>        <span class="hljs-comment">// code in com.inner package</span><br>        <span class="hljs-keyword">package</span> scala &#123;<br>            <span class="hljs-comment">// code in com.innner.scala package</span><br>            <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Inner</span> </span>&#123;<br>                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):<span class="hljs-type">Unit</span> = &#123;<br>                    println(<span class="hljs-type">Outer</span>.name)<br>                    <span class="hljs-type">Outer</span>.name = <span class="hljs-string">&quot;Inner&quot;</span><br>                    println(<span class="hljs-type">Outer</span>.name)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li>嵌套风格好处：<ul><li>一个源文件可以声明多个并列的最顶层的包。</li><li>子包中的类可以访问父包中的内容，无需导入。但外层是不能直接访问内层的，需要导入。</li></ul></li><li>如果单文件VsCode测试嵌套包，而不是用IDE的话，那定义了包就不能直接执行了，需要<code>scalac</code>先编译，并指定入口类运行。编译后的字节码文件和java一样会自动按照包层级关系排列。<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scalac PackageManagement.scala<br>scala com.inner.scala.Inner <br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>包对象：</p><ul><li>为scala包定义一个同名的单例包对象，定义在包对象中的成员，作为其对应包下的所有类和对象的共享变量，可以被直接访问，无需导入。</li><li>关键字<code>package object</code>，需要和包在同一层级下。比如为<code>com.inner</code>包定义包对象的话，必须在<code>com</code>包中，定义形式<code>package obejct inner &#123; ... &#125;</code>。</li></ul><p>包的导入：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> users._      <span class="hljs-comment">// 导入包 users 中的所有成员</span><br><span class="hljs-keyword">import</span> users.<span class="hljs-type">User</span>   <span class="hljs-comment">// 导入类 User</span><br><span class="hljs-keyword">import</span> users.&#123;<span class="hljs-type">User</span>, <span class="hljs-type">UserPreferences</span>&#125;      <span class="hljs-comment">// 仅导入选择的成员</span><br><span class="hljs-keyword">import</span> users.&#123;<span class="hljs-type">UserPreferences</span> =&gt; <span class="hljs-type">UPrefs</span>&#125;  <span class="hljs-comment">// 导入类并且设置别名</span><br><span class="hljs-keyword">import</span> users.&#123;<span class="hljs-type">User</span> =&gt; _, _&#125;               <span class="hljs-comment">// 导入出User类以外的所有users包中的内容</span><br></code></pre></div></td></tr></table></figure></p><ul><li>可以在任意位置导入（作用于代码块），可以设置别名，可以选择性导入想要导入的内容，可以屏蔽某个类。</li><li>所有scala源文件默认导入：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.lang._<br><span class="hljs-keyword">import</span> scala._<br><span class="hljs-keyword">import</span> scala.<span class="hljs-type">Predef</span>._<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类定义：</p><ul><li>回顾java中，如果是<code>public</code>向外公开的，那么必须和文件名一致，也只能有一个。不写访问修饰符则可以定义多个，包访问权限。</li><li>scala中没有<code>public</code>关键字，默认就是公有，不能加<code>public</code>，一个文件可以写多个类，不要求和文件名一致。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">[descriptor] <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classname</span> </span>&#123;<br>    <span class="hljs-comment">// body: fields &amp; methods</span><br>    [descriptor] <span class="hljs-keyword">var</span>/<span class="hljs-keyword">val</span> name: <span class="hljs-type">Type</span> = _<br>    [descriptor] method(args: <span class="hljs-type">ArgsType</span>): <span class="hljs-type">RetType</span> = &#123;<br>        <span class="hljs-comment">// method body</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>访问修饰符可以是：<code>private</code> <code>protected</code> <code>private [pacakgeName]</code>，默认就是公有，不需要加。</li><li>成员如果需要Java Bean规范的getter和setter的话可以加<code>@scala.beans.BeanProperty</code>相当于自动创建，不需要显式写出。</li><li>成员给初值<code>_</code>会赋默认值，scala中定义变量必须赋值，可以这样做。值类型的值0，引用则是<code>null</code>。定义常量的话不能用<code>_</code>，因为只能初始化一次，编译器会提示。</li></ul><p>封装：</p><ul><li>Java的封装：私有化，提供getter和setter。</li><li>scala中考虑到Java太冗余了，脱裤子放屁一样。scala中的公有属性，底层实际为<code>private</code>，并通过get方法<code>obj.field()</code>和set方法<code>obj.field_=(value)</code>对其进行操作。所以scala不推荐设置为<code>private</code>。如果需要和其他框架互操作，必须提供Java Bean规范的getter和setter的话可以加<code>@scala.beans.BeanProperty</code>注解。</li></ul><p>访问权限：</p><ul><li>Java中<code>private protected public</code>和默认包访问权限。</li><li>scala中属性和方法默认公有，并且不提供<code>public</code>关键字。</li><li><code>private</code>私有，类内部和伴生对象内可用。</li><li><code>protected</code>保护权限，scala中比java中严格，只有同类、子类可访问，同包无法访问。【因为java中说实话有点奇怪】</li><li><code>private [pacakgeName]</code>增加包访问权限，在包内可以访问。</li></ul><p>构造器：</p><ul><li>包括主构造器和辅助构造器。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> [descriptor] [([descriptor][val/var] <span class="hljs-title">arg1</span></span>: <span class="hljs-type">Arg1Type</span>, [descriptor][<span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span>] arg2: ...)] &#123; <span class="hljs-comment">// main constructor, only one, like record in java</span><br>    <span class="hljs-comment">// assist constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(argsList1) &#123;<br>        <span class="hljs-keyword">this</span>(args) <span class="hljs-comment">// call main constructor</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(argsList2) &#123; <span class="hljs-comment">// overload constrcutor</span><br>        <span class="hljs-keyword">this</span>(argsList1) <span class="hljs-comment">// can call main constructor or other constructor that call main constructor directly or indirectly</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Constructor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> p: <span class="hljs-type">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br>        p.<span class="hljs-type">Person</span>() <span class="hljs-comment">// call main constructor</span><br><br>        <span class="hljs-keyword">val</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;alice&quot;</span>)<br>        <span class="hljs-keyword">val</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">25</span>)<br>        p1.<span class="hljs-type">Person</span>()<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = _<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _<br>    println(<span class="hljs-string">&quot;call main construtor&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(name: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">this</span>()<br>        println(<span class="hljs-string">&quot;call assist constructor 1&quot;</span>)<br>        <span class="hljs-keyword">this</span>.name = name<br>        println(<span class="hljs-string">s&quot;Person: <span class="hljs-subst">$name</span> <span class="hljs-subst">$age</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">this</span>(name)<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;call assist constructor 2&quot;</span>)<br>        println(<span class="hljs-string">s&quot;Person: <span class="hljs-subst">$name</span> <span class="hljs-subst">$age</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// just a common method, not constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Person</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;call Person.Person() method&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>特点：<ul><li>主构造器写在类定义上，一定是构造时最先被调用的构造器，方法体就是类定义，可以在类中方法定义的同级编写逻辑，都是主构造器一部分，按顺序执行。</li><li>辅助构造器用<code>this</code>定义。</li><li>辅助构造器必须直接或者间接调用主构造器，调用其他构造必须位于第一行。</li><li>主构造器和辅助构造器是重载的方法，所以参数列表不能一致。</li><li>可以定义和类名同名方法，就是一个普通方法。</li></ul></li><li>主构造器中形参三种形式：不使用任何修饰，<code>var</code>修饰，<code>val</code>修饰。<ul><li>不使用任何修饰那就是一个形参，但此时在类内都可以访问到这个变量。逻辑上不是一个成员（报错信息这么写），但是可以访问，WTF？？？</li><li>使用<code>var val</code>修饰那就是定义为类成员，分别是变量和常量，不需要也不能在类内再定义一个同名字段。调用时传入参数就直接给到该成员，不需要再显式赋值。</li><li>主构造器中的<code>var val</code>成员也可以添加访问修饰符。</li><li>不加参数列表相当于为空，<code>()</code>可以省略。</li><li>主构造器的访问修饰符添加到参数列表<code>()</code>前。</li></ul></li><li>实践指南：<ul><li>推荐使用scala风格的主构造器<code>var val</code>修饰参数的编写方法，而不要被Java毒害！</li><li>如果需要多种重载的构造器那么就添加新的的辅助构造器。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">private var name: <span class="hljs-type">String</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _<br>    println(<span class="hljs-string">&quot;call main construtor&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>) = &#123;<br>        <span class="hljs-keyword">this</span>(name)<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;call assist constructor 2&quot;</span>)<br>        println(<span class="hljs-string">s&quot;Person: <span class="hljs-subst">$name</span> <span class="hljs-subst">$age</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// just a common method, not constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Person</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;call Person.Person() method&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>继承：</p><ul><li><code>class ChildClassName[(argList1)] extends BaseClassName[(args)] &#123; body &#125;</code></li><li>子类继承父类属性和方法。</li><li>可以调用父类构造器，但感觉好像很局限，子类中只可能调用到主构造或者辅助构造中的其中一个构造器。那如果父类有多种构造方式，子类想继承也没有办法？只能是其中一种。</li><li>不考虑太多负担，按照scala惯用写法来写起来还是挺轻松的。</li></ul><p>多态：</p><ul><li>java中属性静态绑定，根据变量的引用类型确定，方法是动态绑定。</li><li>但scala中<strong>属性和方法都是动态绑定</strong>。就属性而言，其实也不应该在子类和父类中定义同名字段。</li><li>同java一样，所有实例方法都是虚方法，都可以被子类覆写。</li><li><code>override</code>关键字覆写。</li><li>scala中<strong>属性（字段）也可以被重写</strong>，加<code>override</code>关键字。</li></ul><p>抽象类：</p><ul><li><code>abstract calss ClassName</code></li><li>抽象属性：<code>val/var name: Type</code>，不给定初始值。</li><li>抽象方法：<code>def methodName(): RetType</code>，只声明不实现。</li><li>子类如果没有覆写全部父类未定义的属性和方法，那么就必须定义为抽象类。老生常谈了。</li><li>重写非抽象方法属性必须加<code>override</code>，重写抽象方法则可以不加<code>override</code>。</li><li>子类调用父类中方法使用<code>super</code>关键字。</li><li>子类重写父类抽象属性，父类抽象属性可以用<code>var</code>修饰，<code>val var</code>都可以。因为父类没有实现嘛，需要到子类中来实现。</li><li>如果是<strong>重写非抽象属性</strong>，则父类非抽象属性只支持<code>val</code>，不支持<code>var</code>。因为<code>var</code>修饰为可变量，子类继承后可以直接使用修改，没有必要重写。<code>val</code>不可变才有必要重写。</li><li>实践建议是重写就加<code>override</code>，都是很自然的东西，理解就好，不必纠结于每一个细节。</li></ul><p>匿名子类；</p><ul><li>和java如出一辙。重写所有抽象字段和方法。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> p: baseClass = <span class="hljs-keyword">new</span> baseClass &#123;<br>    <span class="hljs-keyword">override</span> ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>伴生对象（Companion Object）：</p><ul><li>取代<code>static</code>语义。</li><li>编译后其实会生成两个类，伴生对象是伴生类（类名为对应类后加<code>$</code>符号）的单例对象。</li><li><code>obejct</code>，名称和类一致，必须放同一个文件，前面已经说过了。</li><li>常见用法：构造器私有化，用伴生对象中的工厂方法。和静态工厂方法使用起来也没有什么区别。</li><li>伴生对象实现<code>apply</code>方法后调用时可以省略<code>.apply</code>，直接使用<code>className(args)</code>。库中很多这种用法创建实例，是一个语法糖。</li><li>测试伴生对象时就在该对象内定义<code>main</code>函数编译时会出现的奇怪的访问权限问题。可能对包含入口的伴生对象做了特殊处理，具体细节尚不清楚。最好将<code>main</code>定义在单独的伴生对象内。</li></ul><p>Trait（特征/特质）：</p><ul><li>替代java接口的概念。但比接口更为灵活，一种实现多继承的手段。</li><li>多个类具有相同的特征时，就可以将这个特征提取出来，用继承的方式来复用。</li><li>用关键字<code>trait</code>声明。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">traitName</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>引入/混入(mixin)特征：<ul><li>有父类<code>class extends baseClass with trait1 with trait2 ... &#123;&#125;</code></li><li>没有父类<code>class extends trait1 with trait2 ... &#123;&#125;</code></li></ul></li><li>其中可以定义抽象和非抽象的属性和方法。</li><li>匿名子类也可以引入特征。</li><li>特征和基类或者多个特征中重名的属性或方法需要在子类中覆写以解决冲突，最后因为动态绑定，所有使用的地方都是子类的字段或方法。属性的话需要类型一致，不然提示不兼容。方法的话参数列表不一致会视为重载而不是冲突。</li><li>如果基类和特征中的属性或方法一个是抽象的，一个非抽象，且兼容，那么可以不覆写。很直观，就是不能冲突不能二义就行。</li><li>多个特征和基类定义了同名方法的，就需要在子类重写解决冲突。其中可以调用父类和特征的方法，此时<code>super.methodName</code>指代按照顺序最后一个拥有该方法定义的特征或基类。也可以用<code>super[baseClassOrTraitName].methodName</code>直接指代某个基类的方法，注意需要是直接基类，间接基类则不行。</li><li>也就是说基类和特征基本是同等地位。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Person&quot;</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;hello from : <span class="hljs-subst">$name</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Young</span> </span>&#123;<br>    <span class="hljs-comment">// abstract and non-abstract attribute</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;young&quot;</span><br><br>    <span class="hljs-comment">// method</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;young people <span class="hljs-subst">$name</span> is playing&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dating</span></span>(): <span class="hljs-type">Unit</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Knowledge</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> amount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        amount += <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Talent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;increase talent&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Young</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Knowledge</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Talent</span></span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;alice&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dating</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;Sutdent <span class="hljs-subst">$name</span> <span class="hljs-subst">$age</span> is dating&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span></span>(): <span class="hljs-type">Unit</span> = println(<span class="hljs-string">s&quot;Student <span class="hljs-subst">$name</span> is studying&quot;</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">super</span>.sayHi()<br>        println(<span class="hljs-string">s&quot;hello from : student <span class="hljs-subst">$name</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">super</span>.increase() <span class="hljs-comment">// call Talent.increase(), just the last</span><br>        println(<span class="hljs-string">s&quot;studnet <span class="hljs-subst">$name</span> knowledge increase: <span class="hljs-subst">$amount</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Trait</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> s = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>()<br>        s.sayHi()<br>        s.increase()<br><br>        s.study()<br>        s.increase()<br><br>        s.play()<br>        s.increase()<br><br>        s.dating()<br>        s.increase()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>特征的继承：<code>trait childTrait extends baseTrait</code></li><li>特征的<strong>菱形继承</strong>解决方式：转换为线性的继承链条，在前面的成为基类，后面的成为子类。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-string">&quot;ball&quot;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ColorBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;red&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = color + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">CategoryBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> category: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;foot&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = category + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-comment">// equals to MyFootBall -&gt; ColorBall -&gt; CategoryBall -&gt; Ball</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFootBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CategoryBall</span> <span class="hljs-keyword">with</span> <span class="hljs-title">ColorBall</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TraitInheritance</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFootBall</span>()<br>        println(b.describe()) <span class="hljs-comment">// red_foot_ball</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>其实特征的多继承和C++的多继承已经很像了，只是名称冲突的解决方式不一样，菱形继承的解决方式也不一样，而且不能访问间接基类。</li><li>scala<strong>单继承多实现</strong>，实现体现在特征上。基类主要用于一个对象比较核心比较本质的部分上。</li><li><strong>继承特征与类的区别</strong>：特征构造时不能给参数。其他都是同样的，都可以实现多态。</li></ul><p>自身类型（self type）：</p><ul><li>可实现<strong>依赖注入</strong>的功能。</li><li>一个类或者特征指定了自身类型的话，它的对象和子类对象就会拥有这个自身类型中的所有属性和方法。</li><li>是将一个类或者特征插入到另一个类或者特征中，属性和方法都就像直接复制插入过来一样，能直接使用。但不是继承，不能用多态。</li><li>语法，在类或特征中：<code>_: SelfType =&gt;</code>，其中<code>_</code>的位置是别名定义，也可以是其他，<code>_</code>指代<code>this</code>。插入后就可以用<code>this.xxx</code>来访问自身类型中的属性和方法了。</li><li>注入进来的目的是让你能够使用，可见，提前使用应该拥有的属性和方法。最终只要自身类型和注入目标类型同时被继承就能够得到定义了。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val password: <span class="hljs-type">String</span></span>)</span><br><span class="hljs-comment">// user database access object</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// dependency injection from external</span><br>    _: <span class="hljs-type">User</span> =&gt; <span class="hljs-comment">// self type</span><br>    <span class="hljs-comment">// simulate insert data to databse</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;insert into db: <span class="hljs-subst">$name</span> <span class="hljs-subst">$password</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// register user</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterUser</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, password</span>) <span class="hljs-keyword">with</span> <span class="hljs-title">UserDao</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SelfType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> u = <span class="hljs-keyword">new</span> <span class="hljs-type">RegisterUser</span>(<span class="hljs-string">&quot;catholly&quot;</span>, <span class="hljs-string">&quot;nephren&quot;</span>)<br>        u.insert()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>运行时类型识别RTTI：</p><ul><li>判断类型：<code>obj.isInstanceOf[T]</code>，确切匹配的类型或者父类都返回true。</li><li>转换类型：<code>obj.asInstance[T]</code>，转换为目标类型。</li><li>获取类名：<code>classOf[T]</code>，得到类对应的<code>Class</code>对象<code>Class[T]</code>，转字符串结果是<code>class package.xxx.className</code>。</li><li>获取对象的类：<code>obj.getClass</code></li></ul><p>枚举类：</p><ul><li>继承<code>Enumeration</code>。</li><li>用<code>Value</code>类型定义枚举值。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">WorkDay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">MONDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Monday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">TUESDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">THURSDAy</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Thrusday&quot;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">EnumClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">MONDAY</span>)<br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">TUESDAY</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>应用类：</p><ul><li>继承<code>App</code>，包装了<code>main</code>方法，就不需要显式定义<code>main</code>方法了，可以直接执行。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>    println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>定义类型别名：<code>type SelfDefineType = TargetType</code>。</p><p>密封类： <code>sealed</code>，子类只能定义在同一个文件内。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java集合：</p><ul><li>三大类型：列表<code>List</code>、集合<code>Set</code>、映射<code>Map</code>，有多种不同实现。</li></ul><p>Scala集合三大类型：</p><ul><li>序列<code>Seq</code>，集合<code>Set</code>，映射<code>Map</code>，所有集合都扩展自<code>Iterable</code>。</li><li>对于几乎所有集合类，都同时提供<strong>可变和不可变</strong>版本。<ul><li>不可变集合：<code>scala.collection.immutable</code></li><li>可变集合：<code>scala.collection.mutable</code></li><li>两个包中可能有同名的类型，需要注意区分是用的可变还是不可变版本，避免冲突和混淆。</li></ul></li><li>对于不可变集合，指该集合长度数量不可修改，每次修改（比如增删元素）都会返回一个新的对象，而不会修改源对象。</li><li>可变集合可以对源对象任意修改，一般也提供不可变集合相同的返回新对象的方法，但也可以用其他方法修改源对象。</li><li><strong>建议</strong>：操作集合时，不可变用操作符，可变用方法。操作符也不一定就会返回新对象，但大多是这样的，还是要具体看。</li><li>scala中集合类的定义比java要清晰不少。</li></ul><p>不可变集合：</p><ul><li><code>scala.collection.immutable</code>包中不可变集合关系一览：<br><img src="Images/Scala_immutable_collections_tree.jpg" alt="Scala_mutable_collections_tree"></li><li>不可变集合没有太多好说的，集合和映射的哈希表和二叉树实现是肯定都有的，序列中分为随机访问序列（数组实现）和线性序列（链表实现），基本数据结构都有了。</li><li><code>Range</code>是范围，常用来遍历，有语法糖支持<code>1 to 10 by 2</code> <code>10 until 1 by -1</code>其实就是隐式转换加上方法调用。</li><li>scala中的<code>String</code>就是<code>java.lang.String</code>，和集合无直接关系，所以是虚箭头，是通过<code>Perdef</code>中的低优先级隐式转换来做到的。经过隐式转换为一个包装类型后就可以当做集合了。</li><li><code>Array</code>和<code>String</code>类似，在图中漏掉了。</li><li>此类包装为了兼容java在scala中非常常见，scala中很多类型就是对java类型的包装或者仅仅是别名。</li><li>scala中可能会推荐更多地使用不可变集合。能用不可变就用不可变。</li></ul><p>可变集合：</p><ul><li><code>scala.collection.mutable</code>包中可变集合关系一览：<br><img src="Images/Scala_mutable_collections_tree.jpg" alt="Scala_mutable_collections_tree"></li><li>序列中多了<code>Buffer</code>，整体结构差不多。</li></ul><p>不可变和可变：</p><ul><li>不可变指的是对象大小不可变，但是可以修改元素的值（不能修改那创建了也没有用对吧），需要注意这一点。而如果用了<code>val</code>不变量存储，那么指向对象的地址也不可变。</li><li>不可变集合在原集合上个插入删除数据是做不到的，只能返回新的集合。</li></ul><p>泛型：</p><ul><li>集合类型大多都是支持泛型，使用泛型的语法是<code>[Type]</code>，不同于java的<code>&lt;Type&gt;</code>。</li></ul><p>不可变数组：</p><ul><li>访问元素使用<code>()</code>运算符，通过<code>apply/update</code>方法实现，源码中的实现只是抛出错误作为<strong>存根方法</strong>（stab method），具体逻辑由编译器填充。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 1. new</span><br><span class="hljs-keyword">val</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 2. factory method in companion obejct</span><br><span class="hljs-keyword">val</span> arr1 = <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">5</span>)<br><span class="hljs-keyword">val</span> arr2 = <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 3. traverse, range for</span><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> until arr.length) arr(i) = i<br><span class="hljs-keyword">for</span> (i &lt;- arr.indices) print(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;arr(i)&#125;</span> &quot;</span>)<br>println()<br><br><span class="hljs-comment">// 4. tarverse, foreach</span><br><span class="hljs-keyword">for</span> (elem &lt;- arr) print(<span class="hljs-string">s&quot;<span class="hljs-subst">$elem</span> &quot;</span>) <span class="hljs-comment">// elem is a val</span><br>println()<br><br><span class="hljs-comment">// 5. tarverse, use iterator</span><br><span class="hljs-keyword">val</span> iter = arr.iterator<br><span class="hljs-keyword">while</span> (iter.hasNext)<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;iter.next()&#125;</span> &quot;</span>)<br>println()<br><br><span class="hljs-comment">// 6. traverse, use foreach method, pass a function</span><br>arr.foreach((elem: <span class="hljs-type">Int</span>) =&gt; print(<span class="hljs-string">s&quot;<span class="hljs-subst">$elem</span> &quot;</span>))<br>println()<br><br>println(arr2.mkString(<span class="hljs-string">&quot;, &quot;</span>)) <span class="hljs-comment">// to string directly</span><br><br><span class="hljs-comment">// 7. add element, return a new array, : should toward to object</span><br><span class="hljs-keyword">val</span> newArr = arr :+ <span class="hljs-number">10</span> <span class="hljs-comment">//  arr.:+(10) add to end</span><br>println(newArr.mkString(<span class="hljs-string">&quot;, &quot;</span>))<br><span class="hljs-keyword">val</span> newArr2 = <span class="hljs-number">20</span> +: <span class="hljs-number">10</span> +: arr :+ <span class="hljs-number">30</span> <span class="hljs-comment">// arr.+:(10).+:(20).:+(30)</span><br>println(newArr2.mkString(<span class="hljs-string">&quot;, &quot;</span>))<br></code></pre></div></td></tr></table></figure></li><li>可以看到自定义运算符可以非常灵活，规定如果运算符首尾有<code>:</code>那么<code>:</code>一定要指向对象。</li><li>下标越界当然会抛出异常，使用前应该检查。</li><li>通过<code>Predef</code>中的隐式转换为一个混入了集合相关特征的包装类型从而得以使用scala的集合相关特征，<code>Array</code>类型中并没有相关混入。</li></ul><p>可变数组：</p><ul><li>类型<code>ArrayBuffer</code>。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 1. create</span><br><span class="hljs-keyword">val</span> arr: <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>]()<br><span class="hljs-keyword">val</span> arr1: <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br>println(arr.mkString(<span class="hljs-string">&quot;, &quot;</span>))<br>println(arr1) <span class="hljs-comment">// call toString ArrayBuffer(10, 20, 30)</span><br><br><span class="hljs-comment">// 2. visit</span><br>arr1(<span class="hljs-number">2</span>) = <span class="hljs-number">10</span><br><span class="hljs-comment">// 3. add element to tail</span><br><span class="hljs-keyword">var</span> newArr = arr :+ <span class="hljs-number">15</span> :+ <span class="hljs-number">20</span> <span class="hljs-comment">// do not change arr</span><br>println(newArr)<br>newArr = arr += <span class="hljs-number">15</span> <span class="hljs-comment">// modify arr itself, add to tail return itself, do notrecommand assign to other var</span><br>println(arr)<br>println(newArr == arr) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 4. add to head</span><br><span class="hljs-number">77</span> +=: arr <span class="hljs-comment">// WTF?</span><br>println(arr)<br><span class="hljs-comment">// 5. insert to middle</span><br>arr.insert(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>println(arr)<br><span class="hljs-comment">// 6. remove element</span><br>arr.remove(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// startIndex, count</span><br>println(arr)<br>arr -= <span class="hljs-number">15</span> <span class="hljs-comment">// remove specific element</span><br>println(arr)<br><span class="hljs-comment">// 7. convert to Array</span><br><span class="hljs-keyword">val</span> newImmuArr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = arr.toArray<br>println(newImmuArr.mkString(<span class="hljs-string">&quot;, &quot;</span>))<br><span class="hljs-comment">// 8. Array to ArryBuffer</span><br><span class="hljs-keyword">val</span> buffer: scala.collection.mutable.<span class="hljs-type">Buffer</span>[<span class="hljs-type">Int</span>] = newImmuArr.toBuffer<br>println(buffer)<br></code></pre></div></td></tr></table></figure></li><li>推荐：不可变集合用运算符，可变集合直接调用对应方法。运算符容易迷惑。</li><li>更多方法查看文档和源码用到去找就行。</li><li>可变数组和不可变数组可以调用方法互相转换。</li></ul><p>二维数组：</p><ul><li>就是数组的数组。</li><li>使用<code>Array.ofDim[Type](firstDim, secondDim, ...)</code>方法。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// create 2d array</span><br><span class="hljs-keyword">val</span> arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Int</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>arr(<span class="hljs-number">0</span>)(<span class="hljs-number">1</span>) = <span class="hljs-number">10</span><br>arr(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) = <span class="hljs-number">100</span><br> <br><span class="hljs-comment">// traverse</span><br>arr.foreach(v =&gt; println(v.mkString(<span class="hljs-string">&quot;,&quot;</span>)))<br></code></pre></div></td></tr></table></figure></li></ul><p>不可变列表：</p><ul><li><code>List</code>，抽象类，不能直接<code>new</code>，使用伴生对象<code>apply</code>传入元素创建。</li><li><code>List</code>本身也有<code>apply</code>能随机访问（做了优化），但是不能<code>update</code>更改。</li><li><code>foreach</code>方法遍历。</li><li>支持<code>+: :+</code>首尾添加元素。</li><li><code>Nil</code>空列表，<code>::</code>添加元素到表头。</li><li>常用<code>Nil.::(elem)</code>创建列表，换一种写法就是<code>10 :: 20 :: 30 :: Nil</code>得到结果<code>List(10, 20, 30)</code>，糖是真滴多！</li><li>合并两个列表：<code>list1 ::: list2</code> 或者<code>list1 ++ list2</code>。</li></ul><p>可变列表：</p><ul><li>可变列表<code>ListBuffer</code>，和<code>ArrayBuffer</code>很像。</li><li><code>final</code>的，可以直接<code>new</code>，也可以伴生对象<code>apply</code>传入元素创建（总体来说scala中更推荐这种方式）。</li><li>方法：<code>append prepend insert remove</code></li><li>添加元素到头或尾：<code>+=: +=</code></li><li>合并：<code>++</code>得到新的列表，<code>++=</code>合并到源上。</li><li>删除元素也可以用<code>-=</code>运算符。</li><li>具体操作很多，使用时阅读文档即可。</li></ul><p>不可变集合：</p><ul><li>数据无序，不可重复。</li><li>可变和不可变都叫<code>Set</code>，需要做区分。默认<code>Set</code>定义为<code>immutable.Set</code>别名。</li><li>创建时重复数据会被去除，可用来去重。</li><li>添加元素：<code>set + elem</code></li><li>合并：<code>set1 ++ set2</code></li><li>移除元素：<code>set - elem</code></li><li>不改变源集合。</li></ul><p>可变集合：</p><ul><li>操作基于源集合做更改。</li><li>为了与不可变集合区分，<code>import scala.collection.mutable</code>并用<code>mutable.Set</code>。</li><li>不可变集合有的都有。</li><li>添加元素到源上：<code>set += elem</code> <code>add</code></li><li>删除元素：<code>set -= elem</code> <code>remove</code></li><li>合并：<code>set1 ++= set2</code></li><li>都很简单很好理解，多看文档和源码就行。</li></ul><p>不可变映射：</p><ul><li><code>Map</code>默认就是<code>immutable.Map</code>别名。</li><li>两个泛型类型。</li><li>基本元素是一个二元组。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// create Map</span><br><span class="hljs-keyword">val</span> map: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">13</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>)<br>println(map)<br><span class="hljs-comment">// traverse</span><br>map.foreach((kv: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)) =&gt; println(kv))<br>map.foreach(kv =&gt; println(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;kv._1&#125;</span> : <span class="hljs-subst">$&#123;kv._2&#125;</span>&quot;</span>))<br><span class="hljs-comment">// get keys and values</span><br><span class="hljs-keyword">for</span> (key &lt;- map.keys) &#123;<br>    println(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;key&#125;</span> : <span class="hljs-subst">$&#123;map.get(key)&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// get value of given key</span><br>println(map.get(<span class="hljs-string">&quot;a&quot;</span>).get)<br>println(map.getOrElse(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">-1</span>)) <span class="hljs-comment">// avoid excption</span><br>println(map(<span class="hljs-string">&quot;a&quot;</span>)) <span class="hljs-comment">// if no such key will throw exception</span><br><span class="hljs-comment">// merge</span><br><span class="hljs-keyword">val</span> map2 = map ++ <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;e&quot;</span> -&gt; <span class="hljs-number">1024</span>)<br>println(map2)<br></code></pre></div></td></tr></table></figure></li></ul><p>可变映射：</p><ul><li><code>mutable.Map</code></li><li>不可变的都支持。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// create mutable Map</span><br><span class="hljs-keyword">val</span> map: mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = mutable.<span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>)<br><span class="hljs-comment">// add element</span><br>map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">30</span>)<br>map += ((<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">40</span>)) <span class="hljs-comment">// two () represent tuple to avoid ambiguity</span><br>println(map)<br><span class="hljs-comment">// remove element</span><br>map.remove(<span class="hljs-string">&quot;a&quot;</span>)<br>map -= <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-comment">// just need key</span><br>println(map)<br><span class="hljs-comment">// modify element</span><br>map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// call update, add/modify</span><br>println(map)<br><span class="hljs-comment">// merge Map</span><br>map ++= <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">30</span>) <span class="hljs-comment">// add and will override</span><br>println(map)<br></code></pre></div></td></tr></table></figure></li></ul><p>元组：</p><ul><li><code>(elem1, elem2, ...)</code> 类型可以不同。</li><li>最多只能22个元素，从<code>Tuple1</code>定义到了<code>Tuple22</code>。</li><li>使用<code>_1 _2 _3 ...</code>访问。</li><li>也可以使用<code>productElement(index)</code>访问，下标从0开始。</li><li><code>-&gt;</code>创建二元组。</li><li>遍历：<code>for(elem &lt;- tuple.productIterator)</code></li><li>可以嵌套，元组的元素也可以是元组。</li></ul><p>集合通用属性和方法：</p><ul><li>线性序列才有长度<code>length</code>、所有集合类型都有大小<code>size</code>。</li><li>遍历<code>for (elem &lt;- collection)</code>、迭代器<code>for (elem &lt;- collection.iterator)</code>。</li><li>生成字符串<code>toString</code> <code>mkString</code>，像<code>Array</code>这种是隐式转换为scala集合的，<code>toString</code>是继承自<code>java.lang.Object</code>的，需要自行处理。</li><li>是否包含元素<code>contains</code>。</li></ul><p>衍生集合的方式：</p><ul><li>获取集合的头元素<code>head</code>（元素）和剩下的尾<code>tail</code>（集合）。</li><li>集合最后一个元素<code>last</code>（元素）和除去最后一个元素的初始数据<code>init</code>（集合）。</li><li>反转<code>reverse</code>。</li><li>取前后n个元素<code>take(n) takeRight(n)</code></li><li>去掉前后n个元素<code>drop(n) dropRight(n)</code></li><li>交集<code>intersect</code></li><li>并集<code>union</code>，线性序列的话已废弃用<code>concat</code>连接。</li><li>差集<code>diff</code>，得到属于自己、不属于传入参数的部分。</li><li>拉链<code>zip</code>，得到两个集合对应位置元素组合起来构成二元组的集合，大小不匹配会丢掉其中一个集合不匹配的多余部分。</li><li>滑窗<code>sliding(n, step = 1)</code>，框住特定个数元素，方便移动和操作。得到迭代器，可以用来遍历，每个迭代的元素都是一个n个元素集合。步长大于1的话最后一个窗口元素数量可能个数会少一些。</li></ul><p>集合的简单计算操作：</p><ul><li>求和<code>sum</code> 求乘积<code>product</code> 最小值<code>min</code> 最大值<code>max</code></li><li><code>maxBy(func)</code>支持传入一个函数获取元素并返回比较依据的值，比如元组默认就只会判断第一个元素，要根据第二个元素判断就返回第二个元素就行<code>xxx.maxBy(_._2)</code>。</li><li>排序<code>sorted</code>，默认从小到大排序。从大到小排序<code>sorted(Ordering[Int].reverse)</code>。</li><li>按元素排序<code>sortBy(func)</code>，指定要用来做排序的字段。也可以再传一个隐式参数逆序<code>sortBy(func)(Ordering[Int].reverse)</code></li><li>自定义比较器<code>sortWith(cmp)</code>，比如按元素升序排列<code>sortWith((a, b) =&gt; a &lt; b)</code>或者<code>sortWith(_ &lt; _)</code>，按元组元素第二个元素升序<code>sortWith(_._2 &gt; _._2)</code>。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Calculations</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// calculations of collections</span><br>        <span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>        <br>        <span class="hljs-comment">// sum</span><br>        <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (elem &lt;- list) sum += elem<br>        println(sum)<br>        <br>        println(list.sum)<br>        println(list.product)<br>        println(list.min)<br>        println(list.max)<br><br>        <span class="hljs-keyword">val</span> list2 = <span class="hljs-type">List</span>((&#x27;a&#x27;, <span class="hljs-number">1</span>), (&#x27;b&#x27;, <span class="hljs-number">2</span>), (&#x27;d&#x27;, <span class="hljs-number">-3</span>))<br>        println(list2.maxBy((tuple: (<span class="hljs-type">Char</span>, <span class="hljs-type">Int</span>)) =&gt; tuple._2))<br>        println(list2.minBy(_._2))<br><br>        <span class="hljs-comment">// sort, default is ascending</span><br>        <span class="hljs-keyword">val</span> sortedList = list.sorted<br>        println(sortedList)<br>        <span class="hljs-comment">// descending</span><br>        println(list.sorted(<span class="hljs-type">Ordering</span>[<span class="hljs-type">Int</span>].reverse))<br><br>        <span class="hljs-comment">// sortBy</span><br>        println(list2.sortBy(_._2))<br><br>        <span class="hljs-comment">// sortWith</span><br>        println(list.sortWith((a, b) =&gt; a &lt; b))<br>        println(list2.sortWith(_._2 &gt; _._2))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>简单操作还是太少了，不足以应对复杂的需求。</li></ul><p>集合高级计算函数：</p><ul><li>大数据的处理核心就是映射（map）和规约（reduce）。</li><li>映射操作（广义上的map）：<ul><li>过滤：自定义过滤条件，<code>filter(Elem =&gt; Boolean)</code></li><li>转化/映射（狭义上的map）：自定义映射函数，<code>map(Elem =&gt; NewElem)</code></li><li>扁平化（flatten）：将集合中集合元素拆开，去掉里层集合，放到外层中来。<code>flatten</code></li><li>扁平化+映射：先映射，再扁平化，<code>flatMap(Elem =&gt; NewElem)</code></li><li>分组（group）：指定分组规则，<code>groupBy(Elem =&gt; Key)</code>得到一个Map，key根据传入的函数运用于集合元素得到，value是对应元素的序列。</li></ul></li><li>规约操作（广义的reduce）：<ul><li>简化/规约（狭义的reduce）：对所有数据做一个处理，规约得到一个结果（比如连加连乘操作）。<code>reduce((CurRes, NextElem) =&gt; NextRes)</code>，传入函数有两个参数，第一个参数是第一个元素（第一次运算）和上一轮结果（后面的计算），第二个是当前元素，得到本轮结果，最后一轮的结果就是最终结果。<code>reduce</code>调用<code>reduceLeft</code>从左往右，也可以<code>reduceRight</code>从右往左（实际上是递归调用，和一般意义上的从右往左有区别，看下面例子）。</li><li>折叠（fold）：<code>fold(InitialVal)((CurRes, Elem) =&gt; NextRes)</code>相对于<code>reduce</code>来说其实就是<code>fold</code>自己给初值，从第一个开始计算，<code>reduce</code>用第一个做初值，从第二个元素开始算。<code>fold</code>调用<code>foldLeft</code>，从右往左则用<code>foldRight</code>（翻转之后再<code>foldLeft</code>）。具体逻辑还得还源码。从右往左都有点绕和难以理解，如果要使用需要特别注意。</li></ul></li><li>以上：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HighLevelCalculations</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">111</span>)<br>        <br>        <span class="hljs-comment">// 1. map functions</span><br>        <span class="hljs-comment">// filter</span><br>        <span class="hljs-keyword">val</span> evenList = list.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        println(evenList)<br><br>        <span class="hljs-comment">// map</span><br>        println(list.map(_ * <span class="hljs-number">2</span>))<br>        println(list.map(x =&gt; x * x))<br><br>        <span class="hljs-comment">// flatten</span><br>        <span class="hljs-keyword">val</span> nestedList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">List</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), <span class="hljs-type">List</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>))<br>        <span class="hljs-keyword">val</span> flatList = nestedList(<span class="hljs-number">0</span>) ::: nestedList(<span class="hljs-number">1</span>) ::: nestedList(<span class="hljs-number">2</span>)<br>        println(flatList)<br><br>        <span class="hljs-keyword">val</span> flatList2 = nestedList.flatten<br>        println(flatList2) <span class="hljs-comment">// equals to flatList</span><br><br>        <span class="hljs-comment">// map and flatten</span><br>        <span class="hljs-comment">// example: change a string list into a word list</span><br>        <span class="hljs-keyword">val</span> strings: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-string">&quot;yes no&quot;</span>)<br>        <span class="hljs-keyword">val</span> splitList: <span class="hljs-type">List</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]] = strings.map(_.split(<span class="hljs-string">&quot; &quot;</span>)) <span class="hljs-comment">// divide string to words</span><br>        <span class="hljs-keyword">val</span> flattenList = splitList.flatten<br>        println(flattenList)<br><br>        <span class="hljs-comment">// merge two steps above into one</span><br>        <span class="hljs-comment">// first map then flatten</span><br>        <span class="hljs-keyword">val</span> flatMapList = strings.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>        println(flatMapList)<br><br>        <span class="hljs-comment">// divide elements into groups</span><br>        <span class="hljs-keyword">val</span> groupMap = list.groupBy(_ % <span class="hljs-number">2</span>) <span class="hljs-comment">// keys: 0 &amp; 1</span><br>        <span class="hljs-keyword">val</span> groupMap2 = list.groupBy(data =&gt; <span class="hljs-keyword">if</span> (data % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span>) <span class="hljs-comment">// keys : &quot;even&quot; &amp; &quot;odd&quot;</span><br>        println(groupMap)<br>        println(groupMap2)<br><br>        <span class="hljs-keyword">val</span> worldList = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;China&quot;</span>, <span class="hljs-string">&quot;America&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Curry&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>        println(worldList.groupBy(_.charAt(<span class="hljs-number">0</span>)))<br><br>        <span class="hljs-comment">// 2. reduce functions</span><br>        <span class="hljs-comment">// narrowly reduce</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduce(_ + _)) <span class="hljs-comment">// 1+2+3+4 = 10</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduceLeft(_ - _)) <span class="hljs-comment">// 1-2-3-4 = -8</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduceRight(_ - _)) <span class="hljs-comment">// 1-(2-(3-4)) = -2, a little confusing</span><br><br>        <span class="hljs-comment">// fold</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).fold(<span class="hljs-number">0</span>)(_ + _)) <span class="hljs-comment">// 0+1+2+3+4 = 10</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).fold(<span class="hljs-number">10</span>)(_ + _)) <span class="hljs-comment">// 10+1+2+3+4 = 20</span><br>        println(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).foldRight(<span class="hljs-number">10</span>)(_ - _)) <span class="hljs-comment">// 1-(2-(3-(4-10))) = 8, a little confusing</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>集合应用案例：</p><ul><li>Map的默认合并操作是用后面的同key元素覆盖前面的，如果要定制为累加他们的值可以用<code>fold</code>。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// merging two Map will override the value of the same key</span><br><span class="hljs-comment">// custom the merging process instead of just override</span><br><span class="hljs-keyword">val</span> map1 = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">4</span>)<br><span class="hljs-keyword">val</span> map2 = mutable.<span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">6</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">5</span>, <span class="hljs-string">&quot;d&quot;</span> -&gt; <span class="hljs-number">10</span>)<br><span class="hljs-keyword">val</span> map3 = map1.foldLeft(map2)(<br>    (mergedMap, kv) =&gt; &#123;<br>        mergedMap(kv._1) = mergedMap.getOrElse(kv._1, <span class="hljs-number">0</span>) + kv._2<br>        mergedMap<br>    &#125;<br>)<br>println(map3) <span class="hljs-comment">// HashMap(a -&gt; 7, b -&gt; 5, c -&gt; 9, d -&gt; 10)</span><br></code></pre></div></td></tr></table></figure></li><li>经典案例：单词计数：分词，计数，取排名前三结果。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// count words in string list, and get 3 highest frequency words</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordCount</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> stringList: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<br>        <span class="hljs-string">&quot;hello&quot;</span>,<br>        <span class="hljs-string">&quot;hello world&quot;</span>,<br>        <span class="hljs-string">&quot;hello scala&quot;</span>,<br>        <span class="hljs-string">&quot;hello spark from scala&quot;</span>,<br>        <span class="hljs-string">&quot;hello flink from scala&quot;</span><br>    )<br><br>    <span class="hljs-comment">// 1. split</span><br>    <span class="hljs-keyword">val</span> wordList: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = stringList.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>    println(wordList)<br><br>    <span class="hljs-comment">// 2. group same words</span><br>    <span class="hljs-keyword">val</span> groupMap: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]] = wordList.groupBy(word =&gt; word)<br>    println(groupMap)<br><br>    <span class="hljs-comment">// 3. get length of the every word, to (word, length)</span><br>    <span class="hljs-keyword">val</span> countMap: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = groupMap.map(kv =&gt; (kv._1, kv._2.length))<br><br>    <span class="hljs-comment">// 4. convert map to list, sort and take first 3</span><br>    <span class="hljs-keyword">val</span> countList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = countMap.toList<br>        .sortWith(_._2 &gt; _._2)<br>        .take(<span class="hljs-number">3</span>)<br><br>    println(countList) <span class="hljs-comment">// result</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>单词计数案例扩展，每个字符串都可能出现多次并且已经统计好出现次数，解决方式，先按次数合并之后再按照上述例子处理。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// strings has their frequency</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordCountAdvanced</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> tupleList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>(<br>        (<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">2</span>),<br>        (<span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-number">3</span>),<br>        (<span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello flink from scala&quot;</span>, <span class="hljs-number">2</span>)<br>    )<br><br>    <span class="hljs-keyword">val</span> newStringList: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = tupleList.map(<br>        kv =&gt; (kv._1.trim + <span class="hljs-string">&quot; &quot;</span>) * kv._2<br>    )<br><br>    <span class="hljs-comment">// just like wordCount</span><br>    <span class="hljs-keyword">val</span> wordCountList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = newStringList<br>        .flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>        .groupBy(word =&gt; word)<br>        .map(kv =&gt; (kv._1, kv._2.length))<br>        .toList<br>        .sortWith(_._2 &gt; _._2)<br>        .take(<span class="hljs-number">3</span>)<br><br>    println(wordCountList) <span class="hljs-comment">// result</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>当然这并不高效，更好的方式是利用上已经统计的频率信息。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordCountAdvanced2</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> tupleList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>(<br>        (<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">2</span>),<br>        (<span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-number">3</span>),<br>        (<span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello flink from scala&quot;</span>, <span class="hljs-number">2</span>)<br>    )<br><br>    <span class="hljs-comment">// first split based on the input frequency</span><br>    <span class="hljs-keyword">val</span> preCountList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = tupleList.flatMap(<br>        tuple =&gt; &#123;<br>            <span class="hljs-keyword">val</span> strings: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = tuple._1.split(<span class="hljs-string">&quot; &quot;</span>)<br>            strings.map(word =&gt; (word, tuple._2)) <span class="hljs-comment">// Array[(String, Int)]</span><br>        &#125;<br>    )<br><br>    <span class="hljs-comment">// group as words</span><br>    <span class="hljs-keyword">val</span> groupedMap: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)]] = preCountList.groupBy(_._1)<br>    println(groupedMap)<br><br>    <span class="hljs-comment">// count frequency of all words</span><br>    <span class="hljs-keyword">val</span> countMap: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = groupedMap.map(<br>        kv =&gt; (kv._1, kv._2.map(_._2).sum)<br>    )<br>    println(countMap)<br><br>    <span class="hljs-comment">// to list, sort and take first 3 words</span><br>    <span class="hljs-keyword">val</span> countList = countMap.toList.sortWith(_._2 &gt; _._2).take(<span class="hljs-number">3</span>)<br>    println(countList)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>队列：</p><ul><li>可变队列<code>mutable.Queue</code></li><li>入队<code>enqueue(Elem*)</code> 出队<code>Elem = dequeue()</code></li><li>不可变队列<code>immutable.Queue</code>，使用伴生对象创建，出队入队返回新队列。</li></ul><p>并行集合（Parllel Collection）：</p><ul><li>使用并行集合执行时会调用多个线程加速执行。</li><li>使用集合类前加一个<code>.par</code>方法。</li><li>具体细节待补。</li><li>依赖<code>scala.collection.parallel.immutable/mutable</code>，2.13版本后不再在标准库中提供，需要单独下载，暂未找到编好的jar的下载地址，从源码构造需要sbt，TODO。</li></ul><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><code>match-case</code>中的模式匹配：</p><ul><li>用于替代传统C/C++/Java的<code>switch-case</code>结构，但补充了更多功能，拥有更强的能力。</li><li>语法：（Java中现在也支持<code>=&gt;</code>的写法了）<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">value <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> caseVal1 =&gt; returnVal1<br>    <span class="hljs-keyword">case</span> caseVal2 =&gt; returnVal2<br>    ...<br>    <span class="hljs-keyword">case</span> _ =&gt; defaultVal<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>每一个case条件成立才返回，否则继续往下走。</li><li><code>case</code>匹配中可以添加模式守卫，用条件判断来代替精确匹配。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abs</span></span>(num: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span>= &#123;<br>    num <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> =&gt; i<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> =&gt; -i<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>模式匹配支持类型：所有类型字面量，包括字符串、字符、数字、布尔值、甚至数组列表等。</li><li>你甚至可以传入<code>Any</code>类型变量，匹配不同类型常量。</li><li>需要注意默认情况处理，<code>case _</code>也需要返回值，如果没有但是又没有匹配到，就抛出运行时错误。默认情况<code>case _</code>不强制要求通配符（只是在不需要变量的值建议这么做），也可以用<code>case abc</code>一个变量来接住，可以什么都不做，可以使用它的值。</li><li>通过指定匹配变量的类型（用特定类型变量接住），可以匹配类型而不匹配值，也可以混用。</li><li>需要注意类型匹配时由于泛型擦除，可能并不能严格匹配泛型的类型参数，编译器也会报警告。但<code>Array</code>是基本数据类型，对应于java的原生数组类型，能够匹配泛型类型参数。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// match type</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describeType</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> i: <span class="hljs-type">Int</span> =&gt; <span class="hljs-string">&quot;Int &quot;</span> + i<br>    <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; <span class="hljs-string">&quot;String &quot;</span> + s<br>    <span class="hljs-keyword">case</span> list: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] =&gt; <span class="hljs-string">&quot;List &quot;</span> + list<br>    <span class="hljs-keyword">case</span> array: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] =&gt; <span class="hljs-string">&quot;Array[Int] &quot;</span> + array<br>    <span class="hljs-keyword">case</span> a =&gt; <span class="hljs-string">&quot;Something else &quot;</span> + a <br>&#125;<br>println(describeType(<span class="hljs-number">20</span>)) <span class="hljs-comment">// match</span><br>println(describeType(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// match</span><br>println(describeType(<span class="hljs-type">List</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>))) <span class="hljs-comment">// match</span><br>println(describeType(<span class="hljs-type">List</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>))) <span class="hljs-comment">// match</span><br>println(describeType(<span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))) <span class="hljs-comment">// match</span><br>println(describeType(<span class="hljs-type">Array</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>))) <span class="hljs-comment">// not match</span><br>println(describeType((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))) <span class="hljs-comment">// not match</span><br></code></pre></div></td></tr></table></figure></li><li>对于数组可以定义多种匹配形式，可以定义模糊的元素类型匹配、元素数量匹配或者精确的某个数组元素值匹配，非常强大。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (arr &lt;- <span class="hljs-type">List</span>(<br>    <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>),<br>    <span class="hljs-type">Array</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>)<br>)) &#123;<br>    <span class="hljs-keyword">val</span> result = arr <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;0&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;Array(1, 0)&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) =&gt; <span class="hljs-string">s&quot;Array(<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&quot;</span> <span class="hljs-comment">// Array of two elements</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, _*) =&gt; <span class="hljs-string">s&quot;an array begin with 0&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x, <span class="hljs-number">1</span>, z) =&gt; <span class="hljs-string">s&quot;an array with three elements, no.2 is 1&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x:<span class="hljs-type">String</span>, _*) =&gt; <span class="hljs-string">s&quot;array that first element is a string&quot;</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;somthing else&quot;</span><br>    &#125;<br>    println(result)<br></code></pre></div></td></tr></table></figure></li><li><code>List</code>匹配和<code>Array</code>差不多，也很灵活。还可用用集合类灵活的运算符来匹配。<ul><li>比如使用<code>::</code>运算符匹配<code>first :: second :: rest</code>，将一个列表拆成三份，第一个第二个元素和剩余元素构成的列表。</li></ul></li><li>注意模式匹配不仅可以通过返回值当做表达式来用，也可以仅执行语句类似于传统<code>switch-case</code>语句不关心返回值，也可以既执行语句同时也返回。</li><li>元组匹配：<ul><li>可以匹配n元组、匹配元素类型、匹配元素值。如果只关心某个元素，其他就可以用通配符或变量。</li><li>元组大小固定，所以不能用<code>_*</code>。</li></ul></li></ul><p>变量声明匹配：</p><ul><li>变量声明也可以是一个模式匹配的过程。</li><li>元组常用于批量赋值。</li><li><code>val (x, y) = (10, &quot;hello&quot;)</code></li><li><code>val List(first, second, _*) = List(1, 3, 4, 5)</code></li><li><code>val List(first :: second :: rest) = List(1, 2, 3, 4)</code></li></ul><p><code>for</code>推导式中也可以进行模式匹配：</p><ul><li>元组中取元素时，必须用<code>_1 _2 ...</code>，可以用元组赋值将元素赋给变量，更清晰一些。</li><li><code>for ((first, second) &lt;- tupleList)</code></li><li><code>for ((first, _) &lt;- tupleList)</code></li><li>指定特定元素的值，可以实现类似于循环守卫的功能，相当于加一层筛选。比如<code>for ((10, second) &lt;- tupleList)</code></li><li>其他匹配也同样可以用，可以关注数量、值、类型等，相当于做了筛选。</li><li>元组列表匹配、赋值匹配、<code>for</code>循环中匹配非常灵活，灵活运用可以提高代码可读性。</li></ul><p>匹配对象：</p><ul><li>对象内容匹配。</li><li>直接<code>match-case</code>中匹配对应引用变量的话语法是有问题的。编译报错信息提示：不是样例类也没有一个合法的<code>unapply/unapplySeq</code>成员实现。</li><li>要匹配对象，需要实现伴生对象<code>unapply</code>方法，用来对对象属性进行拆解以做匹配。</li></ul><p>样例类：</p><ul><li>第二种实现对象匹配的方式是样例类。</li><li><code>case class className</code>定义样例类，会直接将打包<code>apply</code>和拆包<code>unapply</code>的方法直接定义好。</li><li>样例类定义中主构造参数列表中的<code>val</code>甚至都可以省略，如果是<code>var</code>的话则不能省略，最好加上的感觉，奇奇怪怪的各种边角简化。</li></ul><p>对象匹配和样例类例子：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MatchObject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">18</span>)<br><br>        <span class="hljs-keyword">val</span> result: <span class="hljs-type">String</span> = person <span class="hljs-keyword">match</span> &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">18</span>) =&gt; <span class="hljs-string">&quot;Person: Alice, 18&quot;</span><br>            <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;something else&quot;</span><br>        &#125;<br>        println(result)<br><br>        <span class="hljs-keyword">val</span> s = <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">18</span>)<br>        <span class="hljs-keyword">val</span> result2: <span class="hljs-type">String</span> = s <span class="hljs-keyword">match</span> &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">18</span>) =&gt; <span class="hljs-string">&quot;Student: Alice, 18&quot;</span><br>            <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;something else&quot;</span><br>        &#125;<br>        println(result2)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val age: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name, age)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>(person: <span class="hljs-type">Person</span>): <span class="hljs-type">Option</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = &#123;<br>        <span class="hljs-keyword">if</span> (person == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// avoid null reference</span><br>            <span class="hljs-type">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Some</span>((person.name, person.age))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) <span class="hljs-comment">// name and age are vals</span></span><br></code></pre></div></td></tr></table></figure></p><p>偏函数：</p><ul><li>偏函数是函数的一种，通过偏函数我们可以方便地对参数做更精确的检查，例如偏函数输入类型是<code>List[Int]</code>，需要第一个元素是0的集合，也可以通过模式匹配实现的。</li><li>定义：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> partialFuncName: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]] = &#123;<br>    <span class="hljs-keyword">case</span> x :: y :: _ =&gt; <span class="hljs-type">Some</span>(y)<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>通过一个变量定义方式定义，<code>PartialFunction</code>的泛型类型中，前者是参数类型，后者是返回值类型。函数体中用一个<code>case</code>语句来进行模式匹配。上面例子返回输入的<code>List</code>集合中的第二个元素。</li><li>一般一个偏函数只能处理输入的一部分场景，实际中往往需要定义多个偏函数用以组合使用。</li><li>例子：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PartialFunctionTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> list: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">100</span>), (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">5</span>))<br><br>        <span class="hljs-comment">// keep first constant and double second value of the tuple</span><br>        <span class="hljs-comment">// 1. use map</span><br>        <span class="hljs-keyword">val</span> newList = list.map(tuple =&gt; (tuple._1, tuple._2 * <span class="hljs-number">2</span>))<br>        println(newList)<br><br>        <span class="hljs-comment">// 2. pattern matching</span><br>        <span class="hljs-keyword">val</span> newList1 = list.map(<br>            tuple =&gt; &#123;<br>                tuple <span class="hljs-keyword">match</span> &#123;<br>                    <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>)<br>                &#125;<br>            &#125;<br>        )<br>        println(newList1)<br><br>        <span class="hljs-comment">// simplify to partial function</span><br>        <span class="hljs-keyword">val</span> newList2 = list.map &#123;<br>            <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>) <span class="hljs-comment">// this is a partial function</span><br>        &#125;<br>        println(newList2)<br><br>        <span class="hljs-comment">// application of partial function</span><br>        <span class="hljs-comment">// get absolute value, deal with: negative, 0, positive</span><br>        <span class="hljs-keyword">val</span> positiveAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> =&gt; x<br>        &#125;<br>        <span class="hljs-keyword">val</span> negativeAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> =&gt; -x<br>        &#125;<br>        <span class="hljs-keyword">val</span> zeroAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span><br>        &#125;<br><br>        <span class="hljs-comment">// combine a function with three partial functions</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abs</span></span>(x: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = (positiveAbs orElse negativeAbs orElse zeroAbs) (x)<br>        println(abs(<span class="hljs-number">-13</span>))<br>        println(abs(<span class="hljs-number">30</span>))<br>        println(abs(<span class="hljs-number">0</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2></li></ul><p>scala异常处理整体上的语法和底层处理细节和java非常类似。</p><p>Java异常处理：</p><ul><li>用<code>try</code>语句包围要捕获异常的块，多个不同<code>catch</code>块用于捕获不同的异常，<code>finally</code>块中是捕获异常与否都会执行的逻辑。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> c = a / b;<br>&#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>scala异常处理：</p><ul><li><code>try</code>包围要捕获异常的内容，<code>catch</code>仅仅是关键字，将捕获异常的所有逻辑包围在<code>catch</code>块中。<code>finally</code>块和java一样都会执行，一般用于对象的清理工作。</li><li>scala中没有编译期异常，所有异常都是运行时处理。</li><li>scala中也是用<code>throw</code>关键字抛出异常，所有异常都是<code>Throwable</code>的子类，<code>throw</code>表达式是有类型的，就是<code>Nothing</code>。<code>Nothing</code>主要用在一个函数总是不能正常工作，总是抛出异常的时候用作返回值类型。</li><li>java中用了<code>throws</code>关键字声明此方法可能引发的异常信息，在scala中对应地使用<code>@throws[ExceptionList]</code>注解来声明，用法差不多。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Exceptionstest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// test of exceptions</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> n = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-keyword">case</span> e: <span class="hljs-type">ArithmeticException</span> =&gt; &#123;<br>                println(<span class="hljs-string">s&quot;ArithmeticException raised.&quot;</span>)<br>            &#125;<br>            <span class="hljs-keyword">case</span> e: <span class="hljs-type">Exception</span> =&gt; &#123;<br>                println(<span class="hljs-string">&quot;Normal Exceptions raised.&quot;</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            println(<span class="hljs-string">&quot;finally&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>前面说了很多了，编译器做隐式转换的时机：</p><ul><li>编译器第一次编译失败时，会在当前环境中查找能让代码编译通过的方法，将类型隐式转换，尝试二次编译。</li></ul><p>隐式函数：</p><ul><li>函数定义前加上<code>implicit</code>声明为隐式转换函数。</li><li>当编译错误时，编译器会尝试在当前作用域范围查找能调用对应功能的转换规则，这个过程由编译器完成，称之为隐式转换或者自动转换。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// convert Int to MyRichInt</span><br><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span></span>(arg: <span class="hljs-type">Int</span>): <span class="hljs-type">MyRichInt</span> = &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">MyRickInt</span>(arg)<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>在当前作用域定义时需要在使用前定义才能找到。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span>  <span class="hljs-title">ImplicitConversion</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span></span>(num: <span class="hljs-type">Int</span>): <span class="hljs-type">MyRichInt</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">MyRichInt</span>(num)<br><br>        println(<span class="hljs-number">12.</span>myMax(<span class="hljs-number">15</span>)) <span class="hljs-comment">// will call convert implicitly</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRichInt</span>(<span class="hljs-params">val self: <span class="hljs-type">Int</span></span>) </span>&#123;<br>    <span class="hljs-comment">// self define compare method</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMax</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &lt; self) self <span class="hljs-keyword">else</span> n<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMin</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &gt; self) self <span class="hljs-keyword">else</span> n<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>隐式参数：</p><ul><li>普通方法或者函数中的参数可以通过<code>implicit</code>关键字声明为隐式参数，调用方法时，如果传入了，那么以传入参数为准。如果没有传入，编译器会在当前作用域寻找复合条件的隐式值。例子：集合排序方法的排序规则就是隐式参数。</li><li>隐式值：<ul><li>同一个作用域，相同类型隐式值只能有一个。</li><li>编译器按照隐式参数的类型去寻找对应隐式值，与隐式值名称无关。</li><li>隐式参数优先于默认参数。（也就是说隐式参数和默认参数可以同时存在，加上默认参数之后其实就相当于两个不同优先级的默认参数）</li></ul></li><li>隐式参数有一个很淦的点：<ul><li>如果参数列表中只有一个隐式参数，无论这个隐式参数是否提供默认参数，那么如果要用这个隐式参数就应该<strong>将调用隐式参数的参数列表连同括号一起省略掉</strong>。如果调用时又想加括号可以在函数定义的隐式参数列表前加一个空参数列表<code>()</code>，那么<code>()</code>将使用隐式参数，<code>()()</code>将使用默认参数（如果有，没有肯定编不过），<code>()(arg)</code>使用传入参数。</li><li>也就是说一个隐式参数时通过是否加括号可以区分隐式参数、默认参数、传入参数三种情况。</li><li>那么如果多参数情况下：隐式参数、默认参数、普通参数排列组合在一个参数列表中混用会怎么样呢？没有试验过，不要这么用，思考这些东西搞什么哦！</li><li>具体要不要加这个柯里化的空参数列表，那看习惯就行。不加可能更好一点，加了可能有点让人费解。</li></ul></li><li>可以进一步简写隐式参数，在参数列表中直接去掉，在函数中直接使用<code>implicity[Type]</code>（<code>Predef</code>中定义的）。但这时就不能传参数了，有什么用啊？相当于一个在自己作用域范围内起作用的全局量？<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ImplicitArgments</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> str: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Alice from implicit argument&quot;</span><br>        <br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>()(<span class="hljs-keyword">implicit</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Alice from default argument&quot;</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(<span class="hljs-string">s&quot;hello <span class="hljs-subst">$name</span>&quot;</span>)<br>        &#125;<br><br>        sayHello() <span class="hljs-comment">// implicit</span><br>        sayHello()() <span class="hljs-comment">// default</span><br>        sayHello()(<span class="hljs-string">&quot;Alice from normal argument&quot;</span>) <span class="hljs-comment">// normal</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(<span class="hljs-keyword">implicit</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Alice from default argument&quot;</span>): <span class="hljs-type">Unit</span> = &#123;<br>            println(<span class="hljs-string">s&quot;hi <span class="hljs-subst">$name</span>&quot;</span>)<br>        &#125;<br><br>        sayHi <span class="hljs-comment">// implicit</span><br>        sayHi() <span class="hljs-comment">// default</span><br>        sayHi(<span class="hljs-string">&quot;Alice from normal argument&quot;</span>) <span class="hljs-comment">// normal</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayBye</span></span>() = &#123;<br>            println(<span class="hljs-string">s&quot;bye <span class="hljs-subst">$&#123;implicitly[String]&#125;</span>&quot;</span>)<br>        &#125;<br><br>        sayBye()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>隐式类：</p><ul><li>scala2.10之后提供了隐式类，使用<code>implicit</code>声明为隐式类。将类的构造方法声明为隐式转换函数。</li><li>也就是说如果编译通不过，就可能将数据直接传给构造转换为对应的类。</li><li>隐式函数的一个扩展。</li><li>说明：<ul><li>所带构造参数有且只能有一个。</li><li>隐式类必须被定义在类或者伴生对象或者包对象中，隐式类不能是顶层的。</li></ul></li><li>同一个作用域定义隐式转换函数和隐式类会冲突，定义一个就行。</li></ul><p>隐式解析机制的作用域：</p><ul><li>首先在<strong>当前代码作用域下</strong>查找隐式实体（隐式方法、隐式类、隐式对象）。</li><li>如果第一条规查找隐式对象失败，会继续在<strong>隐式参数的类型的作用域</strong>中查找。</li><li>类型的作用域是指该类型相关联的全部伴生对象以及该类型所在包的包对象。</li></ul><p>作用：</p><ul><li>隐式函数和隐式类可以用于扩充类的功能，常用语比如内建类<code>Int Double String</code>这种。</li><li>隐式参数相当于就是一种更高优先级的默认参数。用于多个函数需要同一个默认参数时，就不用每个函数定义时都写一次默认值了。为了简洁无所不用其极啊真是。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型：</p><ul><li><code>[TypeList]</code>，定义和使用都是。</li><li>常用于集合类型中用于支持不同元素类型。</li><li>和java一样通过类型擦除/擦拭法来实现。</li><li>定义时可以用<code>+-</code>表示协变和逆变，不加则是不变。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[+<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 协变</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[-<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 逆变</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 不变</span><br></code></pre></div></td></tr></table></figure></li></ul><p>协变和逆变：</p><ul><li>比如<code>Son</code>和<code>Father</code>是父子关系，<code>Son</code>是子类。<ul><li>协变（Covariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的子类，协同变化。</li><li>逆变（Contravariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的父类，逆向变化。</li><li>不变（Invariant）：<code>MyList[Father] MyList[Son]</code>没有父子关系。</li></ul></li><li>还需要深入了解。</li></ul><p>泛型上下限：</p><ul><li>泛型上限：<code>class MyList[T &lt;: Type]</code>，可以传入<code>Type</code>自身或者子类。</li><li>泛型下限：<code>class MyList[T &gt;: Type]</code>，可以传入<code>Type</code>自身或者父类。</li><li>对传入的泛型进行限定。</li></ul><p>上下文限定：</p><ul><li><code>def f[A : B](a: A) = println(a)</code>等同于<code>def f[A](a: A)(implicit arg: B[A])</code></li><li>是将泛型和隐式转换结合的产物，使用上下文限定（前者）后，方法内无法使用隐式参数名调用隐式参数，需要通过<code>implicitly[Ordering[A]]</code>获取隐式变量。</li><li>了解即可，可能基本不会用到。</li></ul><h2 id="Style-Guide"><a href="#Style-Guide" class="headerlink" title="Style Guide"></a>Style Guide</h2><p><a href="https://docs.scala-lang.org/style/index.html">官方的Style Guide</a>中的一些建议：</p><ul><li>缩进鼓励为2个，当然我上面都是用的4个。Scala中很多时候嵌套层次会很深，也鼓励这样做，模式匹配、匿名函数、循环、条件等各种嵌套，层次深了之后4空格可能会比较折磨。</li><li>一个表达式一行放不下要换行时，语义上不会产生歧义就行，比如一个运算符放在末尾将其必需的操作数换到下一行。</li><li>多参数函数调用需要换行书写时，将第一个参数放到第二行并缩进2个空格书写，而不是第一个参数放到第一行，然后缩进到对齐（典型java风格）。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// right!</span><br><span class="hljs-keyword">val</span> myLongFieldNameWithNoRealPoint =<br>  foo(<br>    someVeryLongFieldName,<br>    andAnotherVeryLongFieldName,<br>    <span class="hljs-string">&quot;this is a string&quot;</span>,<br>    <span class="hljs-number">3.1415</span>)<br><br><span class="hljs-comment">// wrong!</span><br><span class="hljs-keyword">val</span> myLongFieldNameWithNoRealPoint = foo(someVeryLongFieldName,<br>                                         andAnotherVeryLongFieldName,<br>                                         <span class="hljs-string">&quot;this is a string&quot;</span>,<br>                                         <span class="hljs-number">3.1415</span>)<br></code></pre></div></td></tr></table></figure></li><li>仅介绍第一页的内容，也没有空去看完，以后真写得多了再去看。</li></ul><h2 id="sbt"><a href="#sbt" class="headerlink" title="sbt"></a>sbt</h2><p>上面已经简单介绍了IDEA使用Maven项目编写Scala的配置，但学习scala，官方的构建工具sbt还是必须要了解一下的。</p><p>关于SBT：</p><ul><li>SBT是Scala的构建工具，全称Simple Build Tool，类似于 Maven 或 Gradle。</li><li><a href="https://docs.scala-lang.org/getting-started/sbt-track/getting-started-with-scala-and-sbt-on-the-command-line.html">GETTING STARTED WITH SCALA AND SBT ON THE COMMAND LINE</a></li><li><a href="https://www.scala-sbt.org/1.x/docs/index.html">sbt Reference Manual</a> 要使用sbt，阅读完第一章Getting Started with sbt是必要的。下面的内容皆是第一章翻译。</li></ul><p>特性：</p><ul><li>简单项目零配置。</li><li>用Scala源码管理项目构建。</li><li>精确的重编译，节省时间。</li><li>使用Coursier的库管理器。</li><li>支持Scala和Java的混合项目。</li><li>等等等，具体就不列了，总之一个大型项目构建系统该有的东西。</li></ul><p>安装：</p><ul><li>sbt依赖Java，确保已经安装了JDK1.8或以上版本。</li><li>下载压缩包或者安装包，这里的版本是1.5.5。</li><li>解压或者安装。</li><li>配置环境变量<code>SBT_HOME</code>，并添加<code>%SBT_HOME%\bin</code>到path环境变量，安装包的话会自动配置。</li></ul><h3 id="通过案例入门sbt"><a href="#通过案例入门sbt" class="headerlink" title="通过案例入门sbt"></a>通过案例入门sbt</h3><p>创建一个项目hello作为例子：</p><ul><li>windows上没有的命令按照含义操作即可。<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir foo-build</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> foo-build</span><br><span class="hljs-meta">$</span><span class="bash"> touch build.sbt</span><br></code></pre></div></td></tr></table></figure></li></ul><p>开始sbt shell：<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sbt</span><br>[info] Updated file /tmp/foo-build/project/build.properties: set sbt.version to 1.1.4<br>[info] Loading project definition from /tmp/foo-build/project<br>[info] Loading settings from build.sbt ...<br>[info] Set current project to foo-build (in build file:/tmp/foo-build/)<br>[info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/abc4fb6c89985a00fd95/sock<br>sbt:foo-build&gt;<br></code></pre></div></td></tr></table></figure></p><ul><li>第一次初始化时间会很长。</li><li>退出shell：<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:foo-build&gt; exit<br></code></pre></div></td></tr></table></figure></li><li>编译：<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:foo-build&gt; compile<br></code></pre></div></td></tr></table></figure></li><li>sbt shell中Tab可以补全。</li></ul><p>对修改重新编译：</p><ul><li>在<code>compile</code>命令（或其他命令同理）前加一个<code>~</code>前缀，会进入等待状态，当项目发生修改是会自动重新编译。当然退出这个状态后就不会了。<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:foo-build&gt; ~compile<br>[success] Total time: 0 s, completed May 6, 2018 3:52:08 PM<br>1. Waiting for source changes... (press enter to interrupt)<br></code></pre></div></td></tr></table></figure></li></ul><p>创建源文件：</p><ul><li>执行<code>~compile</code>并保持，创建目录<code>src/main/scala/example</code>新建源文件保存就能看到编译过程了。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// src/main/scala/example/Hello.scala</span><br><span class="hljs-keyword">package</span> example<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>sbt shell常用操作：</p><ul><li><code>help</code>帮助。</li><li><code>help run</code>具体条目的帮助。</li><li><code>run</code>运行程序。</li><li>上下箭头切换已执行命令。</li><li><code>scalaVersion</code> scala版本。</li></ul><p>配置修改：</p><ul><li>切换当前项目的scala版本：<code>set ThisBuild / scalaVersion := &quot;2.13.6&quot;</code>。</li><li><code>session save</code>保存配置到<code>build.sbt</code>，此时其中就会多出<code>ThisBuild / scalaVersion := &quot;2.13.6&quot;</code>。</li><li>编辑<code>build.sbt</code>：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span><br>  )<br></code></pre></div></td></tr></table></figure></li><li>重新加载配置<code>reload</code>。</li></ul><p>测试：</p><ul><li>添加ScalaTest到依赖<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % <span class="hljs-type">Test</span>,<br>  )<br></code></pre></div></td></tr></table></figure></li><li>执行测试：<code>test</code>。</li><li>后续继续运行追加的测试：<code>~testQuick</code></li></ul><p>编写测试：<code>src/test/scala/HelloSpec.scala</code><br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// src/test/scala/HelloSpec.scala</span><br><span class="hljs-keyword">import</span> org.scalatest.funsuite._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>&#123;<br>  test(<span class="hljs-string">&quot;Hello should start with H&quot;</span>) &#123;<br>    assert(<span class="hljs-string">&quot;hello&quot;</span>.startsWith(<span class="hljs-string">&quot;H&quot;</span>))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><ul><li>测试结果当然是失败<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:Hello&gt; test<br>[info] HelloSpec:<br>[info] - Hello should start with H *** FAILED ***<br>[info]   &quot;hello&quot; did not start with &quot;H&quot; (HelloSpec.scala:5)<br>[info] Run completed in 214 milliseconds.<br>[info] Total number of tests run: 1<br>[info] Suites: completed 1, aborted 0<br>[info] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0<br>[info] *** 1 TEST FAILED ***<br>[error] Failed tests:<br>[error]         HelloSpec<br>[error] (Test / test) sbt.TestsFailedException: Tests unsuccessful<br>[error] Total time: 0 s, completed 2021年9月27日 下午11:58:01<br></code></pre></div></td></tr></table></figure></li><li>改一下源码再测试就能通过了：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// src/test/scala/HelloSpec.scala</span><br><span class="hljs-keyword">import</span> org.scalatest.funsuite._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>&#123;<br>  test(<span class="hljs-string">&quot;Hello should start with H&quot;</span>) &#123;<br>    assert(<span class="hljs-string">&quot;Hello&quot;</span>.startsWith(<span class="hljs-string">&quot;H&quot;</span>))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>添加库依赖：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// build.sbt</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % <span class="hljs-type">Test</span>,<br>  )<br></code></pre></div></td></tr></table></figure></p><p>使用REPL（Read-Eval-Print Loop）：<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:Hello&gt; console<br></code></pre></div></td></tr></table></figure></p><ul><li>在scala的REPL环境中粘贴：<code>:paste</code>。</li><li>退出：<code>:q</code></li></ul><p>修改<code>build.sbt</code>创建一个子项目：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % <span class="hljs-type">Test</span>,<br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> helloCore = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>  )<br></code></pre></div></td></tr></table></figure></p><ul><li><code>reload</code>时会自动创建目录<code>core/</code>。</li><li>列出所有子项目：<code>projects</code></li><li>编译子项目：<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">helloCore/compile<br></code></pre></div></td></tr></table></figure></li><li>子项目添加依赖：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">val</span> scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> helloCore = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br></code></pre></div></td></tr></table></figure></li></ul><p>广播命令、添加依赖：</p><ul><li>设置<code>.aggregate(...)</code>，这样发送到<code>hello</code>的命令都会被广播到<code>helloCore</code></li><li>使用<code>.dependsOn(...)</code>可以设置依赖，下面的设置使<code>hello</code>依赖于<code>helloCore</code></li><li>将Gigahorse的依赖移到<code>helloCore</code>。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">val</span> scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br><span class="hljs-keyword">val</span> gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> helloCore = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>    libraryDependencies += gigahorse,<br>  )<br></code></pre></div></td></tr></table></figure></li></ul><p>使用Play JSON解析JSON：</p><ul><li>添加依赖。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">val</span> scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br><span class="hljs-keyword">val</span> gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br><span class="hljs-keyword">val</span> playJson  = <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> helloCore = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies ++= <span class="hljs-type">Seq</span>(gigahorse, playJson),<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br></code></pre></div></td></tr></table></figure></li><li>重载，添加文件：<code>core/src/main/scala/example/core/Weather.scala</code><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// core/src/main/scala/example/core/Weather.scala</span><br><span class="hljs-keyword">package</span> example.core<br><br><span class="hljs-keyword">import</span> gigahorse._, support.okhttp.<span class="hljs-type">Gigahorse</span><br><span class="hljs-keyword">import</span> scala.concurrent._, duration._<br><span class="hljs-keyword">import</span> play.api.libs.json._<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Weather</span> </span>&#123;<br>  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> http = <span class="hljs-type">Gigahorse</span>.http(<span class="hljs-type">Gigahorse</span>.config)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">weather</span></span>: <span class="hljs-type">Future</span>[<span class="hljs-type">String</span>] = &#123;<br>    <span class="hljs-keyword">val</span> baseUrl = <span class="hljs-string">&quot;https://www.metaweather.com/api/location&quot;</span><br>    <span class="hljs-keyword">val</span> locUrl = baseUrl + <span class="hljs-string">&quot;/search/&quot;</span><br>    <span class="hljs-keyword">val</span> weatherUrl = baseUrl + <span class="hljs-string">&quot;/%s/&quot;</span><br>    <span class="hljs-keyword">val</span> rLoc = <span class="hljs-type">Gigahorse</span>.url(locUrl).get.<br>      addQueryString(<span class="hljs-string">&quot;query&quot;</span> -&gt; <span class="hljs-string">&quot;New York&quot;</span>)<br>    <span class="hljs-keyword">import</span> <span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>.global<br>    <span class="hljs-keyword">for</span> &#123;<br>      loc &lt;- http.run(rLoc, parse)<br>      woeid = (loc \ <span class="hljs-number">0</span>  \ <span class="hljs-string">&quot;woeid&quot;</span>).get<br>      rWeather = <span class="hljs-type">Gigahorse</span>.url(weatherUrl format woeid).get<br>      weather &lt;- http.run(rWeather, parse)<br>    &#125; <span class="hljs-keyword">yield</span> (weather \\ <span class="hljs-string">&quot;weather_state_name&quot;</span>)(<span class="hljs-number">0</span>).as[<span class="hljs-type">String</span>].toLowerCase<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span> </span>= <span class="hljs-type">Gigahorse</span>.asString andThen <span class="hljs-type">Json</span>.parse<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>修改<code>src/main/scala/example/Hello.scala</code>:<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> scala.concurrent._, duration._<br><span class="hljs-keyword">import</span> core.<span class="hljs-type">Weather</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> w = <span class="hljs-type">Await</span>.result(<span class="hljs-type">Weather</span>.weather, <span class="hljs-number">10.</span>seconds)<br>  println(<span class="hljs-string">s&quot;Hello! The weather in New York is <span class="hljs-subst">$w</span>.&quot;</span>)<br>  <span class="hljs-type">Weather</span>.http.close()<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>运行：<code>run</code><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:Hello&gt; run<br>[info] running example.Hello<br>Hello! The weather in New York is light cloud.<br>[success] Total time: 5 s, completed 2021年9月28日 上午10:29:57<br></code></pre></div></td></tr></table></figure></li></ul><p>添加sbt-native-packager插件：</p><ul><li>创建<code>project/plugins.sbt</code><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">addSbtPlugin(<span class="hljs-string">&quot;com.typesafe.sbt&quot;</span> % <span class="hljs-string">&quot;sbt-native-packager&quot;</span> % <span class="hljs-string">&quot;1.3.4&quot;</span>)<br></code></pre></div></td></tr></table></figure></li><li>修改<code>build.sbt</code>对<code>Hello</code>项目添加<code>.enablePlugins(JavaAppPackaging)</code></li><li>重载，本地没有执行成功，所以下面的<code>dist</code>命令也就不能用。</li></ul><p>重载并创建.zip分发包：<code>dist</code><br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt:Hello&gt; dist<br>[info] Wrote /tmp/foo-build/target/scala-2.12/hello_2.12-0.1.0-SNAPSHOT.pom<br>[info] Wrote /tmp/foo-build/core/target/scala-2.12/hello-core_2.12-0.1.0-SNAPSHOT.pom<br>[info] Your package is ready in /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip<br></code></pre></div></td></tr></table></figure></p><p>应用容器化：</p><ul><li><code>Docker/publishLocal</code></li><li>运行容器化后的应用：<code>docker run hello:0.1.0-SNAPSHOT</code></li></ul><p>设置应用版本：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// build.sbt</span><br><span class="hljs-type">ThisBuild</span> / version      := <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br><span class="hljs-keyword">val</span> scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br><span class="hljs-keyword">val</span> gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br><span class="hljs-keyword">val</span> playJson  = <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  .enablePlugins(<span class="hljs-type">JavaAppPackaging</span>)<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> helloCore = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies ++= <span class="hljs-type">Seq</span>(gigahorse, playJson),<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>  )<br></code></pre></div></td></tr></table></figure></p><p>临时切换Scala版本：</p><ul><li><code>++2.12.14</code></li></ul><p>在Bash中直接运行sbt的命令：<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sbt clean &quot;testOnly HelloSpec&quot;<br></code></pre></div></td></tr></table></figure></p><ul><li>这样程序运行起来会慢一些。</li><li>连续的开发的话，推荐使用sbt shell或者连续测试比如<code>~testQuick</code>。</li></ul><p><code>new</code>命令：<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sbt new scala/scala-seed.g8</span><br>....<br>A minimal Scala project.<br><br>name [My Something Project]: hello<br><br>Template applied in ./hello<br></code></pre></div></td></tr></table></figure></p><ul><li>会创建一个简单的项目，要求输入项目名时输入<code>hello</code>，会在<code>hello/</code>下创建一个新项目。</li></ul><h3 id="sbt使用"><a href="#sbt使用" class="headerlink" title="sbt使用"></a>sbt使用</h3><p>项目的目录结构：</p><ul><li>base directory是包含项目的目录，这里称为项目根目录。</li><li>sbt使用和Maven一样的源码结构，源文件路径都是基于项目根目录的相对路径。<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">src/<br>  main/<br>    resources/<br>       &lt;files to <span class="hljs-keyword">include</span> <span class="hljs-keyword">in</span> main jar here&gt;<br>    <span class="hljs-keyword">scala</span>/<br>       &lt;main <span class="hljs-keyword">Scala</span> sources&gt;<br>    <span class="hljs-keyword">scala</span>-2.12/<br>       &lt;main <span class="hljs-keyword">Scala</span> 2.12 specific sources&gt;<br>    java/<br>       &lt;main Java sources&gt;<br>  <span class="hljs-keyword">test</span>/<br>    resources<br>       &lt;files to <span class="hljs-keyword">include</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">test</span> jar here&gt;<br>    <span class="hljs-keyword">scala</span>/<br>       &lt;<span class="hljs-keyword">test</span> <span class="hljs-keyword">Scala</span> sources&gt;<br>    <span class="hljs-keyword">scala</span>-2.12/<br>       &lt;<span class="hljs-keyword">test</span> <span class="hljs-keyword">Scala</span> 2.12 specific sources&gt;<br>    java/<br>       &lt;<span class="hljs-keyword">test</span> Java sources&gt;<br></code></pre></div></td></tr></table></figure></li><li>其他<code>src/</code>中的目录会被忽略，所有隐藏目录都会被忽略。</li><li>源码可以被放在根目录的<code>hello/app.scala</code>，对小项目是可行的。然而一般来说，人们倾向于将项目放在<code>src/main/</code>下面来保证事情能够有条理地进行。如果你自行管理定制了项目的构建的话，自定义源码的位置也是可行的。</li><li>sbt的构建定义文件：<code>build.sbt</code></li><li>除此之外，<code>project</code>目录中的<code>.scala</code>文件可以定义项目帮助文件和一次性的插件。<figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">build.sbt<br><span class="hljs-keyword">project</span>/<br>  <span class="hljs-keyword">Dependencies</span>.scala<br></code></pre></div></td></tr></table></figure></li><li>生成文件：<code>.class</code>，生成的<code>jar</code>，其他文件和文档等会被默认输出到<code>target</code>目录。</li><li>一般生成文件应该要排除在版本控制之外，在<code>.gitignore</code>中添加：<figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">target</span>/<br></code></pre></div></td></tr></table></figure></li></ul><p>运行：</p><ul><li>运行sbt shell：<code>sbt</code>无参数运行，进入sbt的提示符，有tab补全和执行历史。</li><li>编译：<code>compile</code></li><li>运行：<code>run</code></li><li>不进入sbt shell直接运行sbt命令：用<code>&quot;&quot;</code>包起来表示是一个命令，相对来说会慢一些。<figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">sbt <span class="hljs-built_in">clean</span> compile <span class="hljs-string">&quot;testOnly TestA TestB&quot;</span><br></code></pre></div></td></tr></table></figure></li><li>会一次执行<code>clean compile testOnly</code>，<code>TestA TestB</code>是传给<code>testOnly</code>的参数。</li><li>保存文件时自动重编译运行测试：<code>~testQuick</code>。</li><li>命令加上<code>~</code>后会进入循环模式，保存文件都会自动运行。回车退出。</li><li>常用命令：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Command</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:center">clean</td><td style="text-align:left">Deletes all generated files (in the target directory).</td></tr><tr><td style="text-align:center">compile</td><td style="text-align:left">Compiles the main sources (in src/main/scala and src/main/java directories).</td></tr><tr><td style="text-align:center">test</td><td style="text-align:left">Compiles and runs all tests.</td></tr><tr><td style="text-align:center">console</td><td style="text-align:left">Starts the Scala interpreter with a classpath including the compiled sources and all dependencies. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows).</td></tr><tr><td style="text-align:center">run argument*</td><td style="text-align:left">Runs the main class for the project in the same virtual machine as sbt.</td></tr><tr><td style="text-align:center">package</td><td style="text-align:left">Creates a jar file containing the files in src/main/resources and the classes compiled from src/main/scala and src/main/java.</td></tr><tr><td style="text-align:center">help command</td><td style="text-align:left">Displays detailed help for the specified command. If no command is provided, displays brief descriptions of all commands.</td></tr><tr><td style="text-align:center">reload</td><td style="text-align:left">Reloads the build definition (build.sbt, project/<em>.scala, project/</em>.sbt files). Needed if you change the build definition.</td></tr></tbody></table></div><h3 id="build-sbt"><a href="#build-sbt" class="headerlink" title="build.sbt"></a>build.sbt</h3><p><code>build.sbt</code>构建定义：</p><ul><li>指定sbt版本，这样就使用不同版本的sbt构建同一个项目了。如果指定的版本不可用，那么会自动下载。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">sbt.version=<span class="hljs-number">1.5</span><span class="hljs-number">.5</span><br></code></pre></div></td></tr></table></figure></li><li>构建定义（build definition）：</li><li>包含了一系列项目（<a href="https://www.scala-sbt.org/1.x/api/sbt/Project.html">Scala中的Project类型</a>），项目这个名词有一定的模糊性，所以其中的一个个项目一般将之称为子项目。</li><li>在<code>build.sbt</code>中可以定义一个在当前目录中的子项目：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    scalaVersion := <span class="hljs-string">&quot;2.12.7&quot;</span><br>  )<br></code></pre></div></td></tr></table></figure></li><li>项目的名称在<code>.setting</code>方法中用一个键值对定义，key是<code>name</code>，值是一个字符串表示项目名称。</li><li><code>build.sbt</code>定义所有的子项目，包含一些的键值对称为<code>setting</code>表达式，使用一门build.sbt DSL（本质上其实就是Scala）来定义项目。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br><span class="hljs-type">ThisBuild</span> / version      := <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;hello&quot;</span><br>  )<br></code></pre></div></td></tr></table></figure></li><li>看一看这门DSL的定义：<br><img src="Images/Scala_sbt_dsl_setting_expression.png" alt="setting expression"></li><li>每一个都叫做一个setting expression，其中的一些又被叫做task expression。</li><li>一个setting expression包含三部分：<ol><li>左边是key。</li><li>操作符，这个例子中是<code>:=</code></li><li>右边是setting body。</li></ol></li><li>一个key的类型是<code>sbt.SettingKey[T] sbt.TaskKey[T] sbt.InputKey[T]</code>其中一者的实例，T是期望的值类型。</li><li>比如<code>name</code>就绑定到了<code>SettingKey[String]</code>类型，给个其他类型比如整数的话就会编译错误。</li><li>在<code>build.sbt</code>中可以穿插<code>val</code> <code>lazy val</code> <code>def</code>，但是不能有顶层<code>object class</code>定义。</li></ul><p>expression的key：</p><ul><li>三种类型：<ul><li><code>SettingKey[T]</code> 值仅在加载子项目时计算一次，然后保持。</li><li><code>TaskKey[T]</code> 值被称为一个任务（task），每次都会重新计算（何时？），存在潜在的副作用。</li><li><code>InputKey[T]</code> 值是有命令行输入作为参数的任务，细节见<a href="https://www.scala-sbt.org/1.x/docs/Input-Tasks.html">Input Tasks</a>。</li></ul></li><li>内建的keys就是<code>sbt.Keys</code>单例伴生对象的域。<code>build.sbt</code>隐式导入<code>import sbt.Keys._</code>，<code>sbt.Keys.name</code>就是<code>name</code>，所以其实就是对这些字段做赋值。</li><li>自定义key：使用各自的方法<code>settingKey taskKey inputKey</code>，每个方法需要一个value的类型和描述。key的名称就是被赋值到的引用变量名称。</li><li>定义一个自定义key，名称是<code>hello</code>，类型是<code>TaskKey</code>，对应值类型是<code>Unit</code>：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = taskKey[<span class="hljs-type">Unit</span>](<span class="hljs-string">&quot;An example task&quot;</span>)<br></code></pre></div></td></tr></table></figure></li><li>所有这种定义都在设置前被求值，无论定义在文件什么位置。</li><li>一般来说，使用<code>lazy val</code>而不是<code>val</code>来避免初始化顺序导致的问题。</li><li>Task和Setting区别：<ul><li>Task是任务，比如<code>compile</code> <code>package</code>都是<code>sbt.Keys</code>中的域，同时也是sbt shell中可执行的命令。应该返回<code>Unit</code>或者返回和这个任务相关的值，比如<code>package</code>是<code>TaskKey[File]</code>值是其创建的jar文件。</li><li>每一次开始一个任务，比如sbt shell中执行<code>compile</code>，sbt都会重新跑（仅）一次这个任务相关的所有任务。</li><li>而Setting仅仅只是一个朴素的设置项。</li></ul></li></ul><p>定义任务和设置：</p><ul><li>使用<code>:=</code>可以将一个设置或者一项计算任务赋值。设置只会在记载项目时计算一次，任务则会在每次执行这个任务被执行时重新执行。</li><li>新建一个任务：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = taskKey[<span class="hljs-type">Unit</span>](<span class="hljs-string">&quot;An example task&quot;</span>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    hello := &#123; println(<span class="hljs-string">&quot;Hello!&quot;</span>) &#125;<br>  )<br></code></pre></div></td></tr></table></figure></li><li>任务也在<code>.settings</code>中被赋值。</li><li>每次在sbt shell中执行<code>hello</code>都会执行其中<code>println</code>语句。</li><li>定义设置的话已经说过。</li><li>从类型系统的视角来看，对任务赋值得到一个<code>Setting[Task[T]]</code>，对设置赋值得到<code>Setting[T]</code>。<code>T Task[T]</code>的区别有一层隐含的含义：一个设置不能依赖于一个任务。因为设置仅记载是求值一次不会每次都重新运行。</li></ul><p>sbt shell中的key：</p><ul><li>sbt shell中可以输入任何任务名称都会运行该任务，因为这个任务名称是key。运行该任务但并不会显示运行结果值（也就是返回值，类型就是<code>taskKey[T]</code>中的<code>T</code>），要显示结果值，应该使用<code>show &lt;task name&gt;</code>而不是单纯的<code>&lt;task name&gt;</code>。</li><li>如果输入设置的key的话，会显示设置的值。</li><li>要知道一个key的更多信息，可以使用<code>inspect &lt;keyname&gt;</code>。某些信息现在看起来可能不知道含义，但最顶上有类型和简要描述。</li></ul><p>在<code>build.sbt</code>中导入信息：</p><ul><li>比如：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> sbt._<br><span class="hljs-keyword">import</span> <span class="hljs-type">Keys</span>._<br></code></pre></div></td></tr></table></figure></li><li>中间不能有空行。</li><li>如果有自动插件（<a href="https://www.scala-sbt.org/1.x/api/sbt/AutoPlugin.html"><code>sbt.AutoPlugin</code></a>，可以从其派生实现自己的插件），那么在其中的<code>autoImport</code>单例对象下的名称会被自动导入。</li></ul><p>Bare .sbt build definition：</p><ul><li>也就是裸的构建定义，设置可以被直接写到<code>.sbt</code>而不是项目的<code>.setting(...)</code>调用下，称之为bare style。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / version := <span class="hljs-string">&quot;1.0&quot;</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br></code></pre></div></td></tr></table></figure></li><li>这种语法推荐用来写在<code>ThisBuild</code>作用域下的设置和添加插件。后续会有作用域和插件的说明。</li></ul><p>添加库依赖：</p><ul><li>为了能够依赖第三方库，有两种方式：</li><li>一是将jar文件直接放在<code>lib/</code>（未管理的依赖）目录下，第二种是添加管理的依赖，通过在<code>.setting(..)</code>调用中对<code>libraryDependencies</code>key做<code>+=</code>操作做到。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> derby = <span class="hljs-string">&quot;org.apache.derby&quot;</span> %% <span class="hljs-string">&quot;derby&quot;</span> % <span class="hljs-string">&quot;10.4.1.3&quot;</span><br><br><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br><span class="hljs-type">ThisBuild</span> / version      := <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += derby<br>  )<br></code></pre></div></td></tr></table></figure></li><li>包含包的组织、包名、和包的版本。可以定义变量来复用。<code>%</code>运算符被用来从字符串构建一个模块ID。</li></ul><h3 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h3><p>多个项目定义：</p><ul><li>在一次构建中编译多个相关联的子项目是很有用的，特别是其间存在依赖，想更改他们所有的时候。</li><li>每个子项目都有自己的目录，构建时都会生成自己的jar文件，</li><li>项目使用<code>lazy val</code>定义一个<a href="https://www.scala-sbt.org/1.x/api/sbt/Project.html">sbt.Project</a>来实现。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util = (project in file(<span class="hljs-string">&quot;util&quot;</span>))<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br></code></pre></div></td></tr></table></figure></li><li>这个<code>val</code>的不变量名称被用做子项目的ID（也即是项目名称），在sbt shell中也用来指代一个子项目。</li><li>后面的<code>in file()</code>调用指定他们的base directory是可选的，目录名就是他们的名称。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util = project<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = project<br></code></pre></div></td></tr></table></figure></li></ul><p>公共设置；</p><ul><li>为了分离出跨子项目的设置，可以将其定义在<code>ThisBuild</code>范围下。<code>ThisBuild</code>表现的像一个普通的子项目名称一样使用，其下用来定义默认值。</li><li>如果定义了多个子项目，并且子项目下没有定义比如<code>scalaVersion</code>这个key，就会查找<code>ThisBuild / scalaVersion</code>。</li><li>这样定义的限制是右边的值只能是纯粹的值或者在<code>Global</code>/<code>ThisBuild</code>下的设置。</li><li>子项目范围下没有默认值。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><span class="hljs-type">ThisBuild</span> / version      := <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br><span class="hljs-type">ThisBuild</span> / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    <span class="hljs-comment">// other settings</span><br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util = (project in file(<span class="hljs-string">&quot;util&quot;</span>))<br>  .settings(<br>    <span class="hljs-comment">// other settings</span><br>  )<br></code></pre></div></td></tr></table></figure></li><li>重载后，现在<code>versoin</code>和其他的设置在所有子项目中都会生效。</li></ul><p>另一种定义公共设置的方式：</p><ul><li>将默认设置放在<code>commonSettings</code>下，然后添加到所有子项目中<code>.setting()</code>调用中。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> commonSettings = <span class="hljs-type">Seq</span>(<br>  target := &#123; baseDirectory.value / <span class="hljs-string">&quot;target2&quot;</span> &#125;<br>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    commonSettings,<br>    <span class="hljs-comment">// other settings</span><br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util = (project in file(<span class="hljs-string">&quot;util&quot;</span>))<br>  .settings(<br>    commonSettings,<br>    <span class="hljs-comment">// other settings</span><br>  )<br></code></pre></div></td></tr></table></figure></li></ul><p>项目间依赖：</p><ul><li>项目间可以完全独立，也通常可能会有某种方式的依赖。</li><li>有两种方式的依赖：aggregate and classpath，用<code>.aggregate .dependsOn</code>定义。</li><li>聚合用来广播命令，类路径依赖则是指项目之间存在依赖关系。</li></ul><p>聚合（Aggregation）：<br><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(util, core)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util = (project in file(<span class="hljs-string">&quot;util&quot;</span>))<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = (project in file(<span class="hljs-string">&quot;core&quot;</span>))<br></code></pre></div></td></tr></table></figure></p><ul><li>这种方式在聚合项目上运行任务时会同样在它聚合的所有子项目上运行。</li><li>比如上面的子项目定义，编译<code>root</code>是会同时编译<code>util core</code>。</li><li>通过在做聚合的项目中定义设置可以修改这种默认行为：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(util, core)<br>  .settings(<br>    update / aggregate := <span class="hljs-literal">false</span><br>  )<br><br>[...]<br></code></pre></div></td></tr></table></figure></li><li>上面设置表示在root项目上执行<code>update</code>是就不会在被聚合的子项目上执行。<code>update / aggregate</code>是update作用域下的key。</li></ul><p>类路径依赖：</p><ul><li>一个项目可能依赖另一个项目的代码，通过<code>.dependsOn(proj1, proj2, ...)</code>方法调用来定义。依赖之后就会被添加到classpth，从而能够导入。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = project.dependsOn(util)<br></code></pre></div></td></tr></table></figure></li><li>现在在<code>core</code>中就可以调用<code>util</code>中的代码了。这同样也确定了代码编译顺序必然是先<code>util</code>后<code>core</code>。</li><li><code>core dependsOn(util)</code>意味着<code>core</code>的编译配置依赖<code>util</code>，也可以显式通过<code>dependsOn(util % &quot;compile-&gt;compile&quot;)</code>这种方式来指定，<code>compile-&gt;compile</code>中的<code>-&gt;</code>意味着依赖。因此如果是<code>&quot;test-&gt;compile&quot;</code>就以为着<code>core</code>的<code>test</code>配置依赖<code>util</code>的<code>compile</code>配置。可以忽略后面的<code>-&gt;config</code>部分意味着就是<code>-&gt;comile</code>。</li><li>一个比较有用的定义是<code>test-&gt;test</code>意味着测试<code>core</code>是先测试<code>util</code>。</li><li>可以用分好分隔：<code>dependsOn(util % &quot;test-&gt;test;compile-&gt;compile&quot;)</code>。</li></ul><p>项目间依赖：</p><ul><li>在大项目中，会有许多文件，持续监视文件修改并重新编译将会消耗大量磁盘和IO资源。</li><li>sbt使用<code>trackInternalDependencies</code> 和 <code>exportToInternal</code>设置用来控制执行<code>compile</code>任务时是否触发独立子项目的编译。两个key都接受三个输入：<ul><li><code>TrackLevel.NoTracking</code></li><li><code>TrackLevel.TrackIfMissing</code></li><li><code>TrackLevel.TrackAlways</code> 默认是这一项。</li><li>含义显而易见。</li></ul></li><li><code>trackInternalDependencies</code>设置如果是<code>TrackLevel.TrackIfMissing</code>，那么sbt将不会尝试自动编译项目间依赖，除非输出目录中的<code>*.class</code>文件缺失了（或者<code>exportJars</code>时jar文件缺失了）。</li><li>当被设置为<code>TrackLevel.NoTracking</code>，项目将依赖将被跳过。但是classpth仍然会被添加，依赖图也会显示他们还是依赖的。这么做的目的是为了减小检查文件修改的IO负担。</li><li>设置方法：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">ThisBuild</span> / trackInternalDependencies := <span class="hljs-type">TrackLevel</span>.<span class="hljs-type">TrackIfMissing</span><br><span class="hljs-type">ThisBuild</span> / exportJars := <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(....)<br></code></pre></div></td></tr></table></figure></li><li><code>exportToInternal</code>设置允许依赖于当前项目的子项目跳过内部追踪。用在一个子项目上，用在当前不关心的依赖于其他项目的子项目，当其他项目发生修改重新编译，它也不会重新编译。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> dontTrackMe = (project in file(<span class="hljs-string">&quot;dontTrackMe&quot;</span>))<br>  .settings(<br>    exportToInternal := <span class="hljs-type">TrackLevel</span>.<span class="hljs-type">NoTracking</span><br>  )<br></code></pre></div></td></tr></table></figure></li><li><code>trackInternalDependencies</code>和<code>exportToInternal</code>，比如当前修改项目时A，A依赖B，C依赖A，那么前者是针对B也就是当前项目依赖的那些子项目，后者针对C也就是依赖当前项目的子项目。这是我的理解，应该是这个样子！</li><li>如果没理解错的话，项目的依赖关系（指classpth，会调用的那种依赖）应该是一棵树，而不会有环图。</li></ul><p>默认的根项目：</p><ul><li>如果没有为最顶层目录<code>.</code>定义项目，那么sbt会创建一个默认的然后在构建时聚合所有子项目。</li></ul><p>与项目的交互：</p><ul><li><code>projects</code>列出所有子项目。</li><li><code>proejct</code>列出当前项目，<code>project &lt;projectname&gt;</code>切换项目。运行一个任务比如<code>compile</code>时是针对当前项目。</li><li>也可以通过指定项目名称来在某个项目上运行任务：<code>subProjectID / &lt;taskname&gt;</code>。</li></ul><p>公共代码：</p><ul><li><code>.sbt</code>文件之间的定义是不共享的。</li><li>为了能够在不同<code>.sbt</code>之间共享代码，需要在根目录的<code>project/</code>下面（子目录中的是没有用的，会被忽略，只有根目录中的才会有效）定义一个或多个scala文件。后续会详述。</li></ul><p>子项目中的<code>.sbt</code>文件：</p><ul><li>所有的<code>.sbt</code>文件都会被合并到一个整体的构建（build）中来，但是只在他们自己的范围内起作用。定义不会被共享。</li><li>比如顶层<code>hello</code>目录中初始化<code>sbt</code>，<code>.</code>定义根项目<code>hello</code>，<code>hello/foo/ hello/bar</code>分别定义项目foo和bar并且有自己的<code>build.sbt</code>并把项目定义在了其中，其中定义了自己的不同版本。</li><li>那么执行<code>show version</code>的结果就是这样的：<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> show version</span><br>[info] hello-foo/*:version<br>[info]  0.7<br>[info] hello-bar/*:version<br>[info]  0.9<br>[info] hello/*:version<br>[info]  0.5<br></code></pre></div></td></tr></table></figure></li><li>所有的<code>build.sbt</code>都是整个构建的一部分，但都有自己的作用范围。</li><li>可以分开定义，也可以合起来定义<code>build.sbt</code>，项目很多时都定义在根目录中可能就太复杂了，定义在子目录找起来好像又挺麻烦。</li><li>风格选择：<ul><li>子项目的设置在子项目的<code>.sbt</code>中定义，根<code>build.sbt</code>中只定义最小的项目声明，形如：<code>lazy val foo = (project in file(&quot;foo&quot;))</code>不修改任何设置。</li><li>推荐是将所有项目定义全都放在根目录中的<code>build.sbt</code>，保持项目定义在一个文件中。</li><li>都可以，这完全取决于你。</li></ul></li></ul><h3 id="任务图"><a href="#任务图" class="headerlink" title="任务图"></a>任务图</h3><p>任务图：</p><ul><li>除了将设置视作一个个键值对，更好的比喻其实是以有向无环图（DAG）。边的方向表示<strong>在之前发生</strong>，称之为任务图（Task Graph） 。</li><li>Setting/Task expression就是前面的在<code>.setting(...)</code>中定义了设置或者任务的表达式。</li></ul><p>任务间依赖：</p><ul><li>使用一个特殊的<code>.value</code>方法调用来解释任务之间的依赖。</li><li>直到非常熟悉<code>hello.sbt</code>之前，都推荐将<code>.value</code>调用放在task定义块中最上方。</li><li>除了使用一个不变量赋值的方式，也可以使用内联的<code>.value</code>调用，更加间接，也不用去想变量名。</li><li><code>.value</code>调用会在进入task body之前被求值，这是需要非常注意的。</li><li>测试：<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hi = taskKey[<span class="hljs-type">Unit</span>](<span class="hljs-string">&quot;An example task for dependency&quot;</span>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  <span class="hljs-comment">// .enablePlugins(JavaAppPackaging)</span><br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-type">Test</span>,<br>    hi := &#123;<br>      <span class="hljs-keyword">val</span> ur = update.value <span class="hljs-comment">// streams task happens-before hi</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">val</span> x = clean.value <span class="hljs-comment">// clean task happens-before hi</span><br>      &#125;<br>    &#125;<br>  )<br></code></pre></div></td></tr></table></figure></li><li>此时任务<code>hi</code>就会依赖于任务<code>update</code>和<code>clean</code>，并且这两个任务是在进入<code>hi</code>任务体前执行的，且不确定两者先后顺序，可先可后可并行。</li><li>在任务体中调用<code>.value</code>仅用来表明任务之间的依赖关系。</li><li>先编译项目，执行<code>hi</code>后会发现<code>target/scala-2.13/clsses/</code>被清除，就是因为执行了<code>clean</code>任务。</li><li>查看任务间依赖：在<code>Dependencies:</code>后可以看到。<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">inspect hi<br></code></pre></div></td></tr></table></figure></li><li>执行<code>inspect tree compile</code>会看到<code>compile</code>命令的依赖树，什么含义暂时不知。</li><li>sbt中的构建任务依赖是自动的而不是显式定义的，如果通过<code>.value</code>定义了，那么会造成任务间依赖。</li></ul><p>任务依赖设置：</p><ul><li>在任务体定义中调用设置的<code>.value</code>就行。</li><li>但设置是不能依赖任务的，因为设置只在重载时执行一次，而任务一直都可以执行。</li></ul><p>设置依赖设置：</p><ul><li>可以将设置看做仅在记加载是执行一次的任务，所以设置也可以依赖设置。</li><li>同样其中调用<code>.value</code>就可以依赖，并且执行时求值：</li><li>一个实际的例子：当Scala版本是2.11时讲将<code>Compile / scalaSource</code>定义到一个不同的目录。<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Compile</span> / scalaSource := &#123;<br>  <span class="hljs-keyword">val</span> old = (<span class="hljs-type">Compile</span> / scalaSource).value<br>  scalaBinaryVersion.value <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2.11&quot;</span> =&gt; baseDirectory.value / <span class="hljs-string">&quot;src-2.11&quot;</span> / <span class="hljs-string">&quot;main&quot;</span> / <span class="hljs-string">&quot;scala&quot;</span><br>    <span class="hljs-keyword">case</span> _      =&gt; old<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>再看<code>build.sbt</code>DSL：</p><ul><li>构建了一个设置和任务的有向无环图。</li><li>设置表达式编码了设置、任务以及他们之间的依赖。</li><li>这种结构在Make/Ant/Rake等构建工具中很常见。</li><li>基于流的编程，减少了重复过程，好处：</li><li>一个任务仅仅只会执行一次，即使它被多个任务所依赖比如<code>Compile / compile</code>。</li><li>基于任务图，任务引擎会安排不相关的任务并行执行。</li><li>关注点分离和灵活性，任务图让用户可以将任务以不同的方式连接到一起，sbt和各种插件可以提供各种各样的特性比如库依赖管理等。</li></ul><p>总结：</p><ul><li>核心就是任务图，任务之间的关系是一个有向无环图。</li><li><code>hello.sbt</code>是一个设计来面向依赖编程（dependency-oriented programming）的DSL，或者叫基于流（flow）的编程。就像Makefile。语法就像Scala，但并不等同于Scala，语义上是有区别的。</li><li>基于流的编程的核心是：减少重复过程、并行处理和定制化。</li></ul><h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p>更多内容就不翻译了，官网上第一章也有中文翻译。需要时再去阅读，现阶段感觉都用不到，真写项目了再看不迟。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>TODO</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：</p><ul><li>看起来是一门静态类型语言，提供了很其强大的类型推导，可以一定程度上实现隐式静态类型，但写起来如果高度依赖类型推导的话会和动态类型一样简洁，仅需提供少量必须的类型，只是有点牺牲可读性。</li><li>函数式编程很有趣。</li><li>语法糖太太太多了，虽然看起来更简洁了，但是读起来不一定更简单，学起来心智负担也更大。</li><li>运算符非常灵活，目前遇到过的运算符最灵活的语言。</li><li>并发编程还没有学，TODO。</li><li>Scala语法确实有点太强大了，当然软件工程的东西都是tradeoff，写起来爽用起来复杂学起来难。</li></ul><p>Scala是我目前学过的最舒服的语言，很多特点简直太棒了，如果此生只能选一门语言的话，那我可能真会选这门刚学了几天的语言。吸引我的点：</p><ul><li>函数式编程，和集合的映射推导结合起来很有用。</li><li>类型推导，像动态语言用起来的感觉，但也有编译期类型检查，再加上隐式类型转换，真我全都要。</li><li>各种能简则简的语法糖，初看可能很诧异，习惯之后只能说去**的java，简洁而不简单。</li><li>运算符重载，容易被滥用，但用得好会使代码进一步简化，当然各式各样的运算符会进一步增加读代码的难度。</li><li>更加纯粹的面向对象，万物皆是对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala（一）：基础篇</title>
    <link href="/202202260117/CS/Scalaessay/cs/scala/2022-02-10-scala/"/>
    <url>/202202260117/CS/Scalaessay/cs/scala/2022-02-10-scala/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><h2 id="1-1-导论"><a href="#1-1-导论" class="headerlink" title="1.1 导论"></a>1.1 导论</h2><p>Scala来源于scalable（可扩展的）这个单词，它的<strong>可扩展性非常强</strong> </p><ul><li><p>Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性</p><ul><li>Scala比Java更加<strong>面向对象</strong></li><li>Scala是一门<strong>函数式编程语言</strong>(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala)</li><li>同样运行在<strong>JVM</strong>上，可以与现存程序同时运行</li><li>可直接使用<strong>Java类库</strong></li><li>同Java一样<strong>静态类型</strong></li><li>语法和Java类似，比Java<strong>更加简洁</strong>（简洁而并不是简单），<strong>表达性更强</strong>。</li></ul></li><li><p>关注点</p><ul><li>类型推断、不变量、函数式编程、高级程序构造</li><li>并发：actor模型</li><li>和现有Java代码交互、相比Java异同和优缺</li></ul></li><li><p><del>Scala更适合大数据的处理</del></p><ul><li><del>Scala对<strong>集合</strong>类型数据处理有非常好的支持</del></li><li><del>Spark的底层用Scala编写</del></li></ul></li><li><p>和Java关系：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">        javac               java<br><span class="hljs-string">.java</span> <span class="hljs-params">--------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br><span class="hljs-string">.scala</span> <span class="hljs-params">-------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br>        scalac              scala<br></code></pre></div></td></tr></table></figure><ul><li>Java很多语法源自Cpp</li><li>Java面向对象不是很彻底，有八大基本数据类型，同时又有包装类型（继承自Object）</li><li>对更加复杂的高端应用</li><li><strong>函数式编程语言</strong>可以解决上述问题</li><li>Scala最重要的是引入了类型推断和lamuda表达式</li></ul></li></ul><h2 id="1-2-总结特点"><a href="#1-2-总结特点" class="headerlink" title="1.2 总结特点"></a>1.2 总结特点</h2><p>Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的<strong>静态类型编程语言</strong>（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）</p><ul><li>Scala是一门多范式的编程语言，Scla支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程、面向对像、泛型、函数式四种程序设计方法）</li><li>Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM文上，并可以调用现有的Java类库，实现两种语言的无缝对接。</li><li>Scala单作为一门语言来看，非常的简洁高效。</li><li>Scaa在设计时，马丁奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁奥德斯基也加入了自己的思想，将<strong>函数式编程语言的特点融合到JAVA</strong>中，因此，对于学习Java的同学，只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的拿握Scaa这门语言</li></ul><h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2 环境"></a>2 环境</h1><h2 id="2-1-交互式命令行"><a href="#2-1-交互式命令行" class="headerlink" title="2.1 交互式命令行"></a>2.1 交互式命令行</h2><ul><li>交互式执行环境（cmd直接输入scala）：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png" alt="image-20220301103816193"></p><ul><li>定义常量</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103912684.png" alt="image-20220301103912684"></p><ul><li>print</li></ul><p>对比Java的<code>system.out.println(&quot;&quot;);</code>确实简洁不少</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301104056461.png" alt="image-20220301104056461"></p><ul><li>推出交互式执行环境</li></ul><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">scala&gt; :<span class="hljs-keyword">quit</span><br></code></pre></div></td></tr></table></figure><h2 id="2-2-完整编译流程"><a href="#2-2-完整编译流程" class="headerlink" title="2.2 完整编译流程"></a>2.2 完整编译流程</h2><p>和Java差不多</p><p><strong>源程序</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//HelloScala.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloScala</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):<span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;hello scala&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>object</code>关键字：定义单例对象(直接定义对象而不是类)</li><li><code>def</code>关键字：声明函数或方法</li><li><code>args</code>：在类型前面，表明我们更关心参数而不是类型</li><li><code>:Array[String]</code>：Array集合类型，[String]一个泛型，表明内部是String的集合</li><li><code>:Unit</code>：返回值为void</li><li><code>=&#123;&#125;</code>：函数体</li><li>没有分号</li></ul><p><strong>编译生成字节码文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scalac HelloScala.scala<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110611005.png" alt="image-20220301110611005"></p><p>为什么有HelloScala$.class和HelloScala.class两个文件？</p><blockquote><p> 底层机制：</p><p>参考<a href="https://www.bilibili.com/video/av204775475">尚硅谷007Scala环境搭建（三）</a></p><p>HelloScala.class：要执行程序的入口类</p><p>HelloScala$.class：上面类所属类，被调用</p><p>进一步补充：</p><p>如果编译的话会生成2个<code>.class</code>字节码文件，<code>HelloScala.class</code>和<code>HelloScala$.class</code>。都是字节码但是不能通过<code>java</code>直接运行。但对于HelloWorld这个例子来说，java源代码编译而成的字节码是可以通过<code>scala</code>命令运行的。</p><p>原因是没有引入Scala的库，添加<code>classpath</code>就可以通过java执行scala编译成的字节码了：</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">java -cp %SCALA_HOME%<span class="hljs-regexp">/lib/</span>scala-library.jar; HelloScala<br></code></pre></div></td></tr></table></figure><p>使用<a href="http://java-decompiler.github.io/">Java Decompiler</a>反编译字节码到java源文件可以看到引入Scala库的逻辑。并且：</p><ul><li>scala源文件中的<code>HelloScala</code>对象编译后成为了一个类，但对象本身编译后就是生成的另一个类<code>HelloScala$</code>类的单例对象<code>HelloScala$.MODULE$</code>，称之为伴生对象。</li><li><code>HelloScala$</code>有一个<code>main</code>实例方法，<code>HelloScala</code>类的静态方法通过这个单例对象转调这个实例方法。完成打印。</li><li>Scala比Java更面向对象。</li></ul></blockquote><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scala HelloScala<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110658494.png" alt="image-20220301110658494"></p><p><strong>反编译</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301113507259.png" alt="image-20220301113507259"></p><hr><p><del>暂时不管项目配置，还是单文件编译执行为主，项目开发肯定要以包的形式组织可以使用IntelliJ IDEA开发，使用maven或者sbt进行项目配置</del></p><p>使用VSCode编辑器，安装插件Scala Syntax (official)和Scala (Mentals)</p><ul><li>新建文件<code>HelloScala.scala</code></li></ul><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">object HelloScala &#123; <span class="hljs-comment">// HelloScala is a object, not a class, will create a </span><br>    <span class="hljs-function">def <span class="hljs-title">main</span><span class="hljs-params">(args : Array[<span class="hljs-keyword">String</span>])</span> : Unit =</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello,world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>可以使用插件CodeRunner直接快捷键运行。也可以在命令行编译为字节码后再运行：</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>HelloScala.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>helloScala<br></code></pre></div></td></tr></table></figure><ul><li>或者直接运行scala源文件：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">scala <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloScala</span>.</span></span>scala<br></code></pre></div></td></tr></table></figure><h1 id="3-变量与数据类型"><a href="#3-变量与数据类型" class="headerlink" title="3 变量与数据类型"></a>3 变量与数据类型</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><ul><li>和java一样</li><li><code>//</code> 单行</li><li><code>/* */</code> 多行</li><li><code>/** */</code> 文档，方法或者类前面，便于<code>scaladoc</code>生成文档。</li></ul><h2 id="3-2-变量与常量"><a href="#3-2-变量与常量" class="headerlink" title="3.2 变量与常量"></a>3.2 变量与常量</h2><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> [:VariableType] = value <span class="hljs-comment">// variable</span><br>val <span class="hljs-keyword">name</span> [:ConstantType] = value <span class="hljs-comment">// constant</span><br></code></pre></div></td></tr></table></figure><p>因为Scala的<strong>函数式编程</strong>要素，所以一个指导意见就是<strong>能用常量就不要用变量</strong></p><ul><li><strong>推断类型：</strong>声明变量时，类型可以省略，编译器会自动推导</li><li><strong>静态类型：</strong>类型<strong>经过给定或推导确定</strong>后就不能修改**</li><li><strong>初始化：</strong>变量和常量声明时，必须有初始值</li><li><strong>变量与常量：</strong>变量可变，常量不可变</li><li><strong>引用类型常量：</strong>不能改变常量指向的对象，可以改变对象的字段</li><li><strong>结尾：</strong>不以<code>;</code>作为语句结尾，scala编译器自动识别语句结尾</li></ul><h2 id="3-3-Scala的基本类型"><a href="#3-3-Scala的基本类型" class="headerlink" title="3.3 Scala的基本类型"></a>3.3 Scala的基本类型</h2><p><strong>静态语言</strong></p><p>​    Scala是<strong>静态语言</strong>，在编译期间会检查每个对象的类型。对于类型不匹配的非法操作，在编译时就能被发现。对于动态语言而言，这种非法操作需要等到运行时才能被发现，此时可能造成严重错误</p><p>​    静态语言相比诸如Python这样的动态语言在某些方面是有优势的。对于Chisel而言，我们就需要这种优势。因为Chisel需要编译成Verilog，我们不能产生非法的Verilog语句并且等到模块运行时才去发现它</p><hr><p><strong>基本类型</strong></p><p>​    Scala标准库定义了一些基本类型，如下表所示。除了“<strong>String”</strong>类型是属于<a href="https://so.csdn.net/so/search?q=java&amp;spm=1001.2101.3001.7020">java</a>.lang包之外，其余都在Scala的包里。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301120214795.png" alt="image-20220301120214795"></h2><p><strong>定义变量</strong></p><p>​    事实上，在定义变量时，应该指明变量的类型，只不过Scala的编译器具有自动推断类型的功能，可以根据赋给变量的对象的类型，来自动推断出变量的类型。</p><p>​    如果要显式声明变量的类型，或者无法推断时，则只需在变量名后面加上一个冒号“ : ”，然后在等号与冒号之间写出类型名即可。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br>x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> y: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;123&quot;</span><br>y: <span class="hljs-type">String</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br>z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>字面量</strong></p><p>​    <strong>整数</strong>有四种类型，<strong>默认情况下推断为Int</strong>类型。如果字面量的结尾有<strong>“l”</strong>或者<strong>“L”</strong>，则推断为<strong>Long</strong>类型。此外，<strong>Byte</strong>和<strong>Short</strong>则<strong>需要定义变量时显式声明</strong>。注意，赋给的字面值不能超过类型的表示范围。</p><p>​    整数字面量默认是十进制的，但如果以“0x”或者“0X”开头，则字面量被认为是十六进制。十六进制的字母不区分大小写。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">100</span><br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">0X123Abc</span><br>b: <span class="hljs-type">Int</span> = <span class="hljs-number">1194684</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Int</span>(<span class="hljs-number">200</span>)<br> required: <span class="hljs-type">Byte</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>                     ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-number">200</span>L<br>d: <span class="hljs-type">Long</span> = <span class="hljs-number">200</span><br><br></code></pre></div></td></tr></table></figure><p>​    <strong>浮点数</strong>的字面量<strong>都是十进制</strong>的，类型<strong>默认是Double</strong>类型。可以增加一个字母<strong>“e”</strong>或<strong>“E”</strong>，再添加一个整数作为指数，这样就构成10的n次幂。最末尾可以写一个<strong>“f”</strong>或者<strong>“F”</strong>，表示Float类型；也可以写一个<strong>“d</strong>”或者<strong>“D”</strong>，表示Double类型。</p><blockquote><p>注意，Double类型的字面量不能赋给Float类型的变量。虽然Float允许扩展成Double类型，但是会发生精度损失</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301121507718.png" alt="image-20220301121507718"></p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">1.2E3</span><br>a: <span class="hljs-type">Double</span> = <span class="hljs-number">1200.0</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">-3.2</span>f<br>b: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Double</span>(<span class="hljs-number">-3.2</span>)<br> required: <span class="hljs-type">Float</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.2</span>F<br>d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.200000047683716</span><br></code></pre></div></td></tr></table></figure><p><strong>字符字面量</strong></p><div class="hljs code-wrapper"><pre><code> **字符**字面量是以**单引号&#39; &#39;**包起来的一个字符，Scala中字符采用Unicode编码，可以用**&#39;\u&#39;编码号&#39;**的方式来**转义**一个Unicode字符，而且**Unicode编码**可以出现在代码的任何地方，甚至是名称命名。此外，还支持转义字符。例如</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = &#x27;<span class="hljs-type">A</span>&#x27;<br>a: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = &#x27;\u0041&#x27; <span class="hljs-comment">// \u0041对应Unicode的A</span><br>b: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = &#x27;\u0042&#x27;<br>c: <span class="hljs-type">Char</span> = <span class="hljs-type">B</span><br><br>scala&gt; <span class="hljs-keyword">val</span> \u0041\u0042 = <span class="hljs-number">1</span> <span class="hljs-comment">// 使用\u构造的Unicode字符作为变量名称</span><br><span class="hljs-type">AB</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; <span class="hljs-keyword">val</span> d = &#x27;\\&#x27; <span class="hljs-comment">//转义字符字符</span><br>d: <span class="hljs-type">Char</span> = \<br></code></pre></div></td></tr></table></figure><p><strong>字符串字面量</strong></p><p>​    <strong>字符串</strong>就是用<strong>双引号” “</strong>包起来的字符序列，长度任意，允许掺杂转义字符。此外，也可以用前后各<strong>三个双引号””” “””</strong>包起来，这样字符串里也能出现双引号，而且转义字符不会被解读</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;\\\\\\&quot;</span><br>a: <span class="hljs-type">String</span> = \\\<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;&quot;&quot;So long \u0041 String \\\&#x27;\&quot;!&quot;&quot;&quot;</span><br>b: <span class="hljs-type">String</span> = <span class="hljs-type">So</span> long <span class="hljs-type">A</span> <span class="hljs-type">String</span> \\\&#x27;\<span class="hljs-string">&quot;!</span><br></code></pre></div></td></tr></table></figure><p><strong>字符串插值</strong></p><p>​    Scala包括了一个灵活的机制来支持字符串插值，这使得<strong>表达式可以被嵌入在字符串字面量中并被求值</strong>。</p><ul><li>第一种形式是<strong>s插值器</strong>，即在字符串的双引号前加一个s，形如<strong>s“…${表达式}…”</strong>，s插值器会对内嵌的每个表达式求值，对<strong>求值结果</strong>调用内置的<strong>toString</strong>方法，替换掉字面量中的表达式。从<u>美元符号开始到首个非标识符字符</u>（字母、数字、下划线和操作符的组合，以及反引号对包起来的字符串，称为<strong>标识符</strong>）的部分会被当作表达式，如果有非标识符字符，就必须放在花括号里，且左花括号要紧跟美元符号</li><li>第二种形式是<strong>raw插值器</strong>，它与s插值器类似，只不过不识别转义字符</li><li>第三种形式是<strong>f插值器</strong>，允许给内嵌的表达式加上printf风格的指令，<strong>指令</strong>放在表达式之后并<strong>以百分号开始</strong>。指令语法来自java.util.Formatter</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;ABC&quot;</span><br>name: <span class="hljs-type">String</span> = <span class="hljs-type">ABC</span><br><br>scala&gt; println(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span> DEFG&quot;</span>)<br><span class="hljs-type">ABC</span> <span class="hljs-type">DEFG</span><br><br>scala&gt; <span class="hljs-string">s&quot;Sum = <span class="hljs-subst">$&#123;1 + 10&#125;</span>&quot;</span> <span class="hljs-comment">//</span><br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Sum</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-string">s&quot;\\\\&quot;</span><br>res1: <span class="hljs-type">String</span> = \\<br><br>scala&gt; <span class="hljs-string">raw&quot;\\\\&quot;</span>    <span class="hljs-comment">// raw插值器</span><br>res2: <span class="hljs-type">String</span> = \\\\<br><br>scala&gt; printf(<span class="hljs-string">f&quot;<span class="hljs-subst">$&#123;math.Pi&#125;</span>%.5f&quot;</span>)    <span class="hljs-comment">// f插值器  %.5f是printf风格，保留小数点后5位</span><br><span class="hljs-number">3.14159</span><br></code></pre></div></td></tr></table></figure><h1 id="4-函数及其几种形式"><a href="#4-函数及其几种形式" class="headerlink" title="4 函数及其几种形式"></a>4 函数及其几种形式</h1><h2 id="4-1-定义一个函数"><a href="#4-1-定义一个函数" class="headerlink" title="4.1 定义一个函数"></a>4.1 定义一个函数</h2><p><strong>(1) 定义一个函数</strong></p><p>​    Scala的函数定义以<strong>“def”</strong>开头，然后是一个自定义的函数名(推荐驼峰命名法)，接着是用圆括号“( )”包起来的参数列表。在参数列表里，多个参数用逗号隔开，并且每个参数名后面<strong>要紧跟一个冒号以及显式声明的参数类型</strong>，因为编译器在编译期间无法推断出入参类型。写完参数列表后，应该紧跟一个冒号，再添加函数返回结果的类型。最后，再写一个等号“=”，等号后面是用花括号“{ }”包起来的函数体。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">用<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">开始函数定义</span></span><br>       | 函数名<br>       |   |  参数及参数类型<br>       |   |        |   函数返回结果的类型<br>       |   |        |          |  等号<br>       |   |        |          |   |<br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        <span class="hljs-keyword">if</span>(x &gt; y)<br>          x<br>        <span class="hljs-keyword">else</span>  |<br>          y   | <br>      &#125;       |<br>              |<br>       花括号里定义函数体<br></code></pre></div></td></tr></table></figure><p><strong>(2) 分号推断</strong></p><p>​    在Scala的代码里，<strong>语句末尾的分号是可选的</strong>，因为编译器会自动推断分号。如果一行只有一条完整的语句，那么分号可写可不写；如果<strong>一行有多条语句，则必须用分号隔开</strong>，有三种情况句末<strong>不会推断出分号</strong>：</p><ul><li><strong>句末</strong>是以非法结尾字符结尾，例如以句点符号“.”或中缀操作符结尾</li><li><strong>下一行的句首</strong>是以非法起始字符开始，例如以句点符号“.”开头</li><li><strong>跨行</strong>出现的圆括号对“( )”或者方括号对“[ ]”，因为它们里面不能进行分号的自动推断，要么只包含一条完整语句，要么包含用分号显式隔开的多条语句。另外，花括号对“{ }”的里面可以进行分号的自动推断</li></ul><p>​    为了简洁起见，同时不产生无意的错误和歧义，<strong>建议一行只写一条完整的语句</strong>，句末分号省略，让编译器自动推断。而且内层的语句最好比外一层语句向内缩进两个空格，使得代码层次分明。</p><p><strong>(3) 函数返回结果</strong></p><p>​    在Scala里，<strong>“return”关键字也是可选的</strong>。默认情况下，编译器会自动为函数体里的最后一个表达式加上“return”，将其作为返回结果。<strong>建议不要显式声明“return”</strong>，这会引发warning，而且使得代码风格看上去像指令式风格。</p><p>​    <strong>返回结果的类型</strong>也是可以根据参数类型和返回的表达式来<strong>自动推断</strong>的，也就是说，上例中的“: Int”通常是可以省略的。</p><p>​    返回结果<strong>Unit</strong>，表示没有值返回。也就是说，这是一个有副作用的函数，并不能提供任何可引用的返回结果。Unit类型同样可以被推断出来，但如果显式声明为Unit类型的函数，则即使函数体最后有一个可以返回具体值的表达式，也不会把表达式的结果返回。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123; x + y &#125;<br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123; x + y &#125;<br>nothing: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; nothing(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p><strong>(4) 函数体与等号</strong></p><p>​    Scala的<strong>函数体是用花括号</strong>包起来的，这与C、C++、Java等语言类似。函数体里可以有多条语句，并自动推断分号、返回最后一个表达式。如果<strong>只有一条语句，那么花括号也可以省略</strong>。</p><p>​    Scala的<strong>函数定义还有一个等号</strong>，这使得它看起来类似数学里的函数“f(x) = …”。当函数的返回类型没有显式声明时，那么这个<strong>等号可以省略，但是返回类型一定会被推断成Unit类型</strong>，不管有没有值返回，而且<strong>函数体必须有花括号</strong>。当函数的返回类型显式声明时，则无论如何<strong>都不能省略等号</strong>。<strong>建议写代码时不要省略等号</strong>，避免产生不必要的错误，返回类型最好也显式声明。</p><p>总结：</p><ul><li>花括号：<ul><li>可以省略：只有一条语句</li><li>不可以省略：省略”=”时</li></ul></li><li>“=”：<ul><li>可以省略：返回值没有显式声明，此时返回值一定是Unit类型</li><li>不可以省略：返回值显式声明</li></ul></li></ul><p><strong>(5) 无参函数</strong></p><p>​    <strong>无参函数</strong>可以<strong>写一个空括号作参数列表</strong>，或者<strong>不写</strong>。如果有空括号，那么调用时可以写也可以不写空括号；如果没有空括号，那么调用时就一定不能写空括号。原则上，<strong>无副作用</strong>的无参函数<strong>省略括号</strong>，<strong>有副作用</strong>的无参函数<strong>添加括号</strong>，这提醒使用者需要额外小心</p><p>无参函数总结：</p><ul><li>写括号<ul><li>建议有副作用函数</li><li>调用时可以不写括号，也可以写括号</li></ul></li><li>不写括号<ul><li>建议无副作用函数</li><li>调用时只可以不写括号</li></ul></li></ul><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>​    方法其实就是定义在class、object、trait里面的函数，这种函数叫做“成员函数”或者“方法”，与多数oop(object-oriented programming)语言一样</p><h2 id="4-3-嵌套函数"><a href="#4-3-嵌套函数" class="headerlink" title="4.3 嵌套函数"></a>4.3 嵌套函数</h2><p>​    函数体内部还可以定义函数，这种函数的<strong>作用域是局部的</strong>，<strong>只能被定义它的外层函数调用</strong>，<strong>外部无法</strong>访问。局部函数可以直接使用外层函数的参数，也可以直接使用外层函数的内部变量。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addSub</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span></span>(z: <span class="hljs-type">Int</span>) = z - <span class="hljs-number">10</span><br>         |     <span class="hljs-keyword">if</span>(x &gt; y) sub(x - y) <span class="hljs-keyword">else</span> sub(y - x)<br>         | &#125;<br>addSub: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addSub(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">70</span><br></code></pre></div></td></tr></table></figure><h2 id="4-4-函数字面量"><a href="#4-4-函数字面量" class="headerlink" title="4.4 函数字面量"></a>4.4 函数字面量</h2><p>​    <strong>函数式编程</strong>有两个主要思想，其中之一就是：<strong>函数是一等(first-class)的值</strong>。换句话说，一个函数的地位与一个Int值、一个String值等等，是一样的（既然一个Int值可以成为函数的参数、函数的返回值、定义在函数体里、存储在变量里，那么，作为地位相同的函数，也可以这样）。</p><p>​    你可以把<strong>一个函数当参数</strong>传递给另一个函数，也可以让一个函数<strong>返回一个函数</strong>，亦可以把<strong>函数赋给一个变量</strong>，又或者像定义一个值那样<strong>在函数里定义别的函数</strong>(即前述的嵌套函数)。就像写一个整数字面量“1”那样，Scala也可以<strong>定义函数的字面量</strong>。<strong>函数字面量是一种匿名函数的形式</strong>，它可以存储在变量里、成为函数参数或者当作函数返回值，其定义形式为：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(参数<span class="hljs-number">1</span>: 参数<span class="hljs-number">1</span>类型, 参数<span class="hljs-number">2</span>: 参数<span class="hljs-number">2</span>类型, ...) =&gt; &#123; 函数体 &#125;<br></code></pre></div></td></tr></table></figure><p>​    <strong>通常，函数字面量会赋给一个变量</strong>，这样就能通过“变量名(参数)”的形式来使用函数字面量。在参数类型可以被推断的情况下，可以省略类型，并且参数只有一个时，圆括号也可以省略。</p><ul><li>圆括号省略：参数只有一个时</li><li>类型省略：类型可以被推断时</li></ul><p>​    <strong>只保留函数体时</strong>，<strong>用下划线“_”作为占位符来代替参数</strong>。在<strong>参数类型不明确时</strong>，需要在下划线后面显式声明其类型。<strong>多个占位符代表多个参数(占位符也可以在大括号函数体内)</strong>，即第一个占位符是第一个参数，第二个占位符是第二个参数……因此不能重复使用某个参数。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> f = (_: <span class="hljs-type">Int</span>) + (_: <span class="hljs-type">Int</span>)<br>f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1072</span>/<span class="hljs-number">1534177037</span><span class="hljs-meta">@fb</span>42c1c<br><br>scala&gt; f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>​    <strong>函数字面量作为返回值：</strong>无论是用“def”定义的函数，还是函数字面量，它们的函数体都可以把一个函数字面量作为一个返回结果，这样就成为了返回函数的函数；它们的参数变量的类型也可以是一个函数，这样调用时给的入参就可以是一个函数字面量。类型为函数的变量，其冒号后面的类型写法是“(参数1类型, 参数2类型,…) =&gt; 返回结果的类型”。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> add = (x: <span class="hljs-type">Int</span>) =&gt; &#123; (y: <span class="hljs-type">Int</span>) =&gt; x + y &#125;<br>add: <span class="hljs-type">Int</span> =&gt; (<span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1192</span>/<span class="hljs-number">1767705308</span>@<span class="hljs-number">55456711</span><br><br>scala&gt; add(<span class="hljs-number">1</span>)(<span class="hljs-number">10</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aFunc</span></span>(f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>aFunc: (f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; aFunc(x =&gt; x + <span class="hljs-number">1</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>​    在第一个例子中，变量add被赋予了一个返回函数的函数字面量。在调用时，第一个括号里的“1”是传递给参数x，第二个括号里的“10”是传递给参数y。如果没有第二个括号，得到的就不是11，而是“(y: Int) =&gt; 1 + y”这个函数字面量。</p><p>​    在第二个例子中，函数aFunc的参数f是一个函数，并且该函数要求是一个入参为Int类型、返回结果也是Int类型的函数。在调用时，给出了函数字面量“x =&gt; x + 1”。这里没有显式声明x的类型，因为可以通过f的类型来推断出x必须是一个Int类型。在执行时，首先求值f(1)，结合参数“1”和函数字面量，可以算出结果是2。那么，“f(1) + 1”就等于3了。</p><h2 id="4-5-部分应用函数"><a href="#4-5-部分应用函数" class="headerlink" title="4.5 部分应用函数"></a>4.5 部分应用函数</h2><p>​    部分应用函数（使得def函数实现函数一等值效果）：给出一部分参数的情况下，赋值给一个变量</p><p>​    上面介绍的函数字面量实现了函数作为一等值的功能，而用“def”定义的函数也具有同样的功能，只不过需要借助部分应用函数的形式来实现。例如，有一个函数定义为“def max(…) …”，若想要把这个函数存储在某个变量里，不能直接写成“val x = max”的形式，而<strong>必须像函数调用那样，给出一部分参数</strong>，故而称作<strong>部分应用函数</strong>(如果参数全给了，就成了函数调用)。<strong>部分应用函数的作用</strong>，就是把def函数打包到一个函数值里，使它可以赋给变量，或当作函数参数进行传递。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//定义了一个函数</span><br>sum: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = sum(<span class="hljs-number">1</span>, _: <span class="hljs-type">Int</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">//提供了一个参数</span><br>b: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1204</span>/<span class="hljs-number">1037479646</span>@<span class="hljs-number">5</span>b0bfe86<br><br>scala&gt; b(<span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = sum _   <span class="hljs-comment">//一个参数都没有给出，像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</span><br>c: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1208</span>/<span class="hljs-number">1853277442</span>@<span class="hljs-number">5e4</span>c26a1<br><br>scala&gt; c(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><p>​    变量a其实是获得了函数sum调用的返回结果，变量b则是获得了部分应用函数打包的sum函数，因为只给出了参数x和z的值，参数y没有给出。注意，<strong>没给出的参数用下划线代替，而且必须显式声明参数类型</strong>。变量c也是部分应用函数，只不过一个参数都没有明确给出。<strong>像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</strong>，注意函数名和下划线之间必须有空格。</p><p>​    如果部分应用函数一个参数都没有给出，比如例子中的c，那么在需要该函数作入参的地方，下划线也可以省略（注：不要和前面给变量赋值的部分应用函数混淆，前者需要有下划线）。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">needSum</span></span>(f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>needSum: (f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br><span class="hljs-comment">//在需要c函数作入参的地方</span><br><br>scala&gt; needSum(sum _) <span class="hljs-comment">//下划线</span><br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; needSum(sum) <span class="hljs-comment">//省略下划线</span><br>res3: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><h2 id="4-6-闭包"><a href="#4-6-闭包" class="headerlink" title="4.6 闭包"></a>4.6 闭包</h2><p>​    一个函数除了可以使用它的参数外，还能<strong>使用定义在函数以外的其他变量</strong>。</p><ul><li><p>函数的参数称为<strong>绑定变量</strong>，因为完全可以根据函数的定义得知参数的信息</p></li><li><p>函数以外的变量称为<strong>自由变量</strong>，因为函数自身无法给出这些变量的定义</p></li></ul><p>​    这样的函数称为<strong>闭包</strong>，因为它要在运行期间捕获自由变量，让函数闭合，定义明确。自由变量必<strong>须在函数前面定义</strong>，否则编译器就找不到，会报错。</p><p>​    闭包捕获的自由变量是闭包创建时活跃的那个自由变量，后续若<strong>新建同名的自由变量来覆盖前面的定义</strong>，由于闭包已经闭合完成，所以新自由变量与已创建的闭包无关。如果闭包捕获的自由变量本身是一个可变对象(例如var类型变量)，那么闭包会随之改变。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> more = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">val</span> addMore = (x: <span class="hljs-type">Int</span>) =&gt; x + more  <span class="hljs-comment">// addMore = x + 1</span><br><br>more = <span class="hljs-number">2</span>                                           <span class="hljs-comment">// addMore = x + 2</span><br><br><span class="hljs-keyword">var</span> more = <span class="hljs-number">10</span>                                   <span class="hljs-comment">// addMore = x + 2</span><br><br>more = <span class="hljs-number">-100</span>                                      <span class="hljs-comment">// addMore = x + 2</span><br></code></pre></div></td></tr></table></figure><h2 id="4-7-函数的体术调用形式"><a href="#4-7-函数的体术调用形式" class="headerlink" title="4.7 函数的体术调用形式"></a>4.7 函数的体术调用形式</h2><p><strong>（1）具名参数</strong>（就是普通用法）</p><p>​    <strong>普通函数</strong>调用形式是<strong>按参数的先后顺序逐个传递的</strong>，但如果调用时显式声明参数名并给其赋值，则可以无视参数顺序。按位置传递的参数和按名字传递的参数可以混用，例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(<span class="hljs-number">1</span>, z = <span class="hljs-number">10</span>, y = <span class="hljs-number">100</span>)<br>y is maximum <br></code></pre></div></td></tr></table></figure><p><strong>（2）默认参数值（和以前学的一样）</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(y = <span class="hljs-number">3</span>, z = <span class="hljs-number">5</span>)<br>x is maximum<br></code></pre></div></td></tr></table></figure><p><strong>（3）重复参数（类似C中的arg*）</strong></p><p>​    Scala允许把<strong>函数的最后一个参数标记为重复参数</strong></p><p>​    形式为在最后一个参数的类型后面加上星号<strong>“*</strong>”。重复参数的意思是可以在运行时传入任意个相同类型的元素，包括零个。<strong>类型为“T*”的参数的实际类型是“Array[T]”</strong>，即若干个T类型对象构成的数组（尽管是T类型的数组，但<strong>要求传入参数的类型仍然是T</strong>，如果传入的<strong>实参是T类型对象构成的数组，则会报错</strong>，除非用<strong>“变量名: _*</strong>”的形式告诉编译器把数组元素一个一个地传入）</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addMany</span></span>(msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*) = &#123;undefined<br>         |     <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>         |     <span class="hljs-keyword">for</span>(x &lt;- num) sum += x<br>         |     println(msg + sum)<br>         |  &#125;<br>addMany: (msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*)<span class="hljs-type">Unit</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>sum = <span class="hljs-number">6</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>)<br>sum = <span class="hljs-number">0</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]<br> required: <span class="hljs-type">Int</span><br>       addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>                              ^<br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): _*)<br>sum = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><h2 id="4-8-柯里化"><a href="#4-8-柯里化" class="headerlink" title="4.8 柯里化"></a>4.8 柯里化</h2><p>​    对大多数编程语言来说，<strong>函数只能有一个参数列表</strong>，但是列表里可以有若干个用逗号间隔的参数。</p><p>​    Scala有一个独特的语法——<strong>柯里化</strong>，也就是一个函数可以<strong>有任意个参数列表</strong>。</p><p>​    柯里化往往与另一个语法结合使用：当参数列表里只有一个参数时，在调用该函数时允许单个参数不用圆括号包起来，改用花括号也是可行的。</p><p>​    这样做的<strong>好处是</strong>：在自定义类库时，自定义方法就好像“if(…) {…}”、“while(…) {…}”、“for(…) {…}”等内建控制结构一样，让人看上去<strong>以为是内建控制</strong>，丝毫看不出是自定义语法。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//普通相加函数</span><br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addCurry</span></span>(x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//柯里化，addCurry拥有三个参数列表</span><br>addCurry: (x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) &#123;<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//用&#123;&#125;代替()的参数列表，从而表现得if,while,for等内建结构一样</span><br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><h2 id="4-9-传名参数（把函数作为形参情况下的简洁用法）"><a href="#4-9-传名参数（把函数作为形参情况下的简洁用法）" class="headerlink" title="4.9 传名参数（把函数作为形参情况下的简洁用法）"></a>4.9 传名参数（把函数作为形参情况下的简洁用法）</h2><p>​    4.4介绍了<strong>函数字面量</strong>如何作为函数的参数进行传递，以及如何表示类型为函数时参数的类型。如果某个函数的入参类型是一个无参函数，那么通常的类型表示法是“() =&gt; 函数的返回类型”。在调用这个函数时，给出的参数就必须写成形如<strong>“() =&gt; 函数体”</strong>这样的函数字面量</p><p><strong>（1）传名参数是什么</strong></p><p>​    <strong>为了让代码看起来更舒服</strong>，也为了让自定义控制结构<strong>更像内建结构</strong>，Scala又提供了一个特殊语法——<strong>传名参数</strong>。</p><p>​    <strong>传名参数</strong>是类型是一个无参函数的<strong>函数入参</strong>。传名参数的类型表示法是<strong>“=&gt; 函数的返回类型”</strong>，即<strong>相对常规表示法去掉了前面的空括号</strong>。在调用该函数时，传递进去的函数字面量则可以只写“函数体”，去掉了“() =&gt;”。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> assertionEnabled = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// predicate是类型为无参函数的函数入参</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAssert</span></span>(predicate: () =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 常规版本的调用</span><br>myAssert(() =&gt; <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br><br> <span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// 传名参数的用法，注意因为去掉了空括号，所以调用predicate时不能有括号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byNameAssert</span></span>(predicate: =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 传名参数版本的调用，看上去更自然</span><br>byNameAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p> <strong>（2）调用函数与传名参数的一致性写法</strong></p><p>​    可以看到，传名参数使得代码更加简洁、自然，而常规写法则很别扭。事实上，predicate的类型可以改成Boolean的<strong>一个变量</strong>，而不必是一个<strong>返回Boolean的函数</strong>，这样<strong>调用函数时与传名参数是一致的</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 使用布尔型参数的版本</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boolAssert</span></span>(predicate: <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><span class="hljs-comment">// 布尔型参数版本的调用</span><br>boolAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p><strong>（3）调用机制说明</strong></p><p>​    尽管byNameAssert和boolAssert在调用形式上是一样的，但是两者的运行机制却不完全一样。如果给函数的实参是一个表达式，比如“5 &gt; 3”这样的表达式，那么boolAssert在运行之前会先对表达式求值，然后把求得的值传递给函数去运行。而myAssert和byNameAssert则不会一开始就对表达式求值，它们是直接运行函数，直到函数调用入参时才会对表达式求值，也就是例子中的代码运行到“!predicate”时才会求“5 &gt; 3”的值。</p><p>​    为了说明这一点，可以传入一个产生异常的表达式，例如除数为零的异常。例子中，逻辑与“&amp;&amp;”具有短路机制：如果&amp;&amp;的左侧是false，那么直接跳过右侧语句的运行(事实上，这种短路机制也是通过传名参数实现的)。所以，布尔型参数版本会抛出除零异常，常规版本和传名参数版本则不会发生任何事。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure><div class="hljs code-wrapper"><pre><code> 如果把变量assertionEnabled设置为true，让&amp;&amp;右侧的代码执行，那么三个函数都会抛出除零异常：</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; assertionEnabled = <span class="hljs-literal">true</span><br>assertionEnabled: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res30$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .myAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res31$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .byNameAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure><h2 id="4-10-章节总结"><a href="#4-10-章节总结" class="headerlink" title="4.10 章节总结"></a>4.10 章节总结</h2><p>​    本章内容是对Scala的函数的讲解，重点在于理解函数作为一等值的概念，函数字面量的作用以及部分应用函数的作用。在阅读复杂的代码时，常常遇见诸如<strong>“def xxx(f: T =&gt; U, …) …”或 “def xxx(…): T =&gt; U”</strong>的代码，要理解前者表示需要传入一个函数作为参数，后者表示函数返回的对象是一个函数。在学习初期，理解函数是一等值的概念可能有些费力，通过大量阅读和编写代码才能熟能生巧。同时不要忘记前一章说过，<strong>函数的参数都是val类型的，在函数体内不能修改传入的参数。</strong></p><h1 id="5-类和对象"><a href="#5-类和对象" class="headerlink" title="5 类和对象"></a>5 类和对象</h1><h2 id="5-1-类"><a href="#5-1-类" class="headerlink" title="5.1 类"></a>5.1 类</h2><p>说了一堆废话，和Java差不多就是</p><blockquote><p>​        在Scala里，类是用关键字<strong>“class”</strong>开头的代码定义。它是对象的<strong>蓝图</strong>，一旦定义完成，就可以通过<strong>“new 类名”</strong>的方式来<strong>构造一个对象</strong>。而这个对象的类型，就是这个类。换句话说，一个类就是一个类型，不同的类就是不同的类型。在后续的章节中，会讲到类的继承关系，以及超类、子类和子类型多态的概念。</p><p>​    在类里可以定义val或var类型的变量，它们被称为“<strong>字段</strong>”；还可以定义“def”函数，它们被称为<strong>“方法”</strong>；字段和方法统称<strong>“成员”</strong>。字段通常用于保存对象的状态或数据，而方法则用于承担对象的计算任务。<strong>字段也叫“实例变量”</strong></p></blockquote><p>​    <strong>介绍对象在操作系统中的情况：</strong></p><blockquote><p>因为每个被构造出来的对象都有其自己的字段。在运行时，操作系统会为每个对象分配一定的内存空间，用于保存对象的字段。方法则不同，对所有对象来说，方法都是一样的程序段，因此不需要为某个对象单独保存其方法。而且，方法的代码只有在被调用时才会被执行，如果一个对象在生命周期内都没有调用某些方法，那么完全没必要浪费内存为某个对象去保存这些无用的代码</p></blockquote><p>​    <strong>访问对象：</strong></p><p>​    <strong>需要注意的是</strong>，val类型的变量只能与初始化时的对象绑定，<strong>不能再被赋予新的对象（相同类也不行）</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">1</span>a2e563e<br><br>scala&gt; stu.name<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">None</span><br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>res2: <span class="hljs-type">String</span> = <span class="hljs-type">Bob</span><br><br>scala&gt; stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>  <span class="hljs-comment">//无法重新赋值给一个变量</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: reassignment to <span class="hljs-keyword">val</span><br>       stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>           ^<br></code></pre></div></td></tr></table></figure><p>​    Scala的<strong>类成员默认都是公有的</strong>，<strong>没有“public”这个关键字</strong>，有private作为私有成员，示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(name)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">75063</span>bd0<br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: variable name in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">cannot</span> <span class="hljs-title">be</span> <span class="hljs-title">accessed</span> <span class="hljs-title">in</span> <span class="hljs-title">Students</span></span><br>       stu.name<br>           ^<br><br>scala&gt; stu.display<br><span class="hljs-type">Bob</span><br></code></pre></div></td></tr></table></figure><h2 id="5-2-类的构造方法"><a href="#5-2-类的构造方法" class="headerlink" title="5.2 类的构造方法"></a>5.2 类的构造方法</h2><p><strong>（1）主构造方法</strong></p><ul><li><p>Scala不需要显式定义构造方法 ，而是把<strong>类内部非字段、非方法的代码都</strong>当作<strong>“主构造方法”</strong></p><ul><li><strong>大白话</strong>：没有用函数框框起来的都是主构造方法</li></ul></li><li><p>类名后面可以定义<strong>若干个参数列表</strong>，用于接收参数，这些参数将在构造对象时用于初始化字段并传递给主构造方法使用。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-type">A</span> student named <span class="hljs-type">Tom</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">5464</span>eb28<br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>（了解）在这个例子中，Students类接收一个String参数n，并用n来初始化字段name。这样做，就无需像之前那样把name定义成var类型，而是使用函数式风格的val类型，而且不再需要一个register方法在构造对象时来更新name的数据</p><p>函数println既不是字段，也不是方法定义，所以被当成是主构造函数的一部分。在构造对象时，主构造函数被执行，因此在解释器里打印了相关信息</p></blockquote><p><strong>（2）辅助构造方法</strong></p><p>​    除了主构造方法，<strong>还可以定义若干个辅助构造方法</strong>。辅助构造方法都是以<strong>“def this(……)”</strong>来开头的，而且<strong>第一步行为必须是调用该类的另一个构造方法</strong>，即第一条语句必须是“this(……)”——要么是主构造方法，要么是之前的另一个辅助构造方法。这种规则的结果就是任何构造方法<strong>最终都会调用该类的主构造方法</strong>，使得主构造方法成为类的<strong>单一入口</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;None&quot;</span>) <span class="hljs-comment">//辅助构造方法</span><br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br><span class="hljs-type">A</span> student named <span class="hljs-type">None</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">74309</span>cd5<br><br></code></pre></div></td></tr></table></figure><blockquote><p>在这个例子中，定义了一个辅助构造方法，该方法是无参的，其行为也仅是给主构造方法传递一个字符串“None”。在后面创建对象时，缺省了参数，这样与主构造方法的参数列表是不匹配的，但是与辅助构造方法匹配，所以stu指向的对象是用辅助构造方法构造的。</p><p>在Java里，辅助构造方法可以调用超类的构造方法，而Scala加强了限制，只允许主构造方法调用超类的构造方法(详情见后续章节)。这种限制源于Scala为了代码简洁性与简单性做出的折衷处理。</p></blockquote><p><strong>（3）析构函数</strong>（也就是没有）</p><p>​    因为Scala没有指针，同时使用了Java的垃圾回收器，所以不需要像C++那样定义析构函数</p><p><strong>（4）私有主构造方法</strong></p><p>​    在<strong>类名与类的参数列表之间</strong>加上关键字<strong>“private”</strong>，那么<strong>主构造方法</strong>就是<strong>私有的</strong>，<strong>只能被内部定义访问</strong>，外部代码构造对象时就<strong>不能通过主构造方法进行</strong>，而<strong>必须使用其他公有的辅助构造方法或工厂方法</strong>(专门用于构造对象的方法)。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">private</span> (<span class="hljs-params">n: <span class="hljs-type">String</span>, m: <span class="hljs-type">Int</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">val</span> score = m<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(n: <span class="hljs-type">String</span>) = <span class="hljs-keyword">this</span>(n, <span class="hljs-number">100</span>)<br>         |    println(n + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + m)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: too many arguments (<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> constructor <span class="hljs-type">Students</span>: (n: <span class="hljs-type">String</span>)<span class="hljs-type">Students</span><br>       <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>                                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>)<br><span class="hljs-type">Bill</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">7509</span>b8e7<br></code></pre></div></td></tr></table></figure><h2 id="5-3-重写toString方法"><a href="#5-3-重写toString方法" class="headerlink" title="5.3 重写toString方法"></a>5.3 重写toString方法</h2><p>toString构造完一个对象时自动被调用的那个方法</p><blockquote><p>​    细心的读者会发现，在前面构造一个Students类的对象时，Scala解释器打印了一串晦涩的信息“Students@7509b8e7”。这其实来自于Students类的toString方法，这个方法返回一个字符串，并在<strong>构造完一个对象时被自动调用</strong>，返回结果交给解释器打印。该方法是所有Scala类<strong>隐式继承</strong>来的，如果不重写这个方法，就会用默认继承的版本。</p></blockquote><p>​    默认的toString方法来自于<strong>java.lang.Object类</strong>，其行为只是简单地打印类名、一个“@”符号和一个十六进制数。如果想让解释器输出更多有用的信息，则可以自定义toString方法。不过，这个方法是继承来的，要重写它必须在前面加上<strong>关键字“override”</strong>(后续章节会讲到override的作用)。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Nancy&quot;</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">A</span> student named <span class="hljs-type">Nancy</span>.<br></code></pre></div></td></tr></table></figure><h2 id="5-4-方法重载"><a href="#5-4-方法重载" class="headerlink" title="5.4 方法重载"></a>5.4 方法重载</h2><p>​    在类里定义了<strong>多个同名的方法</strong>，但是每个方法的<strong>参数(主要是参数类型)不一样</strong>，那么就称这个方法有多个不同的版本。这就叫方法重载，它是面向对象里多态属性的一种表现。这些方法虽然同名，但是它们是不同的，因为函数真正的特征标是它的参数，而不是函数名或返回类型。</p><p>​    注意重载与前面的重写的区别，重载是一个类里有多个不同版本的同名方法，重写是子类覆盖定义了超类的某个方法。</p><h2 id="5-5-类的参数"><a href="#5-5-类的参数" class="headerlink" title="5.5 类的参数"></a>5.5 类的参数</h2><ul><li><strong>前面的例子：</strong>从前面的例子可以发现，<strong>很多时候类的参数仅仅是直接赋给某些字段</strong>。</li><li><strong>参数自动复制到内部成员：</strong>Scala为了进一步简化代码，允许在类参数前加上<strong>val或var来修饰</strong>，这样就会在类的内部会生成<strong>一个与参数同名的公有字段</strong>。构造对象时，<strong>这些参数会直接复制给同名字段</strong>。</li><li><strong>参数限定权限：</strong>除此之外，还可以加上<strong>关键字private、protected或override来表明字段的权限</strong>(<a href="#限定词与自限定"><strong>关于权限修饰见后续章节</strong></a>)。如果<strong>参数没有任何关键字，那它就仅仅是“参数”，不是类的成员</strong>，只能用来初始化字段或给方法使用。外部不能访问这样的参数，内部也不能修改它。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;undefined <span class="hljs-comment">//此处用val和var分别修饰了name和score</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">90</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">90.</span><br><br>scala&gt; stu.exam(<span class="hljs-number">100</span>)<br><br>scala&gt; stu.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure><h2 id="5-6-单例对象与伴生对象（静态变量）"><a href="#5-6-单例对象与伴生对象（静态变量）" class="headerlink" title="5.6 单例对象与伴生对象（静态变量）"></a>5.6 单例对象与伴生对象（静态变量）</h2><blockquote><div class="hljs code-wrapper"><pre><code> 在Scala里，除了用new可以构造一个对象，也可以用“object”开头定义一个对象。它类似于类的定义，只不过不能像类那样有参数，也没有构造方法。因此，不能用new来实例化一个object的定义，因为它已经是一个对象了。</code></pre></div><p>​    <strong>单例对象定义</strong>：用“object”开头定义一个对象对象和用new实例化出来的对象没有什么区别，只不过new实例的对象是以类为蓝本构建的，并且数量没限制，而<strong>object定义的对象只能有这一个</strong>，故而得名<strong>“单例对象”</strong>。</p><p>​    </p></blockquote><ul><li><p>class：定义一个类</p></li><li><p>object：定义一个单例对象</p></li><li><p>new：实例化一个对象</p></li></ul><hr><blockquote><p><strong>伴生对象定义</strong>：如果某个单例对象和某个类同名，那么<strong>单例对象称为</strong>这个类的<strong>“伴生对象”</strong>，同样，<strong>类称</strong>为这个<strong>单例对象的“伴生类”</strong>。<strong>伴生类和伴生对象必须在同一个文件</strong>里，而且两者可以<strong>互访对方所有</strong>成员。</p></blockquote><ul><li>同名的某个类：<strong>伴生类</strong></li><li>同名的单例对象：<strong>伴生对象</strong></li><li>伴生类和伴生对象必须在同一文件中</li></ul><hr><blockquote><p>​    在C++、Java等oop语言里，类内部可以定义静态变量。这些静态变量不属于任何一个用new实例化的对象，而是它们的公有部分。Scala追求纯粹的面向对象属性，即所有的事物都是类或对象，但是静态变量这种不属于类也不属于对象的事物显然违背了Scala的理念。所以，Scala的做法是<strong>把类内所有的静态变量从类里移除</strong>，转而<strong>集中定义在伴生对象里</strong>，让静态变量属于伴生对象这个独一无二的对象。</p><p>​    既然单例对象和new实例的对象一样，那么类内可以定义的代码，单例对象同样可以拥有。例如，单例对象里面可以定义字段和方法。Scala允许在类里定义别的类和单例对象，所以单例对象也可以包含别的类和单例对象的定义。</p></blockquote><p>单例对象的<strong>作用</strong>：</p><ul><li><strong>用作伴生对象</strong></li><li>打包某方面功能的函数系列成为一个<strong>工具集</strong></li><li>包含<strong>主函数</strong>成为程序的入口</li></ul><hr><blockquote><p>“object”后面定义的<strong>单例对象名</strong>可以认为是这个单例对象的<strong>名称标签</strong>，因此可以通过句点符号访问单例对象的成员——“单例对象名.成员”，<strong>也可以赋给一个变量</strong>——“val 变量 = 单例对象名”，<strong>就像用new实例的对象那样</strong>。</p></blockquote><ul><li><p>名称标签：“object”后面定义的单例对象名</p></li><li><p>定义方式：object可以赋值给一个变量，就和new实例化一样</p></li></ul><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7e5831</span>c4<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; (<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>).a<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span> </span>&#123; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;a singleton object&quot;</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-type">B</span>.b<br>res2: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-type">B</span><br>y: <span class="hljs-type">B</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">B</span>$@<span class="hljs-number">4489</span>b853<br><br>scala&gt; y.b<br>res3: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br></code></pre></div></td></tr></table></figure><hr><p><strong>object.type：</strong></p><p>​    前面说过，<strong>定义一个类，就是定义了一种类型</strong>。从抽象层面讲，<strong>定义单例对象却并没有定义一种类型</strong>。实际上<strong>每个单例对象有自己独特的类型</strong>，即<strong>object.type</strong>（可以认为新类型出现了，只不过这个类型并不能用来归类某个对象集合，等同于没有定义新类型）</p><p>​    即使是<strong>伴生对象也没有定义类型</strong>，而是<strong>由伴生类定义了同名的类型</strong>。后续章节将讲到，单例对象可以<strong>继承自超类</strong>或<strong>混入特质</strong>，这样它就能<strong>出现在需要超类对象的地方</strong>。例如下面的例子中，可以明确看到X.type和Y.type两种新类型出现，并且是不一样的：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br><br>scala&gt; <span class="hljs-keyword">var</span> x = <span class="hljs-type">X</span><br>x: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">X</span>$@<span class="hljs-number">630</span>bb67<br><br>scala&gt; x = <span class="hljs-type">Y</span><br>&lt;console&gt;:<span class="hljs-number">17</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Y</span>.<span class="hljs-keyword">type</span><br> required: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span><br>       x = <span class="hljs-type">Y</span><br>           ^<br></code></pre></div></td></tr></table></figure><h2 id="5-7-工厂对象与工厂方法"><a href="#5-7-工厂对象与工厂方法" class="headerlink" title="5.7 工厂对象与工厂方法"></a>5.7 工厂对象与工厂方法</h2><p>​    如果定义<strong>一个方法专门用来构造某一个类的对象</strong>，那么<strong>这种方法</strong>就称为<strong>“工厂方法”。</strong>包含这些工厂方法集合的单例对象，也就叫<strong>“工厂对象”</strong> 。</p><p>工厂对象的使用场景和好处：</p><div class="hljs code-wrapper"><pre><code>+ 通常，**工厂方法会定义在伴生对象里**。+ 当一系列类存在继承关系时，可以在基类的伴生对象里定义一系列对应的工厂方法。+ **使用工厂方法的好处**是可以不用直接使用new来实例化对象，改用方法调用，而且方法名可以是任意的，这样**对外隐藏了类的实现细节**。例如：</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">registerStu</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    将文件students.scala编译后，并在解释器里用<strong>“import Students._</strong>”导入单例对象后，就能这样使用：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = registerStu(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment">//利用工厂方法生成对象</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100.</span><br></code></pre></div></td></tr></table></figure><h2 id="5-8-一个特殊的方法：apply方法"><a href="#5-8-一个特殊的方法：apply方法" class="headerlink" title="5.8 一个特殊的方法：apply方法"></a>5.8 一个特殊的方法：apply方法</h2><blockquote><p>如果定义了这个方法，那么既可以显式调用——“对象.apply(参数)” ，也可以隐式调用——“对象(参数)”。隐式调用时，编译器会自动插入缺失的“.apply”。如果apply是无参方法，应该写出空括号，否则无法隐式调用。无论是类还是单例对象，都能定义这样的apply方法。</p></blockquote><p><strong>apply方法特殊点：</strong>这个方法可以进行隐式调用，如果是无参方法应有空括号，无论是类还是单例对象都可以定义apply方法</p><p><strong>apply方法的调用：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">对象(参数)  <span class="hljs-comment">//隐式，省略了.apply</span><br>对象.apply(参数)<span class="hljs-comment">//显式，和正常调用方法一样</span><br></code></pre></div></td></tr></table></figure><p><strong>apply方法使用场景：</strong></p><ul><li><strong>在伴生对象里定义名为apply的工厂方法，就能通过“伴生对象名(参数)”来构造一个对象。</strong></li><li>也常常在类里定义一个与类相关的、具有特定行为的apply方法，<strong>让使用者可以隐式调用，进而隐藏相应的实现细节</strong>。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-9-主函数"><a href="#5-9-主函数" class="headerlink" title="5.9 主函数"></a>5.9 主函数</h2><p>​    <strong>主函数是Scala程序唯一的入口</strong>，即程序是从主函数开始运行的。要提供这样的入口，则必须<strong>在某个单例对象里定义一个名为“main”的函数</strong>，而且<strong>该函数只有一个参数</strong>，<strong>类型为字符串数组Array[String]</strong>，函数的<strong>返回类型是Unit</strong>。<strong>任何符合条件的单例对象都能成为程序的入口</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br> <br><span class="hljs-comment">// main.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> score = args(<span class="hljs-number">1</span>).toInt<br>      <span class="hljs-keyword">val</span> s = <span class="hljs-type">Students2</span>(args(<span class="hljs-number">0</span>), score)<br>      println(s.toString)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">ArrayIndexOutOfBoundsException</span> =&gt; println(<span class="hljs-string">&quot;Arguments are deficient!&quot;</span>)<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Second argument must be a Int!&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>使用命令<code>scalac students2.scala main.scala</code>将两个文件编译后</p></li><li><p>用命令<code>scala Start 参数1 参数2</code>来运行程序。（命令里的“Start”就是包含主函数的单例对象的名字，后面可以输入若干个用空格间隔的参数。这些参数被打包成字符串数组供主函数使用，也就是代码里的args(0)、args(1)。）</p></li></ul><p>示例代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom<br>Arguments are deficient!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom aaa<br>Second argument must be a Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom <span class="hljs-number">100</span><br>Tom<span class="hljs-string">&#x27;s score is 100.</span><br></code></pre></div></td></tr></table></figure><hr><p>​    <strong>主函数的一种简化写法是让单例对象混入“App”特质</strong>(特质在后续章节讲解)，这样就<strong>只要在单例对象里编写主函数的函数体</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// main2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(arg &lt;- args) &#123;<br>      sum += arg.toInt<br>    &#125;<br>    println(<span class="hljs-string">&quot;sum = &quot;</span> + sum)<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Arguments must be Int!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将文件编译后，就可以如下使用：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> AAA<br>Arguments must be Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> <span class="hljs-number">8</span><br>sum = <span class="hljs-number">30</span><br></code></pre></div></td></tr></table></figure><h2 id="5-10-章节总结"><a href="#5-10-章节总结" class="headerlink" title="5.10 章节总结"></a>5.10 章节总结</h2><p>​    本章讲解了Scala的类和对象，从中可以初窥Scala在语法精简和便捷上的努力。<strong>难点是</strong>理解单例对象的概念、类与类型的关系和工厂方法的作用。如果读者有其他oop语言基础，在这里也并不是能一下就接受Scala的语法。最后一个重点就是学会灵活使用apply方法。</p><h1 id="6-操作符即方法"><a href="#6-操作符即方法" class="headerlink" title="6 操作符即方法"></a>6 操作符即方法</h1><h2 id="6-1-操作符在Scala里的解释"><a href="#6-1-操作符在Scala里的解释" class="headerlink" title="6.1 操作符在Scala里的解释"></a>6.1 操作符在Scala里的解释</h2><blockquote><p>​    在诸如C++、Java等oop语言里，定义了像byte、short、int、char、float之类的基本类型，但是<strong>这些基本类型不属于面向对象的范畴</strong>。就好比C语言也有这些类型，但是C语言根本没有面向对象的概念。 比如只能说“1”是一个int类型的常量，却不能说它是一个int类型的对象。与之对应的，这些语言还定义了与基本类型相关的操作符。例如，有算术操作符加法“+”，它可以连接左、右两个操作数，然后算出相应的总和。</p></blockquote><p>​    前面提到，Scala追求纯粹的面向对象，像这种不属于面向对象范畴的基本类型及其操作符都是有违宗旨的。那么，Scala如何实现这些基本类型呢？实际<strong>在Scala标准库里定义了“class Byte”、“class  Short”、“class  Char”、“class Int”、“class  Long”、“class  Float”、“class  Double”、“class  Boolean”和“class Unit”九种值类，</strong>只不过<strong>这些类是抽象的、不可继承的，因此不能通过“new Int”这种语句来构造一个Int对象，也不能编写它们的子类，它们的对象都是由字面量来表示</strong>。例如，整数字面量“1”就是一个Int的对象。在运行时，前八种值类会被转换成对应的Java基本类型。第九个Unit类对应Java的“void”类型，即表示空值，这样就能理解返回值类型为Unit的、有副作用的函数其实是空函数。<strong>Unit类的对象由一个空括号作为字面量来表示。</strong></p><p>​    <strong>简而言之，Scala做到了真正的“万物皆对象”。</strong></p><p>​    还有，与基本类型相关的操作符该如何处理呢？严格来讲，<strong>Scala并不存在操作符的概念</strong>，这些所谓的操作符，例如算术运算的加减乘除，逻辑运算的与或非，比较运算的大于小于等等，其实都是定义在“class Int”、“class Double”等类里的成员方法。也就是说，<strong>在Scala里，操作符即方法。</strong>例如，Int类定义了一个名为“+”的方法，那么表达式“1 + 2”的真正形式应该是“1.+(2)”。它的释义是：Int对象“1”调用了它的成员方法“+”，并把Int对象“2”当作参数传递给了该方法，最后这个方法会返回一个新的Int对象“3”。</p><p>​    <strong><u>//////重要使用方法：类似操作符的方法调用（省略句号）///////</u></strong></p><p>​    推而广之，<u>“操作符即方法”的概念不仅仅限于九种值类的操作符，<strong>Scala里任何类定义的成员方法都是操作符，而且方法调用都能写成操作符的形式：去掉句点符号，并且方法参数只有一个时可以省略圆括号。</strong></u>示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friends</span></span>(n: <span class="hljs-type">String</span>, s: <span class="hljs-type">Int</span>) = println(<span class="hljs-string">&quot;My friend &quot;</span> + n + <span class="hljs-string">&quot; gets &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>)<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Students3</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>)<br>stu3: <span class="hljs-type">Students3</span> = <span class="hljs-type">Alice</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">80.</span><br><br>scala&gt; stu3 exam <span class="hljs-number">100</span><br><br>scala&gt; stu3.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; stu3 friends (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">70</span>)<br><span class="hljs-type">My</span> friend <span class="hljs-type">Bob</span> gets <span class="hljs-number">70.</span><br></code></pre></div></td></tr></table></figure><h2 id="6-2-三种操作符"><a href="#6-2-三种操作符" class="headerlink" title="6.2 三种操作符"></a>6.2 三种操作符</h2><p><strong>（1）前缀操作符（+-!~）</strong></p><p>​    写在<strong>操作数前面的操作符</strong>称为<strong>前缀操作符</strong>，并且<strong>操作数只有一个</strong>。</p><p>​    前缀操作符<strong>对应一个无参方法</strong>，<strong>操作数是调用该方法的对象</strong>。<strong>前缀操作符只有“+”、“-”、“!”和“~”四个</strong>，相对应的方法名分别是“unary_+”，“unary_-”、“unary_!”和“unary_~”</p><blockquote><p>​    <strong>如果自定义的方法名是 “unary_”</strong>加上这四个操作符之外的操作符，那么就不能写成前缀操作符的形式。假设定义了方法“unary_*”（意思是unary_与乘号结合），那么写成“<em>p”的形式让人误以为这是一个指针，实际Scala并不存在指针，因此只能写成“p.unary_\</em>”或后缀操作符“p unary_*”的形式。例如：</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_!</span> </span>= -x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_*</span> </span>= x * <span class="hljs-number">2</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt</span>(<span class="hljs-number">10</span>)<br>mi: <span class="hljs-type">MyInt</span> = <span class="hljs-type">MyInt</span>@<span class="hljs-number">2</span>aac87ab<br><br>scala&gt; !mi<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">-10</span><br><br>scala&gt; *mi<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: not found: value *<br>       *mi<br>       ^<br>&lt;console&gt;:<span class="hljs-number">12</span>: warning: postfix operator mi should be enabled<br>by making the <span class="hljs-keyword">implicit</span> value scala.language.postfixOps visible.<br><span class="hljs-type">This</span> can be achieved by adding the <span class="hljs-keyword">import</span> clause <span class="hljs-symbol">&#x27;import</span> scala.language.postfixOps&#x27;<br>or by setting the compiler option -language:postfixOps.<br><span class="hljs-type">See</span> the <span class="hljs-type">Scaladoc</span> <span class="hljs-keyword">for</span> value scala.language.postfixOps <span class="hljs-keyword">for</span> a discussion<br>why the feature should be explicitly enabled.<br>       *mi<br>        ^<br><br>scala&gt; mi.unary_*<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p><strong>（2）中缀操作符(可以带很多操作数)</strong></p><p>​    <strong>中缀操作符</strong>的<strong>左右两边都接收操作数</strong>，它<strong>对应普通的有参方法</strong>。两个操作数中的一个是调用该方法的对象，一个是传入该方法的参数，<strong>参数那一边没有数量限制</strong>，只是多个参数需要放在圆括号里。</p><p>​    <strong>Scala规定，以冒号“ : ”结尾的操作符，其<u>右操作数</u>是调用该方法的对象，<u>其余操作符</u>都是把左操作数当调用该方法的对象。</strong> 例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+*</span></span>(y: <span class="hljs-type">Int</span>) = (x + y) * y<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>:(y: <span class="hljs-type">Int</span>) = x + y<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi2 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt2</span>(<span class="hljs-number">10</span>)<br>mi2: <span class="hljs-type">MyInt2</span> = <span class="hljs-type">MyInt2</span>@<span class="hljs-number">216</span>c6825<br><br>scala&gt; mi2 +* <span class="hljs-number">10</span> <span class="hljs-comment">//两个操作符，先+10后乘10</span><br>res7: <span class="hljs-type">Int</span> = <span class="hljs-number">200</span><br><br>scala&gt; mi2 +: <span class="hljs-number">10</span> <span class="hljs-comment">//右侧才是</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: value +: is not a member of <span class="hljs-type">Int</span><br>       mi2 +: <span class="hljs-number">10</span><br>           ^<br><br>scala&gt; <span class="hljs-number">10</span> +: mi2 <span class="hljs-comment">//右侧mi2是调用该方法的对象，其余操作符为+,其余操作符的操作数为左侧的10</span><br>res9: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>​    对于系统打印函数<strong>“print”、“printf”和“println”，其实也是中缀操作符</strong>，不过<strong>左侧的操作数是调用对象——控制台Console</strong>，<strong>右侧是要打印的内容</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Console</span> println <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-type">Hello</span>, world! <br></code></pre></div></td></tr></table></figure><p><strong>（3）后缀操作符(类似方法调用)</strong></p><p>​    写在<strong>操作数后面的操作符</strong>称为<strong>后缀操作符</strong>，并且<strong>操作数只有一个</strong>，即调用该方法的对象。</p><p>​    后缀操作符也对应一个无参方法，但是要注意方法名<strong>如果构成前缀操作符的条件，那么既可以写成前缀操作符</strong>，也可以把完整的方法名写成后缀操作符。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;The value is &quot;</span> + x + <span class="hljs-string">&quot;.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi3 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt3</span>(<span class="hljs-number">10</span>)<br>mi3: <span class="hljs-type">MyInt3</span> = <span class="hljs-type">MyInt3</span>@<span class="hljs-number">2670435</span><br><br>scala&gt; <span class="hljs-keyword">import</span> scala.language.postfixOps<br><span class="hljs-keyword">import</span> scala.language.postfixOps<br><br>scala&gt; mi3 display <span class="hljs-comment">//操作数mi3  操作符display</span><br><span class="hljs-type">The</span> value is <span class="hljs-number">10.</span><br></code></pre></div></td></tr></table></figure><h2 id="6-3-操作符的优先级和结核性"><a href="#6-3-操作符的优先级和结核性" class="headerlink" title="6.3 操作符的优先级和结核性"></a>6.3 操作符的优先级和结核性</h2><p><strong>（1）优先级</strong></p><p>​    在数学运算中，乘、除法的优先级要高于加、减法，这是算术操作符的优先级。Scala也保留了这种特性，并有一套判断操作符优先级的规则：通过操作符的首个字符来判断。因为操作符都是方法，所以也就是通过方法名的首个字符来比较优先级，注意前缀操作符的方法名要去掉关键字。当然，圆括号内的优先级是最高的，圆括号可以改变操作符的结合顺序。<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>​    上图给出了各种字符的优先级顺序。例如，常规算术运算法则在计算表达式“1 + 2 <em> 3”时，会先算乘法，后算加法。类似地，如果有一个表达式“1 +++ 2 **</em> 3”，那么结合顺序就是“1 +++ (2 <em>*</em> 3)”。</p><blockquote><p>​    这个规则有一个例外（就是比较，+=一系列的，不用看）：如果操作符以等号结尾，并且不是“&gt;=”、“&lt;=”、“==”或“!=”四个比较操作符之一，那么就认为是赋值操作符，优先级最低。例如，表达式“sum *= 1 + 2”会先算“1 + 2”，再把得出的3和sum相乘并赋给sum。也就是说，“*=”的优先级并不会因为以乘号开头就比加号高，而是被当作了一种赋值操作。</p></blockquote><p><strong>（2）结合性（注意冒号这玩意就行）</strong></p><p>​    一般情况下，同级的操作符都是<strong>从左往右结合的</strong>。但是，前面说了，<strong>以冒号结尾的中缀操作符的调用对象在右侧</strong>，所以这些操作符是从右往左结合的。例如，“a + b + c + d”的结合顺序是“((a + b) + c) + d”，而“a ::: b ::: c ::: d”的结合顺序则是“a ::: (b ::: (c ::: d))”。</p><blockquote><p>​    一个好的编程习惯是让代码简洁易懂，不造成歧义。所以，在操作符的结合顺序不能一眼就看明白时，最好加上圆括号来表示前后顺序，即使不加圆括号也能得到预期的结果。例如，想要得到“x + y &lt;&lt; z”的默认结果，最好写成“(x + y) &lt;&lt; z”，以便阅读。</p></blockquote><p><strong>（3）预设操作符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">+</th><th style="text-align:center">算术加法</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">算术减法</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">算术乘法</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">算术除法</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">算术取余</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&amp;&amp;、&amp;</td><td style="text-align:center">逻辑与，前者短路，后者不短路</td></tr><tr><td style="text-align:center">&#124;&#124;、&#124;</td><td style="text-align:center">逻辑或，前者短路，后者不短路</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">位或</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">位取反</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">算术右移</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;</td><td style="text-align:center">逻辑右移</td></tr></tbody></table></div><h2 id="6-5-对象的相等性"><a href="#6-5-对象的相等性" class="headerlink" title="6.5 对象的相等性"></a>6.5 对象的相等性</h2><p>​    在编程时，常常需要比较两个对象的相等性。其实相等性有两种：</p><ul><li><strong>自然相等性</strong>，也就是常见的相等性。<strong>只要字面上的值相等，就认为两个对象相等</strong></li><li><strong>引用相等性</strong>。构造的对象常常会赋给一个变量，即让变量引用该对象。引用相等性用于比较两个变量是否引用了同一个对象，<strong>即是否指向JVM的堆里的同一个内存空间</strong>。如果两个变量引用了两个完全一样的对象，那么它们的自然相等性为true，但是引用相等性为false</li></ul><blockquote><p>在Java里，这两种相等性都是由操作符“==”和“!=”比较的。</p><p>Scala为了区分得更细致，也为了符合常规思维，<strong>只让“==”和“!=”比较自然相等性</strong>。<strong>这两个方法是所有类隐式继承来的，但是它们不能被子类重写。</strong>自定义类可能需要不同行为的相等性比较，因此<strong>可以重写隐式继承来的“equals”方法。</strong>为了比较引用相等性，Scala提供了“eq”和“ne”方法，它们也是被所有类隐式继承的，且不可被子类重写。例如：</p></blockquote><p><strong>Scala比较自然相等性：</strong></p><ul><li>只让<strong>“==”和“!=”</strong>方法比较，被所有类隐式继承的，且不可被子类重写</li></ul><p><strong>Scala比较引用相等性：</strong></p><ul><li>提供了“<strong>eq”和“ne”方法</strong>，它们也是被所有类隐式继承的，且不可被子类重写</li></ul><p><strong>自定义相等性行为：</strong></p><ul><li>可以重写隐式继承来的“equals”方法</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>a: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>b: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>c: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> d = a<br>d: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; a == c<br>res0: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a == b<br>res1: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a equals b<br>res2: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a eq b<br>res3: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a eq d<br>res4: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h2 id="6-6-章节总结"><a href="#6-6-章节总结" class="headerlink" title="6.6 章节总结"></a>6.6 章节总结</h2><p>​    本章又进一步阐释了Scala追求的纯粹的面向对象，介绍了“操作符即方法”这个重要概念。这一概念对构建良好的DSL语言很重要，因为它使得不仅内建类型可以写成表达式，也让自定义的类在计算时可以写出自然的表达式风格。</p><p>​    关于对象相等性，这是一个较为复杂的概念。在自定义类里，如果要比较对象相等性，则不仅是简单地重写equals方法，还需要其他手段。这里不再赘述，如有必要，后续会继续讨论。</p><h1 id="7-extends类继承"><a href="#7-extends类继承" class="headerlink" title="7 extends类继承"></a>7 extends类继承</h1><h2 id="7-1-Scala的类集成"><a href="#7-1-Scala的类集成" class="headerlink" title="7.1 Scala的类集成"></a>7.1 Scala的类集成</h2><p>​    在类的参数列表后面加上关键字<strong>“extends”</strong>和被继承类的类名，就完成了一个继承的过程。通常使用的三个名词：</p><ul><li>超类：基本的一种继承关系<ul><li>父类：只限定于一级继承时这么称呼</li></ul></li><li>子类</li></ul><blockquote><p>​    被继承的类称为“超类”或者“父类”，而派生出来的类称为“子类”。如果继承层次较深，最顶层的类通常也叫“基类”。继承关系只有“超类”和“子类”的概念，即超类的超类也叫超类，子类的子类还叫子类。例如：</p></blockquote><p>示例代码（纯粹演示Scala语法，没有实际意义）：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Class A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;Class B inherits from A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">5922</span>cff3<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">A</span><br><br>scala&gt; x.b<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">B</span> inherits from <span class="hljs-type">A</span><br></code></pre></div></td></tr></table></figure><h2 id="7-2-构造方法"><a href="#7-2-构造方法" class="headerlink" title="7.2 构造方法"></a>7.2 构造方法</h2><p>​    子类调用超类的构造方法的语法是：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span>(<span class="hljs-params">子类从外接收的参数</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">超类</span>(<span class="hljs-params">子类给超类的参数</span>)</span><br></code></pre></div></td></tr></table></figure><p>​    父类构造方法没有参数：6.1中的例子中，父类的构造方法<strong>没有参数，所以“extends A”也就不需要参数</strong></p><p>​    只有主构造方法才能调用超类的构造方法：Scala<strong>只允许主构造方法调用超类的构造方法</strong>，而这种写法就是子类的主构造方法在调用超类的构造方法。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val a: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">giveA: <span class="hljs-type">Int</span>, val b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>(<span class="hljs-params">giveA</span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>x: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">5</span>f81507a<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; x.b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><h2 id="7-3-一些特殊性质"><a href="#7-3-一些特殊性质" class="headerlink" title="7.3 一些特殊性质"></a>7.3 一些特殊性质</h2><p><strong>（1）覆盖：override</strong></p><p>​    覆盖超类的成员时，应该在定义的开头<strong>加上关键字“override”</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mercury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Metal</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> state = <span class="hljs-string">&quot;liquid&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mercury</span></span><br></code></pre></div></td></tr></table></figure><hr><p><strong>（2）不可覆盖的成员、不可被继承的类：final</strong></p><ul><li><p>如果超类成员在开头用<strong>关键字“final”</strong>修饰，那么<strong>子类就只能继承，而不能重写</strong>。</p></li><li><p><strong>“final”也可以用于修饰class</strong>，那么这个类就禁止被其他类继承。</p></li></ul><hr><p><strong>（3）无参方法与字段</strong></p><p>​    Scala的<strong>无参方法在调用时，可以省略空括号</strong>。</p><blockquote><p>鉴于此，对用户代码而言，如果看不到类库的具体实现，那么调用无参方法和调用同名的字段则没有什么不同，甚至无法区分其具体实现到底是方法还是字段。如果把类库里的无参方法改成字段，或是把字段改成无参方法，那么客户代码不用更改也能运行。</p></blockquote><p>​    为了方便在这两种定义之间进行切换，Scala允许<strong>超类的无参方法</strong>被子类<strong>重写为字段</strong>，<strong>但字段不能反过来被重写为无参方法</strong>，而且<strong>方法的返回类型必须和字段的类型一致</strong>。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">justA</span></span>() = <span class="hljs-string">&quot;A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-string">&quot;B&quot;</span> <span class="hljs-comment">//超类的无参方法被子类重写为字段</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-number">1</span> <span class="hljs-comment">//方法的返回类型必须和字段的类型一致</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: overriding method justA in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> (<span class="hljs-params"></span>)<span class="hljs-title">String</span></span>;<br> value justA has incompatible <span class="hljs-class"><span class="hljs-keyword">type</span></span><br>         <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-number">1</span><br>                      ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> d = <span class="hljs-number">10</span> <br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span></span>() = <span class="hljs-number">100</span>  <span class="hljs-comment">//超类的字段不能反过来被重写为无参方法</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: overriding value d in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> <span class="hljs-title">Int</span></span>;<br> method d needs to be a stable, immutable value<br>         <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span></span>() = <span class="hljs-number">100</span><br>                      ^<br></code></pre></div></td></tr></table></figure><blockquote><p>​    <strong>字段与方法的区别</strong>在于：字段一旦被初始化之后，就会被保存在内存中，以后每次调用都只需直接读取内存即可；方法不会占用内存空间，但是每次调用都需要执行一遍程序段，速度比字段要慢。因此，到底定义成无参方法还是字段，就是在速度和内存之间折衷。</p><p>​    <strong>字段能重写无参方法的原理</strong>是<strong>Scala只有两种命名空间</strong>：</p><ul><li>值——字段、方法、包、单例对象</li><li>类型——类、特质。</li></ul><p>​    因为<strong>字段和方法同处一个命名空间</strong>，所以字段可以重写无参方法。这也告诉我们，同处一个命名空间的定义类型，在同一个作用域内不能以相同的名字同时出现。例如，同一个类里不能同时出现同名的字段、无参方法和单例对象：</p></blockquote><h2 id="7-4-多态与动态绑定"><a href="#7-4-多态与动态绑定" class="headerlink" title="7.4 多态与动态绑定"></a>7.4 多态与动态绑定</h2><p>​    类型为超类的变量可以指向子类的对象，这一现象被称为<strong>子类型多态</strong>，也是面向对象的多态之一。但是对于方法而言，尽管变量的类型是超类，<strong>方法的版本却是“动态绑定”的</strong>。也就是说，调用的方法要运行哪个版本，<strong>是由变量指向的对象来决定</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = <span class="hljs-string">&quot;I&#x27;m A.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = <span class="hljs-string">&quot;I&#x27;m B.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">A</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">B</span>@<span class="hljs-number">6</span>c5abd8f<br><br>scala&gt; x.display<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">I</span><span class="hljs-symbol">&#x27;m</span> <span class="hljs-type">B</span>.<br></code></pre></div></td></tr></table></figure><h2 id="7-5-抽象类（abstract）"><a href="#7-5-抽象类（abstract）" class="headerlink" title="7.5 抽象类（abstract）"></a>7.5 抽象类（abstract）</h2><p>抽象类：</p><ul><li>类里<strong>包含了没有具体定义的成员</strong>（没有初始化的字段或没有函数体的方法）</li><li>必须用关键字“abstract”修饰</li></ul><p>抽象成员：</p><ul><li>没有具体定义的成员</li><li>不需要“abstract”的修饰</li></ul><p>​    <strong>抽象类无法构造</strong>出具体的对象，不能通过”new”构造实例对象</p><blockquote><p>​    如果类里<strong>包含了没有具体定义的成员</strong>（没有初始化的字段或没有函数体的方法），那么这个类就是<strong>抽象类</strong>，<strong>必须用关键字“abstract”修饰</strong>。相应的成员称为<strong>抽象成员</strong>，<strong>不需要“abstract”的修饰</strong>。因为存在抽象成员，所以这个类不可能构造出具体的对象，因为有无法初始化抽象字段或者无法执行抽象方法，所以抽象类不能通过“new”来构造实例对象。</p></blockquote><p>​    <strong>抽象类的子类</strong>可以对父类抽象成员进行定义，此时<strong>关键字”override”可以不写</strong></p><p>​    <strong>抽象类常用于定义基类</strong>，因为基类会派生出很多不同的子类，这些子类往往具有行为不同的同名成员，所以基类只需要声明有哪些公共成员，让子类去实现它们各自期望的版本。 </p><blockquote><p>​    抽象类缺失的抽象成员的定义，可以由抽象类的子类来补充。也就是说，抽象类“声明”了抽象成员，却没有立即“定义”它。如果子类补齐了抽象成员的相关定义，就称子类“实现”了超类的抽象成员。相对的，我们称超类的成员是“抽象”的，而子类的成员是“具体”的。子类实现超类的抽象成员时，关键字“override”可写可不写。例如</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a: <span class="hljs-type">Int</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">is</span> <span class="hljs-title">abstract</span></span>; cannot be instantiated<br>       <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>               ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">val b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = b * <span class="hljs-number">2</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>(<span class="hljs-number">1</span>)<br>y: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">7</span>fe87c0e<br><br>scala&gt; y.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; y.b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="7-6-没有多重继承"><a href="#7-6-没有多重继承" class="headerlink" title="7.6 没有多重继承"></a>7.6 没有多重继承</h2><p>​    <strong>Scala没有多重继承</strong>，也就是说，在“extends”后面只能有一个类，这与大多数oop语言不同。多重继承其实是一个很让人头疼的问题，使用起来很复杂，也很容易出错。在笔者学习C++的时候，看到了C++为了使用多重继承而不得不做出的大量语法规则修改，和单个继承混在一起时常把人搞晕。<strong>Scala舍弃多重继承的做法，对于程序员而言是莫大的帮助</strong>，不用在编写代码时考虑冗长的代码设计。尤其是对超类方法的调用，当存在多个超类时，为了避免歧义而不得不仔细设计方法的行为。</p><p>​    虽然多重继承不好用，但是它实现的功能在某些时候又不可或缺。为此，Scala<strong>专门设计了“特质”来实现相同的功能</strong>，并且特质的规则更简单、更明了。特质将在后一章介绍。</p><h2 id="7-7-Scala类的层次结构"><a href="#7-7-Scala类的层次结构" class="headerlink" title="7.7 Scala类的层次结构"></a>7.7 Scala类的层次结构</h2><p>​    Scala所有的类——不管是标准库里已有的类还是自定义的类<strong>都存在层次关系</strong>。这种关系如下图所示，其中<strong>实线箭头</strong>表示属于指向的<strong>类的子类</strong>，<strong>虚线箭头</strong>表示可以<strong>隐式转换</strong>成指向的类：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20190208201013172.png" alt=""></p><p><strong>最顶部的类是抽象类Any</strong>，<strong>它是所有类的超类</strong>，Any类定义了几个成员方法，如下表所示：</p><center><b>Any类的成员方法</b></center><div class="table-container"><table><thead><tr><th>方法定义</th><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>def getClass(): Class[_]</td><td style="text-align:center">抽象</td><td style="text-align:center">返回运行时对象所属的类的表示</td></tr><tr><td>final def !=(arg0: Any): Boolean</td><td style="text-align:center">具体</td><td style="text-align:center">比较两个对象的自然相等性是否不相等</td></tr><tr><td>final def ==(arg0: Any): Boolean</td><td style="text-align:center">具体</td><td style="text-align:center">比较两个对象的自然相等性是否相等</td></tr><tr><td>def equals(arg0: Any): Boolean</td><td style="text-align:center">具体</td><td style="text-align:center">比较两个对象的自然相等性，被!=和==调用</td></tr><tr><td>final def ##(): Int</td><td style="text-align:center">具体</td><td style="text-align:center">计算对象的哈希值，等同于hashCode，但是自然相等性相等的两个对象会得到相同的哈希值，并且不能计算null对象</td></tr><tr><td>def hashCode(): Int</td><td style="text-align:center">具体</td><td style="text-align:center">计算对象的哈希值</td></tr><tr><td>final def asInstanceOf[T]: T</td><td style="text-align:center">具体</td><td style="text-align:center">把对象强制转换为T类型</td></tr><tr><td>final def isInstanceOf[T]: Boolean</td><td style="text-align:center">具体</td><td style="text-align:center">判断对象是否属于T类型，或T的子类</td></tr><tr><td>def toString(): String</td><td style="text-align:center">具体</td><td style="text-align:center">返回一个字符串来表示对象</td></tr></tbody></table></div><p>​    也就是说，<strong>任何类都有这几个方法</strong>。注意，不能出现同名的方法，若确实需要自定义版本，则记得带上“override”。</p><p>​    <strong>再往下一层</strong>，Any类有<strong>两个子类：AnyVal和AnyRef</strong>。也就是说，<strong>所有类被分成两大部分：值类和引用类</strong>。值类也就是前面讲过的对应Java的九种基本类型，并且其中七个存在一定的隐式转换，例如Byte可以扩展成Short等等。隐式转换是Scala的一个语法，用于对象在两个类之间进行类型转换，后面章节会讲到。除了标准库里已有的隐式转换，也可以自定义隐式转换。</p><p>​    <strong>除了这九个值类，也可以自定义值类</strong>，即定义时显式地继承自AnyVal类。如果没有显式地继承自AnyVal类，则都认为是AnyRef类的子类，也就是说一般自定义的类都属于引用类。大部分标准库里的类都是引用类，比如常见的字符串类String，还有后续会讲解的列表类、映射类、集合类等等。Java的类都属于引用类，因为Java的基本类型都在值类里面。</p><p>​    前面讲过引用相等性，很显然只有引用类才有引用相等性。事实上，比较引用相等性的两个方法——eq和ne，都定义在AnyRef类里。值类AnyVal是没有这两个方法的，也不需要。</p><p>​    在层次结构的底部有两个底类型——Null类和Nothing类。其中Null类是所有引用类的子类，表示空引用，即指向JVM里的空内存，这与Java的null概念是一样的。但是Null并不兼容值类，所以Scala还有一个类——Nothing，它是所有值类和引用类的子类，甚至还是Null类的子类。因此Nothing不仅表示空引用，还表示空值。Scala里有一个可选值语法，也就是把各种类型打包成一个特殊的可选值。为了表示“空”、“没有”这个特殊的概念，以及兼容各种自定义、非自定义的值和引用类，这个特殊的可选值其实就是把Nothing类进行打包。</p><p>​    除了自定义的普通类属于引用类，后一章讲解的特质，也是属于引用类的范畴。</p><h2 id="7-8-章节总结"><a href="#7-8-章节总结" class="headerlink" title="7.8 章节总结"></a>7.8 章节总结</h2><p>​    本章介绍了类继承的语法，其内容不多，也简单易懂。这一章真正的难点是阅读大型系统软件时，遇到的纷繁复杂的类层次，要梳理这些类的继承关系往往费时费力。还有自己编写代码时，<strong>如何设计类的结构，让系统稳定、简单、逻辑清晰</strong>，也不是一件容易事。</p><p>​    <strong>在编写Chisel时，类继承主要用于编写接口</strong>，因为接口可以扩展，但是实际的硬件电路并没有很强烈的继承关系。</p><h1 id="8-trait特质"><a href="#8-trait特质" class="headerlink" title="8 trait特质"></a>8 trait特质</h1><h2 id="8-1-什么是特质"><a href="#8-1-什么是特质" class="headerlink" title="8.1 什么是特质"></a>8.1 什么是特质</h2><p><strong>（1）特质trait</strong></p><p>​    Scala没有多重继承，为了提高代码复用率，故而创造了新的编程概念——<strong>特质</strong></p><p>​    特质是用<strong>关键字“trait”</strong>为开头来定义的</p><p>​    <strong>特质与单例对象很像</strong>，两者都不能有入参。<strong>类、单例对象、特质三者一样</strong>，内部可以包含字段和方法，甚至包含其他类、单例对象、特质的定义。</p><div class="table-container"><table><thead><tr><th>特质</th><th>单例对象</th></tr></thead><tbody><tr><td>不能有入参</td><td>不能有入参</td></tr><tr><td>抽象的，但不需要用“abstract”来说明</td><td>具体的</td></tr><tr><td>可以包含抽象成员</td><td>不能包含抽象成员</td></tr><tr><td>不能用new来实例化</td><td>不能用new来实例化</td></tr></tbody></table></div><p><strong>（2）混入</strong>：</p><ul><li><strong>特质可以被其它类、单例对象和特质“混入”</strong>。这里使用术语“混入”而不是“继承”，是因为特质在<strong>超类方法调用上采用线性化机制</strong>，<strong>与多重继承有很大的区别</strong>。</li><li>其它方面，“混入”和“继承”其实是一样的。例如，某个类混入一个特质后，就包含了特质的所有公有成员，而且也可以用“override”来重写特质的成员</li><li>要混入一个特质，在当前类没有继承的情况下<strong>可以使用关键字“extends”</strong>，否则<strong>通过关键字“with”来混入其他特质</strong>。例如：</li></ul><p>​    Scala只允许继承自一个类，但是<strong>对特质的混入数量却没有限制</strong>，故而<strong>可用于替代多重继承语法</strong>，同时也拥有多态的特性</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Class A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;Trait B&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span> </span>= <span class="hljs-string">&quot;Trait C&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> <span class="hljs-keyword">with</span> <span class="hljs-title">C</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-type">D</span>.a<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-type">D</span>.b<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">Trait</span> <span class="hljs-type">B</span><br><br>scala&gt; <span class="hljs-type">D</span>.c<br>res2: <span class="hljs-type">String</span> = <span class="hljs-type">Trait</span> <span class="hljs-type">C1</span><br></code></pre></div></td></tr></table></figure><p><strong>（3）特质拥有多态的特性</strong>：</p><blockquote><p>​    特质也定义了一个类型，而且类型为该特质的变量，可以指向混入该特质的对象。例如：</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">A</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">B</span>@<span class="hljs-number">7</span>cc1f72c <br></code></pre></div></td></tr></table></figure><h2 id="8-2-特质的继承和混入"><a href="#8-2-特质的继承和混入" class="headerlink" title="8.2 特质的继承和混入"></a>8.2 特质的继承和混入</h2><p>​    <strong>特质也可以继承自其他类</strong>，<strong>或混入任意个特质</strong>，这样该特质就是关键字“extends”引入的那个类/特质的子特质。如果没有继承和混入，那么这个特质就是AnyRef类的子特质。前面讲过AnyRef类是所有非值类和特质的超类。</p><p>​    <strong>当某个类、单例对象或特质用关键字“extends”混入一个特质时，会隐式继承自这个特质的超类。</strong>（也就是说，类/单例对象/特质的超类，都是由“extends”引入的类或特质决定的。）</p><p>​    <strong>特质对混入有一个限制条件</strong>：那就是要混入该特质的类/单例对象/特质，它的超类必须是待混入特质的超类，或者是待混入特质的超类的子类。因为特质是多重继承的替代品，那就有“继承”的意思。既然是继承，混入特质的类/单例对象/特质的层次，就必须比待混入特质的层次要低。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: illegal inheritance; superclass <span class="hljs-type">C</span><br> is not a subclass of the superclass <span class="hljs-type">A</span><br> of the mixin <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span></span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>                                  ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span></span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: illegal inheritance; superclass <span class="hljs-type">A</span><br> is not a subclass of the superclass <span class="hljs-type">B</span><br> of the mixin <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span></span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span></span><br></code></pre></div></td></tr></table></figure><blockquote><p>​    上例中，类Test1直接混入特质D，这样隐式继承自D的超类——类A，所以合法。类Test2和Test3分别继承自类A和A的子类，所以也允许混入特质D。类Test4的超类是C，而C与A没有任何关系，所以非法。类Test5的超类是A，特质E的超类是B，尽管类A是类B的超类，这也仍然是非法的。从提示的错误信息也可以看出，混入特质的类/单例对象/特质，其超类必须是待混入特质的超类或超类的子类。</p></blockquote><h2 id="8-3-混入特质的简便方法"><a href="#8-3-混入特质的简便方法" class="headerlink" title="8.3 混入特质的简便方法"></a>8.3 混入特质的简便方法</h2><ul><li><strong>快速构造一个混入某些特质的实例：</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait2</span> ... &#123; definition &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>​    上面代码其实是<strong>定义了一个匿名类</strong>，这个匿名类混入了这些特质，并且花括号内是该匿名类的定义。然后使用new构造了这个匿名类的一个对象，其等效的代码就是：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Trait2</span> ... </span>&#123; definition &#125;<br><br>&gt;<span class="hljs-keyword">new</span> <span class="hljs-type">AnonymousClass</span><br></code></pre></div></td></tr></table></figure><p>一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">T</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> tt = <span class="hljs-string">&quot;T__T&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">T</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">X</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> xx = <span class="hljs-string">&quot;X__X&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">X</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">T</span> <span class="hljs-keyword">with</span> <span class="hljs-type">X</span><br>a: <span class="hljs-type">T</span> <span class="hljs-keyword">with</span> <span class="hljs-type">X</span> = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">4</span>c1fed69<br><br>scala&gt; a.tt<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">T__T</span><br><br>scala&gt; a.xx<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">X__X</span><br></code></pre></div></td></tr></table></figure></blockquote><ul><li><strong>除此之外，还可以在最前面加上一个想要继承的超类</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">SuperClass</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait2</span> ... &#123; definition &#125;<br></code></pre></div></td></tr></table></figure><h2 id="8-4-特质的线性化叠加的计算"><a href="#8-4-特质的线性化叠加的计算" class="headerlink" title="8.4 特质的线性化叠加的计算"></a>8.4 特质的线性化叠加的计算</h2><p>​    <strong>多重继承一个很明显的问题</strong>：多个超特质的方法调用</p><blockquote><p>当子类特质调用超类的方法时，若多个超类都有该方法的不同实现，那么需要附加额外的语法来确定具体调用哪个版本。</p></blockquote><p>​    <strong>Scala特质采取一种线性化的规则</strong>来调用特质中的方法，这与大多数语言不一样。在特质里，<strong>“super”调用是动态绑定的</strong>。也就是说，按特质本身的定义，无法确定super调用的具体行为；直到特质混入某个类或别的特质，有了具体的超类方法，才能确定super的行为。这是实现线性化的基础。</p><p>线性化叠加特点总结：</p><ul><li><p>① <strong>超特质</strong>的方法实现前用关键字组合<strong>“abstract override”</strong>进行声明</p><blockquote><p>注意这不是重写，而是告诉编译器该方法用于线性叠加。这个关键字组合只能用在特质里，不允许用在其他地方。</p></blockquote></li><li><p>② <strong>超特质</strong>对该方法的定义必须出现“super.方法名(参数)”</p></li><li><p>③ <strong>被混入的类</strong>应有同名同参的方法（内部定义、继承、重写都可以）</p><blockquote><p>这个关键字组合也意味着该特质必须被某个拥有该方法具体定义的类混入(这个类的方法可以是自己实现或者重写的，也可以是继承的，总之它拥有该方法)，也就是这个类定义了该方法的最终行为。如果被没有拥有该方法具体定义的类给混入了，那么就会报错。</p></blockquote></li><li><p>④ <strong>被混入的类不能立刻混入</strong>，应该把他再作为父类定义一个子类，用子类混入各种特质;同时也可以使用简便方法，定义新的匿名类如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span> <span class="hljs-keyword">with</span> <span class="hljs-type">D</span> <span class="hljs-keyword">with</span> <span class="hljs-type">E</span> <span class="hljs-keyword">with</span> <span class="hljs-type">F</span> <span class="hljs-keyword">with</span> <span class="hljs-type">B</span><br></code></pre></div></td></tr></table></figure><blockquote><p>需要混入特质进行线性化计算的类，在定义时不能立即混入特质。这样做会让编译器认为这个类是在重写末尾那个特质的方法，而且当类的上一层超类是抽象类时还会报错。应该先定义这个类的子类来混入特质，然后构造子类的对象。或者直接用第三点讲的“new SuperClass with Trait1 with Trait2 …”来快速构造一个子类对象。</p></blockquote><ul><li><p>⑤ <strong>方法的执行顺序遵循线性化计算公式</strong>：<strong>起点最右边特质</strong>，同时<strong>从起点处接收参数</strong>，结果返回作为参数传<strong>递给右边第二个参数</strong>，最后回到最左边的<strong>被混入的类本身</strong></p><blockquote><p>可以理解为特质是按一定顺序对入参进行各种变换，最后把变换后的入参交给类来计算。</p></blockquote></li></ul><p>⑥ <span id="jump">回到<strong>被混入的类</strong>本身，说明此类<strong>直接或间接override或实现了基类的方法</strong>，且直接实现时<strong>需使用override关键词</strong></span></p><ul><li>如果此类同名同参方法的实现使用了<strong>“super.方法名(参数)”</strong>，那么会调用它的上一层超类的实现版本</li><li><strong>此类没有override</strong>，那就一定要对该同名同参方法的实现，或也调用上一层超类的实现版本</li></ul><p><mark>线性化计算公式（定义被混入类的匿名子类的规则）：</mark></p><ul><li>① <strong>最左边</strong>是被混入类本身。</li><li>② <strong>左边第二个</strong>写最后混入的那个特质，<strong>往右按继承顺序写下该特质的所有超类和超特质</strong></li><li>③ 写完<strong>第二个带着的所有超类和特质后</strong>，往右写下<strong>倒数第二个混入的特质</strong>，以及其超类和超特质，直到写完所有特质。</li><li>④ <strong>所有重复项只保留最右边那个</strong>，并在最右边加上<code>AnyRef和Any</code>。</li></ul><p>为了具体说明，以如下代码为例：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><br><span class="hljs-comment">// test.scala</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;X -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;B -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;C -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;D -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;E -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">F</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;F -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span> <span class="hljs-keyword">with</span> <span class="hljs-type">D</span> <span class="hljs-keyword">with</span> <span class="hljs-type">E</span> <span class="hljs-keyword">with</span> <span class="hljs-type">F</span> <span class="hljs-keyword">with</span> <span class="hljs-type">B</span><br>println(x.m(<span class="hljs-string">&quot;End&quot;</span>))<br></code></pre></div></td></tr></table></figure><p><strong>实例运行结果：</strong></p><blockquote><p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End</p><p>​    首先，需要混入特质进行线性化计算的类G在定义时没有立即混入特质，即只有“class G extends X”，而是通过“new G with D with E with F with B”来构造G的匿名子类的对象。其次，注意基类A是一个抽象类，类X实现了抽象方法m，类G重写了X的m，其余特质也用“abstract override”重写了m，这保证了m最终会回到类G。最后，基类A的m的返回类型“String”的声明是必须的，因为抽象方法无法推断返回类型，不声明就默认是Unit。</p></blockquote><p>根据线性化计算公式可得(蓝色表示起点，红色表示重复，类X不参与计算)：</p><blockquote><p>① G</p><p>② G→B(蓝色)→A</p><p>③ G→B→A→F→C→A</p><p>④ G→B→A→F→C→A→E→C→A</p><p>⑤ G→B→A→F→C→A→E→C→A→D→A</p><p>⑥ G→B→F→E→C→D→A</p><p>⑦ G→B→F→E→C→D→A→AnyRef→Any</p><p>​    起点是B，传入参数“End”会得到“B -&gt; End”；然后B的super.m调用F的m，并传入计算得到的“B -&gt; End”，那么F会得到“F -&gt; B -&gt; End”，再继续向右调用；最后A的m是抽象的，无操作可执行，转而回到G的m，所以最后传给G的参数实际是“D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End”，得到的结果也就是“G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End”。 </p></blockquote><h2 id="8-5-特殊情况的验证"><a href="#8-5-特殊情况的验证" class="headerlink" title="8.5 特殊情况的验证"></a>8.5 特殊情况的验证</h2><ul><li><strong>如果G的m也有super或没有重写</strong>，那么会调用X的m，最后的结果是最左边多个X<a href="#jump">（也就是第六点）： </a></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;G -&gt; &quot;</span> + s)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>X -&gt; G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End</p></blockquote><hr><ul><li>如果<strong>立即混入特质</strong>，则相当于普通的方法重写：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span> <span class="hljs-keyword">with</span> <span class="hljs-title">F</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span><br>...<br></code></pre></div></td></tr></table></figure><blockquote><p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>G -&gt; End </p></blockquote><hr><ul><li>如果<strong>上一层超类是抽象类</strong>，立即混入会引发错误：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span> <span class="hljs-keyword">with</span> <span class="hljs-title">F</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span><br>...<br></code></pre></div></td></tr></table></figure><blockquote><p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>E:\Microsoft VS\Scala\Chapter 12.\traittest.scala:23: error: overriding method m in trait B of type (s: String)String;<br> method m needs `abstract override’ modifiers<br>  override def m(s: String) = “G -&gt; “ + s<br>               ^<br>one error found </p></blockquote><h2 id="8-6-章节总结"><a href="#8-6-章节总结" class="headerlink" title="8.6 章节总结"></a>8.6 章节总结</h2><p>​    <strong>特质用于代码重用，这与抽象基类的作用相似</strong>。不过，特质<strong>常用于混入在不相关的类中</strong>，而抽象基类则用于构成有继承层次的一系列相关类。在Chisel中，特质常用于<strong>硬件电路模块的公有属性的提取</strong>，在需要这些属性的电路中混入相应的特质，在不需要的时候删去，就能快速地修改电路设计</p><h1 id="9-package包"><a href="#9-package包" class="headerlink" title="9 package包"></a>9 package包</h1><h2 id="9-1-包的定义、命名方式、内容、编译"><a href="#9-1-包的定义、命名方式、内容、编译" class="headerlink" title="9.1 包的定义、命名方式、内容、编译"></a>9.1 包的定义、命名方式、内容、编译</h2><blockquote><p>​    当代码过于庞大时，为了让整个系统层次分明，各个功能部分划分明显，常常需要把整体划分成若干独立的模块。与Java一样，Scala把代码以“包”的形式划分。</p></blockquote><p>​    <strong>包定义</strong>：<strong>以关键字“package”为开头来定义的</strong>，有两种风格的定义方式：</p><ul><li>可以用花括号把包的范围包起来（这种风格类似C++和C#的命名空间）<ul><li>好处：而且这种方法使得一个文件可以包含多个不同的包</li></ul></li><li>也可以不用花括号标注范围（这种风格类似Java）<ul><li>好处：但包的声明必须在文件最前面，这样使得整个文件的内容都属于这个包</li></ul></li></ul><p>​    <strong>包的命名方式</strong>：推荐使用Java的<strong>反转域名法，即“com.xxx.xxx”的形式</strong></p><p>​    <strong>包的内容</strong>：可以定义<strong>class、object和trait</strong>，也可以定义<strong>别的package</strong></p><p>​    <strong>包的编译：</strong>如果编译一个包文件，那么会在当前路径下<strong>生成一个与包名相同的文件夹</strong>，文件夹里是包内class、object和trait编译后生成的文件，或者是包内层的包生成的更深一层文件夹<strong>。如果多个文件的顶层包的包名相同</strong>，那么编译后的文件会放在同一个文件夹内。<strong>也就是说，一个包的定义可以由多个文件的源代码组成</strong></p><h2 id="9-2-包的访问、层次、精确代码访问"><a href="#9-2-包的访问、层次、精确代码访问" class="headerlink" title="9.2 包的访问、层次、精确代码访问"></a>9.2 包的访问、层次、精确代码访问</h2><blockquote><p>​    因为包里还可以定义包，所以包也有层次结构。包的层次不仅<strong>便于人们按模块阅读</strong>，同时<strong>也告诉编译器这些代码存在某些层次联系</strong>。</p></blockquote><p>​    <strong>（1）包的访问</strong>：</p><ul><li>方法一（注：如果包名中就出现了句点，那么编译器也会按层次编译）：<ul><li>如果一个包仅仅是包含了其他的包，没有额外的class、object和trait定义，推荐使用这种方式访问，这样内部代码省去了一次缩进。</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> one.two<br></code></pre></div></td></tr></table></figure><ul><li>方法二：<ul><li><span id="可用于声明不同的包，方法一不行">可用于声明不同的包，方法一不行</span></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> one<br>    <span class="hljs-keyword">package</span> two<br></code></pre></div></td></tr></table></figure><p><strong>（2）编译的先后顺序</strong>：先编译出一个名为one的文件夹，然后在里面又编译出一个名为two的文件夹</p><p><strong>（3）Scala的包是嵌套的而不是分级的</strong>：而不像Java那样只是分级的。这体现在Java访问包内的内容必须从最顶层的包开始把全部路径写齐，而<strong>Scala则可以按照一定的规则书写更简短的形式</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-keyword">package</span> navigation &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navigator</span> </span>&#123;<br>      <span class="hljs-comment">// 不需要写成bobsrockets.navigation.StarMap</span><br>      <span class="hljs-keyword">val</span> map = <span class="hljs-keyword">new</span> <span class="hljs-type">StarMap</span><br>    &#125;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarMap</span></span><br>  &#125;<br> <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> </span>&#123;<br>    <span class="hljs-comment">// 不需要写成bobsrockets.navigation.Navigator</span><br>    <span class="hljs-keyword">val</span> nav = <span class="hljs-keyword">new</span> navigation.<span class="hljs-type">Navigator</span><br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> fleets &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>      <span class="hljs-comment">// 不需要写成bobsrockets.Ship</span><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>嵌套的几个特点：</strong>    </p><ul><li>访问<strong>同一个包内</strong>的class、object和trait不需要增加路径前缀</li></ul><blockquote><p>因为“new StarMap”和“class StarMap”都位于bobsrockets.navigation包内，所以这条代码能够通过编译。</p></blockquote><ul><li>访问<strong>同一个包内更深一层的包</strong>所含的class、object和trait，只需要写出那层更深的包。</li></ul><blockquote><p>因为“class Ship”和“package navigation”都位于bobsrockets包内，所以要访问navigation包内的class、object和trait只需要增加“navigation.”，而不是完整的路径。</p></blockquote><ul><li>当使用<strong>花括号显式表明包的作用范围</strong>时，包外所有可访问的class、object和trait在包内也可以直接访问</li></ul><blockquote><p>因为“package fleets”位于外层包bobsrockets，所以bobsrockets包内、fleets包外的所有class、object和trait可以直接访问，故而“new Ship”不需要完整路径也能通过编译。</p></blockquote><ul><li>以上规则只在<strong>同一个文件内显式嵌套时可以生效</strong></li><li><strong>通过包名带句点来访问嵌套（即使把这两个文件合并），无法编译</strong>。例如下面的代码就不能通过编译：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span></span><br>&#125;<br> <br><span class="hljs-comment">// fleets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets.fleets &#123; <span class="hljs-comment">//一起声明</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>    <span class="hljs-comment">// 无法编译，Ship不在作用域内</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>但是当第二个文件把<a href="#可用于声明不同的包，方法一不行"><strong>每个包分开声明时</strong></a>，上述规则又能生效。例如下面的代码是合法的：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span></span><br> <br><span class="hljs-comment">// fleets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets<br>  <span class="hljs-keyword">package</span> fleets <span class="hljs-comment">//分开声明</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>      <span class="hljs-comment">// 可以编译</span><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><strong>（4）访问最顶包的内容：root</strong></p><p>​    为了访问不同文件最顶层包的内容，Scala定义了一个<strong>隐式的顶层包“_root_”</strong>，<strong>所有自定义的包其实都包含在这个包里</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// launch.scala</span><br><span class="hljs-keyword">package</span> launch &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster3</span></span><br>&#125;<br> <br><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-keyword">package</span> navigation &#123;<br>    <span class="hljs-keyword">package</span> launch &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster1</span></span><br>    &#125;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MissionControl</span> </span>&#123;<br>      <span class="hljs-keyword">val</span> booster1 = <span class="hljs-keyword">new</span> launch.<span class="hljs-type">Booster1</span><br>      <span class="hljs-keyword">val</span> booster2 = <span class="hljs-keyword">new</span> bobsrockets.launch.<span class="hljs-type">Booster2</span><br>      <span class="hljs-keyword">val</span> booster3 = <span class="hljs-keyword">new</span> _root_.launch.<span class="hljs-type">Booster3</span><br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> launch &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster2</span></span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Booster3必须通过“<em>root</em>”才能访问，否则就和Booster1混淆，造成歧义。</p></blockquote><h2 id="9-3-import导入"><a href="#9-3-import导入" class="headerlink" title="9.3 import导入"></a>9.3 import导入</h2><blockquote><p>和python类似，如果每次都按第二点的精确访问方式来编程，则显得过于繁琐和复杂。因此，可以通过关键字“import”来导入相应的内容。</p></blockquote><p><strong>（1）Scala的import的特点：</strong></p><ul><li>①可以<strong>出现在代码的任意位置</strong>，而不仅仅是开头</li><li>②除了导入包内所含的内容，<strong>还能导入对象</strong>(单例对象和new构造的对象都可以)和<strong>包自身</strong>，<strong>甚至函数的参数</strong>都能<strong>作为对象来导入</strong></li><li>③可以<strong>重命名或隐藏某些成员</strong>，（类似python import as）例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><br><span class="hljs-keyword">package</span> <span class="hljs-type">A</span> &#123;<br>  <span class="hljs-keyword">package</span> <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span></span><br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> <span class="hljs-type">C</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">N</span></span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>​    通过语句“import A.B”就能把包B导入。当要访问M时，只需要写“B.M”而不需要完整的路径。通过“import A.B.M”和“import A.C.N”就分别导入了类M和对象N。此时访问它们只需要写M和N即可。</p></blockquote><p><strong>（2）import多个元素：</strong></p><p>​    <strong>路径最后的元素</strong>可以<strong>放在花括号里</strong>，这样就能导入一个或多个元素</p><p>​    例如通过<code>import A.&#123;B, C&#125;</code>就<strong>导入了两个包</strong>。花括号内的语句也叫<strong>“引入选择器子句”</strong>。</p><p><strong>（3）导入所有的元素</strong></p><p>​    <strong>使用下划线</strong>。例如<code>import A._或import A.&#123;_&#125;</code>就把包B和C都导入了，<strong>其中通配符“_”代指其余元素</strong></p><p><strong>（4）导入时对包重命名</strong>    </p><p>​    如果写成<code>import A.&#123;B =&gt; packageB&#125;</code>，就是在导入包B的同时重命名为“packageB”，此时可以<strong>用packageB指代包B</strong>，也<strong>仍能用“A.B”显式访问</strong></p><p><strong>（5）导入时对包隐藏</strong></p><p>​    如果写成<code>import A.&#123;B =&gt; _, _&#125;</code>，就是<strong>把包B进行隐藏，而导入A的其他元素</strong>。注意，指<strong>代其余元素的下划线通配符必须放在最后</strong>。</p><p><strong>（6）导入时注意相对路径问题</strong></p><p>​    <strong>包导入是相对路径</strong>，也就是<strong>代码里有<code>import A._</code>的文件要和包A编译后的文件夹要在同一级目录下</strong></p><h2 id="9-4-this自引用"><a href="#9-4-this自引用" class="headerlink" title="9.4 this自引用"></a>9.4 this自引用</h2><p>​    Scala有一个<strong>关键字“this”</strong>，用于指代对象自己。</p><p>​    <strong>简单的理解就是</strong>：</p><ul><li>如果this用在<strong>类的方法</strong>里，则指代<strong>正在调用方法的那个对象</strong>；</li><li>如果用在类的<strong>构造方法</strong>里，则指代<strong>当前正在构建的对象</strong>。</li></ul><h2 id="9-5-访问修饰符"><a href="#9-5-访问修饰符" class="headerlink" title="9.5 访问修饰符"></a>9.5 访问修饰符</h2><p>​    <strong>包、类、对象的成员</strong>都可以标上<strong>访问修饰符“private”和“protected”</strong>。</p><ul><li>用“private”修饰的成员是私有的，只能被包含它的包、类或对象的内部代码访问；</li><li>用“protected”修饰的成员是受保护的，除了能被包含它的包、类或对象的内部代码访问，<strong>还能被子类访问(只有类才有子类)</strong>。</li></ul><p><span id="限定词与自限定"></span></p><h2 id="9-6-限定词与自限定"><a href="#9-6-限定词与自限定" class="headerlink" title="9.6 限定词与自限定"></a>9.6 限定词与自限定</h2><p>​    <strong>限定词：</strong>除此之外，还可以加上限定词，<strong>使被修饰对象能被限定词访问</strong>，语法为：<code>[限定词]</code></p><blockquote><p>假设X指代某个包、类或对象，那么private[X]和protected[X]就是在不加限定词的基础上，<strong>把访问权限扩大到X的内部</strong>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-type">A</span> &#123;<br>  <span class="hljs-keyword">package</span> <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-keyword">private</span>[<span class="hljs-type">A</span>] <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustA</span></span><br>  &#125;<br> <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeA</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>.<span class="hljs-type">JustA</span>  <span class="hljs-comment">// OK</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">package</span> <span class="hljs-type">C</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>.<span class="hljs-type">B</span>.<span class="hljs-type">JustA</span>  <span class="hljs-comment">// error</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>​    <strong>限定词还能是自引用关键字“this”</strong></p><ul><li><p><strong>private[this]比private更严格</strong>，不仅只能由内部代码访问，还<strong>必须是调用方法的对象或构造方法正在构造的对象来访问</strong></p></li><li><p><strong>protected[this]则在private[this]的基础上扩展到定义时的子类</strong>，例如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt1</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mi1 = x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt1</span>) = mi1 + m.mi1<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt1</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">val</span> mi2 = x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt2</span>) = mi2 + m.mi2<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: value mi2 is not a member of <span class="hljs-type">MyInt2</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt2</span>) = mi2 + m.m<br><br></code></pre></div></td></tr></table></figure><blockquote><p>MyInt1可以编译成功，但是MyInt2却不行，因为add传入的对象不是调用方法的对象，所以不能访问字段mi2，尽管这还是代码内部。换句话说，用private[this]和protected[this]修饰的成员x，只能通过“this.x”的方式来访问。</p></blockquote><p>​    <strong>对于类、对象和特质，不建议直接用private和protected修饰，容易造成作用域混乱，应该用带有限定词的访问修饰符来修饰，显式声明它们在包内的作用域。</strong></p><p>​    前面说过，伴生对象和伴生类共享访问权限，即两者可以互访对方的所有私有成员。<strong>在伴生对象里使用“protected”没有意义</strong>，因为伴生对象没有子类。<strong>特质使用“private”和“protected”修饰成员也没有意义。</strong></p><h2 id="9-7-package-object包对象"><a href="#9-7-package-object包对象" class="headerlink" title="9.7 package object包对象"></a>9.7 package object包对象</h2><blockquote><p>​    <strong>包里可直接包含的元素有类、特质和单例对象</strong>，但其实<strong>类内可定义的元素都能放在包里</strong>（只不过字段和方法不能直接定义在包里）</p><p>​    <strong>包对象可以理解为</strong>（我自己想的）：包中唯一的可定义字段和方法且直属该包的区域/对象）</p></blockquote><p>​    <strong>Scala把字段和方法放在一个“包对象”中，每个包都允许有一个包对象。</strong></p><p>​    <strong>包对象</strong>用<strong>关键字组合“package object”</strong>为开头来定义，其<strong>名称与关联的包名相同，有点类似伴生类与伴生对象的关系</strong>。</p><p>​    <mark>包对象不是包，也不是对象</mark>，它会被编译成名为“package.class”的文件，该文件位于与它关联的包的对应文件夹里。<strong>为了保持路径同步，建议定义包对象的文件命名为“package.scala”，并和定义关联包的文件放在同一个目录下。</strong></p><h2 id="9-8-章节总结"><a href="#9-8-章节总结" class="headerlink" title="9.8 章节总结"></a>9.8 章节总结</h2><p>​    本章讲解了包的概念，以及Scala独有的一些语法特点。<strong>这一章并不是重点</strong>，主要是方便读者在阅读别人的代码时能理解层次结构、模块划分，以及根据import的路径来快速寻找相应的定义</p><h1 id="10-集合"><a href="#10-集合" class="headerlink" title="10 集合"></a>10 集合</h1><p>​    不管是用Scala编写软件，还是用Chisel开发硬件电路，集合都是非常有用的数据结构。</p><p>​    Scala里常见的集合有：<strong>数组、列表、集、映射、序列、元组、数组缓冲、列表缓冲</strong>。</p><p>​    了解这些集合的概念并熟练掌握基本使用方法，对提高工作效率大有帮助。本章的内容便是逐一讲解这些集合类，所涉内容均为基础，对编写、阅读Chisel代码有用即可。<u>如果想深入了解集合的原理，请读者自行学习。</u></p><h2 id="10-1-Array数组（一个类）"><a href="#10-1-Array数组（一个类）" class="headerlink" title="10.1 Array数组（一个类）"></a>10.1 Array数组（一个类）</h2><p>​    <strong>数组是最基本的集合</strong>，实际是计算机内一片地址连续的内存空间，通过指针来访问每一个数组元素。因为数组是结构最简单的集合，所以<strong>它在访问速度上要比其它集合要更快</strong></p><p>​    <strong>关于数组你必须知道的事情：</strong>    </p><ul><li><strong>Scala的数组类名为Array</strong>，    <strong>Array是一个具体的类，通过new来构造一个数组对象。数组元素的类型任意的，所有元素的类型必须一致。且数组在运行时会保存类型参数信息。</strong></li></ul><blockquote><p>Scala编译器的泛型机制是擦除式的，在运行时并不会保留类型参数的信息。但是数组的特点使得它成为唯一的例外，因为数组的元素类型跟数组保存在一起</p></blockquote><ul><li><p><strong>数组的性质：</strong>数组对象必须是定长的，也就是在构造时可以选择任意长度的数组，构造完毕后就不能再更改长度了</p></li><li><p><strong>构造数组对象</strong>的语法如下：</p><ul><li><strong>T表示元素的类型</strong>，可以显式声明，也可以通过传入给构造方法的对象来自动推断（构造对象时，除了可以用值参数来“配置”对象，也可以用类型参数来“配置”。这其实是oop里一种重要的多态，称为全类型多态或参数多态，即通过已有的各种类型创建新的各种类型。）</li><li><strong>n代表元素个数</strong>，它必须是一个非负整数，如果n等于0则表示空数组</li></ul></li></ul><p><mark>常用的构造方法实例：</mark></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//使用模板：</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>](n)<br><span class="hljs-comment">//使用实例：</span><br><span class="hljs-keyword">val</span> intArray = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p><mark>特殊的构造方法实例：</mark></p><ul><li><strong>特殊的构造方法</strong>：除此之外，Array的伴生对象里还定义了一个apply工厂方法，因此也可以按如下方式构造数组对象：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> charArray = <span class="hljs-type">Array</span>(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)<br>charArray: <span class="hljs-type">Array</span>[<span class="hljs-type">Char</span>] = <span class="hljs-type">Array</span>(a, b, c) <br></code></pre></div></td></tr></table></figure><ul><li><strong>数组的访问：</strong>数组可以用过<code>(下标)</code>来索引每个元素（用括号索引的原因是让编译器隐式插入apply方法的调用）</li></ul><blockquote><p>和大多数语言一样，Scala的数组下标也是从0开始的。不过，有一点不同的是，其他语言的数组下标都是写在方括号里，而Scala的数组下标却是写在圆括号里。还记得“操作符即方法吗”？Scala并没有什么下标索引操作符，而是在Array类里定义了一个apply方法，该方法接收一个Int类型的参数，返回对应下标的数组元素。所以，Scala的数组下标才要写在圆括号里，这其实是让编译器隐式插入apply方法的调用，当然读者也可以显式调用。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> intArray = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)<br>intArray: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>scala&gt; intArray(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span><br><br>scala&gt; intArray(<span class="hljs-number">1</span>) = <span class="hljs-number">2</span><br><br>scala&gt; intArray(<span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br><br>scala&gt; intArray<br>res0: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><h2 id="10-2-List列表-一个抽象类，类似不可写入的Array"><a href="#10-2-List列表-一个抽象类，类似不可写入的Array" class="headerlink" title="10.2 List列表(一个抽象类，类似不可写入的Array)"></a>10.2 List列表(一个抽象类，类似不可写入的Array)</h2><blockquote><p>​    列表是一种基于链表的数据结构，这使得<strong>列表访问头部元素很快，往头部增加新元素也是消耗定长时间，但是对尾部进行操作则需要线性化的时间，也就是列表越大时间越长</strong>。</p></blockquote><ul><li><strong>List列表是一个抽象类，因此不能用new来构造列表对象。</strong>但是伴生对象里有一个apply工厂方法，接收若干个参数，<strong>以数组的形式转换成列表(链表)</strong>。<strong>列表也是定长的</strong>，<strong>且每个元素的类型相同、不可再重新赋值</strong></li><li><p><strong>List有点像不可写入的Array</strong></p></li><li><p><strong>列表元素的访问</strong>：同Array</p></li></ul><p><mark>常用的构造与访问方法实例：</mark></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> intList = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-5</span>)<br>intList: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-5</span>)<br><br>scala&gt; intList(<span class="hljs-number">0</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; intList(<span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">-5</span><br><br></code></pre></div></td></tr></table></figure><ul><li><strong>列表添加新元素</strong>（不是修改旧表，列表不可变，而是构造新表）：列表定义了一个名为<code>::</code>的方法，在列表头部添加新元素。其写法如下：</li></ul><blockquote><p>因为列表的数据结构特性使得在头部添加元素很快，而尾部很慢，所以列表定义了一个名为“::”的方法，在列表头部添加新元素。注意，这会构造一个新的列表对象，而不是直接修改旧列表，因为列表是不可变的</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">x :: xs<br></code></pre></div></td></tr></table></figure><ul><li><ul><li><p>左侧的x是一个T类型的元素</p></li><li><p>右侧的xs是一个List[T]类型的列表。</p></li><li><p>这种写法符合直观表示。</p></li><li><blockquote><p>还记得前面说过以冒号结尾的中缀操作符，其调用对象在右侧吗？其实正是出自这里。因为x是任意类型的，如果让x成为调用对象，那么就必须在所有类型包括自定义类型里都添加方法“::”，这显然是不现实的。如果<strong>让列表xs成为调用对象</strong>，那么只需要列表类定义该方法即可。例如：</p></blockquote></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scalal">scala&gt; 1 :: List(2, 3)<br>res0: List[Int] = List(1, 2, 3)<br></code></pre></div></td></tr></table></figure><ul><li><strong>拼接左、右两个列表，返回新的列表</strong>：<code>:::</code></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ::: <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <br></code></pre></div></td></tr></table></figure><ul><li><p><strong>空列表</strong>：</p><ul><li>L<strong>ist有一个子对象<code>Nil</code>，示空列表</strong>。<strong>Nil的类型是List[Nothing]</strong></li><li>因为List的类型参数是协变的(有关泛型请见后续章节)，而Nothing又是所有类的子类，所以<strong>List[Nothing]是所有列表的子类，即<code>Nil</code>兼容所有元素</strong></li></ul></li><li><p><strong>使用空列表构造列表：</strong>既然Nil是一个空列表对象，那么它同样能调用方法<code>::</code>，通过<code>Nil和::</code>就能构造出一个列表</p></li></ul><p><mark>使用空列表构造方法实例：</mark></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span> :: <span class="hljs-number">2</span> :: <span class="hljs-number">3</span> :: <span class="hljs-type">Nil</span><br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><ul><li><ul><li>用apply工厂方法构造其实是上述方式的等效形式。展开来解释就是：在空列表Nil的头部添加了一个元素3，构成了列表List(3)；随后，继续在头部添加元素2，构成列表List(2, 3)；最后，在头部添加元素1，得到最终的List(1, 2, 3)</li></ul></li><li><p><strong>使数组和列表包含不同类型的元素（不推荐）</strong>：<strong>数组与列表元素不仅可以是值类型，它们也可以是自定义的类，甚至是数组和列表本身，构成嵌套的数组与列表</strong>。此外，如果元素类型是Any，那么数组和列表也就可以包含不同类型的元素。当然，并不推荐这么做。例如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>))<br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">List</span>(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>))<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, &#x27;<span class="hljs-number">1</span>&#x27;, <span class="hljs-string">&quot;1&quot;</span>)<br>res1: <span class="hljs-type">List</span>[<span class="hljs-type">Any</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h2 id="10-3-快速添加元素、数组缓冲与列表缓冲"><a href="#10-3-快速添加元素、数组缓冲与列表缓冲" class="headerlink" title="10.3 快速添加元素、数组缓冲与列表缓冲"></a>10.3 快速添加元素、数组缓冲与列表缓冲</h2><p><strong>（1）如何快速添加元素往尾部添加元素：</strong></p><ul><li><p>一种可行方案是先往列表头部添加，再把列表整体翻转。</p></li><li><p>另一种方案是使用定义在scala.collection.mutable包里的ArrayBuffer和ListBuffer。</p><ul><li>这两者<strong>并不是真正的数组和列表，而可以认为是暂存在缓冲区的数据</strong>。在数组缓冲和列表缓冲的头部、尾部都能添加、删去元素，并且<strong>耗时是固定的</strong>，只不过<strong>数组缓冲要比数组慢一些</strong>。数组和列表能使用的成员方法，在它们的缓冲类里也有定义。</li></ul></li></ul><p><strong>（2）使用ArrayBuffer/ListBuffer添删元素的具体方法：</strong></p><ul><li><code>ArrayBuffer/ListBuffer += value</code>可以往<strong>缓冲尾部添加元素</strong></li><li>通过<code>value +=: ArrayBuffer/ListBuffer</code>可以往<strong>缓冲头部添加元素</strong></li><li>只能通过<code>ArrayBuffer/ListBuffer -= value</code>往缓冲的<strong>尾部删去第一个符合的元素</strong></li><li><strong>往尾部增加或删除元素时，元素数量可以不只一个</strong>。</li></ul><p><mark>常用的构造与访问方法实例：</mark></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> scala.collection.mutable.&#123;<span class="hljs-type">ArrayBuffer</span>, <span class="hljs-type">ListBuffer</span>&#125;<br><span class="hljs-keyword">import</span> scala.collection.mutable.&#123;<span class="hljs-type">ArrayBuffer</span>, <span class="hljs-type">ListBuffer</span>&#125;<br><br>scala&gt; <span class="hljs-keyword">val</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>]()<br>ab: scala.collection.mutable.<span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">ArrayBuffer</span>()<br><br>scala&gt; ab += <span class="hljs-number">10</span><br>res0: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">10</span>)<br><br>scala&gt; <span class="hljs-number">-10</span> +=: ab<br>res1: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)<br><br>scala&gt; ab -= <span class="hljs-number">-10</span><br>res2: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">10</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> lb = <span class="hljs-keyword">new</span> <span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>]()<br>lb: scala.collection.mutable.<span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">ListBuffer</span>()<br><br>scala&gt; lb += (<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;oops&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>)<br>res3: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(abc, oops, good)<br><br>scala&gt; lb -= <span class="hljs-string">&quot;abc&quot;</span><br>res4: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(oops, good)<br><br>scala&gt; <span class="hljs-string">&quot;scala&quot;</span> +=: lb<br>res5: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(scala, oops, good)<br></code></pre></div></td></tr></table></figure><p><strong>（3）使用ArrayBuffer/ListBuffer转换数组的方法：</strong></p><ul><li>通过方法<code>toArray</code>或<code>toList</code>把缓冲的数据构造成一个数组或列表对象</li><li>注意，<strong>这是构造一个新的对象，原有缓冲仍然存在</strong>。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; lb.toArray<br>res6: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Array</span>(scala, oops, good)<br><br>scala&gt; lb.toList<br>res7: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(scala, oops, good)<br><br>scala&gt; lb<br>res8: scala.collection.mutable.<span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">ListBuffer</span>(scala, oops, good)<br></code></pre></div></td></tr></table></figure><h2 id="10-4-Tuple元组（一系列类）"><a href="#10-4-Tuple元组（一系列类）" class="headerlink" title="10.4 Tuple元组（一系列类）"></a>10.4 Tuple元组（一系列类）</h2><ul><li><strong>元组</strong>也是一种常用的数据结构，<strong>不是一个类是一系列类，不可变，但可以包含不同类型元素</strong></li><li><strong>两种元组的构造写法：</strong><ul><li><strong>(不常用)使用具体的元组类进行元组构造</strong>：<code>new TupleX(元组元素)</code>，见<a href="#元组并不是一个类，而是一系列类">下方介绍</a><ul><li><strong>元组字面量构造的写法：</strong>就是在圆括号里编写用逗号间隔的元素。<mark>常用的构造方法实例：</mark></li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tuple&quot;</span>, <span class="hljs-type">Console</span>)<br>res0: (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>, <span class="hljs-type">Console</span>.<span class="hljs-keyword">type</span>) = (<span class="hljs-number">1</span>,tuple,scala.<span class="hljs-type">Console</span>$@<span class="hljs-number">5</span>fc59e43) <br></code></pre></div></td></tr></table></figure><blockquote><p><strong>上述例子构造了一个三元组</strong>，包含了一个Int对象、一个String对象和控制台对象。注意查看打印的元组类型。</p></blockquote><ul><li><p><strong>元组最常用的地方：作为函数的返回值。</strong>由于函数只有一个返回语句，但如果想返回多个表达式或对象，就可以把它们包在一个元组里返回。</p></li><li><p><strong>元组不可遍历，无法通过下标来索引：</strong>因为元组含有不同类型的对象，所以不可遍历，也就无法通过下标来索引，<strong>只能通过“_1”、“_2”……这样来访问每个元素</strong>。<strong>注意第一个元素就是“_1”，不是“_0”（与Array和List从0开始不同）</strong>例如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> t = (<span class="hljs-string">&quot;God&quot;</span>, &#x27;<span class="hljs-type">A</span>&#x27;, <span class="hljs-number">2333</span>)<br>t: (<span class="hljs-type">String</span>, <span class="hljs-type">Char</span>, <span class="hljs-type">Int</span>) = (<span class="hljs-type">God</span>,<span class="hljs-type">A</span>,<span class="hljs-number">2333</span>)<br><br>scala&gt; t._1<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">God</span><br><br>scala&gt; t._2<br>res1: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; t._3<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">2333</span><br></code></pre></div></td></tr></table></figure><p><span id="元组并不是一个类，而是一系列类"></span></p><ul><li><p><strong>元组并不是一个类，而是一系列类</strong>：Tuple1、Tuple2、Tuple3……Tuple22</p><ul><li><p><strong>这些类都是具体的</strong>，因此除了通过字面量的写法构造元组，也可以显式地通过<code>new TupleX(元组元素)</code>来构造。其中，<strong>每个数字代表元组包含的元素数量，也就是说元组最多只能包含22个元素，除非自定义Tuple23、Tuple24……不过这没有意义</strong>，因为元组可以嵌套元组，并不妨碍元组包含任意数量的元素。</p></li><li><p>查看元组的API，会发现每个TupleX类里都有名为“_1”、“_2”……“_X”的字段。这正好呼应了前面访问元组元素所用的独特语法。</p><ul><li><strong>Tuple1（一元组）</strong>没有字面量，只能显式地通过“new Tuple1(元组元素)”来构造一元组，因为<strong>此时编译器不会把圆括号解释成元组</strong></li><li><strong>Tuple2（二元组）</strong>也叫“对偶”，这在<strong>映射里会用到</strong></li></ul></li></ul></li><li><p>当函数的入参数量只有一个时，那么调用时传递进去的<strong>元组字面量也可以省略圆括号</strong>。例如：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getType</span></span>(x: <span class="hljs-type">Any</span>) = x.getClass<br>getType: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">Class</span>[_]<br><br>scala&gt; getType(<span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">Class</span>[_] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Integer</span></span><br><br>scala&gt; getType(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Class</span>[_] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">scala</span>.<span class="hljs-title">Tuple3</span></span><br></code></pre></div></td></tr></table></figure><h2 id="10-5-Map映射（一个特质）"><a href="#10-5-Map映射（一个特质）" class="headerlink" title="10.5 Map映射（一个特质）"></a>10.5 Map映射（一个特质）</h2><ul><li><p>映射是包含一系列<strong>“键-值”对的集合</strong>，可重复的键值对（可重复hash）</p></li><li><p><strong>键和值的类型可以是任意的，但是每个键-值对的类型必须一致</strong></p></li><li><p><strong>键-值对的写法是“键 -&gt; 值”</strong></p></li><li><p><strong>映射并不是一个类，而是一个特质</strong>。所以<strong>无法用new构建映射对象</strong>，只能通过伴生对象里的<strong>apply工厂方法来构造映射类型的对象</strong>，<mark>常用的构造方法实例：</mark></p></li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>(<span class="hljs-number">1</span> -&gt; <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">2</span> -&gt; <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">3</span> -&gt; <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">4</span> -&gt; <span class="hljs-string">&quot;/&quot;</span>)<br>map: scala.collection.immutable.<span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>,<span class="hljs-type">String</span>] = <span class="hljs-type">Map</span>(<span class="hljs-number">1</span> -&gt; +, <span class="hljs-number">2</span> -&gt; -, <span class="hljs-number">3</span> -&gt; *, <span class="hljs-number">4</span> -&gt; /)<br></code></pre></div></td></tr></table></figure><ul><li><strong>Map返回键对应值：</strong>对映射的apply方法通过接收一个键作为参数，返回对应的值。例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; map(<span class="hljs-number">3</span>)<br>res0: <span class="hljs-type">String</span> = *<br><br>scala&gt; map(<span class="hljs-number">0</span>)<br>java.util.<span class="hljs-type">NoSuchElementException</span>: key not found: <span class="hljs-number">0</span><br>  at scala.collection.immutable.<span class="hljs-type">Map</span>$<span class="hljs-type">Map4</span>.apply(<span class="hljs-type">Map</span>.scala:<span class="hljs-number">204</span>)<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure><ul><li><strong>实际意义（可以写成对偶形式）：表达式“object1 -&gt; object2”实际就是一个对偶(二元组)，</strong>因此<strong>键-值对也可以写成对偶的形式。</strong>例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> tupleMap = <span class="hljs-type">Map</span>((&#x27;a&#x27;, &#x27;<span class="hljs-type">A</span>&#x27;), (&#x27;b&#x27;, &#x27;<span class="hljs-type">B</span>&#x27;))<br>tupleMap: scala.collection.immutable.<span class="hljs-type">Map</span>[<span class="hljs-type">Char</span>,<span class="hljs-type">Char</span>] = <span class="hljs-type">Map</span>(a -&gt; <span class="hljs-type">A</span>, b -&gt; <span class="hljs-type">B</span>)<br><br>scala&gt; tupleMap(&#x27;a&#x27;)hex<br>res0: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br></code></pre></div></td></tr></table></figure><ul><li>映射可变与不可变：<strong>默认情况下，使用的是scala.collection.immutable包</strong>里的不可变映射。当然，<strong>也可以导入scala.collection.mutable包里的可变映射</strong>，这样就能动态地增加、删除键-值对。可变映射的名字也叫“Map”，因此要注意使用import导入可变映射时，是否把不可变映射覆盖了。</li></ul><h2 id="10-6-Set集合（一个特质）"><a href="#10-6-Set集合（一个特质）" class="headerlink" title="10.6 Set集合（一个特质）"></a>10.6 Set集合（一个特质）</h2><ul><li><strong>集和映射一样，也是一个特质，也只能通过apply工厂方法构建对象</strong></li><li><p><strong>理解为hash哈希</strong></p></li><li><p>集只能包含<strong>字面值不相同</strong>的<strong>同类型元素</strong></p></li><li><strong>集的apply方法是测试是否包含传入的参数，返回true或false，而不是通过下标来索引元素</strong></li></ul><p><mark>常用的构造方法如下：</mark></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> set = <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">233</span>)<br>set: scala.collection.immutable.<span class="hljs-type">Set</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">233</span>)<br><br>scala&gt; set(<span class="hljs-number">100</span>)<br>res0: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; set(<span class="hljs-number">233</span>)<br>res1: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>默认情况下，使用的也是不可变集，scala.collection.mutable包里也有同名的可变集</strong></li></ul><h2 id="10-7-Seq序列（一个特质）"><a href="#10-7-Seq序列（一个特质）" class="headerlink" title="10.7 Seq序列（一个特质）"></a>10.7 Seq序列（一个特质）</h2><ul><li><p><strong>序列Seq也是一个特质，数组和列表都混入了这个特质</strong></p></li><li><p><strong>序列可遍历、可迭代</strong>，也就是能用从0开始的下标索引，也可用于循环。</p></li><li><strong>序列也是包含一组相同类型的元素，并且不可变</strong>。</li><li><strong>其构造方法也是通过apply工厂方法</strong>。</li></ul><p>只是因为Chisel在某些场合会用到Seq，所以介绍这个概念，但是不必深入了解。</p><h2 id="10-8-针对集合的几种常用方法"><a href="#10-8-针对集合的几种常用方法" class="headerlink" title="10.8 针对集合的几种常用方法"></a>10.8 针对集合的几种常用方法</h2><p>​    上述类都定义了很多有用的成员方法，在这里介绍一二。如果想查看更多内容，建议前往官网的API网站查询</p><p><strong>（1）map方法</strong>（同python里面的Map）</p><p>​    <strong>为集合内每个元素接受参数：</strong>Map方法接收一个无副作用的函数作为入参，对调用该方法的集合的每个元素应用入参函数，并把所得结果全部打包在一个集合里返回</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Array</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>).map(_ + <span class="hljs-string">&quot;s&quot;</span>)<br>res0: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Array</span>(apples, oranges, pears)<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(_ * <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br></code></pre></div></td></tr></table></figure><p><strong>（2）foreach方法</strong>（同java里面的泛式）</p><p>​    <strong>遍历集合内每一个元素</strong>：foreach方法与map方法<strong>作用类似</strong>，不过它的入参是一个有副作用的函数。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>sum: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">234</span>).foreach(sum += _)<br><br>scala&gt; sum<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br></code></pre></div></td></tr></table></figure><p><strong>（3）zip方法</strong></p><p>​    <strong>把两个可迭代的集合一一对应，构成若干个对偶</strong>。如果其中一个集合比另一个长，则忽略多余的元素。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) zip <span class="hljs-type">Array</span>(&#x27;<span class="hljs-number">1</span>&#x27;, &#x27;<span class="hljs-number">2</span>&#x27;, &#x27;<span class="hljs-number">3</span>&#x27;)<br>res0: <span class="hljs-type">List</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Char</span>)] = <span class="hljs-type">List</span>((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) zip <span class="hljs-type">Set</span>(<span class="hljs-string">&quot;good&quot;</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br>res1: <span class="hljs-type">List</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>)] = <span class="hljs-type">List</span>((<span class="hljs-number">1</span>,good), (<span class="hljs-number">2</span>,<span class="hljs-type">OK</span>))<br></code></pre></div></td></tr></table></figure><h2 id="10-9-章节总结"><a href="#10-9-章节总结" class="headerlink" title="10.9 章节总结"></a>10.9 章节总结</h2><p>​    本章介绍了Scala标准库里的常用集合，<strong>这些数据结构在Chisel里面也经常用到</strong>，读者应该熟悉掌握它们的概念和相关重点。在后一章内建控制结构中，也要用到这些集合</p><h1 id="11-内建控制结构"><a href="#11-内建控制结构" class="headerlink" title="11 内建控制结构"></a>11 内建控制结构</h1><h2 id="11-1-if表达式"><a href="#11-1-if表达式" class="headerlink" title="11.1 if表达式"></a>11.1 if表达式</h2><blockquote><p>用于判断的“if……else if……else”语法想必是所有编程语言都具备的。Scala的if表达式与大多数语言是一样的。在if和每个else if后面都将接收一个Boolean类型的表达式作为参数，如果表达式的结果为true，就执行对应的操作，否则跳过。每个分支都可以包含一个表达式作为执行体，如果有多个表达式，则应该放进花括号里。对整个if表达式而言，实际是算作一个表达式。</p></blockquote><p><strong>为什么叫if表达式？</strong></p><ul><li>Scala把“if”叫“表达式”，是因为if表达式能返回有用的值</li><li>但是while叫循环，是因为while循环不会返回有用的值，主要作用是不断重写某些var变量，所以while循环的类型是Unit</li><li>跟多内容在下一节有解释</li></ul><p>类似大多数高级语言，不过多介绍</p><h2 id="11-2-while循环"><a href="#11-2-while循环" class="headerlink" title="11.2 while循环"></a>11.2 while循环</h2><p>类似大多数高级语言，不过多介绍</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcdLoop</span></span>(x: <span class="hljs-type">Long</span>, y: <span class="hljs-type">Long</span>): <span class="hljs-type">Long</span> = &#123;<br>  <span class="hljs-keyword">var</span> a = x<br>  <span class="hljs-keyword">var</span> b = y<br>  <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">val</span> temp = a<br>    a = b % a<br>    b = temp<br>  &#125;<br>  b<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    从上述代码可以看出，<strong>while语法的风格是指令式的</strong>。实际上，<strong>Scala把“if”叫“表达式”</strong>，是因为if表达式能返回有用的值，而“while”叫循环，是因为<strong>while循环不会返回有用的值</strong>，主要作用是不断重写某些var变量，所以<strong>while循环的类型是Unit</strong>，<strong>在纯函数式的语言里，只有表达式，不会存在像while循环这样的语法。</strong>Scala兼容两种风格，并引入了while循环，是因为某些时候用while编写的代码可阅读性更强</p><p>​    <strong>函数式风格的while循环(使用递归的方式实现)</strong>：<strong>其实所有的while循环都可以通过其它函数式风格的语法来实现</strong>，常见做法就是函数的<strong>递归调用</strong>。例如，一个函数式风格的求取最大公约数的函数定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span></span>(x: <span class="hljs-type">Long</span>, y: <span class="hljs-type">Long</span>): <span class="hljs-type">Long</span> =<br>  <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) x <span class="hljs-keyword">else</span> gcd(y, x % y)<br></code></pre></div></td></tr></table></figure><h2 id="11-3-for表达式与for循环（推荐）"><a href="#11-3-for表达式与for循环（推荐）" class="headerlink" title="11.3 for表达式与for循环（推荐）"></a>11.3 for表达式与for循环（推荐）</h2><p><strong>（1）for循环介绍</strong></p><p>​    <strong>要实现循环，在Scala里推荐使用for表达式</strong>。Scala的<strong>for表达式是函数式风格的</strong>，<strong>没有引入指令式风格的“for(i = 0; i &lt; N; i++)”</strong></p><p>​    <strong>其他风格的for</strong>（类似传统上的for循环）循环可以参考链接：<a href="https://www.runoob.com/scala/scala-for-loop.html">https://www.runoob.com/scala/scala-for-loop.html</a></p><p><strong>（2）使用yield的循环：</strong></p><p>一个Scala的for表达式的一般形式如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>( seq ) <span class="hljs-keyword">yield</span> expression<br></code></pre></div></td></tr></table></figure><ul><li><strong>整个for表达式算一个语句</strong>。</li><li><strong>seq代表一个序列</strong><ul><li><strong>能放进for表达式里的对象，必须是一个可迭代（Iterable）的集合</strong>。比如常用的列表(List)、数组(Array)、映射(Map)、区间(Range)、迭代器(Iterator)、流(Stream)和所有的集(Set)，<strong>它们都混入了特质Iterable</strong><ul><li><strong>可迭代的集合对象能生成一个迭代器</strong>，用该<strong>迭代器可以逐个遍历</strong>集合中的所有元素，<strong>进而构成了for表达式所需的序列</strong>。</li></ul></li></ul></li><li><strong>关键字“yield”是“产生”的意思</strong>，也就是把前面序列里符合条件的元素拿出来，<strong>逐个应用到后面的“expression”</strong>，<strong>得到的所有结果按顺序产生一个新的集合对象</strong></li></ul><p><strong>（3）完整的For循环（上述seq展开式）：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> &#123;<br>   <span class="hljs-comment">//sep包括三部分：生成器、定义、过滤器</span><br>  p &lt;- persons          <span class="hljs-comment">// 一个生成器</span><br>  n = p.name            <span class="hljs-comment">// 一个定义</span><br>  <span class="hljs-keyword">if</span>(n startsWith <span class="hljs-string">&quot;To&quot;</span>)  <span class="hljs-comment">// 一个过滤器</span><br>&#125; <span class="hljs-keyword">yield</span> n<br></code></pre></div></td></tr></table></figure><p>​    <strong>seq是由“生成器”、“定义”和“过滤器”三条语句组成</strong>（以分号隔开，或者放在花括号里让编译器自动推断分号）</p><ul><li>①<strong>生成器</strong><code>p &lt;- persons</code>右侧<code>persons</code>就是一个可迭代的集合对象，把它的每个元素逐一拿出来与左侧的模式<code>p</code>进行匹配(有关模式匹配请见后续章节)。<ul><li>如果匹配<strong>成功</strong>，那么<strong>模式里的变量</strong>就会绑定上该元素对应的部分；</li><li>如果匹配<strong>失败</strong>，并不会抛出匹配错误，而是简单地<strong>丢弃该元素</strong>。</li><li>在这个例子里，<strong>左侧的p</strong>是一个<strong>无需定义的变量名，它构成了变量模式</strong>，也就是<strong>简单地指向persons的每个元素</strong></li><li><strong>大多数情况下的for表达式的生成器都是这么简单</strong>。</li></ul></li><li>②<strong>定义就是一个赋值语句</strong>，这里的<strong>n</strong>也是一个无需定义的变量名。<strong>定义并不常用</strong>，比如这里的定义就可有可无。</li><li>③<strong>过滤器</strong>则是一个if语句，只有if后面的表达式为true时，生成器的元素才会继续向后传递，否则就丢弃该元素。</li><li><strong>这个例子中，是判断persons的元素的name字段是否以“To”为开头</strong>。<strong>最后，name以“To”为开头的persons元素会应用到yield后面的表达式，在这里仅仅是保持不变，没有任何操作。</strong>（总之，这个表达式的结果就是遍历集合persons的元素，按顺序找出所有name以“To”为开头的元素，然后把这些元素组成一个新的集合）</li><li>完整的sep展开的for的示例代码：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span></span>)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Alice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Alice</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Tom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Tom</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Tony</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Tony</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Bob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Bob</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Todd</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Todd</span>&quot;</span>)</span><br> <br><span class="hljs-keyword">val</span> persons = <span class="hljs-type">List</span>(<span class="hljs-type">Alice</span>, <span class="hljs-type">Tom</span>, <span class="hljs-type">Tony</span>, <span class="hljs-type">Bob</span>, <span class="hljs-type">Todd</span>)<br> <br><span class="hljs-keyword">val</span> <span class="hljs-type">To</span> = <span class="hljs-keyword">for</span> &#123;<br>  p &lt;- persons          <br>  n = p.name            <br>  <span class="hljs-keyword">if</span>(n startsWith <span class="hljs-string">&quot;To&quot;</span>) <br>&#125; <span class="hljs-keyword">yield</span> n<br> <br>println(<span class="hljs-type">To</span>)<br></code></pre></div></td></tr></table></figure><blockquote><p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>List(Tom, Tony, Todd)</p></blockquote><p><strong>（4）嵌套for</strong></p><ul><li><strong>一个for表达式中有多个生成器</strong>：那么出现在后面的生成器比出现在前面的生成器变得更频繁，也就是指令式编程里的嵌套的for循环。例如计算乘法口诀表：</li></ul><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"> scala&gt; <span class="hljs-keyword">for</span> &#123;undefined<br>          |    i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">9</span><br>          |    j &lt;- i to <span class="hljs-number">9</span><br>          |  &#125; <span class="hljs-keyword">yield</span> i * j<br>res0: scala.collection.immutable.<span class="hljs-type">IndexedSeq</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">28</span>, <span class="hljs-number">32</span>, <span class="hljs-number">36</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>, <span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">36</span>, <span class="hljs-number">42</span>, <span class="hljs-number">48</span>, <span class="hljs-number">54</span>, <span class="hljs-number">49</span>, <span class="hljs-number">56</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">81</span>)<br><br></code></pre></div></td></tr></table></figure><p><strong>（5）普通遍历的for、定义的重新计算</strong>    </p><p>​    <strong>每当生成器生成一个匹配的元素，后面的定义就会重新求值。</strong></p><p>​    这个求值是有必要的，因为定义很可能需要随生成器的值变化而变化。为了不浪费这个操作，定义应尽量用到相关生成器绑定的变量，否则就没必要使用定义。例如： </p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">1000</span>; y = 一条计算x的函数) <span class="hljs-keyword">yield</span> x * y<br></code></pre></div></td></tr></table></figure><p>​    不如写成：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> y =  一条计算x的函数 <br><br><span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">1000</span>) <span class="hljs-keyword">yield</span> x * y<br></code></pre></div></td></tr></table></figure><p><strong>（6）for求和、省略yield</strong></p><p>​    如果只想把每个元素应用到一个Unit类型的表达式，那么就是一个“for循环”，而不再是一个“for表达式”。关键字“yield”也可以省略。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>sum: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">100</span>) sum += x<br><br>scala&gt; sum<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">5050</span><br></code></pre></div></td></tr></table></figure><h2 id="11-4-用try表达式处理异常"><a href="#11-4-用try表达式处理异常" class="headerlink" title="11.4 用try表达式处理异常"></a>11.4 用try表达式处理异常</h2><p><strong>（1）抛出一个异常</strong></p><p>​    如果操作非法，那么<strong>JVM会自动抛出异常</strong>。</p><p>​    <strong>也可以手动抛出异常，</strong>只需要用new构造一个异常对象，并用关键字“throw”抛出即可，<strong>语法与Java一样。</strong></p><p>​    <strong>try表达式的完整形式是“try-catch-finally”</strong></p><p><strong>（2）try-catch</strong></p><blockquote><p>​    try后面可以用花括号包含任意条代码，当这些代码产生异常时，JVM并不会立即抛出，而是被catch捕获。catch捕获异常后，按其后面的定义进行相应的处理。处理的方式一般借助偏函数，在详细了解模式匹配前，只需要了解这些语法即可。例如处理除零异常：</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intDivision</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">try</span> &#123;undefined<br>         |       x / y<br>         |     &#125; <span class="hljs-keyword">catch</span> &#123;undefined<br>         |       <span class="hljs-keyword">case</span> ex: <span class="hljs-type">ArithmeticException</span> =&gt; println(<span class="hljs-string">&quot;The divisor is Zero!&quot;</span>)<br>         |     &#125;<br>         |  &#125;<br>intDivision: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">AnyVal</span><br><br>scala&gt; intDivision(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-type">The</span> divisor is <span class="hljs-type">Zero</span>!<br>res0: <span class="hljs-type">AnyVal</span> = ()<br><br>scala&gt; intDivision(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">AnyVal</span> = <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p><strong>（3）finally</strong></p><p>​    try表达式的完整形式是“try-catch-finally”。<strong>不管有没有异常产生，finally里的代码一定会执行。通常finally语句块都是执行一些清理工作，比如关闭文件。尽管try表达式可以返回有用值，但是最好不要在finally语句块里这么做。</strong>因为Java在显式声明“return”时，会用finally的返回值覆盖前面真正需要的返回值。为了以防万一，最好不要这样做。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span></span>(): <span class="hljs-type">Int</span> = <span class="hljs-keyword">try</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">finally</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>a: ()<span class="hljs-type">Int</span><br><br>scala&gt; a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span></span>(): <span class="hljs-type">Int</span> = <span class="hljs-keyword">try</span> <span class="hljs-number">1</span> <span class="hljs-keyword">finally</span> <span class="hljs-number">2</span><br>b: ()<span class="hljs-type">Int</span><br><br>scala&gt; b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="10-5-match表达式"><a href="#10-5-match表达式" class="headerlink" title="10.5 match表达式"></a>10.5 match表达式</h2><p>​    match表达式的作用相当于“switch”，也就是把作用对象与定义的模式逐个比较，按匹配的模式执行相应的操作。在详细了解模式匹配之前，先看一个简单的例子粗浅地了解一番：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">something</span></span>(x: <span class="hljs-type">String</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Apple&quot;</span> =&gt; println(<span class="hljs-string">&quot;Fruit!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Tomato&quot;</span> =&gt; println(<span class="hljs-string">&quot;Vegetable!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Cola&quot;</span> =&gt; println(<span class="hljs-string">&quot;Beverage!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> _ =&gt; println(<span class="hljs-string">&quot;Huh?&quot;</span>)<br>         |  &#125;<br>something: (x: <span class="hljs-type">String</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; something(<span class="hljs-string">&quot;Cola&quot;</span>)<br><span class="hljs-type">Beverage</span>!<br><br>scala&gt; something(<span class="hljs-string">&quot;Toy&quot;</span>)<br><span class="hljs-type">Huh</span>?<br></code></pre></div></td></tr></table></figure><h2 id="10-6-关于continue和break"><a href="#10-6-关于continue和break" class="headerlink" title="10.6 关于continue和break"></a>10.6 关于continue和break</h2><p><strong>（1）传统循环中的continue和break</strong></p><p>​    对于指令式编程而言，循环里经常用到关键字“continue”和“break”，例如下面的Java程序：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Java</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">boolean</span> foundIt = <span class="hljs-keyword">false</span>;<br> <br><span class="hljs-keyword">while</span> (i &lt; args.length) &#123;<br>  <span class="hljs-keyword">if</span> (args[i].startsWith(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>    i = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (args[i].endsWith(<span class="hljs-string">&quot;.scala&quot;</span>)) &#123;<br>    foundIt = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  i = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    实际上，这两个关键字对循环而言并不是必须的。例如可以改写成如下Scala代码：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bad Scala</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> foundIt = <span class="hljs-literal">false</span><br> <br><span class="hljs-keyword">while</span> (i &lt; args.length &amp;&amp; !foundIt) &#123;<br>  <span class="hljs-keyword">if</span> (!args(i).startsWith(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (args(i).endsWith(<span class="hljs-string">&quot;.scala&quot;</span>))<br>      foundIt = <span class="hljs-literal">true</span><br>  &#125;<br>  i = i + <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>（2）Scala中的break和continue</strong></p><blockquote><p>​    又因为这两个关键字过于偏向指令式风格，就像“return”，所以<strong>Scala并没有引入它们</strong>。</p></blockquote><p>​    <strong>Scala不提供原生的break和continue，也不推荐用for循环，而是通过递归调用实现：</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// good Scala</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchFrom</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> =<br>  <span class="hljs-keyword">if</span> (i &gt;= args.length) <span class="hljs-number">-1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args(i).startsWith(<span class="hljs-string">&quot;-&quot;</span>)) searchFrom(i + <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args(i).endsWith(<span class="hljs-string">&quot;.scala&quot;</span>)) i<br>  <span class="hljs-keyword">else</span> searchFrom(i + <span class="hljs-number">1</span>)<br> <br><span class="hljs-keyword">val</span> i = searchFrom(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>​    <strong>Scala标准库中提供了Break类从而实现break</strong></p><p>​    通过<code>import scala.util.control.Breaks._”</code>可以导入Breaks类，该类定义了一个名为“break”的方法。那么，在写下break的地方，就会被编译器标记为可中断。</p><h2 id="11-7-变量的作用域"><a href="#11-7-变量的作用域" class="headerlink" title="11.7 变量的作用域"></a>11.7 变量的作用域</h2><p>​    在使用控制结构的时候，尤其是有嵌套时，必然要搞清楚变量的作用范围。Scala变量作用范围很明确，边界就是花括号。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printMultiTable</span></span>() = &#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 只有i在作用域内</span><br>  <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// i和j都在作用域内</span><br>    <span class="hljs-keyword">while</span> (j &lt;= <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">val</span> prod = (i * j).toString<br>      <span class="hljs-comment">// i、j和prod都在作用域内</span><br>      <span class="hljs-keyword">var</span> k = prod.length<br>      <span class="hljs-comment">// i、j、prod和k都在作用域内</span><br>      <span class="hljs-keyword">while</span> (k &lt; <span class="hljs-number">4</span>) &#123;<br>        print(<span class="hljs-string">&quot; &quot;</span>)<br>        k += <span class="hljs-number">1</span><br>      &#125;<br>      print(prod)<br>      j += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// i和j仍在作用域内；prod和k已经超出作用域</span><br>    println()<br>    i += <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-comment">// i仍在作用域内；j、prod和k已经超出作用域</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    如果内、外作用域有同名的变量，那么内部作用域以内部变量为准，超出内部的范围以外部变量为准。例如：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>() = &#123;undefined<br>         |     <span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span><br>         |     do &#123;undefined<br>         |         <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>         |         println(a)<br>         |     &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">false</span>)<br>         |     println(a)<br>         |  &#125;<br>f: ()<span class="hljs-type">Unit</span><br><br>scala&gt; f<br><span class="hljs-number">10</span><br><span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="11-8-章节总结"><a href="#11-8-章节总结" class="headerlink" title="11.8 章节总结"></a>11.8 章节总结</h2><p>​    本章介绍了Scala的内建控制结构，尤其是for表达式，在Chisel里面也是经常用到。<strong>对于重复逻辑、连线等，使用for表达式就很方便。尽管Verilog也有for语法，但是使用较为麻烦，而且不能像Chisel一样支持泛型。</strong></p><p>​    除此之外，Chisel也有自定义的控制结构，这些内容会在后续章节讲解。</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96247202_p0.jpg" alt="pixivid：96247202"></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶9：寄存器模型概览_集成.md</title>
    <link href="/202202110126/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B69%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88_%E9%9B%86%E6%88%90/"/>
    <url>/202202110126/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B69%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88_%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>sv实验五到uvm实验四之间所有的验证结构、组件、环境、运行、怎么开始结束，都是映射的，uvm所有的核心已经sv过度到uvm</p><p>今天我们学的寄存器结构，sv里面虽然也有但比较简陋，在uvm我们需要用相关语法去合成一个寄存器模型，利用寄存器模型我们可以做成很多东西</p><ul><li>理论对应内容（uvm入门进阶）：<ul><li>寄存器模型在不同公司情况：有的可能是doc文档/excel，设计根据这些进行手动实现。不同公司方法不一样</li><li>对于这个模型，我们怎么理解、实现、集成</li></ul></li><li>实战对应内容（uvm实战）：<ul><li>深入内容</li><li>如果公司内部模型是自动化生成的话，我们通过（第三个例子）简单脚本帮助我们生成寄存器模型</li></ul></li></ul><h1 id="1-寄存器模型概览"><a href="#1-寄存器模型概览" class="headerlink" title="1 寄存器模型概览"></a>1 寄存器模型概览</h1>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶8：Sequencer仲裁_Sequence层次化</title>
    <link href="/202202110115/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/"/>
    <url>/202202110115/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节内容为上一节《UVM入门进阶7：Item_Sequence_Sequencer_Driver》的后半部节选，因为UVM7内容过多因此创建本小节。本节主要学习Sequencer和Sequence的关系</p><h1 id="4-Sequencer和Sequence：初步"><a href="#4-Sequencer和Sequence：初步" class="headerlink" title="4 Sequencer和Sequence：初步"></a>4 Sequencer和Sequence：初步</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-主要学习内容"><a href="#4-1-1-主要学习内容" class="headerlink" title="4.1.1 主要学习内容"></a>4.1.1 主要学习内容</h3><p>主要讲几种常见的仲裁方式，一般可能用不太到</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202220542862.png" alt="image-20211202220542862"></p><h3 id="4-1-2-sequence宏概述：区分两种挂载seq到sqr方式"><a href="#4-1-2-sequence宏概述：区分两种挂载seq到sqr方式" class="headerlink" title="4.1.2 sequence宏概述：区分两种挂载seq到sqr方式"></a>4.1.2 sequence宏概述：区分两种挂载seq到sqr方式</h3><ul><li>start()<ul><li>在test对top_seq挂载（参考第三章），在top_sep对child_sep和item挂载，在child_sep对item挂载</li></ul></li><li>`uvm_do<ul><li>一种宏：参考第五章</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221445893.png" alt="image-20211202221445893"></p><h2 id="4-2-sequence和item发送示例"><a href="#4-2-sequence和item发送示例" class="headerlink" title="4.2 sequence和item发送示例"></a>4.2 sequence和item发送示例</h2><h3 id="bus-trans"><a href="#bus-trans" class="headerlink" title="bus_trans"></a>bus_trans</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221650621.png" alt="image-20211202221650621"></p><h3 id="child-seq"><a href="#child-seq" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221712682.png" alt="image-20211202221712682"></p><h3 id="top-seq"><a href="#top-seq" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222244292.png" alt="image-20211202222244292"></p><p>包含child_seq与item</p><h3 id="sqr"><a href="#sqr" class="headerlink" title="sqr"></a>sqr</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222302835.png" alt="image-20211202222302835"></p><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222337508.png" alt="image-20211202222337508"></p><p>driver里面get的全是最小颗粒度item，seq在sqr处被拆解</p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222453646.png" alt="image-20211202222453646"></p><h3 id="test与输出结果"><a href="#test与输出结果" class="headerlink" title="test与输出结果"></a>test与输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222607612.png" alt="image-20211202222607612"></p><h2 id="4-3-示例总结：两种挂载方式"><a href="#4-3-示例总结：两种挂载方式" class="headerlink" title="4.3 示例总结：两种挂载方式"></a>4.3 示例总结：两种挂载方式</h2><p>两种挂载方式，分别把seq和item挂载到sqr上</p><h3 id="4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上"><a href="#4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上" class="headerlink" title="4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上"></a>4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222550069.png" alt="image-20211202222550069"></p><p>top_seq中的uvm_sequence::start()</p><ul><li>start内部参数解释<ul><li>uvm_sequencer_base sequencer：<ul><li>挂载到的sqr实例句柄</li></ul></li><li>uvm_sequence_base parent_sequence：<ul><li>上层对象句柄，示例中top_seq调用该方法时代入”this”代表child_seq的上层对象为自己</li><li>这样做的好处是保持子对象优先级一致，进而对仲裁有帮助仲裁表现一致</li></ul></li><li>int this_priority：<ul><li>优先级，默认值-1，此时实际优先级为100</li></ul></li><li>call_pre_post：<ul><li>建议使用默认值<ul><li>补充：body的pre和post回调函数不建议实现</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-2-把item挂载到sqr上"><a href="#4-3-2-把item挂载到sqr上" class="headerlink" title="4.3.2 把item挂载到sqr上"></a>4.3.2 把item挂载到sqr上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202223931132.png" alt="image-20211202223931132"></p><p>第二个参数不需要特别关心，往往知道挂载哪个item就够了</p><h3 id="4-3-3-item创建发送过程"><a href="#4-3-3-item创建发送过程" class="headerlink" title="4.3.3 item创建发送过程"></a>4.3.3 item创建发送过程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202224727373.png" alt="image-20211202224727373"></p><p>pre_do()，mid_do()，post_do()：不建议实现，会变复杂</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225013595.png" alt="image-20211202225013595"></p><h3 id="4-3-4-seq-item的start-挂载内部逻辑"><a href="#4-3-4-seq-item的start-挂载内部逻辑" class="headerlink" title="4.3.4 seq/item的start()挂载内部逻辑"></a>4.3.4 seq/item的start()挂载内部逻辑</h3><h4 id="sequence挂载到sequencer"><a href="#sequence挂载到sequencer" class="headerlink" title="sequence挂载到sequencer"></a>sequence挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225207310.png" alt="image-20211202225207310"></p><p>为什么可以不关心：有时候call_pre_post=1时这些post和pre都不会执行</p><h4 id="item挂载到sequencer"><a href="#item挂载到sequencer" class="headerlink" title="item挂载到sequencer"></a>item挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225413186.png" alt="image-20211202225413186"></p><p>start_item立即返回，因为只有一个sqr进行仲裁可以立刻返回结果</p><h1 id="5-Sequencer和Sequence：更简单的创建挂载传输方式：宏"><a href="#5-Sequencer和Sequence：更简单的创建挂载传输方式：宏" class="headerlink" title="5 Sequencer和Sequence：更简单的创建挂载传输方式：宏"></a>5 Sequencer和Sequence：更简单的创建挂载传输方式：宏</h1><p>图中宏省略了`</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225658481.png" alt="图中宏省略了`"></p><p><strong>这些宏封装了好多方法函数，x表示包括，空表示不包括</strong></p><p><strong>Item：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程，但直接randomiztion</li><li>`uvm_do_with：做一个带constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>body为空，因为item没有</li></ul></li></ul><p><strong>Sequence：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程<br>+ </li><li>`uvm_do_with：做一个constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>没有做sync和post-sync<ul><li>因为sync和post-sync需要在body里面拿到优先级，`uvm_do本身不会拿到优先级，只有在seq_body里面，只有在发送item时候才会拿到（即每次发送一个item的时候都会申请一次优先级）</li></ul></li></ul></li></ul><h3 id="宏的调用位置"><a href="#宏的调用位置" class="headerlink" title="宏的调用位置"></a>宏的调用位置</h3><ul><li>这些宏调用的都是 sequence方法，因此只有sequence才可以调用这些宏</li></ul><h3 id="宏带来的怠惰"><a href="#宏带来的怠惰" class="headerlink" title="宏带来的怠惰"></a>宏带来的怠惰</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203115317909.png" alt="image-20211203115317909"></p><h2 id="5-2-其他的宏"><a href="#5-2-其他的宏" class="headerlink" title="5.2 其他的宏"></a>5.2 其他的宏</h2><ul><li>将优先级作为参数传递的<strong><code>`uvm_do_pri/`uvm_do_on_prio</code></strong>等宏<ul><li>并行发送多个seq时，伴随优先级发送</li><li>形参优先级，默认为100</li><li>`uvm_do_on：这个on是什么意思，表示把这个特定的seq挂载到某一个sqr上面<ul><li>对于item来说，使用`uvm_do则会被同样挂载到seq挂载到的sqr上</li><li>`uvm_do_on则可以进行指定</li></ul></li></ul></li><li>专门针对seq的<strong><code>`uvm_create_seq/`uvm_do_seq/`uvm_do_seq_with</code></strong>等宏</li></ul><h2 id="5-3-序列宏的示例"><a href="#5-3-序列宏的示例" class="headerlink" title="5.3 序列宏的示例"></a>5.3 序列宏的示例</h2><h3 id="child-seq-1"><a href="#child-seq-1" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135350051.png" alt="image-20211203135350051"></p><p>怎样利用宏发送的：</p><ul><li>`uvm_create(req)：创建item</li><li>`uvm_rand_send_with：添加constraint</li></ul><p>上述宏可以合并为：</p><ul><li>`uvm_do_with</li></ul><h3 id="top-seq-1"><a href="#top-seq-1" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135410573.png" alt="image-20211203135410573"></p><ul><li>`uvm_do：这里发送了child_seq</li><li>`uvm_do_with：这里发送了item</li></ul><h2 id="5-4-序列宏的建议"><a href="#5-4-序列宏的建议" class="headerlink" title="5.4 序列宏的建议"></a>5.4 序列宏的建议</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135746376.png" alt="image-20211203135746376"></p><p>（1）不管seq在哪个层次，都应在test结束前执行完毕</p><p>（2）可以用fork_join完成seq发送。而不建议用fork_join_any和fork_join_none，可能会导致seq没结束就立即退出，使得后台仍然有一些seq像挂载到sqr上面；进一步如果你针对fork调用disable可能会所锁sqr，因为你来不及释放seq线程权限。</p><ul><li>补充：你在代码中使用fork_join_any和fork_join_none一定要使用同步，如此处假如你使用了fork_join_any和fork_join_none你应该完成即便fork退出seq运行在后台时，仍然能与后台运行的seq进行同步，使得所有seq结束以后才进行后续的操作</li></ul><p>（3）fork_join其中一个seq线程无法结束时，考虑在合适时间点使用disbale</p><h1 id="5-Sequencer和Sequence：仲裁特性"><a href="#5-Sequencer和Sequence：仲裁特性" class="headerlink" title="5 Sequencer和Sequence：仲裁特性"></a>5 Sequencer和Sequence：仲裁特性</h1><h2 id="5-1-Sequencer和Sequence的仲裁特性"><a href="#5-1-Sequencer和Sequence的仲裁特性" class="headerlink" title="5.1 Sequencer和Sequence的仲裁特性"></a>5.1 Sequencer和Sequence的仲裁特性</h2><h3 id="5-1-1-仲裁特性介绍"><a href="#5-1-1-仲裁特性介绍" class="headerlink" title="5.1.1 仲裁特性介绍"></a>5.1.1 仲裁特性介绍</h3><p>仲裁场景结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141411994.png" alt="仲裁场景结构图"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141403633.png" alt="image-20211203141403633"></p><p>（1）<strong>sqr已经内建了仲裁机制，只需要在top_seq设置仲裁的模式就足够</strong></p><p>（2）</p><p>如何设置：uvm_sequencer::set_arbitration(UVM_SEQ_ARB_TYPE val)</p><p>模式介绍：</p><ul><li>UVM_SEQ_ARB_FIFO：默认模式，竞争优先</li><li>UVM_SEQ_ARB_WEIGHTED：优先级模式</li><li>UVM_SEQ_ARB_RANDOM：随机模式</li><li>UVM_SEQ_ARB_STRICT_FIFO：按照优先和抵达顺序授权</li><li>UVM_SEQ_ARB_STRICT_RANDOM：最高优先级并随机授权</li><li>UVM_SEQ_ARB_USER：自定义仲裁，很少用</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143759204.png" alt="image-20211203143759204"></p><h3 id="5-1-2-Sequencer的仲裁示例"><a href="#5-1-2-Sequencer的仲裁示例" class="headerlink" title="5.1.2 Sequencer的仲裁示例"></a>5.1.2 Sequencer的仲裁示例</h3><h4 id="item和child-seq"><a href="#item和child-seq" class="headerlink" title="item和child_seq"></a>item和child_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143948761.png" alt="image-20211203143948761"></p><h4 id="top-seq和sqr"><a href="#top-seq和sqr" class="headerlink" title="top_seq和sqr"></a>top_seq和sqr</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203144103956.png" alt="image-20211203144103956"></p><p>top_seq：</p><ul><li>body：<ul><li>设置优先级模式</li><li>fork_join进行调度：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145448313.png" alt="image-20211203145448313"></li><li>三个同一时间申请的，seq1和seq2优先级更高</li><li>base是constraint</li><li>此时赋予了优先级之后child_seq中的`uvm_do_with就可以进行挂在了，因为它们等待的就是这个顶层的优先级，使用wait_for_guant等待授权</li></ul></li></ul></li></ul><h4 id="driver-1"><a href="#driver-1" class="headerlink" title="driver"></a>driver</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145759397.png" alt="image-20211203145759397"></p><p>没有太多新意</p><h3 id="env-1"><a href="#env-1" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145816089.png" alt="image-20211203145816089"></p><h3 id="test和输出结果"><a href="#test和输出结果" class="headerlink" title="test和输出结果"></a>test和输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145834402.png" alt="image-20211203145834402"></p><p>test：</p><ul><li>为什么test里面不用宏：因为用不了只能在seq里面用</li></ul><p>为什么是seq1seq2seq1seq2seq3seq3，而且还是0时刻？：</p><ul><li>发送item没有耗时</li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150048046.png" alt="image-20211203150048046"></p><h2 id="5-2-Sequencer的锁定机制介绍"><a href="#5-2-Sequencer的锁定机制介绍" class="headerlink" title="5.2 Sequencer的锁定机制介绍"></a>5.2 Sequencer的锁定机制介绍</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150933463.png" alt="image-20211203150933463"></p><p>（1）锁定机制</p><p>什么是锁定机制：seq拿到权限后进行锁定，</p><p>什么是锁定：seq拿到一个item后锁定下来，后续item都可以拿到</p><p>（2）两种锁定方式：两个函数都可以</p><ul><li>lock()与unlock<ul><li>一定记得unlock</li></ul></li><li>grab()与ungrab()<ul><li>优先级比lock高，下一次授权周期可以无条件获取授权</li></ul></li></ul><h3 id="5-2-2-Sequencer的锁定示例"><a href="#5-2-2-Sequencer的锁定示例" class="headerlink" title="5.2.2 Sequencer的锁定示例"></a>5.2.2 Sequencer的锁定示例</h3><h4 id="item、child-seq、lock-seq"><a href="#item、child-seq、lock-seq" class="headerlink" title="item、child_seq、lock_seq"></a>item、child_seq、lock_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155333757.png" alt="image-20211203155333757"></p><p>child_seq：内部重复发送两次，间隔10ns，参考之前一节的示例</p><p>lock_seq：</p><ul><li><p>先等了10ns，试图达到等待授权把sqr锁住</p></li><li><p>m_sequencer.lock(this);</p><ul><li>什么时候才能lock住：下一次等待授权的时候，即大家都在等待的时候</li></ul></li><li>重复发送三次</li></ul><h3 id="grab-seq"><a href="#grab-seq" class="headerlink" title="grab_seq"></a>grab_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155557543.png" alt="image-20211203155557543"></p><p>grab_seq：</p><ul><li><p>等了20ns</p></li><li><p>m_sequencer.grab(this);</p><ul><li>什么时候才能锁住：只要重新做仲裁就能锁住</li></ul></li><li>重复发送三次</li></ul><h4 id="top-seq-2"><a href="#top-seq-2" class="headerlink" title="top_seq"></a>top_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155814989.png" alt="image-20211203155814989"></p><p>seq1,seq2,seq3</p><p>lock_seq：优先级为300</p><p>grab_seq：没有优先级</p><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160141887-16385185030091.png" alt="image-20211203160141887"></p><hr><p>注释版：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160157368-16385185184612.png" alt="image-20211203160157368"></p><h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>10ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送（发送完等待10纳秒，重新排队伍）</li><li>lock_seq开始要权限</li></ul><p>10ns-20ns：</p><ul><li>seq发送</li></ul><p>20ns：</p><ul><li>seq1,2,3,lock都开始等待（lock因为优先级低所以也要等待）</li></ul><p>20ns-40ns：</p><ul><li>被lock锁住</li></ul><p>40ns：</p><ul><li>grabs拿到权限（实际上20nsgrab就开始试图拿权限，但被lock控制，只能等到重新仲裁，届时即可直接锁住无需）</li></ul><p>40ns-70ns：</p><ul><li>被grabs锁住</li></ul><p>70ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送</li></ul><h4 id="结果补充"><a href="#结果补充" class="headerlink" title="结果补充"></a>结果补充</h4><p>seq优先级如果使用默认，不给定，则默认100</p><p>即直接：</p><ul><li><code>`uvm_do_pri_with(seq)</code></li><li><code>`uvm_do_pri_with(lock)</code></li><li><code>`uvm_do_pri_with(grab)</code></li></ul><h3 id="5-2-3-结论"><a href="#5-2-3-结论" class="headerlink" title="5.2.3 结论"></a>5.2.3 结论</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203161407082.png" alt="image-20211203161407082"></p><p>无论是lock或者grab都是在重新仲裁时才能锁住</p><h1 id="6-Sequence的层次化"><a href="#6-Sequence的层次化" class="headerlink" title="6 Sequence的层次化"></a>6 Sequence的层次化</h1><p>对于小白我们可能更关心如何让你的sequence层次化，如何理解别人写的层次化的sequence，以及把它们作为更顶层的sequence如何一层一层的调用</p><h2 id="6-1-概述：水平复用和垂直复用"><a href="#6-1-概述：水平复用和垂直复用" class="headerlink" title="6.1 概述：水平复用和垂直复用"></a>6.1 概述：水平复用和垂直复用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203162021806.png" alt="image-20211203162021806"></p><ul><li>hierarchical sequence：层次序列，seq都挂载在一个sqr上</li><li>virtual sequence：seq可挂载在多个sqr上</li><li>layering sequence</li></ul><h2 id="6-2-Hierarchical-Sequence层次序列"><a href="#6-2-Hierarchical-Sequence层次序列" class="headerlink" title="6.2 Hierarchical Sequence层次序列"></a>6.2 Hierarchical Sequence层次序列</h2><h3 id="6-2-1-Hierarchical-Sequence介绍"><a href="#6-2-1-Hierarchical-Sequence介绍" class="headerlink" title="6.2.1 Hierarchical Sequence介绍"></a>6.2.1 Hierarchical Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203170532752.png" alt="image-20211203170532752"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203173213812.png" alt="image-20211203173213812"></p><h3 id="6-2-2-Hierarchical-Sequence代码示例"><a href="#6-2-2-Hierarchical-Sequence代码示例" class="headerlink" title="6.2.2 Hierarchical Sequence代码示例"></a>6.2.2 Hierarchical Sequence代码示例</h3><p><strong>cmd 和 item</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215113852.png" alt="image-20211203215113852"></p><p><strong>clk_rst_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215132273.png" alt="image-20211203215132273"></p><p><strong>reg_test_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215159086.png" alt="image-20211203215159086"></p><p><strong>top_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215246475.png" alt="image-20211203215246475"></p><p><strong>reg_master_sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215319193.png" alt="image-20211203215319193"></p><p><strong>driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215348378.png" alt="image-20211203215348378"></p><p><strong>agent</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215406423.png" alt="image-20211203215406423"></p><ul><li>例化与连接</li></ul><h3 id="6-2-3-示例解析"><a href="#6-2-3-示例解析" class="headerlink" title="6.2.3 示例解析"></a>6.2.3 示例解析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215450672.png" alt="image-20211203215450672"></p><h3 id="6-2-4-总结"><a href="#6-2-4-总结" class="headerlink" title="6.2.4 总结"></a>6.2.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215501808-16385397031013.png" alt="image-20211203215501808"></p><h2 id="6-3-Virtual-Sequence"><a href="#6-3-Virtual-Sequence" class="headerlink" title="6.3 Virtual Sequence"></a>6.3 Virtual Sequence</h2><h3 id="6-3-1-Virtual-Sequence介绍"><a href="#6-3-1-Virtual-Sequence介绍" class="headerlink" title="6.3.1 Virtual Sequence介绍"></a>6.3.1 Virtual Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215818498.png" alt="image-20211203215818498"></p><hr><p>把所有子系统的sqr都放在virtual_sequencer里面</p><ul><li>virtual_sequencer包含着很多实例句柄</li><li>它就像一个路由一样，找到他就能找到各个子系统的sqr</li><li>起到一个统筹的作用</li><li>virtual sequencer往往与virtual sequence有联系的</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215944706.png" alt="image-20211203215944706"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220636658.png" alt="image-20211203220636658"></p><p>virtual sequencer就是个简单的路由器，包含句柄而已，没有任何item经过，也不需要与driver连接</p><h3 id="6-3-2-Virtual-Sequence示例"><a href="#6-3-2-Virtual-Sequence示例" class="headerlink" title="6.3.2 Virtual Sequence示例"></a>6.3.2 Virtual Sequence示例</h3><p><strong>vritual sequencer结构图</strong>：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220753318.png" alt="vritual sequencer结构图"></p><p><strong>【重要】有关挂载</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203222842906.png" alt="image-20211203222842906"></p><p>mcdf_normal_seq(virtual sequence)要挂载到virutal sequencer</p><p>其他的seq间接的通过virutal sequencer挂载到不同的sqr上面，挂载的目的地不一样所以用uvm_do_on</p><hr><p><strong>virtual sequence</strong></p><p>定义了一个sequence：实际上就是我们的virtual sequence</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220826070.png" alt="image-20211203220826070"></p><p>包括了好多seq句柄</p><p>sqr与vsqr区别：</p><ul><li>用了很多`uvm<em>do</em><strong>on</strong></li><li>有别于Hierarchical Sequence使用的`uvm_do</li></ul><p>子</p><p>p_sequencer和m_sequencer的区别：</p><ul><li>m_sequencer：是父类句柄，类型是uvm_sequencer</li><li>p_sequencer：是子类句柄，类型是`uvm_declare_p_sequencer(mcdf_virtual_sequencer)<ul><li>自定义出来的，不是与定义好的，定义语句就来源于`uvm_declare_p_sequencer(mcdf_virtual_sequencer)</li><li>定义语句完成了两个步骤：<ul><li>mcdf_virtual_sequencer p_sequencer;</li><li>$cast(p_sequencer, m_sequencer);//把父类句柄转为子类句柄</li></ul></li><li>为什么一定要子类句柄：<ul><li>因为父类的访问不到这些子系统sqr句柄</li><li>通过这个子类句柄p_sequencer我们可以访问到vsqr里面所有成员变量</li></ul></li></ul></li></ul><p><strong>子一级的sqr，agent，和virutal sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223410467.png" alt="image-20211203223410467"></p><p>virutal sequencer 包含各个句柄就完事了</p><p><strong>mcdf_env</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223436428.png" alt="image-20211203223436428"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223450033-16385420908084.png" alt="image-20211203223450033"></p><p>千万不要忘了再connect里进行句柄传递，避免悬空</p><p><strong>test</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223457604.png" alt="image-20211203223457604"></p><h3 id="6-3-3-示例解析"><a href="#6-3-3-示例解析" class="headerlink" title="6.3.3 示例解析"></a>6.3.3 示例解析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224423125.png" alt="image-20211203224423125"></p><h3 id="6-3-4-总结"><a href="#6-3-4-总结" class="headerlink" title="6.3.4 总结"></a>6.3.4 总结</h3><p>中心化协调</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224508271.png" alt="image-20211203224508271"></p><h3 id="6-3-5-Virutal-Sequencer建议"><a href="#6-3-5-Virutal-Sequencer建议" class="headerlink" title="6.3.5 Virutal Sequencer建议"></a>6.3.5 Virutal Sequencer建议</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224612008.png" alt="image-20211203224612008"></p><ul><li>vseq与普通seq区分</li><li>vsqr同底层负责传输对象的sqr区分</li><li>vseq中使用`uvm_declare_p_sqr来创建p_sequencer变量方便之后索引</li><li>顶层环境中创建vsqr并完成内部各个sqr句柄与底层sqr实例连接</li></ul><h2 id="6-4-Layering-Sequence：层次化"><a href="#6-4-Layering-Sequence：层次化" class="headerlink" title="6.4 Layering Sequence：层次化"></a>6.4 Layering Sequence：层次化</h2><h3 id="6-4-1-Layering-Sequence介绍"><a href="#6-4-1-Layering-Sequence介绍" class="headerlink" title="6.4.1 Layering Sequence介绍"></a>6.4.1 Layering Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224824934.png" alt="image-20211203224824934"></p><ul><li><p>普通协议，构建协议总线时通过：sequencer item包含与约束关系</p></li><li><p>复杂协议，网络传输协议，需要更深层次一层一层解析，通过：若干个抽象层次去做</p></li></ul><p><strong>由高抽象级到低抽象级（传输层&gt;&gt;链路层&gt;&gt;物理层）</strong>的构建，我们称为<strong>Layering Sequence</strong></p><p>接下来学习，一定考虑三个层次：高抽象级的item，低抽象级的item，中间做转化的sequence</p><p>Layering Sequence层次结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p>寄存器模型下的item传递结构图与layering sequence具体作用内容：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225425767.png" alt="寄存器模型下的item传递结构图"></p><ul><li>对寄存器的reg.write()和reg.read()指令，通过寄存器模型的Adaption Layer转化层次，进而转化为总线的一个item。即把reg_item转为bug_item</li><li>得出layering sequence包括三者：高抽象级的item，低抽象级的item，中间做转化的sequence</li><li>高抽象级的item与低抽象级的item没有直接的继承关系所以需要做一个映射</li><li>高抽象级不包括具体的数据，只有类似命令、长度、idle等信息</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204114418582.png" alt="image-20211204114418582"></p><h3 id="6-4-2-Layering-Sequence代码示例"><a href="#6-4-2-Layering-Sequence代码示例" class="headerlink" title="6.4.2 Layering Sequence代码示例"></a>6.4.2 Layering Sequence代码示例</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p><strong>cmd和bus_trans(item)</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204114905038.png" alt="image-20211204114905038"></p><p>比较底层</p><p><strong>packet_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115007333.png" alt="image-20211204115007333"></p><p><strong>layer_trans(item)</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115027913.png" alt="image-20211204115027913"></p><p>比较抽象：</p><ul><li>没有任何与数据有关的传输内用，只有cmd，len，idle</li><li>与底层的bus_trans没有任何继承关系所以要做一个映射</li></ul><p><strong>adapter_seq：转化层</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115443718.png" alt="image-20211204115443718"></p><ul><li>p_sequencer通过`ucm_declare获得，通过p_sqr拿到up_sqr更上层的layersqr句柄</li><li><p>拿到子类句柄void($cast(trans,req))</p></li><li><p>转化为一个底层个seq，把高抽象级的长度转化为低抽象级的pkt_seq，`uvm_do挂载到了phy_driver上</p></li><li>做一个握手，告诉高层，我已经把高抽象层的trans消化掉了</li></ul><p><strong>top_seq , layering_sqr , phy_sqr</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204121723508.png" alt="image-20211204121723508"></p><p>layering_sqr , phy_sqr定义不讲了</p><p>phy_sqr里面有个句柄up_sqr，需要顶层把相关实例传递进来</p><p>top_seq：连续发送了两个layer_trans</p><p><strong>phy_driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204121949423-16385915953441.png" alt="image-20211204121949423"></p><p><strong>phy_agent</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122004651.png" alt="image-20211204122004651"></p><p>包含phy_drv和phy_sqr的例化与连接</p><p><strong>test，重点在这里，查看连接关系</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122057373.png" alt="image-20211204122057373"></p><ul><li>例化了layer_sqr与phy_agt<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122201923.png" alt="image-20211204122201923"></li></ul></li><li>sqr句柄的传递，layer_seq/top_seq，adapter_seq，phy_seq的挂载<ul><li>up_sqr句柄的传递<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122317592.png" alt="image-20211204122317592"></li></ul></li><li>adapter_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122352177.png" alt="image-20211204122352177"></li></ul></li><li>top_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122458395.png" alt="image-20211204122458395"></li></ul></li><li>phy_seq的挂载实际上不是个挂载而是产生的过程，在adapter_seq用uvm_do出来好多pkg_seq，这些pkg_seq时加上就属于phy到drv的seq</li></ul></li><li>为什么用fork_join_none<ul><li>用fork_join_none直接挂载上去就可以了</li><li>用fork_join不行，这个start会自动帮我们执行body()，adapter.body()是个forever会卡在这里</li></ul></li></ul><h3 id="6-4-3-如何实现sequencer-layer协议转换的方法："><a href="#6-4-3-如何实现sequencer-layer协议转换的方法：" class="headerlink" title="6.4.3 如何实现sequencer layer协议转换的方法："></a>6.4.3 如何实现sequencer layer协议转换的方法：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123212588.png" alt="image-20211204123212588"></p><p>（1）layer_trans,bus_trans完全两个不同的抽象级</p><p>（2）需要adapter_seq完成从获取layer_trans再去生成phy_trans和seq，再从physqr发送出去</p><p>（2）fork_join_none</p><p>（4）至于多少个层次取决于</p><h3 id="6-4-4-总结"><a href="#6-4-4-总结" class="headerlink" title="6.4.4 总结"></a>6.4.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123514922.png" alt="image-20211204123514922"></p><p>（2）只有高抽象级到低抽象级，低到高需要有回路，通过response_item实现，两者的思想实际上一样</p><p>（3）也可以不通过高到低的回路，而是外部通过monitor采集response trans最终实现返回，避开adapter</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCL入门</title>
    <link href="/202202110058/IC/TCL%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/TCL%E5%85%A5%E9%97%A8/"/>
    <url>/202202110058/IC/TCL%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/TCL%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/Eclipse-dltk-itcl_en_fedora_11_con_KDE_4.2.4.png" alt="Eclipse-dltk-itcl_en_fedora_11_con_KDE_4.2.4"></p><h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6 流程控制"></a>6 流程控制</h1><h2 id="6-1-语法重点"><a href="#6-1-语法重点" class="headerlink" title="6.1 语法重点"></a>6.1 语法重点</h2><ul><li>各种控制语句包括：if,switch,while,for,foreach(在列表和数组中提到),source</li><li>控制语句内部执行的脚本实际上是本语句的一个参数（本质上执行了一条语句）</li><li><p>有关大括号{}和换行符的</p><ul><li>Tcl解释器认为换行符是前一个命令的分隔符，除非换行符在花括号或者双引号之内（参考if语句的参数二）</li></ul></li></ul><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-number">123</span><br></code></pre></div></td></tr></table></figure><ul><li>有关大括号{}和双引号的</li><li><p>表达式真假：</p><ul><li>真：非0、yes、true</li><li>假：0、no、false</li></ul></li></ul><h2 id="6-2-各种控制语句"><a href="#6-2-各种控制语句" class="headerlink" title="6.2 各种控制语句"></a>6.2 各种控制语句</h2><h3 id="6-2-1-if-语句"><a href="#6-2-1-if-语句" class="headerlink" title="6.2.1 if 语句"></a>6.2.1 if 语句</h3><h4 id="标准if"><a href="#标准if" class="headerlink" title="标准if"></a>标准if</h4><p>标准语句：</p><p><code>if&#123;参数一&#125;&#123;参数二&#125;</code>：第一个参数是一个表达式，第二个参数是待执行的TCL脚本</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> x <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>&#123;<span class="hljs-variable">$x</span>&gt;<span class="hljs-number">0</span>&#125;&#123;<br><span class="hljs-keyword">set</span> x -<span class="hljs-variable">$x</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>错误语句（类C）：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> x <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>&#123;<span class="hljs-variable">$x</span>&gt;<span class="hljs-number">0</span>&#125;<br>&#123;<br><span class="hljs-keyword">set</span> x -<span class="hljs-variable">$x</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>错误原因查看上一节有关大括号和双引号内容</li></ul><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>标准语句：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><p>错误语句（类C）：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;<br>&#123;<br>脚本一<br>&#125; <br>else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><ul><li>错误原因查看上一节有关大括号和双引号内容</li></ul><h4 id="if-elseif-else"><a href="#if-elseif-else" class="headerlink" title="if-elseif-else"></a>if-elseif-else</h4><p>标准语句：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; elseif &#123;<br>脚本二<br>&#125; else &#123;<br>脚本三<br>&#125;<br>脚本四<br></code></pre></div></td></tr></table></figure><p>有时候switch比if-elseif-else更高效</p><h3 id="6-2-2-switch"><a href="#6-2-2-switch" class="headerlink" title="6.2.2 switch"></a>6.2.2 switch</h3><h4 id="标准语句："><a href="#标准语句：" class="headerlink" title="标准语句："></a>标准语句：</h4><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span>&#123;表达式一&#125;&#123;<br>脚本一<br>&#125; else &#123;<br>脚本二<br>&#125;<br>脚本三<br></code></pre></div></td></tr></table></figure><h4 id="匹配模式参数"><a href="#匹配模式参数" class="headerlink" title="匹配模式参数"></a>匹配模式参数</h4><h2 id="2-3-while"><a href="#2-3-while" class="headerlink" title="2.3 while"></a>2.3 while</h2><h2 id="2-4-for"><a href="#2-4-for" class="headerlink" title="2.4 for"></a>2.4 for</h2><h2 id="2-5-source"><a href="#2-5-source" class="headerlink" title="2.5 source"></a>2.5 source</h2><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h2><h1 id="7-过程"><a href="#7-过程" class="headerlink" title="7 过程"></a>7 过程</h1><p>Tcl分为：</p><ul><li>内建(Build-in)过程（如power()、exp()等）</li><li>用户自定义过程</li></ul><p>``proc 参数一 {参数二} {参数三}</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Tcl"><span class="hljs-keyword">proc</span><span class="hljs-title"> func</span> &#123;ref1 ref2&#125;&#123;<br>tcl_sentence<br>&#125;<br></code></pre></div></td></tr></table></figure><p>proc只是一个普通的Tcl命令而不是特殊的语法声明，因此pro的参数处理方法和其他Tcl命令相同</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>TCL学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门</tag>
      
      <tag>TCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础内容（一）</title>
    <link href="/202202100117/CS/Linuxessay/cs/linux/Linux%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/202202100117/CS/Linuxessay/cs/linux/Linux%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础内容（一）"><a href="#Linux基础内容（一）" class="headerlink" title="Linux基础内容（一）"></a>Linux基础内容（一）</h1><span id="more"></span><p>git遇到fatal: unable to access ‘<a href="https://github.com/xxx/xxx/’:OpenSSL">https://github.com/xxx/xxx/’:OpenSSL</a> SSL_read: Connection was aborted, errno 10053的问题</p><h2 id="常见bash命令"><a href="#常见bash命令" class="headerlink" title="常见bash命令"></a>常见bash命令</h2><ul><li>把/a/b/c/目录下的d文件复制到本目录下</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cp /a/b/c/d . <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>概论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo框架下的博客多主机写作方案</title>
    <link href="/202201111602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%9A%E4%B8%BB%E6%9C%BA%E5%86%99%E4%BD%9C%E6%96%B9%E6%A1%88/"/>
    <url>/202201111602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%9A%E4%B8%BB%E6%9C%BA%E5%86%99%E4%BD%9C%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo框架下的博客多主机写作方案"><a href="#hexo框架下的博客多主机写作方案" class="headerlink" title="hexo框架下的博客多主机写作方案"></a>hexo框架下的博客多主机写作方案</h2><p>参考链接：<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1 安装Git"></a>1 安装Git</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程</p><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git</p><h2 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2 安装nodejs"></a>2 安装nodejs</h2><p>安装nodejs，因为之前用的nodejs是<a href="https://nodejs.org/dist/v12.16.1/">v12.16.1/</a>版本的，所以下载也是，通过这个官方镜像网站进行访问<a href="https://npmmirror.com/mirrors/node/">Node.js Mirror (npmmirror.com)</a></p><p>或者是通过中文官网找到合适的下载路径<a href="http://nodejs.cn/download/">下载 | Node.js 中文网 (nodejs.cn)</a></p><p>下载时选择.msi文件的安装包进行安装</p><h2 id="3-安装hexo-博客文件夹下"><a href="#3-安装hexo-博客文件夹下" class="headerlink" title="3 安装hexo(博客文件夹下)"></a>3 安装hexo(博客文件夹下)</h2><h3 id="本地目录的创建-克隆："><a href="#本地目录的创建-克隆：" class="headerlink" title="本地目录的创建/克隆："></a>本地目录的创建/克隆：</h3><p>前面git和nodejs安装好后，就可以安装hexo了</p><p>首先，你需要一个博客的本地目录/将远程工程克隆到本地用来安装hexo：</p><ul><li><p>你需要先把之前本地blog push到github上，在这里就只需要进行<code>git clone</code>就可以，<a href="https://github.com/GreensCH/blog-code.git">本博客git clone地址（需要权限）</a></p></li><li><p>你也可以创建一个文件夹blog，然后<code>cd</code>到这个文件夹下</p><hr></li></ul><h3 id="hexo的安装："><a href="#hexo的安装：" class="headerlink" title="hexo的安装："></a>hexo的安装：</h3><p>再者进行hexo的安装</p><ul><li>使用<a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供的命令进行安装<ul><li><code>npm install hexo-cli -g</code></li><li>如果安装中出现问题，输入返回提示中的命令<code>$ rm -rf node_modules &amp;&amp; npm install --force</code>即可</li></ul></li></ul><h2 id="4-SSH添加到github"><a href="#4-SSH添加到github" class="headerlink" title="4 SSH添加到github"></a>4 SSH添加到github</h2><h3 id="创建SSH："><a href="#创建SSH：" class="headerlink" title="创建SSH："></a>创建SSH：</h3><ul><li>回到你的git bash中，输入以下命令（这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户）</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li>可以用以下两条，检查一下你有没有输对</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config user.name<br>git config user.email<br></code></pre></div></td></tr></table></figure><ul><li>然后用下方命令创建SSH，一路回车</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></div></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><hr><h3 id="公钥添加到github上："><a href="#公钥添加到github上：" class="headerlink" title="公钥添加到github上："></a>公钥添加到github上：</h3><blockquote><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/3194ad0a9d04d94c09485122932968f3.png" alt="img"></p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><hr><h3 id="查看是否成功："><a href="#查看是否成功：" class="headerlink" title="查看是否成功："></a>查看是否成功：</h3><ul><li><p>在gitbash中，查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="5-修改live2d的本地目录地址，或者将文件移动到此地址"><a href="#5-修改live2d的本地目录地址，或者将文件移动到此地址" class="headerlink" title="5 修改live2d的本地目录地址，或者将文件移动到此地址"></a>5 修改live2d的本地目录地址，或者将文件移动到此地址</h2>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(个人用)游戏快捷键</title>
    <link href="/202201051602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/%E7%BA%A2%E8%AD%A63%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/202201051602/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/%E7%BA%A2%E8%AD%A63%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>部队位置预览：同时按住左右两个按键，可用于集中部队</p><p>平视视角：极高画质下，滚轮拉到底</p><p>恢复视角：点击滚轮</p><p>维修：C</p><p>卖出：Z</p><p>滚到某一类型单位：TAB</p><p>回滚到某一类型单位：shift+TAB</p><p>选择某一类型单位： F1，2，3，4（用于替换单击）如右图<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220108203153584.png" alt="image-20220108203153584"></p><p><strong>同时安装多个建筑：</strong>利用上述F123456配合切换的ER切换建造单位进行建造（即对应位置F1~F9，ER相互切换的点）</p><p><strong>连续造五个单位：</strong>shift+单机</p><p>一次性清空所有建造单位：shift+右键</p><p>路径点模式：alt</p><p>*计划模式（先不动的路径点模式）：ctrl+z</p><p>*编屏/跳转地图书签：ctrl+JKL/JKL…</p><p>选中全体作战单位：Q</p><p>选中当前画面相同的单位：W</p><p>选中所有相同的单位：WW</p><p>加入原有选择：shift</p><p><strong>补充编队（两种方法）：</strong></p><ul><li>不断WW选中再重新ctrl编队</li><li>方法二（两部）：<ul><li>选中：shift+编队名</li><li>编队：ctrl+编队名</li></ul></li></ul><p>显示血条：shift+space</p><p>*设置集结点：ctrl+R</p><p>跳转到下一个支援单位(支援单位指的是基地车、矿车、工兵)：N</p><p><strong>查看前一个事件(事件指的是副官说的内容)</strong>：space</p><p>一键散兵：X</p><hr><h2 id="补充实用内容"><a href="#补充实用内容" class="headerlink" title="补充实用内容"></a>补充实用内容</h2><p>路径点模式配合F：</p><ul><li>设置路径点</li><li>手动点击特殊技能而不是直接按F</li></ul><p><strong>四连F：</strong></p><ul><li>选中</li><li>F+1</li><li>F+2</li><li>….F345567</li></ul><p><strong>如何攻击：</strong></p><ul><li>选中</li><li>按A</li><li>鼠标左右预览过去，而不是直接右键（所有单位同步过去）</li></ul><hr><h2 id="不实用内容"><a href="#不实用内容" class="headerlink" title="不实用内容"></a>不实用内容</h2><p>全局聊天：enter</p><p>友军聊天：backspace</p><p>语音聊天/切换全局和团队语音：V/ctrl+V</p><p>加信标（只能同时存在三个）：B</p><p>删除信标：delete</p><p>在小地图上画画：B</p><p>csgo的无线电：M</p><p>放录像快进：.</p><p>快速保存：shift+S</p><p>快速载入：shift+l</p><p>关闭血条：end</p><p>截图：F12</p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶7：Item_Sequence_Sequencer_Driver</title>
    <link href="/202111302244/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B67%EF%BC%9AItem_Sequence_Sequencer_Driver/"/>
    <url>/202111302244/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B67%EF%BC%9AItem_Sequence_Sequencer_Driver/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>Item， Sequence， Sequencer， Driver介绍</li><li>Item， Sequence， Sequencer， Driver两两之间的关系与常见操作</li><li>如何构建一个测试序列(sequence)</li></ul><p>背景：</p><p>小白第一年可能不会直接写验证环境，而是写一些seq和test</p><p>对于小白来讲第一年工作基本就两件事：</p><ul><li>（第一年）构建seq，使用这些宏</li><li>（第一年）定义功能覆盖率，对他们进行收敛</li></ul><p>第二年创建环境：</p><ul><li>（第二年）创建环境，你可以把实验代码照搬过工作中去修改</li></ul><h1 id="1-新手上路"><a href="#1-新手上路" class="headerlink" title="1 新手上路"></a>1 新手上路</h1><h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><h3 id="run-phase"><a href="#run-phase" class="headerlink" title="run_phase"></a>run_phase</h3><ul><li><p>到我们的run_phase了</p></li><li><p>driver,monitor,checker,reference_model的run_phase都是些forever，和sv里面的run任务相同，它们不会停下来，sv里面只有generator会停下来</p></li><li><p>这节课我们会讲，在run_phase我们的激励怎么一步一步把item通过sqr发送到dri一侧</p></li></ul><h2 id="1-2-四个核心词介绍"><a href="#1-2-四个核心词介绍" class="headerlink" title="1.2 四个核心词介绍"></a>1.2 四个核心词介绍</h2><p><strong>本章主要讲四个核心词的作用、分类以及之间的互动关系</strong></p><ul><li>sequence item</li><li>sequence</li><li>sequencer</li><li>driver</li></ul><h3 id="1-2-1-trans驱动作用"><a href="#1-2-1-trans驱动作用" class="headerlink" title="1.2.1 trans驱动作用"></a>1.2.1 trans驱动作用</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201105614128.png" alt="image-20211201105614128"></p><p>整个事物的驱动力就是transaction的传送</p><h3 id="1-2-2-四者关系打比方"><a href="#1-2-2-四者关系打比方" class="headerlink" title="1.2.2 四者关系打比方"></a>1.2.2 四者关系打比方</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201113557243.png" alt="image-20211201113557243"></p><pre><code class=" mermaid">graph TBsequence --&gt; 道路sequence_item --&gt; 货车sequencer --&gt; 目的地关卡driver --&gt; 目的_进行扫描与分解</code></pre><p>通路结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201133536311.png" alt="image-20211201133536311"></p><ul><li>sqr到driver是通过req与rsp</li></ul><h3 id="1-2-3-sequencer-item"><a href="#1-2-3-sequencer-item" class="headerlink" title="1.2.3 sequencer item"></a>1.2.3 sequencer item</h3><p>sequence item是driver与DUT每一次互动的最小颗粒度</p><p>sequence item是一个类</p><ul><li>内部可定义成员方法或变量，成员变量应考虑是否需要随机化</li></ul><h3 id="1-2-4-driver：一个例子"><a href="#1-2-4-driver：一个例子" class="headerlink" title="1.2.4 driver：一个例子"></a>1.2.4 driver：一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201134705399-16383376267321.png" alt="image-20211201134705399"></p><p><strong>一个例子</strong>：假设DUT是slave端，driver扮演master访问DUT寄存器</p><ul><li>item定义的数据信息包括：地址、命令码、数据和状态值（访问是否成功，V1V2的MCDF不涉及状态码，UVM实战会完善）</li><li>driver任务：<ul><li>driver取得后通过时序方式在initerface一侧发起激励至DUT<ul><li>这种时序需要保持几个时钟（按照总线做寄存去访问的习惯）</li></ul></li></ul></li></ul><h3 id="1-2-5-sequence-的层次化"><a href="#1-2-5-sequence-的层次化" class="headerlink" title="1.2.5 sequence 的层次化"></a>1.2.5 sequence 的层次化</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201135832487.png" alt="image-20211201135832487"></p><p>sequence内部包括item可以包括sequence，从而sequence一层一层实现层次化</p><h3 id="1-2-6-sequencer"><a href="#1-2-6-sequencer" class="headerlink" title="1.2.6 sequencer"></a>1.2.6 sequencer</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141140565.png" alt="image-20211201141140565"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141204261.png" alt="image-20211201141204261"></p><ul><li>sequencer是sequence与driver之间的桥梁，使用TLM进行通信，通信参数为sequence_item类</li><li>sequencer的相关控制方法都在uvm_sequence里面</li></ul><h3 id="1-2-7-driver"><a href="#1-2-7-driver" class="headerlink" title="1.2.7 driver"></a>1.2.7 driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141253909.png" alt="image-20211201141253909"></p><p>driver特点：</p><ul><li>永远喂不饱，forever驱动</li><li>不会修改item值</li></ul><h3 id="1-2-8-sequence的互动"><a href="#1-2-8-sequence的互动" class="headerlink" title="1.2.8 sequence的互动"></a>1.2.8 sequence的互动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201133503968.png" alt="image-20211201133503968"></p><h2 id="1-3-继承关系"><a href="#1-3-继承关系" class="headerlink" title="1.3 继承关系"></a>1.3 继承关系</h2><h3 id="1-3-1-uvm-sequence是obj"><a href="#1-3-1-uvm-sequence是obj" class="headerlink" title="1.3.1 uvm_sequence是obj"></a>1.3.1 uvm_sequence是obj</h3><p>uvm_sequence_item和uvm_sequence都继承于uvm_object，不同于comp只在build_phase里创建和配置，obj可以在任何时候穿几件</p><p>uvm_sequence与uvm_comp继承树</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141531814.png" alt="image-20211201141531814"></p><h3 id="1-3-2-提示：sequence继承obj而带来的特点"><a href="#1-3-2-提示：sequence继承obj而带来的特点" class="headerlink" title="1.3.2 提示：sequence继承obj而带来的特点"></a>1.3.2 提示：sequence继承obj而带来的特点</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201141627603.png" alt="image-20211201141627603"></p><p>（1）你无法预测run阶段什么时候会创建sequence并挂在到sqr上，也无法通过phase机制识别sequence 的运行阶段</p><p>（2）obj独立于build阶段外，所以可以动态挂在</p><p>（3）seq无法在顶层配置的时候按照层次关系直接进行配置</p><p>（4）seq必须挂载到sqr，并依赖于sqr的结构关系来间接获取顶层配置信息</p><h3 id="1-3-3-提示"><a href="#1-3-3-提示" class="headerlink" title="1.3.3 提示"></a>1.3.3 提示</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201170827558.png" alt="image-20211201170827558"></p><p>（1）新手：将时序控制的权力给seq，即seq产生item，seq交给driver</p><p>（2）明确职责的情况：seq应该只负责生成item</p><p>（3）item生成和传送并不代表最终的接口时序，决定接口时序的是sqr和dri。进而引申出一个问题，为什么要有sqr在seq和dri之间</p><ul><li>sqr既是关卡也是路由</li><li>sqr是一个组件，可以通过TLM端口传送item</li><li>sqr有仲裁机制，处理多个并行seq</li></ul><h2 id="1-4-总结：数据传送机制"><a href="#1-4-总结：数据传送机制" class="headerlink" title="1.4 总结：数据传送机制"></a>1.4 总结：数据传送机制</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201172240003.png" alt="image-20211201172240003"></p><p>（1）数据传送机制是get模式（关于put和ge模式参考TLM）</p><ul><li>sv里面是generator产生item，stimulator/driver去get</li><li>uvm也是get模式，driver是initiator，是get模式</li></ul><p>如图：</p><p>通信模式</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174511162.png" alt="image-20211201174511162"></p><p>数据传输方向：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174541927.png" alt="image-20211201174541927"></p><p>（2）为什么是get模式：</p><ul><li>效率较高：seq产生item可以直接到达sqr，穿过sqr到达dri即可结束传输；put还需要收到返回值才可以发起下一次的传输</li><li>seq的仲裁特性：仲裁特性更符合设计思维：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201174819011.png" alt="image-20211201174819011"></li></ul></li></ul><h1 id="2-Sequence和Item"><a href="#2-Sequence和Item" class="headerlink" title="2 Sequence和Item"></a>2 Sequence和Item</h1><h2 id="2-1-概述（引入）"><a href="#2-1-概述（引入）" class="headerlink" title="2.1 概述（引入）"></a>2.1 概述（引入）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201175018828.png" alt="image-20211201175018828"></p><p>（3）</p><ul><li><p>seq指的是：uvm_sequence类</p></li><li><p>item指的是：uvm_sequence_item类</p></li></ul><p>（4）环境中至少有一个seq，不能仅仅一个item就可以想当然的发送到sqr</p><h2 id="2-2-sequence-item-介绍"><a href="#2-2-sequence-item-介绍" class="headerlink" title="2.2 sequence item 介绍"></a>2.2 sequence item 介绍</h2><p>item继承于uvm_object，具备obj核心方法：<code>copy()</code>，<code>clone()</code>，<code>compare()</code>，<code>record()</code></p><p>item内部数据成员可分为以下几类：</p><ul><li>控制类：如总线协议上的读写类型、数据长度、传送模式</li><li>负载类：一般指数据总线上的数据包</li><li>配置类：用来控制driver的驱动行为，例如命令driver的发送间隔或者有无错误插入<ul><li>config_db只能配置一次driver</li><li>item控制</li></ul></li><li>调试类：用来标记一些额外信息方便调试，例如该对象的<strong>实例序号</strong>、创建时间、被driver解析的时间始末等</li></ul><h2 id="2-3-item的简单例子"><a href="#2-3-item的简单例子" class="headerlink" title="2.3 item的简单例子"></a>2.3 item的简单例子</h2><p>sqr没有接dri与seq，仅仅看item是怎么回事</p><h3 id="item定义"><a href="#item定义" class="headerlink" title="item定义"></a>item定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225256849.png" alt="image-20211201225256849"></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225400298.png" alt="image-20211201225400298"></p><p>这里用new创建obj，复习一下create的好处：</p><ul><li>override</li><li>建立层次化关系</li><li>comp不可以new？</li></ul><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225558954.png" alt="image-20211201225558954"></p><p>t1没有随机化，t2随机化了</p><h2 id="2-4-item使用特点"><a href="#2-4-item使用特点" class="headerlink" title="2.4 item使用特点"></a>2.4 item使用特点</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225617852.png" alt="image-20211201225617852"></p><p>（1）数据成员为rand形</p><p>（2）使用`uvm_field_xxx宏进行数据成员声明，便于域自动化</p><p>（3）seq的body()很重要，和run类似</p><p>（4）item生命周期：始于seq的body()，穿越sqr，最终到达dri并被笑话</p><ul><li>item要善用copy()，clone()等数据方法</li></ul><h2 id="2-5-item与seq的关系"><a href="#2-5-item与seq的关系" class="headerlink" title="2.5 item与seq的关系"></a>2.5 item与seq的关系</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201225939333.png" alt="image-20211201225939333"> </p><p>（1）seq控制item实例的随机化，因此内部应预留可供外部随机化的变量，通过层级传递进seq进而控制item，控制item的内容有</p><ul><li>item内部随机变量</li><li>item之间的组织和时序控制</li></ul><h2 id="2-6-三类常见的seq定义方式："><a href="#2-6-三类常见的seq定义方式：" class="headerlink" title="2.6 三类常见的seq定义方式："></a>2.6 三类常见的seq定义方式：</h2><ul><li><p>扁平类（flat sequence）：最简单的，只组织最小颗粒度即item</p></li><li><p>层次类（hierarchical sequence）：更高层seq包括底层seq</p></li><li>虚拟类（virtual sequence）：工作后经常用的，控制整个测试场景中不同的seq</li></ul><h2 id="2-7-三类seq定义：Flat-Sequence-介绍"><a href="#2-7-三类seq定义：Flat-Sequence-介绍" class="headerlink" title="2.7 三类seq定义：Flat Sequence 介绍"></a>2.7 三类seq定义：Flat Sequence 介绍</h2><h3 id="2-7-1-介绍"><a href="#2-7-1-介绍" class="headerlink" title="2.7.1 介绍"></a>2.7.1 介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230645731.png" alt="image-20211201230645731"></p><h3 id="2-7-2-代码示例一"><a href="#2-7-2-代码示例一" class="headerlink" title="2.7.2 代码示例一"></a>2.7.2 代码示例一</h3><h4 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230925611.png" alt="image-20211201230925611"></p><ul><li>body就像组件中的run一样，因为obj不参与phase，定义了body你不需要手动运行就和你不需要手动run一样</li><li>数据的随机化：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231059436.png" alt="image-20211201231059436"></li></ul></li></ul><h4 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201230854209.png" alt="image-20211201230854209"></p><p>这里为什么手动执行body()，因为这不是个完整的代码，完整的应该是由挂载到的sqr自动运行</p><h4 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231331801.png" alt="image-20211201231331801"></p><p>（1）暂时没有用seq宏</p><p>（4）示例一颗粒度较小没有使用item</p><h3 id="2-7-3-代码示例二：加大颗粒度（使用item）"><a href="#2-7-3-代码示例二：加大颗粒度（使用item）" class="headerlink" title="2.7.3 代码示例二：加大颗粒度（使用item）"></a>2.7.3 代码示例二：加大颗粒度（使用item）</h3><h4 id="trans"><a href="#trans" class="headerlink" title="trans"></a>trans</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231554790.png" alt="image-20211201231554790"></p><h4 id="seq更多的去做一些控制的任务"><a href="#seq更多的去做一些控制的任务" class="headerlink" title="seq更多的去做一些控制的任务"></a>seq更多的去做一些控制的任务</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201231846970.png" alt="image-20211201231846970"></p><ul><li><p>seq更加简洁</p></li><li><p>多的去做一些控制的任务，粒度由trans控制</p></li><li><p>只需要例化一个trans实例</p></li></ul><h4 id="test没有什么大的变化"><a href="#test没有什么大的变化" class="headerlink" title="test没有什么大的变化"></a>test没有什么大的变化</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232126539.png" alt="image-20211201232126539"></p><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232239563.png" alt="image-20211201232239563"></p><h3 id="2-7-4-如何去定义一个item，粒度多少合适？"><a href="#2-7-4-如何去定义一个item，粒度多少合适？" class="headerlink" title="2.7.4 如何去定义一个item，粒度多少合适？"></a>2.7.4 如何去定义一个item，粒度多少合适？</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232253752.png" alt="image-20211201232253752"></p><p>简单来讲：seq里面包含多个item</p><h2 id="2-8-三类seq定义：Hierarchical-Sequence-介绍"><a href="#2-8-三类seq定义：Hierarchical-Sequence-介绍" class="headerlink" title="2.8 三类seq定义：Hierarchical Sequence 介绍"></a>2.8 三类seq定义：Hierarchical Sequence 介绍</h2><h3 id="2-8-1-介绍"><a href="#2-8-1-介绍" class="headerlink" title="2.8.1 介绍"></a>2.8.1 介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232405666.png" alt="image-20211201232405666"></p><ul><li>嵌套seq好处是可以创建更丰富的激励场景</li><li>hierarchical seq可以嵌套：hierarchical seq，flat seq，item</li></ul><h3 id="2-8-2-代码示例：trans与flatseq基于2-7-3"><a href="#2-8-2-代码示例：trans与flatseq基于2-7-3" class="headerlink" title="2.8.2 代码示例：trans与flatseq基于2.7.3"></a>2.8.2 代码示例：trans与flatseq基于2.7.3</h3><h4 id="hier-seq"><a href="#hier-seq" class="headerlink" title="hier_seq"></a>hier_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232553633.png" alt="image-20211201232553633"></p><p>宏做了三件事：</p><ul><li>创建了seq和item</li><li>完成了随机化</li><li>传送到sqr上</li></ul><h3 id="2-8-3-示例总结"><a href="#2-8-3-示例总结" class="headerlink" title="2.8.3 示例总结"></a>2.8.3 示例总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211201232800181.png" alt="image-20211201232800181"></p><p>（1）示例代码宏的三个作用</p><p>（3）示例中既有串行的激励关系，也有并行的激励关系</p><p>更复杂的场景中可以加入seq/item之间的时序关系：</p><ul><li>事件同步</li><li>一定的延迟关系</li></ul><h1 id="3-Sequencer和Driver"><a href="#3-Sequencer和Driver" class="headerlink" title="3 Sequencer和Driver"></a>3 Sequencer和Driver</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-数据传输概述"><a href="#3-1-1-数据传输概述" class="headerlink" title="3.1.1 数据传输概述"></a>3.1.1 数据传输概述</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202164914967.png" alt="image-20211202164914967"></p><hr><ul><li><p>seq与dri是组件，组件之间的通信依赖于TLM端口</p></li><li><p>数据传送机制是get模式（关于put和ge模式参考TLM）</p><ul><li><p>sv里面是generator产生item，stimulator/driver去get</p></li><li><p>uvm也是get模式，driver是initiator，是get模式</p></li></ul></li></ul><hr><p>seq与dri的端口结构图：双向的数据传输</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202164857361.png" alt="image-20211202164857361"></p><h3 id="3-1-2-端口"><a href="#3-1-2-端口" class="headerlink" title="3.1.2 端口"></a>3.1.2 端口</h3><p><strong>（1）端口：</strong></p><p>UVM<strong>专门提供</strong>便于item传输的<strong>端口</strong>，供seq与driv使用：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm seq_item pull_port <span class="hljs-variable">#(type REQ=int, type RSP=REQ)</span><br>uvm_seq_item_pull_export <span class="hljs-variable">#(type REQ=int, type RSP=REQ)</span><br>uvm_seq_item_pull_imp <span class="hljs-variable">#(type REQ=int, type RSP=REQ, type imp=int)</span><br></code></pre></div></td></tr></table></figure><p><strong>（2）端口分类：</strong></p><p>由于<strong>driver</strong>是请求发起端，所以在driver一侧例化了下面<strong>两种</strong>端口，<strong>一般我们只会使用其中一种</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_seq_item_pull_port <span class="hljs-variable">#(REP, RSP)</span> seq_item_port<span class="hljs-comment">//一般只使用这个，这个端口既可以get req又可以put rsp</span><br>uvm_analysis_port <span class="hljs-variable">#(RSP)</span> rsp_port<span class="hljs-comment">//广播模式端口，一段对多段，专门广播rsp，一般Monitor会用</span><br></code></pre></div></td></tr></table></figure><p>而<strong>sequencer</strong>一侧则为请求的响应端，在sequencer一侧例化了 对应的两种端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_seq_item_pull_imp <span class="hljs-variable">#(REQ, RSP, this_type)</span> seq_item_export<span class="hljs-comment">//名字export实际上是imp</span><br>uvm_analysis_export <span class="hljs-variable">#(RSP)</span> rsp_export<br></code></pre></div></td></tr></table></figure><ul><li>为什么是export实际上是imp？：<ul><li>因为sqr里面有fifo，对外显示的是export但已经是最后一个组件了，对内还需要连接</li><li>如图所示：<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202165831924.png" alt="image-20211202165831924"></li><li>补充sqr只有rsp的fifo没有req的fifo</li></ul></li></ul><p>回忆三种port</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202165649765.png" alt="image-20211202165649765"></p><h3 id="3-1-3-端口的连接"><a href="#3-1-3-端口的连接" class="headerlink" title="3.1.3 端口的连接"></a>3.1.3 端口的连接</h3><p>dri与sqr的端口成对组合，一共两对，进行连接：</p><ul><li>第一对：<ul><li><code>uvm_seq_item_pull_port #(REP, RSP) seq_item_port</code></li><li><code>uvm_seq_item_pull_imp #(REQ, RSP, this_type) seq_item_export</code></li></ul></li><li>第二对：<ul><li><code>uvm_analysis_port #(RSP) rsp_port</code></li><li><code>uvm_analysis_export #(RSP) rsp_export</code></li></ul></li></ul><p>两组端口都可以实现rsp发送，但方式不一样</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202170821975.png" alt="image-20211202170821975"></p><p>（1）<strong>通常使用第一对就够了</strong>，即：<code>driver::seq_item_port.connect(sequencer::seq_item_export)</code></p><h3 id="3-1-4-第一对端口的方法-需要反复听"><a href="#3-1-4-第一对端口的方法-需要反复听" class="headerlink" title="3.1.4 第一对端口的方法(需要反复听)"></a>3.1.4 第一对端口的方法(需要反复听)</h3><p>在driver一侧，通过seq_item_port调用这一种类型的TLM端口的方法：</p><ul><li>task get_next_item(output REQ req_arg)：采取blocking的方式等待从sequence获 取下一个item<ul><li><strong>常用</strong>，blocking即阻塞的方式</li></ul></li><li>task try_next_item(output REQ req_arg):采取nonblocking的方式从sequencer获 取item,如果立即返回的结果req_arg为null,则表示sequence还没有准备好<ul><li>nonblocking即非阻塞</li></ul></li><li>function void item_done(input RSP rsp_arg=null)：用来<strong>通知sequence</strong>当前的 sequence item已经消化完毕，可以选播性地传递RSP参数，返回状态值<ul><li><strong>不可缺少</strong>，完成一个完整的握手</li></ul></li><li>task wait_for_sequences()：等待当前的sequence直到产生下一个有效的item <ul><li>用的较少</li></ul></li><li>function bit has_do_available():如果当前的sequence准备好而且可以获取下一个有 效的item,则返向1,否则返回0</li><li><p>function void put_response(input RSP rsp_arg)：采取nonblocking方式发送 response,如果丽］返回1,否则返回0</p></li><li><p>也可以用传统的：</p><ul><li><p>task get(output REQ req_arg):采用get方式获取item</p></li><li><p>task peek(output REQ req_arg):采用peek方式获取item</p></li><li><p>task put(input RSP rsp_arg)：采取blocking方式将response发送回sequence</p></li><li><p>为什么有这三个port？</p><ul><li>uvm seq_item pull_port,uvm seq_item pull_export,uvm seq_item pull_imp这三个port继承于之前的tlm_port，这些port保留下来</li></ul></li></ul></li></ul><p>经常成对出现的方法：</p><ul><li>get_next_item与item_done</li></ul><p>put rsp独立出现</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202171759071.png" alt="image-20211202171759071"></p><h3 id="3-1-5-sqr与dri参数类的REQ与RSP的类型参数"><a href="#3-1-5-sqr与dri参数类的REQ与RSP的类型参数" class="headerlink" title="3.1.5 sqr与dri参数类的REQ与RSP的类型参数"></a>3.1.5 sqr与dri参数类的REQ与RSP的类型参数</h3><h4 id="参数类声明原型："><a href="#参数类声明原型：" class="headerlink" title="参数类声明原型："></a>参数类声明原型：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202180517844-16384395186521.png" alt="image-20211202180517844"></p><p>参数类内部的类型一致，缺省值为uvm_sequence_item，即自定义的Item的父类类型</p><hr><h4 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202182723182.png" alt="image-20211202182723182"></p><p>（1）如上所说缺省时拿到的是父类类型，需要动态进行类型转换</p><p>（2）类型参数为自定义类时不用在意</p><hr><h4 id="类型保持一致的作用："><a href="#类型保持一致的作用：" class="headerlink" title="类型保持一致的作用："></a>类型保持一致的作用：</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202182940197.png" alt="image-20211202182940197"></p><p>把rsp反馈到sqr的四种方法：</p><ul><li>put(rsp)//put rsp</li><li>put()//put方法</li><li>rsp_port::write(RSP)//rsp_port进行write写入</li><li>item_done</li></ul><p>这四种方法最终都会写入到一个fifo里面</p><h2 id="3-2-事务传递实例"><a href="#3-2-事务传递实例" class="headerlink" title="3.2 事务传递实例"></a>3.2 事务传递实例</h2><h3 id="（1）item-trans-和-flat-seq"><a href="#（1）item-trans-和-flat-seq" class="headerlink" title="（1）item(trans) 和 flat_seq"></a>（1）item(trans) 和 flat_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183241815.png" alt="image-20211202183241815"></p><p>flat_seq：</p><ul><li>body<ul><li>调用seq里面的函数create_item创建了一个item，创建时参数包括item的类型，被挂载到的sqr, （补充：用new也能）</li><li>父类句柄转换：<code>void`($cast(req, tmp))</code>，记住这种类型转换的方法（补充：如果只做randomize可以把子类也随机了，但这里要调用子类内的成员变量所以需要转换类型）</li></ul></li></ul><p>补充内容：</p><ul><li>为什么item也被挂载到sqr上<ul><li>实际上seq与Item都挂载到sqr上</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184105335.png" alt="image-20211202184105335"></li><li><strong>而自己定义的sqr又是uvm_sequence的成员变量</strong></li></ul></li><li>一个完成的传输：<ul><li>seq收到item_done才算结束，这里使用get_response(tmp)</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184636538.png" alt="image-20211202184636538"></li></ul></li></ul><h3 id="（2）sqr：最简单的一个"><a href="#（2）sqr：最简单的一个" class="headerlink" title="（2）sqr：最简单的一个"></a>（2）sqr：最简单的一个</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202184922242.png" alt="image-20211202184922242"></p><p>继承于uvm_sequencer</p><p><strong>只要进行一个注册就ok，最简单的一个</strong>，更多的握手关系在seq和dri一侧，sqr做路由作用</p><h3 id="（3）driver"><a href="#（3）driver" class="headerlink" title="（3）driver"></a>（3）driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183323782.png" alt="image-20211202183323782"></p><ul><li><p>关于REQ是哪来的，你忘了自己是个参数类了吗？这不是参数类的类型参数值吗？</p><ul><li>这里没有进行参数指明，所以直接用默认了，就是没有下图红字部分<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202204354109.png" alt="image-20211202204354109"></li></ul></li></ul></li><li><p>run_phase</p><ul><li><p>通过port拿到item：seq_item_port.get_next_item(tmp)</p></li><li><p>item父类转子类</p></li><li><p>子类克隆方法（返回父类句柄）</p></li><li><p>克隆的对象的父类句柄转子类</p></li><li><p>req的id交给rsp的id：rsp.set_sequence_id(req.get_sequence_id())</p><ul><li><p>seq_id是什么时候产生的？item经过sqr时被打上</p></li><li><p>seq_id有什么用？用于识别不同seq</p></li><li><p>为什么要手动set？id没有进行域的自动化，克隆的时候不会复制id，克隆只关心数据部分而id不是数据部分</p></li><li><p>传输结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202185848489.png" alt="image-20211202185848489"></p></li></ul></li><li><p>item_done(rsp句柄)，让seq结束</p><ul><li>即便没有rsp句柄（即没有rsp消息）也是一个完整的数据传输过程</li><li>如果没有rsp句柄，seq能否等到？<ul><li>finish_item可以等到，因为等到的item_done</li><li>get_response(tmp)会卡住，因为fifo为空没有数据<ul><li><strong>因此get_response一定要成对不然会卡住</strong></li></ul></li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202190641416.png" alt="image-20211202190641416"></li></ul></li></ul></li></ul></li></ul><h3 id="（4）env"><a href="#（4）env" class="headerlink" title="（4）env"></a>（4）env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183249715.png" alt="image-20211202183249715"></p><ul><li><p>成员区域</p><ul><li>对sqr和drv进行例化</li></ul></li><li><p>build</p><ul><li>对sqr和drv进行创建</li></ul></li><li><p>connect</p><ul><li>对第一个端口类进行连接，这就够了</li></ul></li></ul><h3 id="（5）test"><a href="#（5）test" class="headerlink" title="（5）test"></a>（5）test</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202183254693.png" alt="image-20211202183254693"></p><p>build：</p><ul><li>sqr的创建</li></ul><p>run_phase控制各个run_phase：</p><ul><li><p>挂起objection防止退出</p></li><li><p>例化flat_seq</p><ul><li>flat是Obj是在运行过程中动态产生的所以不在build里面例化</li></ul></li><li><p>flat_sep挂载到sqr上</p></li><li>结束挂起结束运行</li></ul><h3 id="（6）输出结果"><a href="#（6）输出结果" class="headerlink" title="（6）输出结果"></a>（6）输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202190839895.png" alt="image-20211202190839895"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202201323144.png" alt="image-20211202201323144">     </p><h2 id="3-3-【重要】各个模块的动作总结"><a href="#3-3-【重要】各个模块的动作总结" class="headerlink" title="3.3 【重要】各个模块的动作总结"></a>3.3 【重要】各个模块的动作总结</h2><h3 id="flat-seq："><a href="#flat-seq：" class="headerlink" title="flat_seq："></a>flat_seq：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202203103945.png" alt="image-20211202203103945"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">create_item()<br>start_item()<br>randomize()<br>finish_item()<br>*get_response()<br></code></pre></div></td></tr></table></figure><h3 id="driver以及之后的逻辑："><a href="#driver以及之后的逻辑：" class="headerlink" title="driver以及之后的逻辑："></a>driver以及之后的逻辑：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202204659663.png" alt="image-20211202204659663"></p><h3 id="高层次端口的连接（env和test）"><a href="#高层次端口的连接（env和test）" class="headerlink" title="高层次端口的连接（env和test）"></a>高层次端口的连接（env和test）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202205103247.png" alt="image-20211202205103247"></p><p>（1）env端口连接，使用一种端口进行成对连接就行</p><p>（2）</p><ul><li><p>记得在test中挂起objection防止提前退出</p></li><li><p>挂载seq到sqr使用uvm_sequence::<strong>start</strong>(SEQUENCER)完成</p></li></ul><h2 id="3-4-【重要】通信时序"><a href="#3-4-【重要】通信时序" class="headerlink" title="3.4 【重要】通信时序"></a>3.4 【重要】通信时序</h2><h3 id="3-4-1-通信时序"><a href="#3-4-1-通信时序" class="headerlink" title="3.4.1 通信时序"></a>3.4.1 通信时序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210435732.png" alt="image-20211202210435732"></p><h3 id="3-4-2-seq与sqr的细节补充"><a href="#3-4-2-seq与sqr的细节补充" class="headerlink" title="3.4.2 seq与sqr的细节补充"></a>3.4.2 seq与sqr的细节补充</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210329060.png" alt="image-20211202210329060"></p><p>（1）seq起点是create</p><p>（2）sqr的仲裁机制根据dri的get_next_item来的</p><p>（3）sqr在获取item之前item应该完成随机化</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210714053.png" alt="image-20211202210714053"></p><h3 id="3-4-3-握手建议、类型问题"><a href="#3-4-3-握手建议、类型问题" class="headerlink" title="3.4.3 握手建议、类型问题"></a>3.4.3 握手建议、类型问题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210749419.png" alt="image-20211202210749419"></p><ul><li><p>主要讲克隆和ID一部分的内容，可以参考3.2driver的run_phase</p></li><li><p>以及rep和rsp使用一个item所带来的危害</p></li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202210904018.png" alt="image-20211202210904018"></p><ul><li><p>seq与driver类型完全保持一致</p></li><li><p>如何修改底层的sequence item类型？override</p></li></ul><h1 id="4-Sequencer和Sequence：初步"><a href="#4-Sequencer和Sequence：初步" class="headerlink" title="4 Sequencer和Sequence：初步"></a>4 Sequencer和Sequence：初步</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-主要学习内容"><a href="#4-1-1-主要学习内容" class="headerlink" title="4.1.1 主要学习内容"></a>4.1.1 主要学习内容</h3><p>主要讲几种常见的仲裁方式，一般可能用不太到</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202220542862.png" alt="image-20211202220542862"></p><h3 id="4-1-2-sequence宏概述：区分两种挂载seq到sqr方式"><a href="#4-1-2-sequence宏概述：区分两种挂载seq到sqr方式" class="headerlink" title="4.1.2 sequence宏概述：区分两种挂载seq到sqr方式"></a>4.1.2 sequence宏概述：区分两种挂载seq到sqr方式</h3><ul><li>start()<ul><li>在test对top_seq挂载（参考第三章），在top_sep对child_sep和item挂载，在child_sep对item挂载</li></ul></li><li>`uvm_do<ul><li>一种宏：参考第五章</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221445893.png" alt="image-20211202221445893"></p><h2 id="4-2-sequence和item发送示例"><a href="#4-2-sequence和item发送示例" class="headerlink" title="4.2 sequence和item发送示例"></a>4.2 sequence和item发送示例</h2><h3 id="bus-trans"><a href="#bus-trans" class="headerlink" title="bus_trans"></a>bus_trans</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221650621.png" alt="image-20211202221650621"></p><h3 id="child-seq"><a href="#child-seq" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202221712682.png" alt="image-20211202221712682"></p><h3 id="top-seq"><a href="#top-seq" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222244292.png" alt="image-20211202222244292"></p><p>包含child_seq与item</p><h3 id="sqr"><a href="#sqr" class="headerlink" title="sqr"></a>sqr</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222302835.png" alt="image-20211202222302835"></p><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222337508.png" alt="image-20211202222337508"></p><p>driver里面get的全是最小颗粒度item，seq在sqr处被拆解</p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222453646.png" alt="image-20211202222453646"></p><h3 id="test与输出结果"><a href="#test与输出结果" class="headerlink" title="test与输出结果"></a>test与输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222607612.png" alt="image-20211202222607612"></p><h2 id="4-3-示例总结：两种挂载方式"><a href="#4-3-示例总结：两种挂载方式" class="headerlink" title="4.3 示例总结：两种挂载方式"></a>4.3 示例总结：两种挂载方式</h2><p>两种挂载方式，分别把seq和item挂载到sqr上</p><h3 id="4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上"><a href="#4-3-1-把seq挂载到sqr上：这种挂载发生在top-seq上" class="headerlink" title="4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上"></a>4.3.1 把seq挂载到sqr上：这种挂载发生在top_seq上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202222550069.png" alt="image-20211202222550069"></p><p>top_seq中的uvm_sequence::start()</p><ul><li>start内部参数解释<ul><li>uvm_sequencer_base sequencer：<ul><li>挂载到的sqr实例句柄</li></ul></li><li>uvm_sequence_base parent_sequence：<ul><li>上层对象句柄，示例中top_seq调用该方法时代入”this”代表child_seq的上层对象为自己</li><li>这样做的好处是保持子对象优先级一致，进而对仲裁有帮助仲裁表现一致</li></ul></li><li>int this_priority：<ul><li>优先级，默认值-1，此时实际优先级为100</li></ul></li><li>call_pre_post：<ul><li>建议使用默认值<ul><li>补充：body的pre和post回调函数不建议实现</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-2-把item挂载到sqr上"><a href="#4-3-2-把item挂载到sqr上" class="headerlink" title="4.3.2 把item挂载到sqr上"></a>4.3.2 把item挂载到sqr上</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202223931132.png" alt="image-20211202223931132"></p><p>第二个参数不需要特别关心，往往知道挂载哪个item就够了</p><h3 id="4-3-3-item创建发送过程"><a href="#4-3-3-item创建发送过程" class="headerlink" title="4.3.3 item创建发送过程"></a>4.3.3 item创建发送过程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202224727373.png" alt="image-20211202224727373"></p><p>pre_do()，mid_do()，post_do()：不建议实现，会变复杂</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225013595.png" alt="image-20211202225013595"></p><h3 id="4-3-4-seq-item的start-挂载内部逻辑"><a href="#4-3-4-seq-item的start-挂载内部逻辑" class="headerlink" title="4.3.4 seq/item的start()挂载内部逻辑"></a>4.3.4 seq/item的start()挂载内部逻辑</h3><h4 id="sequence挂载到sequencer"><a href="#sequence挂载到sequencer" class="headerlink" title="sequence挂载到sequencer"></a>sequence挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225207310.png" alt="image-20211202225207310"></p><p>为什么可以不关心：有时候call_pre_post=1时这些post和pre都不会执行</p><h4 id="item挂载到sequencer"><a href="#item挂载到sequencer" class="headerlink" title="item挂载到sequencer"></a>item挂载到sequencer</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225413186.png" alt="image-20211202225413186"></p><p>start_item立即返回，因为只有一个sqr进行仲裁可以立刻返回结果</p><h1 id="5-Sequencer和Sequence：更简单的创建挂载传输方式：宏"><a href="#5-Sequencer和Sequence：更简单的创建挂载传输方式：宏" class="headerlink" title="5 Sequencer和Sequence：更简单的创建挂载传输方式：宏"></a>5 Sequencer和Sequence：更简单的创建挂载传输方式：宏</h1><p>图中宏省略了`</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211202225658481.png" alt="图中宏省略了`"></p><p><strong>这些宏封装了好多方法函数，x表示包括，空表示不包括</strong></p><p><strong>Item：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程，但直接randomiztion</li><li>`uvm_do_with：做一个带constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>body为空，因为item没有</li></ul></li></ul><p><strong>Sequence：</strong></p><ul><li><p>宏解释：</p><ul><li>`uvm_do：是一个完整的过程<br>+ </li><li>`uvm_do_with：做一个constraints的randomiztion</li><li>`uvm_create：就是一个创建</li><li>`uvm_send()：就是发送</li></ul></li><li><p>执行顺序解释：</p><ul><li>没有做sync和post-sync<ul><li>因为sync和post-sync需要在body里面拿到优先级，`uvm_do本身不会拿到优先级，只有在seq_body里面，只有在发送item时候才会拿到（即每次发送一个item的时候都会申请一次优先级）</li></ul></li></ul></li></ul><h3 id="宏的调用位置"><a href="#宏的调用位置" class="headerlink" title="宏的调用位置"></a>宏的调用位置</h3><ul><li>这些宏调用的都是 sequence方法，因此只有sequence才可以调用这些宏</li></ul><h3 id="宏带来的怠惰"><a href="#宏带来的怠惰" class="headerlink" title="宏带来的怠惰"></a>宏带来的怠惰</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203115317909.png" alt="image-20211203115317909"></p><h2 id="5-2-其他的宏"><a href="#5-2-其他的宏" class="headerlink" title="5.2 其他的宏"></a>5.2 其他的宏</h2><ul><li>将优先级作为参数传递的<strong><code>`uvm_do_pri/`uvm_do_on_prio</code></strong>等宏<ul><li>并行发送多个seq时，伴随优先级发送</li><li>形参优先级，默认为100</li><li>`uvm_do_on：这个on是什么意思，表示把这个特定的seq挂载到某一个sqr上面<ul><li>对于item来说，使用`uvm_do则会被同样挂载到seq挂载到的sqr上</li><li>`uvm_do_on则可以进行指定</li></ul></li></ul></li><li>专门针对seq的<strong><code>`uvm_create_seq/`uvm_do_seq/`uvm_do_seq_with</code></strong>等宏</li></ul><h2 id="5-3-序列宏的示例"><a href="#5-3-序列宏的示例" class="headerlink" title="5.3 序列宏的示例"></a>5.3 序列宏的示例</h2><h3 id="child-seq-1"><a href="#child-seq-1" class="headerlink" title="child_seq"></a>child_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135350051.png" alt="image-20211203135350051"></p><p>怎样利用宏发送的：</p><ul><li>`uvm_create(req)：创建item</li><li>`uvm_rand_send_with：添加constraint</li></ul><p>上述宏可以合并为：</p><ul><li>`uvm_do_with</li></ul><h3 id="top-seq-1"><a href="#top-seq-1" class="headerlink" title="top_seq"></a>top_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135410573.png" alt="image-20211203135410573"></p><ul><li>`uvm_do：这里发送了child_seq</li><li>`uvm_do_with：这里发送了item</li></ul><h2 id="5-4-序列宏的建议"><a href="#5-4-序列宏的建议" class="headerlink" title="5.4 序列宏的建议"></a>5.4 序列宏的建议</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203135746376.png" alt="image-20211203135746376"></p><p>（1）不管seq在哪个层次，都应在test结束前执行完毕</p><p>（2）可以用fork_join完成seq发送。而不建议用fork_join_any和fork_join_none，可能会导致seq没结束就立即退出，使得后台仍然有一些seq像挂载到sqr上面；进一步如果你针对fork调用disable可能会所锁sqr，因为你来不及释放seq线程权限。</p><ul><li>补充：你在代码中使用fork_join_any和fork_join_none一定要使用同步，如此处假如你使用了fork_join_any和fork_join_none你应该完成即便fork退出seq运行在后台时，仍然能与后台运行的seq进行同步，使得所有seq结束以后才进行后续的操作</li></ul><p>（3）fork_join其中一个seq线程无法结束时，考虑在合适时间点使用disbale</p><h1 id="5-Sequencer和Sequence：仲裁特性"><a href="#5-Sequencer和Sequence：仲裁特性" class="headerlink" title="5 Sequencer和Sequence：仲裁特性"></a>5 Sequencer和Sequence：仲裁特性</h1><h2 id="5-1-Sequencer和Sequence的仲裁特性"><a href="#5-1-Sequencer和Sequence的仲裁特性" class="headerlink" title="5.1 Sequencer和Sequence的仲裁特性"></a>5.1 Sequencer和Sequence的仲裁特性</h2><h3 id="5-1-1-仲裁特性介绍"><a href="#5-1-1-仲裁特性介绍" class="headerlink" title="5.1.1 仲裁特性介绍"></a>5.1.1 仲裁特性介绍</h3><p>仲裁场景结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141411994.png" alt="仲裁场景结构图"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203141403633.png" alt="image-20211203141403633"></p><p>（1）<strong>sqr已经内建了仲裁机制，只需要在top_seq设置仲裁的模式就足够</strong></p><p>（2）</p><p>如何设置：uvm_sequencer::set_arbitration(UVM_SEQ_ARB_TYPE val)</p><p>模式介绍：</p><ul><li>UVM_SEQ_ARB_FIFO：默认模式，竞争优先</li><li>UVM_SEQ_ARB_WEIGHTED：优先级模式</li><li>UVM_SEQ_ARB_RANDOM：随机模式</li><li>UVM_SEQ_ARB_STRICT_FIFO：按照优先和抵达顺序授权</li><li>UVM_SEQ_ARB_STRICT_RANDOM：最高优先级并随机授权</li><li>UVM_SEQ_ARB_USER：自定义仲裁，很少用</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143759204.png" alt="image-20211203143759204"></p><h3 id="5-1-2-Sequencer的仲裁示例"><a href="#5-1-2-Sequencer的仲裁示例" class="headerlink" title="5.1.2 Sequencer的仲裁示例"></a>5.1.2 Sequencer的仲裁示例</h3><h4 id="item和child-seq"><a href="#item和child-seq" class="headerlink" title="item和child_seq"></a>item和child_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203143948761.png" alt="image-20211203143948761"></p><h4 id="top-seq和sqr"><a href="#top-seq和sqr" class="headerlink" title="top_seq和sqr"></a>top_seq和sqr</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203144103956.png" alt="image-20211203144103956"></p><p>top_seq：</p><ul><li>body：<ul><li>设置优先级模式</li><li>fork_join进行调度：<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145448313.png" alt="image-20211203145448313"></li><li>三个同一时间申请的，seq1和seq2优先级更高</li><li>base是constraint</li><li>此时赋予了优先级之后child_seq中的`uvm_do_with就可以进行挂在了，因为它们等待的就是这个顶层的优先级，使用wait_for_guant等待授权</li></ul></li></ul></li></ul><h4 id="driver-1"><a href="#driver-1" class="headerlink" title="driver"></a>driver</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145759397.png" alt="image-20211203145759397"></p><p>没有太多新意</p><h3 id="env-1"><a href="#env-1" class="headerlink" title="env"></a>env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145816089.png" alt="image-20211203145816089"></p><h3 id="test和输出结果"><a href="#test和输出结果" class="headerlink" title="test和输出结果"></a>test和输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203145834402.png" alt="image-20211203145834402"></p><p>test：</p><ul><li>为什么test里面不用宏：因为用不了只能在seq里面用</li></ul><p>为什么是seq1seq2seq1seq2seq3seq3，而且还是0时刻？：</p><ul><li>发送item没有耗时</li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150048046.png" alt="image-20211203150048046"></p><h2 id="5-2-Sequencer的锁定机制介绍"><a href="#5-2-Sequencer的锁定机制介绍" class="headerlink" title="5.2 Sequencer的锁定机制介绍"></a>5.2 Sequencer的锁定机制介绍</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203150933463.png" alt="image-20211203150933463"></p><p>（1）锁定机制</p><p>什么是锁定机制：seq拿到权限后进行锁定，</p><p>什么是锁定：seq拿到一个item后锁定下来，后续item都可以拿到</p><p>（2）两种锁定方式：两个函数都可以</p><ul><li>lock()与unlock<ul><li>一定记得unlock</li></ul></li><li>grab()与ungrab()<ul><li>优先级比lock高，下一次授权周期可以无条件获取授权</li></ul></li></ul><h3 id="5-2-2-Sequencer的锁定示例"><a href="#5-2-2-Sequencer的锁定示例" class="headerlink" title="5.2.2 Sequencer的锁定示例"></a>5.2.2 Sequencer的锁定示例</h3><h4 id="item、child-seq、lock-seq"><a href="#item、child-seq、lock-seq" class="headerlink" title="item、child_seq、lock_seq"></a>item、child_seq、lock_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155333757.png" alt="image-20211203155333757"></p><p>child_seq：内部重复发送两次，间隔10ns，参考之前一节的示例</p><p>lock_seq：</p><ul><li><p>先等了10ns，试图达到等待授权把sqr锁住</p></li><li><p>m_sequencer.lock(this);</p><ul><li>什么时候才能lock住：下一次等待授权的时候，即大家都在等待的时候</li></ul></li><li>重复发送三次</li></ul><h3 id="grab-seq"><a href="#grab-seq" class="headerlink" title="grab_seq"></a>grab_seq</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155557543.png" alt="image-20211203155557543"></p><p>grab_seq：</p><ul><li><p>等了20ns</p></li><li><p>m_sequencer.grab(this);</p><ul><li>什么时候才能锁住：只要重新做仲裁就能锁住</li></ul></li><li>重复发送三次</li></ul><h4 id="top-seq-2"><a href="#top-seq-2" class="headerlink" title="top_seq"></a>top_seq</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203155814989.png" alt="image-20211203155814989"></p><p>seq1,seq2,seq3</p><p>lock_seq：优先级为300</p><p>grab_seq：没有优先级</p><h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160141887-16385185030091.png" alt="image-20211203160141887"></p><hr><p>注释版：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203160157368-16385185184612.png" alt="image-20211203160157368"></p><h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>10ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送（发送完等待10纳秒，重新排队伍）</li><li>lock_seq开始要权限</li></ul><p>10ns-20ns：</p><ul><li>seq发送</li></ul><p>20ns：</p><ul><li>seq1,2,3,lock都开始等待（lock因为优先级低所以也要等待）</li></ul><p>20ns-40ns：</p><ul><li>被lock锁住</li></ul><p>40ns：</p><ul><li>grabs拿到权限（实际上20nsgrab就开始试图拿权限，但被lock控制，只能等到重新仲裁，届时即可直接锁住无需）</li></ul><p>40ns-70ns：</p><ul><li>被grabs锁住</li></ul><p>70ns：</p><ul><li>seq1,seq2优先级500先发送sep3优先级300再发送</li></ul><h4 id="结果补充"><a href="#结果补充" class="headerlink" title="结果补充"></a>结果补充</h4><p>seq优先级如果使用默认，不给定，则默认100</p><p>即直接：</p><ul><li><code>`uvm_do_pri_with(seq)</code></li><li><code>`uvm_do_pri_with(lock)</code></li><li><code>`uvm_do_pri_with(grab)</code></li></ul><h3 id="5-2-3-结论"><a href="#5-2-3-结论" class="headerlink" title="5.2.3 结论"></a>5.2.3 结论</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211203161407082.png" alt="image-20211203161407082"></p><p>无论是lock或者grab都是在重新仲裁时才能锁住</p><h1 id="6-Sequence的层次化"><a href="#6-Sequence的层次化" class="headerlink" title="6 Sequence的层次化"></a>6 Sequence的层次化</h1><p>对于小白我们可能更关心如何让你的sequence层次化，如何理解别人写的层次化的sequence，以及把它们作为更顶层的sequence如何一层一层的调用</p><h2 id="6-1-概述：水平复用和垂直复用"><a href="#6-1-概述：水平复用和垂直复用" class="headerlink" title="6.1 概述：水平复用和垂直复用"></a>6.1 概述：水平复用和垂直复用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203162021806.png" alt="image-20211203162021806"></p><ul><li>hierarchical sequence：层次序列，seq都挂载在一个sqr上</li><li>virtual sequence：seq可挂载在多个sqr上</li><li>layering sequence</li></ul><h2 id="6-2-Hierarchical-Sequence层次序列"><a href="#6-2-Hierarchical-Sequence层次序列" class="headerlink" title="6.2 Hierarchical Sequence层次序列"></a>6.2 Hierarchical Sequence层次序列</h2><h3 id="6-2-1-Hierarchical-Sequence介绍"><a href="#6-2-1-Hierarchical-Sequence介绍" class="headerlink" title="6.2.1 Hierarchical Sequence介绍"></a>6.2.1 Hierarchical Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203170532752.png" alt="image-20211203170532752"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203173213812.png" alt="image-20211203173213812"></p><h3 id="6-2-2-Hierarchical-Sequence代码示例"><a href="#6-2-2-Hierarchical-Sequence代码示例" class="headerlink" title="6.2.2 Hierarchical Sequence代码示例"></a>6.2.2 Hierarchical Sequence代码示例</h3><p><strong>cmd 和 item</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215113852.png" alt="image-20211203215113852"></p><p><strong>clk_rst_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215132273.png" alt="image-20211203215132273"></p><p><strong>reg_test_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215159086.png" alt="image-20211203215159086"></p><p><strong>top_seq</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215246475.png" alt="image-20211203215246475"></p><p><strong>reg_master_sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215319193.png" alt="image-20211203215319193"></p><p><strong>driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215348378.png" alt="image-20211203215348378"></p><p><strong>agent</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215406423.png" alt="image-20211203215406423"></p><ul><li>例化与连接</li></ul><h3 id="6-2-3-示例解析"><a href="#6-2-3-示例解析" class="headerlink" title="6.2.3 示例解析"></a>6.2.3 示例解析</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211203215450672.png" alt="image-20211203215450672"></p><h3 id="6-2-4-总结"><a href="#6-2-4-总结" class="headerlink" title="6.2.4 总结"></a>6.2.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215501808-16385397031013.png" alt="image-20211203215501808"></p><h2 id="6-3-Virtual-Sequence"><a href="#6-3-Virtual-Sequence" class="headerlink" title="6.3 Virtual Sequence"></a>6.3 Virtual Sequence</h2><h3 id="6-3-1-Virtual-Sequence介绍"><a href="#6-3-1-Virtual-Sequence介绍" class="headerlink" title="6.3.1 Virtual Sequence介绍"></a>6.3.1 Virtual Sequence介绍</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215818498.png" alt="image-20211203215818498"></p><hr><p>把所有子系统的sqr都放在virtual_sequencer里面</p><ul><li>virtual_sequencer包含着很多实例句柄</li><li>它就像一个路由一样，找到他就能找到各个子系统的sqr</li><li>起到一个统筹的作用</li><li>virtual sequencer往往与virtual sequence有联系的</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203215944706.png" alt="image-20211203215944706"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220636658.png" alt="image-20211203220636658"></p><p>virtual sequencer就是个简单的路由器，包含句柄而已，没有任何item经过，也不需要与driver连接</p><h3 id="6-3-2-Virtual-Sequence示例"><a href="#6-3-2-Virtual-Sequence示例" class="headerlink" title="6.3.2 Virtual Sequence示例"></a>6.3.2 Virtual Sequence示例</h3><p><strong>vritual sequencer结构图</strong>：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220753318.png" alt="vritual sequencer结构图"></p><p><strong>【重要】有关挂载</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203222842906.png" alt="image-20211203222842906"></p><p>mcdf_normal_seq(virtual sequence)要挂载到virutal sequencer</p><p>其他的seq间接的通过virutal sequencer挂载到不同的sqr上面，挂载的目的地不一样所以用uvm_do_on</p><hr><p><strong>virtual sequence</strong></p><p>定义了一个sequence：实际上就是我们的virtual sequence</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203220826070.png" alt="image-20211203220826070"></p><p>包括了好多seq句柄</p><p>sqr与vsqr区别：</p><ul><li>用了很多`uvm<em>do</em><strong>on</strong></li><li>有别于Hierarchical Sequence使用的`uvm_do</li></ul><p>子</p><p>p_sequencer和m_sequencer的区别：</p><ul><li>m_sequencer：是父类句柄，类型是uvm_sequencer</li><li>p_sequencer：是子类句柄，类型是`uvm_declare_p_sequencer(mcdf_virtual_sequencer)<ul><li>自定义出来的，不是与定义好的，定义语句就来源于`uvm_declare_p_sequencer(mcdf_virtual_sequencer)</li><li>定义语句完成了两个步骤：<ul><li>mcdf_virtual_sequencer p_sequencer;</li><li>$cast(p_sequencer, m_sequencer);//把父类句柄转为子类句柄</li></ul></li><li>为什么一定要子类句柄：<ul><li>因为父类的访问不到这些子系统sqr句柄</li><li>通过这个子类句柄p_sequencer我们可以访问到vsqr里面所有成员变量</li></ul></li></ul></li></ul><p><strong>子一级的sqr，agent，和virutal sequencer</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223410467.png" alt="image-20211203223410467"></p><p>virutal sequencer 包含各个句柄就完事了</p><p><strong>mcdf_env</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223436428.png" alt="image-20211203223436428"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223450033-16385420908084.png" alt="image-20211203223450033"></p><p>千万不要忘了再connect里进行句柄传递，避免悬空</p><p><strong>test</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203223457604.png" alt="image-20211203223457604"></p><h3 id="6-3-3-示例解析"><a href="#6-3-3-示例解析" class="headerlink" title="6.3.3 示例解析"></a>6.3.3 示例解析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224423125.png" alt="image-20211203224423125"></p><h3 id="6-3-4-总结"><a href="#6-3-4-总结" class="headerlink" title="6.3.4 总结"></a>6.3.4 总结</h3><p>中心化协调</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203224508271.png" alt="image-20211203224508271"></p><h3 id="6-3-5-Virutal-Sequencer建议"><a href="#6-3-5-Virutal-Sequencer建议" class="headerlink" title="6.3.5 Virutal Sequencer建议"></a>6.3.5 Virutal Sequencer建议</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211203224612008.png" alt="image-20211203224612008"></p><ul><li>vseq与普通seq区分</li><li>vsqr同底层负责传输对象的sqr区分</li><li>vseq中使用`uvm_declare_p_sqr来创建p_sequencer变量方便之后索引</li><li>顶层环境中创建vsqr并完成内部各个sqr句柄与底层sqr实例连接</li></ul><h2 id="6-4-Layering-Sequence：层次化"><a href="#6-4-Layering-Sequence：层次化" class="headerlink" title="6.4 Layering Sequence：层次化"></a>6.4 Layering Sequence：层次化</h2><h3 id="6-4-1-Layering-Sequence介绍"><a href="#6-4-1-Layering-Sequence介绍" class="headerlink" title="6.4.1 Layering Sequence介绍"></a>6.4.1 Layering Sequence介绍</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211203224824934.png" alt="image-20211203224824934"></p><ul><li><p>普通协议，构建协议总线时通过：sequencer item包含与约束关系</p></li><li><p>复杂协议，网络传输协议，需要更深层次一层一层解析，通过：若干个抽象层次去做</p></li></ul><p><strong>由高抽象级到低抽象级（传输层&gt;&gt;链路层&gt;&gt;物理层）</strong>的构建，我们称为<strong>Layering Sequence</strong></p><p>接下来学习，一定考虑三个层次：高抽象级的item，低抽象级的item，中间做转化的sequence</p><p>Layering Sequence层次结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p>寄存器模型下的item传递结构图与layering sequence具体作用内容：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211203225425767.png" alt="寄存器模型下的item传递结构图"></p><ul><li>对寄存器的reg.write()和reg.read()指令，通过寄存器模型的Adaption Layer转化层次，进而转化为总线的一个item。即把reg_item转为bug_item</li><li>得出layering sequence包括三者：高抽象级的item，低抽象级的item，中间做转化的sequence</li><li>高抽象级的item与低抽象级的item没有直接的继承关系所以需要做一个映射</li><li>高抽象级不包括具体的数据，只有类似命令、长度、idle等信息</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204114418582.png" alt="image-20211204114418582"></p><h3 id="6-4-2-Layering-Sequence代码示例"><a href="#6-4-2-Layering-Sequence代码示例" class="headerlink" title="6.4.2 Layering Sequence代码示例"></a>6.4.2 Layering Sequence代码示例</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211203225616936.png" alt="Layering Sequence层次结构图"></p><hr><p><strong>cmd和bus_trans(item)</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204114905038.png" alt="image-20211204114905038"></p><p>比较底层</p><p><strong>packet_seq</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204115007333.png" alt="image-20211204115007333"></p><p><strong>layer_trans(item)</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204115027913.png" alt="image-20211204115027913"></p><p>比较抽象：</p><ul><li>没有任何与数据有关的传输内用，只有cmd，len，idle</li><li>与底层的bus_trans没有任何继承关系所以要做一个映射</li></ul><p><strong>adapter_seq：转化层</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204115443718.png" alt="image-20211204115443718"></p><ul><li>p_sequencer通过`ucm_declare获得，通过p_sqr拿到up_sqr更上层的layersqr句柄</li><li><p>拿到子类句柄void($cast(trans,req))</p></li><li><p>转化为一个底层个seq，把高抽象级的长度转化为低抽象级的pkt_seq，`uvm_do挂载到了phy_driver上</p></li><li>做一个握手，告诉高层，我已经把高抽象层的trans消化掉了</li></ul><p><strong>top_seq , layering_sqr , phy_sqr</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204121723508.png" alt="image-20211204121723508"></p><p>layering_sqr , phy_sqr定义不讲了</p><p>phy_sqr里面有个句柄up_sqr，需要顶层把相关实例传递进来</p><p>top_seq：连续发送了两个layer_trans</p><p><strong>phy_driver</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204121949423-16385915953441.png" alt="image-20211204121949423"></p><p><strong>phy_agent</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B68%EF%BC%9ASequencer%E4%BB%B2%E8%A3%81_Sequence%E5%B1%82%E6%AC%A1%E5%8C%96/image-20211204122004651.png" alt="image-20211204122004651"></p><p>包含phy_drv和phy_sqr的例化与连接</p><p><strong>test，重点在这里，查看连接关系</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122057373.png" alt="image-20211204122057373"></p><ul><li>例化了layer_sqr与phy_agt<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122201923.png" alt="image-20211204122201923"></li></ul></li><li>sqr句柄的传递，layer_seq/top_seq，adapter_seq，phy_seq的挂载<ul><li>up_sqr句柄的传递<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122317592.png" alt="image-20211204122317592"></li></ul></li><li>adapter_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122352177.png" alt="image-20211204122352177"></li></ul></li><li>top_seq的挂载<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204122458395.png" alt="image-20211204122458395"></li></ul></li><li>phy_seq的挂载实际上不是个挂载而是产生的过程，在adapter_seq用uvm_do出来好多pkg_seq，这些pkg_seq时加上就属于phy到drv的seq</li></ul></li><li>为什么用fork_join_none<ul><li>用fork_join_none直接挂载上去就可以了</li><li>用fork_join不行，这个start会自动帮我们执行body()，adapter.body()是个forever会卡在这里</li></ul></li></ul><h3 id="6-4-3-如何实现sequencer-layer协议转换的方法："><a href="#6-4-3-如何实现sequencer-layer协议转换的方法：" class="headerlink" title="6.4.3 如何实现sequencer layer协议转换的方法："></a>6.4.3 如何实现sequencer layer协议转换的方法：</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123212588.png" alt="image-20211204123212588"></p><p>（1）layer_trans,bus_trans完全两个不同的抽象级</p><p>（2）需要adapter_seq完成从获取layer_trans再去生成phy_trans和seq，再从physqr发送出去</p><p>（2）fork_join_none</p><p>（4）至于多少个层次取决于</p><h3 id="6-4-4-总结"><a href="#6-4-4-总结" class="headerlink" title="6.4.4 总结"></a>6.4.4 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211204123514922.png" alt="image-20211204123514922"></p><p>（2）只有高抽象级到低抽象级，低到高需要有回路，通过response_item实现，两者的思想实际上一样</p><p>（3）也可以不通过高到低的回路，而是外部通过monitor采集response trans最终实现返回，避开adapter</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶5(了解)：TLM2与同步通信元件.md</title>
    <link href="/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%20(copy)/"/>
    <url>/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%20(copy)/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>TLM2通信</li><li>同步通信元件</li></ul><p>TLM2.0与UVM入门进阶5的双向通信都作为了解</p><h1 id="1-TLM2-0通信（了解）"><a href="#1-TLM2-0通信（了解）" class="headerlink" title="1 TLM2.0通信（了解）"></a>1 TLM2.0通信（了解）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-由TLM1-0到TLM2-0"><a href="#1-1-1-由TLM1-0到TLM2-0" class="headerlink" title="1.1.1 由TLM1.0到TLM2.0"></a>1.1.1 由TLM1.0到TLM2.0</h3><ul><li>TLM1.0用UVM各个组件之间连接</li><li>TLM2.0用于与SystemC进行连接</li></ul><p>目前TLM开源包也是基于TLM2.0，且TLM2.0早于UVM成立的标准</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204050389.png" alt="image-20211129204050389"></p><h3 id="1-1-2-对比、主要内容"><a href="#1-1-2-对比、主要内容" class="headerlink" title="1.1.2 对比、主要内容"></a>1.1.2 对比、主要内容</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204417791.png" alt="image-20211129204417791"></p><p><strong>什么时候用到</strong>TLM2.0，uvm与systemc做继承，把systemc作为reference model的时候</p><ul><li>因为systemc是纯设计模型，没有时间概念 </li></ul><p>纯验证环境中不需要TLM2.0</p><h2 id="1-2-接口实现"><a href="#1-2-接口实现" class="headerlink" title="1.2 接口实现"></a>1.2 接口实现</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205403805.png" alt=""></p><hr><h3 id="1-2-1-传输方法"><a href="#1-2-1-传输方法" class="headerlink" title="1.2.1 传输方法"></a>1.2.1 传输方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205432385.png" alt="image-20211129205432385"></p><p>两种方法：</p><ul><li>_fw：forward拿过来一个req</li><li>_bw：backward拿过来一个rsp</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205521092.png" alt="image-20211129205521092"></p><h3 id="1-2-2-传输端口：端口类socket"><a href="#1-2-2-传输端口：端口类socket" class="headerlink" title="1.2.2 传输端口：端口类socket"></a>1.2.2 传输端口：端口类socket</h3><p>socket由port,export和imp组合而成</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205557115.png" alt="image-20211129205557115"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205653551.png" alt="image-20211129205653551"></p><h3 id="1-2-3-端口类socket继承于uvm-port-base"><a href="#1-2-3-端口类socket继承于uvm-port-base" class="headerlink" title="1.2.3 端口类socket继承于uvm_port_base"></a>1.2.3 端口类socket继承于uvm_port_base</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205707575.png" alt="image-20211129205707575"></p><h2 id="1-3-传输数据"><a href="#1-3-传输数据" class="headerlink" title="1.3 传输数据"></a>1.3 传输数据</h2><h3 id="1-3-1-传输数据类型uvm-tlm-generic-payload"><a href="#1-3-1-传输数据类型uvm-tlm-generic-payload" class="headerlink" title="1.3.1 传输数据类型uvm_tlm_generic_payload"></a>1.3.1 传输数据类型uvm_tlm_generic_payload</h3><p>严格使用uvm_tlm_generic_payload类进行数据传输</p><p>这样才能与systemc无缝连接</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205747604-16381906688471.png" alt="image-20211129205747604"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205825619.png" alt="image-20211129205825619"></p><h3 id="1-3-2-uvm-tlm-generic-payload内部变量"><a href="#1-3-2-uvm-tlm-generic-payload内部变量" class="headerlink" title="1.3.2 uvm_tlm_generic_payload内部变量"></a>1.3.2 uvm_tlm_generic_payload内部变量</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205855177.png" alt="image-20211129205855177"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205938411.png" alt="image-20211129205938411"></p><h3 id="1-3-3-其他数据类型：两种解决方法"><a href="#1-3-3-其他数据类型：两种解决方法" class="headerlink" title="1.3.3 其他数据类型：两种解决方法"></a>1.3.3 其他数据类型：两种解决方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210001509.png" alt="image-20211129210001509"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210352251.png" alt="image-20211129210352251"></p><h2 id="1-4-时间标记"><a href="#1-4-时间标记" class="headerlink" title="1.4 时间标记"></a>1.4 时间标记</h2><h3 id="1-4-1-uvm-tlm-tim"><a href="#1-4-1-uvm-tlm-tim" class="headerlink" title="1.4.1 uvm_tlm_tim"></a>1.4.1 uvm_tlm_tim</h3><p>原则上systemc可以自己创建一些时钟，当我们很少这样做，因为会大幅度降低仿真效率</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210411249.png" alt="image-20211129210411249"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210541718.png" alt="image-20211129210541718"></p><h2 id="1-5-通信代码示例"><a href="#1-5-通信代码示例" class="headerlink" title="1.5 通信代码示例"></a>1.5 通信代码示例</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210558006.png" alt="image-20211129210558006"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210851775.png" alt="image-20211129210851775"></p><ul><li>数据类型固定所以不需要再指定数据传输类型</li><li>自始至终rsq与rsp都是一个对象</li></ul><p>顶层代码：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211419275.png" alt="image-20211129211419275"></p><h2 id="1-6-通信代码示例（有标注版）"><a href="#1-6-通信代码示例（有标注版）" class="headerlink" title="1.6 通信代码示例（有标注版）"></a>1.6 通信代码示例（有标注版）</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210811424.png" alt="image-20211129210811424"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211211453.png" alt="image-20211129211211453"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211507182.png" alt="image-20211129211507182"></p><h1 id="2-同步通信元件"><a href="#2-同步通信元件" class="headerlink" title="2 同步通信元件"></a>2 同步通信元件</h1>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶6：同步通信元件（解决组件同步与进程同步）</title>
    <link href="/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B66%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%85%83%E4%BB%B6/"/>
    <url>/202111292035/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B66%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%85%83%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li>同步通信元件</li><li>第一组类：uvm_event、uvm_event_pool、uvm_event_callback</li><li>第二组类：uvm_barrier, uvm_barrier_pool</li></ul><h1 id="1-同步通信元件"><a href="#1-同步通信元件" class="headerlink" title="1 同步通信元件"></a>1 同步通信元件</h1><p>SV的同步通信元件：event, semaphore, mailbox</p><p>UVM的线程同步，不局限于同一对象中，而针对不同组件之间的同步问题</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129213636303.png" alt="image-20211129213636303"></p><p><strong>同步类</strong>(保证了封闭性)：</p><ul><li>uvm_event, uvm_event_pool和uvm_event_callback</li><li>uvm_barrier, uvm_barrier_pool</li></ul><hr><p>补充：</p><p>不推荐句柄的形式进行同步：</p><ul><li>什么是句柄的形式？</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130100921108.png" alt="image-20211130100921108"></p><p>c2拿到了c1中例化的event1句柄</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130101116086.png" alt="image-20211130101116086"></p><p>两组类指的是这两组：</p><p>第一组：uvm_event, uvm_event_pool和uvm_event_callback</p><p>第二组：uvm_barrier, uvm_barrier_pool</p><p>uvm_callback具有回调特点的同时还能有丰富特性供<strong>层次化调用</strong></p><h1 id="2-第一组类：uvm-event、uvm-event-pool、uvm-event-callback"><a href="#2-第一组类：uvm-event、uvm-event-pool、uvm-event-callback" class="headerlink" title="2 第一组类：uvm_event、uvm_event_pool、uvm_event_callback"></a>2 第一组类：uvm_event、uvm_event_pool、uvm_event_callback</h1><p>学习内容：第一组类：</p><ul><li>uvm_event</li><li>uvm_event_pool</li><li>uvm_event_callback</li></ul><p>uvm_event解决问题（详细参考2.5节总结）</p><ul><li>obj与comp的同步</li><li>comp之间的同步</li><li>seq与dri之间的同步</li><li>seq之间的同步</li></ul><h2 id="2-1-对比与注意"><a href="#2-1-对比与注意" class="headerlink" title="2.1 对比与注意"></a>2.1 对比与注意</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130101432927-16382384751551.png" alt="image-20211130101432927"></p><ul><li>有post/pre trigger回调</li><li>trigger时能传入数据</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130165629774.png" alt="image-20211130165629774"></p><h2 id="2-2-uvm-event介绍"><a href="#2-2-uvm-event介绍" class="headerlink" title="2.2 uvm_event介绍"></a>2.2 uvm_event介绍</h2><p>不同组件共享一个名称相同的uvm_event，这个uvm_event创建、存放、例化、管理在uvm_pool这一个资源池中，uvm_pool是继承于uvm_object_string_pool#(T)一个参数类</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130154308227.png" alt="image-20211130154308227"></p><hr><p>关于uvm_object_string_pool #(T)：</p><p>T pool [stirng] —&gt;uvm_event pool [“event_name”]</p><h2 id="2-3-部分总结-详细参考2-1"><a href="#2-3-部分总结-详细参考2-1" class="headerlink" title="2.3 部分总结(详细参考2.1)"></a>2.3 部分总结(详细参考2.1)</h2><p>(1) <strong>uvm_event_pool不需要例化，就在后台一直工作</strong></p><p>(2) 如何在组件中拿到/创建event：</p><ul><li><p>声明一个uvm_event句柄e1</p></li><li><p><code>e1.uvm_event_pool::get_gobal(&quot;event_name&quot;);</code>//创建或得到了一个event句柄</p></li><li><p>真正的创建其实时在uvm_event_pool自动完成的</p></li></ul><p>(3) 如何触发、被触发、重复触发：</p><ul><li>与SV不同</li><li>trigger()触发，同时可以传入数据</li><li>wait_trigger()/wait_trigger_data等待</li><li>重复触发之前一定要reset</li></ul><p>(4) 如何增加回调函数：</p><ul><li>创建一个回调类uvm_callback（按照组件创建的方式）</li><li>在类里面实现：pre_trigger,post_trigger两种方法<ul><li>pre_trigger()有返回值，返回1时表明uvm_event不会被trigger同时不会执行post_trigger()，否则反之</li></ul></li><li>最后在event被例化处使用add_callback添加回调函数</li></ul><p>(5) 获取等待某个事件的进程数：</p><ul><li>get_num_waiters()</li></ul><p>(6) 查看uvm_event状态（即查看是否已被触发）或者说是<strong>电平触发</strong></p><ul><li>wait_ptrigger()与wait_ptrigger_data()</li></ul><p>(7) 补充：wait_trigger与wait_ptrigger</p><ul><li>wait_trigger边沿触发：同SV中的@</li><li>wait_ptrigger电平触发</li></ul><h2 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4 示例代码"></a>2.4 示例代码</h2><h4 id="（1）transaction-amp-uvm-callback"><a href="#（1）transaction-amp-uvm-callback" class="headerlink" title="（1）transaction&amp;uvm_callback"></a>（1）transaction&amp;uvm_callback</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130155117660.png" alt="image-20211130155117660"></p><ul><li><p>定义了一个transaction类型edata</p></li><li><p>定义ecb继承于uvm_event_callback注册肯定跑不掉</p></li><li>回调函数的定义与实现<ul><li>回调函数只能是<strong>pre_trigger，post_trigger</strong></li><li>形参data解释：触发时可以<strong>传入某些数据</strong></li></ul></li></ul><h4 id="（2）comp1对event1由全局pool进行的例化"><a href="#（2）comp1对event1由全局pool进行的例化" class="headerlink" title="（2）comp1对event1由全局pool进行的例化"></a>（2）comp1对event1由全局pool进行的例化</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130163328262.png" alt="image-20211130163328262"></p><p>通过全局Pool进行例化</p><p><code>e1=uvm_event_pool::get_gobal(&quot;e1&quot;);</code></p><ul><li>event pool里面有e1：直接拿到一个句柄</li><li>event pool里面没有e1：帮助创建一个名字是e1的句柄</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130163631552.png" alt="image-20211130163631552"></p><hr><p>task run_phase()中的要点：</p><ul><li>edata d = new()</li><li><strong>e1.trigger(d);//把数据传入triggered</strong></li><li>把callback与event1做个关联<ul><li><code>e1.add_callback(cb)</code></li></ul></li></ul><h4 id="（3）comp2-amp-env"><a href="#（3）comp2-amp-env" class="headerlink" title="（3）comp2&amp;env"></a>（3）comp2&amp;env</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130164226422.png" alt="image-20211130164226422"></p><p><code>e1.wait_triiger_data(tmp)</code>：等待被触发同时等待一个数据过来</p><ul><li>tmp默认obj类型</li></ul><p>void`($cast(d, tmp))：tmp进行父类转子类的转化</p><p><code>e1.wait_triiger()</code>：直接等待被触发</p><h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130155105004.png" alt="image-20211130155105004"></p><h2 id="2-5-应用场景总结"><a href="#2-5-应用场景总结" class="headerlink" title="2.5 应用场景总结"></a>2.5 应用场景总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130170353117.png" alt="image-20211130170353117"></p><ul><li>uvm_event的使用场景</li><li>uvm_event的使用场景</li><li>uvm_event什么时候使用到<ul><li>obj与comp的同步</li><li>comp之间的同步</li><li>seq与dri之间的同步</li><li>seq之间的同步</li></ul></li></ul><h2 id="3-第二组类：uvm-barrier-uvm-barrier-pool"><a href="#3-第二组类：uvm-barrier-uvm-barrier-pool" class="headerlink" title="3 第二组类：uvm_barrier, uvm_barrier_pool"></a>3 第二组类：uvm_barrier, uvm_barrier_pool</h2><p>学习内容：第二组类：</p><ul><li>uvm_barrier</li><li>uvm_barrier_pool </li></ul><h2 id="3-1-进程同步与uvm-barrier-amp-uvm-barrier-pool"><a href="#3-1-进程同步与uvm-barrier-amp-uvm-barrier-pool" class="headerlink" title="3.1 进程同步与uvm_barrier&amp;uvm_barrier_pool"></a>3.1 进程同步与uvm_barrier&amp;uvm_barrier_pool</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130171903482.png" alt="image-20211130171903482"></p><p>P1：SV中多线程的同步</p><p>P2：UVM的组件独立，SV方法收到作用域限制</p><p>P3：uvm_barrier解决多个组件同步协调，uvm_barrier_pool全局管理uvm_barrier</p><p>P4：继承关系同uvm_event_pool</p><h2 id="3-2-uvm-barrier-pool-amp-uvm-event-pool继承于uvm-object-string-pool"><a href="#3-2-uvm-barrier-pool-amp-uvm-event-pool继承于uvm-object-string-pool" class="headerlink" title="3.2 uvm_barrier_pool&amp;uvm_event_pool继承于uvm_object_string_pool"></a>3.2 uvm_barrier_pool&amp;uvm_event_pool继承于uvm_object_string_pool</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130172416691.png" alt="image-20211130172416691"></p><h2 id="3-3-阈值"><a href="#3-3-阈值" class="headerlink" title="3.3 阈值"></a>3.3 阈值</h2><p>可设置阈值threshold</p><p>等待线程<strong>不少于</strong>阈值时触发全体线程中的等待</p><h3 id="3-4-部分总结"><a href="#3-4-部分总结" class="headerlink" title="3.4 部分总结"></a>3.4 部分总结</h3><ul><li>wait_for()进行等待</li><li>set_threshold()设置触发阈值</li></ul><h2 id="3-5-代码示例"><a href="#3-5-代码示例" class="headerlink" title="3.5 代码示例"></a>3.5 代码示例</h2><h3 id="（1）comp1-amp-comp2及其获得b句柄"><a href="#（1）comp1-amp-comp2及其获得b句柄" class="headerlink" title="（1）comp1&amp;comp2及其获得b句柄"></a>（1）comp1&amp;comp2及其获得b句柄</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173016211.png" alt="image-20211130173016211"></p><ul><li>b.wait_for()</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173010530.png" alt="image-20211130173010530"></p><h3 id="（2）env"><a href="#（2）env" class="headerlink" title="（2）env"></a>（2）env</h3><p>env1做了一个裁判员</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173104269.png" alt="image-20211130173104269"></p><h3 id="（3）结果与总结"><a href="#（3）结果与总结" class="headerlink" title="（3）结果与总结"></a>（3）结果与总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173252341.png" alt="image-20211130173252341"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130173336364.png" alt="image-20211130173336364"></p><h2 id="4-正式进入uvm-callback"><a href="#4-正式进入uvm-callback" class="headerlink" title="4 正式进入uvm_callback"></a>4 正式进入uvm_callback</h2><p>之前都是稍微提到组件或obj的回调方法，以及uvm_event_callback，今天我们正式分析uvm_callback机制</p><h3 id="4-1-回调的作用"><a href="#4-1-回调的作用" class="headerlink" title="4.1 回调的作用"></a>4.1 回调的作用</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130211756901.png" alt="image-20211130211756901"></p><p>第一段，<strong>回调的好处</strong></p><ul><li>另一种同步方式</li><li>方便里类的封装复用</li></ul><p>第二三四段，<strong>如何实现封闭的包扩展新方法</strong></p><ul><li>类的继承</li><li>uvm覆盖机制</li><li>callback，无需继承何添加新方法，只需要后期定义</li></ul><h3 id="4-2-之前学习过什么uvm-callback？"><a href="#4-2-之前学习过什么uvm-callback？" class="headerlink" title="4.2 之前学习过什么uvm_callback？"></a>4.2 之前学习过什么uvm_callback？</h3><ul><li><p>学过uvm_event_callback</p></li><li><p>学过uvm_object提供了一些callback方法供用户们定义：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">copy () /do_copy () <br>print () /do_print () <br>compare()/do_compare() <br>pack () /do_pack ()<br>unpack() /do_unpack () <br>record()/do_record()<br></code></pre></div></td></tr></table></figure><p>默认情况下，这些回调函数do_xxx是定义为空的</p><p>如果用户执行了uvm_object::copy()函数，那么在该函数执行末尾会自动执行 uvm_object::do_copy()</p><p>do_copy()是copy，的回调函数，uvm_object会在copy()的执行尾端勾住(hook) callback 函数即do_copy()</p><p>如果用户自定义了这些回调函数，就可以在对应函数执行结束后再执行扩展后的回调方法</p><p>通过这个新添加的类，使得函数回调有了顺序和继承性</p><p>关于顺序和继承性的实现，UVM是通过两个相关类uvm_callback_iter和uvm_callbacks #(T, CB)来实现的</p><p>如何定义这些callback类：<br>UVM是通过两个相关类uvm_callback_iter和uvm_callbacks #(T, CB)来实现的</p><ul><li><code>uvm_callback_iter</code></li><li><code>uvm_callbacks #(T, CB)</code></li></ul><h2 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h2><h3 id="（1）trans数据类以及callback定义"><a href="#（1）trans数据类以及callback定义" class="headerlink" title="（1）trans数据类以及callback定义"></a>（1）trans数据类以及callback定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215505263.png" alt="image-20211130215505263"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215542955.png" alt="image-20211130215542955"></p><ul><li>trans数据类<ul><li>obj注册</li></ul></li><li>定义cb1<ul><li>obj注册</li><li>虚函数，名称随便起</li></ul></li><li>定义cb2继承于cb1<ul><li>override do_trans</li></ul></li></ul><p><strong>你可以在callback里面定义任何你想定义的函数名称</strong>：这里我们定义了do_trans函数</p><h3 id="（2）comp1定义"><a href="#（2）comp1定义" class="headerlink" title="（2）comp1定义"></a>（2）comp1定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130213618156.png" alt="image-20211130213618156"></p><ul><li>定义comp1<ul><li>注册(关联)comp1与cb1两个类的关系，方便之后检查(其实也可以不写，类型不同时无法提醒警告，参考4.4节)<ul><li><code>uvm_register_cb(comp1, cb1)</code></li></ul></li><li>run_phase中插入callback<ul><li>插入callbacks：<code>uvm_do_callback(comp1, cb1, do_trans(d))</code><ul><li>参数解释：我在comp1里面调用cb1类型的callback，callback方法名为do_trans(d)，d为传入参数</li></ul></li></ul></li></ul></li></ul><h3 id="（3）env与输出结果"><a href="#（3）env与输出结果" class="headerlink" title="（3）env与输出结果"></a>（3）env与输出结果</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130215608187.png" alt="image-20211130215608187"></p><ul><li>构造函数<ul><li>例化comp1,cb1,cb2</li></ul></li><li>build_phase<ul><li>添加callbacks进行绑定：<code>uvm_callbacks # (comp1)::add(组件实例句柄, callback实例句柄1)</code><ul><li>实现callback与comp1进行绑定</li></ul></li><li>添加callbacks进行绑定：<code>uvm_callbacks # (comp1)::add(组件实例句柄, callback实例句柄2)</code><ul><li>实现callback与comp1进行绑定</li><li>cb2没有注册为什么添加到m_cb2到c1可以？：因为cb2继承cb1，<strong>一旦发生继承关系你不需要再进行绑定</strong></li></ul></li></ul></li></ul><p>comp1的run_phase最终执行顺序：</p><ul><li>run_phase原来部分程序</li><li>cb1.do_trans(d)</li><li>cb2.do_trans(d)</li></ul><hr><h3 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h3><p>①注册你的callback</p><p>②绑定以及插入callback</p><p>③添加callback</p><h2 id="4-4-总结：结对子"><a href="#4-4-总结：结对子" class="headerlink" title="4.4 总结：结对子"></a>4.4 总结：结对子</h2><p>UVMcallback与SVcallback没区别，建议使用UVMcallback，更为标准化</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211130220008552.png" alt="image-20211130220008552"></p><h3 id="部分函数总结"><a href="#部分函数总结" class="headerlink" title="部分函数总结"></a>部分函数总结</h3><ul><li>组件创建时注册：<code>uvm_register_cb(组件类名, callback类名)</code></li><li><p>组件对应位置插入：<code>uvm_do_callback(组件类名, callback类名, callback内回调方法名(回调传入数据参数))</code></p></li><li><p>环境中添加：<code>uvm_callbacks # (组件类名)::add(组件实例句柄, callback实例句柄)</code></p></li><li><p>控制回调函数的层次（了解）：<code>`uvm_do_callbacks_exit_on(T,CB,METHOD,VAL)</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门进阶5：TLM通信_单向双向多向_通信管道_TLM2.0</title>
    <link href="/202111271641/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/"/>
    <url>/202111271641/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li><p>TLM通信</p><ul><li>单向通信</li><li>双向通信</li><li>多向通信</li><li>通信管道</li></ul></li><li><p>TLM2.0</p></li></ul><p>双向通信（使用较少）与TLM2.0（与SystemC通信），都作为<strong>了解</strong></p><h1 id="1-TLM通信"><a href="#1-TLM通信" class="headerlink" title="1 TLM通信"></a>1 TLM通信</h1><p>transaction level module</p><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>不用端口也是ok的（如实验2）但使用端口可以降低耦合度，有利于更长远的维护</p><h3 id="1-1-1-系统原型与芯片验证"><a href="#1-1-1-系统原型与芯片验证" class="headerlink" title="1.1.1 系统原型与芯片验证"></a>1.1.1 系统原型与芯片验证</h3><p>芯片开发流程中，两个地方对项目的助推起到关键作用：</p><ul><li>系统原型</li><li>芯片验证</li></ul><p>系统原型：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127173613007-16381918085062.png" alt="image-20211127173613007"></p><p>芯片验证：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127173627851-16381918085094.png" alt="image-20211127173627851"></p><p>实际上sv在组件间发送的数据都是trans，把硬件发送的数据抽象到一个数据包中，模拟硬件内部多个周期的数据传输</p><p>两者中的TLM与其作用：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174154049-16381918085096.png" alt="image-20211127174154049"></p><p>TLM是一个标准，而不一种特定语言：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174214668-16381918085108.png" alt="image-20211127174214668"></p><p>TLM引用越来越广泛，uvm与sv验证平台互通可以通过这个标准</p><h3 id="1-1-2-开发结构图（软件开发消耗人力较多）"><a href="#1-1-2-开发结构图（软件开发消耗人力较多）" class="headerlink" title="1.1.2 开发结构图（软件开发消耗人力较多）"></a>1.1.2 开发结构图（软件开发消耗人力较多）</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127174327342-163819180851010.png" alt="image-20211127174327342"></p><p>软件开发的两方面：</p><ul><li>对系统原型开发，没有硬件</li><li>等到设计开发到达稳定阶段时在稳定系统（simulator,FPGA,emulator硬件加速器）基础上</li></ul><h3 id="1-2-1-TLM"><a href="#1-2-1-TLM" class="headerlink" title="1.2.1 TLM"></a>1.2.1 TLM</h3><p>TLM：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185549442-163819180851012.png" alt="image-20211127185549442"></p><p>如何提高系统模型仿真性能：1、自身运算优化；2、通信优化</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185613000-163819180851114.png" alt="image-20211127185613000"></p><p>TLM就是通信角度的一种优化方式</p><h3 id="1-2-2-TLM通信基本概念"><a href="#1-2-2-TLM通信基本概念" class="headerlink" title="1.2.2 TLM通信基本概念"></a>1.2.2 TLM通信基本概念</h3><ul><li>基于事务的通信方式，可用于多种语言的模型中</li><li>需要两个通信对象，initiator与target，谁先发请求谁是initiator，谁响应谁是target<ul><li>initiator,target并不代表数据传输方向</li></ul></li><li>transaction数据流向分类分为producer（数据产生）与consumer（数据流向）</li><li>producer/consumer，initiator/target，关系不是固定的</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127185746270-163819180851116.png" alt="image-20211127185746270"></p><h3 id="1-2-3-TLM通信步骤："><a href="#1-2-3-TLM通信步骤：" class="headerlink" title="1.2.3 TLM通信步骤："></a>1.2.3 TLM通信步骤：</h3><ul><li>确定通信对象</li><li>将TLM<strong>通信方法</strong>在target一段实现（从而init调用target方法）</li><li>两个对象中创建TLM端口（uvm中端口预设，只需例化）</li><li>在更高层次中将两个对象的端口进行连接</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127190821795-163819180851218.png" alt="image-20211127190821795"></p><h3 id="1-2-4-示意图"><a href="#1-2-4-示意图" class="headerlink" title="1.2.4 示意图"></a>1.2.4 示意图</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127190837689-163819180851220.png" alt="image-20211127190837689"></p><h3 id="1-2-5-分类"><a href="#1-2-5-分类" class="headerlink" title="1.2.5 分类"></a>1.2.5 分类</h3><p>单向(unidirection)和双向(bidirection)传输：</p><ul><li>单向传输：由initor发起req trans</li><li>双向传输：由initor发起req trans，传送到target；target处理req trans后发起rsp trans，返回initor</li></ul><p>端口类型三种：</p><ul><li>prot：常作为initor发起端，initor借助port才能访问target的TLM通信方法（port也能连接到port上）</li><li><p>export：作为initor与target中间层次的端口</p></li><li><p>imp(implementation)：作为target接收rsp的末端，无法作为中间层次端口，所以imp的连接无法再次延伸（无法再连接到imp或其他端口上）</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127192644202.png" alt="image-20211127192644202"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195412692-163819180851324.png" alt="image-20211127195412692"></p><p>单向通信补充(参考1.3节)：</p><ul><li>多个port可以连到同一port/export/imp上</li><li>一个port不能连接到多个imp</li><li>为什么：<ul><li>多个initor可对同一组件发起req请求</li><li>同一initor无法连接多个target</li></ul></li></ul><p>如上可知，将传输方向与端口类型组合，得出TLM端口共六类，进而理解TLM端口的继承树：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_UNDIR_port <span class="hljs-variable">#(trans_t)</span><br>uvm_UNDIR_export <span class="hljs-variable">#(trans_t)</span><br>uvm_UNDIR_imp <span class="hljs-variable">#(trans_t)</span><br>uvm_BIDIR_port <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br>uvm_BIDIR_export <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br>uvm_BIDIR_imp <span class="hljs-variable">#(trans_t, imp_parent_t)</span><br></code></pre></div></td></tr></table></figure><p>端口既不是obj也不是comp类型，比较特殊<strong>不能通过type_id::create创建，即不存在factory的注册与创建</strong>：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127193020422-163819180851426.png" alt="image-20211127193020422"></p><h2 id="1-3-端口的使用："><a href="#1-3-端口的使用：" class="headerlink" title="1.3 端口的使用："></a>1.3 端口的使用：</h2><h3 id="1-3-1-结构示意图，port-import-export的符号"><a href="#1-3-1-结构示意图，port-import-export的符号" class="headerlink" title="1.3.1 结构示意图，port,import,export的符号"></a>1.3.1 结构示意图，port,import,export的符号</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127193208516-163819180851428.png" alt="image-20211127193208516"></p><h3 id="1-3-2-上述结构图代码"><a href="#1-3-2-上述结构图代码" class="headerlink" title="1.3.2 上述结构图代码"></a>1.3.2 上述结构图代码</h3><p>注意端口类型：</p><p>port：<code>uvm_blocking_get_port</code></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195110198-163819180851530.png" alt="image-20211127195110198"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127195005868-163819180851532.png" alt="image-20211127195005868"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127194942991-163819180851634.png" alt="image-20211127194942991"></p><h3 id="1-3-3-示例得出的TLM通信常规步骤"><a href="#1-3-3-示例得出的TLM通信常规步骤" class="headerlink" title="1.3.3 示例得出的TLM通信常规步骤"></a>1.3.3 示例得出的TLM通信常规步骤</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127200002390.png" alt="image-20211127200002390"></p><h1 id="2-单向通信"><a href="#2-单向通信" class="headerlink" title="2 单向通信"></a>2 单向通信</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="2-1-1-单向通信-unidirection-communication"><a href="#2-1-1-单向通信-unidirection-communication" class="headerlink" title="2.1.1 单向通信(unidirection communication)"></a>2.1.1 单向通信(unidirection communication)</h3><p>指的是从initiator到target之间的数据刘翔是单一方向的，也就是书initor与target只能扮演producer或consumer其中之一</p><p>UVM中单一数据流向的TLM端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br>uvm_blockong_put_PORT<br>uvm_nonblockong_put_PORT<br>uvm_put_PORT<br><span class="hljs-comment">//get</span><br>uvm_blockong_get_PORT<br>uvm_nonblockong_get_PORT<br>uvm_get_PORT<br><span class="hljs-comment">//peek</span><br>uvm_blockong_peek_PORT<br>uvm_nonblockong_peek_PORT<br>uvm_peek_PORT<br><span class="hljs-comment">//get_peek</span><br>uvm_blockong_get_peek_PORT<br>uvm_nonblockong_get_peek_PORT<br>uvm_get_peek_PORT<br></code></pre></div></td></tr></table></figure><h3 id="2-1-2-类型与表（非常重要）"><a href="#2-1-2-类型与表（非常重要）" class="headerlink" title="2.1.2 类型与表（非常重要）"></a>2.1.2 类型与表（非常重要）</h3><p>PORT代表三种端口名：port、export和imp，例如：</p><ul><li><code>uvm_blocking_put_PORT</code></li><li><code>uvm_blocking_put_EXPORT</code></li><li><code>uvm_blocking_put_IMP</code></li></ul><p>按照UVM端口命名规则，它们指出了通信的两个要素：</p><ul><li>是否是阻塞方式（block/nonblock）</li><li>何种通信方法（put/get/peek/get_peek）</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127202106862-163819180851638.png" alt="image-20211127202106862"></p><p>例如：</p><ul><li><p>看到<code>uvm_blocking_put_PORT</code></p><ul><li>我们要在target实现<code>task put(T t)</code>这一个方法</li></ul></li><li><p>看到<code>uvm_nonblocking_put_PORT</code></p><ul><li>我们要在target实现实现 <code>function bit try_put(T t)</code>，<code>function bit can_put()</code></li></ul></li><li>看到<code>uvm_put_PORT</code><ul><li>我们要在target实现上述三个方法</li></ul></li></ul><p>关于put，get，peek，get_peek：</p><ul><li>put：initiator—&gt;target</li><li>get：target—&gt;initiator</li><li>peek：与get方向一样，但没有把target_buf内数据移除</li></ul><h3 id="2-1-3-方法"><a href="#2-1-3-方法" class="headerlink" title="2.1.3 方法"></a>2.1.3 方法</h3><p>阻塞的是任务，非阻塞的是函数（函数有返回值）</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203157709-163819180851740.png" alt="image-20211127203157709"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203247382-163819180851742.png" alt="image-20211127203247382"></p><h2 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127203326914-163819180851844.png" alt="image-20211127203326914"></p><hr><p>代码：</p><p><strong>数据类型、组件一：</strong></p><p>传输的数据类型一定写的明明白白</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204455138-163819180851846.png" alt="image-20211127204455138"></p><hr><p><strong>组件1在run_phase是怎么做的呢</strong></p><p>线程1：</p><ul><li>通过bp_port.put发送出去<ul><li>port没有实现任何方法，这个方法不是port提供的，而是连接到的imp的组件2提供的</li></ul></li><li>更好的隔离性：完全看不到组件2，组件2的句柄，组件2的方法，完全不知道trans要发送到哪里；只知道要调用我的put方法</li></ul><p>线程2：</p><ul><li>try_get进行forever轮询</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204113119-163819180851848.png" alt="image-20211127204113119"></p><hr><p><strong>组件2：</strong></p><p>为什么要多传递所例化在的类型？</p><ul><li>这样才能在port找到imp端口后，再通过imp找到组件二的方法</li></ul><p>省略号省略例化</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127204821405-163819180851950.png" alt="image-20211127204821405"></p><hr><p><strong>组件二方法定义续，端口连接</strong></p><ul><li>对c1,c2例化</li><li>对c1,c2连接<ul><li>从initor_port连接到target_imp</li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205350698-163819180851954.png" alt="image-20211127205350698"></p><hr><p><strong>示例代码总结</strong></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205728745-163819180851952.png" alt="image-20211127205728745"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211127205412314-163819180852056.png" alt="image-20211127205412314"></p><h2 id="2-3-调用端口方法之前的几个步骤是必不可少的"><a href="#2-3-调用端口方法之前的几个步骤是必不可少的" class="headerlink" title="2.3 调用端口方法之前的几个步骤是必不可少的"></a>2.3 调用端口方法之前的几个步骤是必不可少的</h2><ul><li>定义端口</li><li>实现对应方法啊</li><li>在上层将端口进行连接</li></ul><h1 id="3-双向通信"><a href="#3-双向通信" class="headerlink" title="3 双向通信"></a>3 双向通信</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-双向通信-bidirectional-communication"><a href="#3-1-1-双向通信-bidirectional-communication" class="headerlink" title="3.1.1 双向通信(bidirectional communication)"></a>3.1.1 双向通信(bidirectional communication)</h3><p>应用场景较少，目前大多数是单向通信</p><p>与单向通信相同的是，双向通信(bidirectional communication)的两端也分为initiator与target</p><p>但数据流向在端对端之间是双向的，两端同时扮演者着producer与consumer的角色，而initiator作为request发起方在发起request之后还会等待response返回</p><p>UVM双向端口分为以下类型：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//transport</span><br>uvm_blockong_transport_PORT<br>uvm_nonblockong_transport_PORT<br>uvm_transport_PORT<br><span class="hljs-comment">//master</span><br>uvm_blockong_master_PORT<br>uvm_nonblockong_master_PORT<br>uvm_master_PORT<br><span class="hljs-comment">//slave</span><br>uvm_blockong_slave_PORT<br>uvm_nonblockong_slave_PORT<br>uvm_slave_PORT<br></code></pre></div></td></tr></table></figure><h3 id="3-1-2-类型与表"><a href="#3-1-2-类型与表" class="headerlink" title="3.1.2 类型与表"></a>3.1.2 类型与表</h3><ul><li>transport双向通信<ul><li>调用task transport/nb_transport 使得在一次传输中同时完成req与rsp的返回</li></ul></li><li>master/slave成对双向通信<ul><li>至少要调用两次对应的方法</li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122449307-163819180852058.png" alt="image-20211128122449307"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128122841747.png" alt="image-20211128122841747"></p><h2 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a>3.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122924921-163819180852162.png" alt="image-20211128122924921"></p><p><strong>transport双向通信方式，因为它明显区分于之前的单向通信方式</strong></p><hr><p>代码：</p><p>组件一：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128122953437-163819180852164.png" alt="image-20211128122953437"></p><p>组件二：</p><ul><li><p>下二语句内类型严格一致：</p><ul><li><p>uvm_blocking_transport_imp #（类型）</p></li><li><p>task transport(类型)</p></li></ul></li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128124144451-163819180852166.png" alt="image-20211128124144451"></p><p>env例化：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128124351358.png" alt="image-20211128124351358"></p><p>输出结果：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128124421630-163819180852270.png" alt="image-20211128124421630"></p><h1 id="4-多向通信"><a href="#4-多向通信" class="headerlink" title="4 多向通信"></a>4 多向通信</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-多向通信-multi-directional-communication"><a href="#4-1-1-多向通信-multi-directional-communication" class="headerlink" title="4.1.1 多向通信(multi-directional communication)"></a>4.1.1 多向通信(multi-directional communication)</h3><p>仍然是两个组件的通信，但是两个组件的通信由多个端口完成</p><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128125224093-163819180852272.png" alt="image-20211128125224093"></p><p>具体内容：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128124518033-16381062899701.png" alt="image-20211128124518033"></p><p>多向通信解决的问题：</p><ul><li><p>comp2中需要实现两个put造成的命名冲突</p></li><li><p>同时降低了耦合性</p></li></ul><h3 id="4-1-2-解决方案与命名方式"><a href="#4-1-2-解决方案与命名方式" class="headerlink" title="4.1.2 解决方案与命名方式"></a>4.1.2 解决方案与命名方式</h3><p>UVM通过<strong>端口宏</strong>声明端口来解决</p><p>它解决问题的核心在于<strong>让不同端口对应不同名的任务</strong></p><ul><li>也就是让方法名不一样</li></ul><p>UVM 为解决多向通信问题的宏按照端口名的命名方式分为：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br><span class="hljs-meta">`uvm_blockong_put_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_put_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_put_imp_decl(SFX)</span><br><span class="hljs-comment">//get</span><br><span class="hljs-meta">`uvm_blockong_get_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_get_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_get_imp_decl(SFX)</span><br><span class="hljs-comment">//peek</span><br><span class="hljs-meta">`uvm_blockong_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_peek_imp_decl(SFX)</span><br><span class="hljs-comment">//get_peek</span><br><span class="hljs-meta">`uvm_blockong_get_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_get_peek_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_get_peek_imp_decl(SFX)</span><br><span class="hljs-comment">//transport</span><br><span class="hljs-meta">`uvm_blockong_transport_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_transport_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_transport_imp_decl(SFX)</span><br><span class="hljs-comment">//master</span><br><span class="hljs-meta">`uvm_blockong_master_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_master_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_master_imp_decl(SFX)</span><br><span class="hljs-comment">//slave</span><br><span class="hljs-meta">`uvm_blockong_slave_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_nonblockong_slave_imp_decl(SFX)</span><br><span class="hljs-meta">`uvm_slave_PORT</span><br></code></pre></div></td></tr></table></figure><p>上述宏名称解释：</p><ul><li>decl：表明要声明一个新的端口</li><li>SFX：独一无二的名称</li></ul><h2 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a>4.2 代码示例</h2><p>数据传输结构图：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211128125224093-163819180852272.png" alt="image-20211128125224093"></p><hr><p>代码：</p><p><strong>宏声明与组件一</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221446172.png" alt="image-20211128221446172"></p><p><strong>组件二</strong></p><ul><li>方法实现</li><li>push到buf里<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221811119.png" alt="image-20211128221811119"></li></ul></li><li>旗语锁定buf</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221758250.png" alt="image-20211128221758250"></p><p><strong>env（顶层）做连接</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128214115156.png" alt="image-20211128214115156"></p><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128221858109.png" alt="image-20211128221858109"></p><hr><p>与这种端口区别开，这种直接单向通信就可以</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222125651.png" alt="image-20211128222125651"></p><h1 id="5-通信管道"><a href="#5-通信管道" class="headerlink" title="5 通信管道"></a>5 通信管道</h1><h2 id="5-1-问题及相关TLM组件和端口"><a href="#5-1-问题及相关TLM组件和端口" class="headerlink" title="5.1 问题及相关TLM组件和端口"></a>5.1 问题及相关TLM组件和端口</h2><p>TLM通信的实现方式都是端到端的，即target实现传输方法</p><ul><li><p>如何可以自己不是现这些传输方法同时使用到TLM呢</p></li><li><p>对于monitor、coverage collector等组件存在一端到多端的传输如何解决</p></li></ul><p>几个TLM组件和端口可以解决：</p><ul><li>TLM FIFO</li><li>analysis port</li><li>analysis TLM FIFO</li><li>request &amp; response 通信管道</li></ul><h2 id="5-2-TLM-FIFO组件"><a href="#5-2-TLM-FIFO组件" class="headerlink" title="5.2 TLM_FIFO组件"></a>5.2 TLM_FIFO组件</h2><h3 id="5-2-1-概述：TLM-FIFO是一个组件"><a href="#5-2-1-概述：TLM-FIFO是一个组件" class="headerlink" title="5.2.1 概述：TLM_FIFO是一个组件"></a>5.2.1 概述：TLM_FIFO是一个组件</h3><p>put方法一般就是往FIFO里面送数据，我们使用UVM组件进行简单化就不用我们自己实现了</p><hr><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">TLM　FIFO uvm_tlm_fifo<br></code></pre></div></td></tr></table></figure><p>TLM_FIFO是一个组件，继承于uvm_component，预先<strong>内置多个端口</strong>以及<strong>实现了多个对应方法</strong>供用户使用</p><ul><li><p>为什么是组件？</p><ul><li>因为只有组件才可以例化端口</li></ul></li><li><p>因此transaction不能例化该端口（组件），因为obj不是继承于comp</p></li></ul><p>uvm_tlm_fifo功能类似于mailbox，只不过提供了各种端口使用</p><p>我们推荐在initiator例化put_port，或者get_peek_port来匹配uvm_tlm_fifo的端口类型。当然如果用户例化了其它类型的端口，uvm_tlm_fifo还提供了put、get、peek对应端口</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222642907.png" alt=""></p><hr><p>uvm_tlm_fifo结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211128222656394.png" alt="image-20211128222656394"></p><h3 id="5-2-2-TLM-FIFO-具有的端口"><a href="#5-2-2-TLM-FIFO-具有的端口" class="headerlink" title="5.2.2 TLM_FIFO 具有的端口"></a>5.2.2 TLM_FIFO 具有的端口</h3><p>uvm_tlm_fifo功能类似于mailbox，只不过提供了各种端口使用</p><p>我们推荐在initiator例化put_port，或者get_peek_port来匹配uvm_tlm_fifo的端口类型。当然如果用户例化了其它类型的端口，uvm_tlm_fifo还提供了put、get、peek对应端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//put</span><br>uvm_put_imp <span class="hljs-variable">#(T, this_type)</span> blockong_put_export<br>uvm_put_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_put_export<br><span class="hljs-comment">//get</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_get_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_get_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> get_export<br><span class="hljs-comment">//peek</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> peek_export<br><span class="hljs-comment">//get_peek</span><br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> blockong_get_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> nonblockong_get_peek_export<br>uvm_get_peek_imp <span class="hljs-variable">#(T, this_type)</span> get_peek_export<br></code></pre></div></td></tr></table></figure><ul><li>_export：实际上都是实现的方法</li></ul><h2 id="5-3-Analysis-Port"><a href="#5-3-Analysis-Port" class="headerlink" title="5.3 Analysis Port"></a>5.3 Analysis Port</h2><p>本节内容唯一一个一端到多端的组件，利用到观察者模式/广播模式实现</p><hr><p>observer patten的核心：</p><ul><li>从一个initiator到多个target端</li><li>analysis port采取push模式，即从initiator端调用多个target端的<strong>write</strong>函数实现传输</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102446101.png" alt="image-20211129102446101"></p><p>Analysis Port连接结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102358636.png" alt="image-20211129102358636"></p><ul><li>我只管把消息发送出来</li></ul><h3 id="5-3-2-连接思路"><a href="#5-3-2-连接思路" class="headerlink" title="5.3.2 连接思路"></a>5.3.2 连接思路</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129102358636.png" alt="image-20211129102358636"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target1<span class="hljs-variable">.amp</span>);<br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target2<span class="hljs-variable">.amp</span>);<br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(target3<span class="hljs-variable">.amp</span>);<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129103636616.png" alt="image-20211129103636616"></p><h2 id="5-3-Analysis-TLM-FIFO"><a href="#5-3-Analysis-TLM-FIFO" class="headerlink" title="5.3 Analysis TLM FIFO"></a>5.3 Analysis TLM FIFO</h2><h3 id="5-3-1-uvm-tlm-analysis-fifo"><a href="#5-3-1-uvm-tlm-analysis-fifo" class="headerlink" title="5.3.1 uvm_tlm_analysis_fifo"></a>5.3.1 uvm_tlm_analysis_fifo</h3><p>Analysis TLM FIFO就是Analysis Port中间加一个fifo的一种结构封装为的类</p><ul><li>第一部分是端到端</li><li>第二部分是单向传递的port</li></ul><p>uvm_tlm_analysis_fifo类继承于uvm_tlm_fifo类，再此基础上添加了uvm_analysis_imp端口</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_analysis_imp <span class="hljs-variable">#(T,uvm_tlm_analysis_fifo #(T))</span> analysis_export<br></code></pre></div></td></tr></table></figure><ul><li>端口名称就叫analysis_export</li><li>FIFO参数类为T</li></ul><p>Analysis TLM FIFO连接结构图：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129103747402.png" alt="image-20211129103747402"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104134652.png" alt="image-20211129104134652"></p><h3 id="5-3-2-连接思路-1"><a href="#5-3-2-连接思路-1" class="headerlink" title="5.3.2 连接思路"></a>5.3.2 连接思路</h3><p>两部分连接：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104816121.png" alt="image-20211129104816121"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129104259780.png" alt="image-20211129104259780"></p><ul><li>ap</li><li>fifo1~3</li><li>target1~3</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo1<span class="hljs-variable">.analysis_export</span>);<br>target1<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo1<span class="hljs-variable">.get_export</span>);<br><br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo2<span class="hljs-variable">.analysis_export</span>);<br>target2<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo2<span class="hljs-variable">.get_export</span>);<br><br>initiator<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo3<span class="hljs-variable">.analysis_export</span>);<br>target3<span class="hljs-variable">.get_port</span><span class="hljs-variable">.connect</span>(tlm_analysis_fifo3<span class="hljs-variable">.get_export</span>);<br></code></pre></div></td></tr></table></figure><h2 id="5-4-Request-amp-Response管道"><a href="#5-4-Request-amp-Response管道" class="headerlink" title="5.4 Request&amp;Response管道"></a>5.4 Request&amp;Response管道</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><ul><li>单端（单向通信）：<ul><li>TLM FIFO、analysis port、analysis TLM FIFO</li></ul></li><li>双向通信，匹配双向通信的FIFO：<ul><li>request &amp; response 通信管道</li></ul></li></ul><p>双向通信端口名：transport</p><p>需要在target实现transport()方法完成一次传输既发送req又接受rsp</p><p>UVM提供两种简便的通信管道作为数据缓冲区，<strong>既有TLM端口从外侧接收req和rsp</strong>，同时也有TLM端口供外侧获取req和rsp，这两种TLM通信管道分别是：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_tlm_req_rsp_channel<br>uvm_tlm_transport_channel<br></code></pre></div></td></tr></table></figure><h3 id="5-4-2-端口"><a href="#5-4-2-端口" class="headerlink" title="5.4.2 端口"></a>5.4.2 端口</h3><p>对uvm_tlm_req_rsp_channel而言，提供端口是单一方向的，为简洁只列出该类例化的端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_put_export <span class="hljs-variable">#(REQ)</span> put_request_export;<br>uvm_put_export <span class="hljs-variable">#(RSP)</span> put_response_export;<br><br>uvm_get_peek_export <span class="hljs-variable">#(REQ)</span> get_peek_response_export;<br>uvm_put_peek_export <span class="hljs-variable">#(RSP)</span> get_peek_request_export;<br><br>uvm_analysis_port <span class="hljs-variable">#(REQ)</span> request_ap;<br>uvm_analysis_port <span class="hljs-variable">#(RSP)</span> response_ap;<br><br>uvm_master_imp <span class="hljs-variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> master_export<br>uvm_slave_imp <span class="hljs-variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> slave_export<br></code></pre></div></td></tr></table></figure><p>例化这么多端口，使用户可以在使用成对的端口进行数据的存储和访问</p><h3 id="5-4-3-示例结构一"><a href="#5-4-3-示例结构一" class="headerlink" title="5.4.3 示例结构一"></a>5.4.3 示例结构一</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129112631868.png" alt="image-20211129112631868"></p><hr><p>uvm_tlm_req_rsp_channel内部例化了两个mailbox分别用来存储req和rsp</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">protected</span> uvm_tlm_fifo <span class="hljs-variable">#(REQ)</span> m_request_fifo;<br><span class="hljs-keyword">protected</span> uvm_tlm_fifo <span class="hljs-variable">#(RSP)</span> m_response_fifo;<br></code></pre></div></td></tr></table></figure><p>例如initiator端可以连接channel的put_request_export, target连接channel的get_peek_request_export,同时target连接channel的put_response_export, initiator连接channel的 get_peek_response_export端口</p><hr><p>target不需要再实现对应的put,get,peek，对应的端口连接代码：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129112735235-16381564560181.png" alt="image-20211129112735235"></p><h3 id="5-4-4-示例结构二：利用一个端口实现双向通信（master-amp-slave）"><a href="#5-4-4-示例结构二：利用一个端口实现双向通信（master-amp-slave）" class="headerlink" title="5.4.4 示例结构二：利用一个端口实现双向通信（master&amp;slave）"></a>5.4.4 示例结构二：利用一个端口实现双向通信（master&amp;slave）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113506603.png" alt="image-20211129113506603"></p><hr><p>•也可以利用另外一种连接方式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.master_port</span><span class="hljs-variable">.connect</span>(req_rsp_channel,master_export);<br>target<span class="hljs-variable">.slave_port</span><span class="hljs-variable">.connect</span>(req_rsp_channel<span class="hljs-variable">.slave_export</span>);<br></code></pre></div></td></tr></table></figure><p>通过所述的这些方式，我们可以实现initiator与target之间自由的request和 response传输，而这两种连接方式仍然需要分别调用两次方法才可以完成 request 和 response 的传输。</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113521538.png" alt="image-20211129113521538"></p><hr><p>过程：</p><p>端口虽然减少了，调用的方法并没有减少</p><ul><li><p>put(rsp)-&gt;get(rsq)</p></li><li><p>get(rsp)&lt;-put(rsp)//target组件put时rr_channel才有数据</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113633263.png" alt="image-20211129113633263"></p><hr><h3 id="5-4-5-uvm-tlm-transport-channel"><a href="#5-4-5-uvm-tlm-transport-channel" class="headerlink" title="5.4.5 uvm_tlm_transport_channel"></a>5.4.5 uvm_tlm_transport_channel</h3><p>在uvm_t[m_req_rsp_channel的基础上，UVM又添加了具备transport端口的管道组件uvm_tlm_transport_channel类</p><p>它继承于 uvm_tlm_req_rsp_channel,并且新例化了transport端口：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm transport imp <span class="hljs-variable">#(REQ, RSP, this type)</span> transport_export<br></code></pre></div></td></tr></table></figure><p>新添加的这个TLM FIFO组件类型是针对于一些无法流水化处理的 request和response传输，例如initiator一端要求每次发送完 request,必须等到response接收到以后才可以发送下一个request, 这时transport。方法就可以满足这一需求<br>如果将上面的传输方式进行修改，需要变化的是initiator端到 req_rsp_channel的连接，应该修改为：</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">initiator<span class="hljs-variable">.transport_port</span><span class="hljs-variable">.connect</span>(transport_channel<span class="hljs-variable">.transport_export</span>)<br></code></pre></div></td></tr></table></figure><p>•至于transport_channel和target之间的连接，则可以仍然保留之 前的单向传输连接方式</p><p>过程：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211129113923124.png" alt="image-20211129113923124"></p><h1 id="6-TLM2-0通信（了解）"><a href="#6-TLM2-0通信（了解）" class="headerlink" title="6 TLM2.0通信（了解）"></a>6 TLM2.0通信（了解）</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><h3 id="6-1-1-由TLM1-0到TLM2-0"><a href="#6-1-1-由TLM1-0到TLM2-0" class="headerlink" title="6.1.1 由TLM1.0到TLM2.0"></a>6.1.1 由TLM1.0到TLM2.0</h3><ul><li>TLM1.0用UVM各个组件之间连接</li><li>TLM2.0用于与SystemC进行连接</li></ul><p>目前TLM开源包也是基于TLM2.0，且TLM2.0早于UVM成立的标准</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204050389.png" alt="image-20211129204050389"></p><h3 id="6-1-2-对比、主要内容"><a href="#6-1-2-对比、主要内容" class="headerlink" title="6.1.2 对比、主要内容"></a>6.1.2 对比、主要内容</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129204417791.png" alt="image-20211129204417791"></p><p><strong>什么时候用到</strong>TLM2.0，uvm与systemc做继承，把systemc作为reference model的时候</p><ul><li>因为systemc是纯设计模型，没有时间概念 </li></ul><p>纯验证环境中不需要TLM2.0</p><h2 id="6-2-接口实现"><a href="#6-2-接口实现" class="headerlink" title="6.2 接口实现"></a>6.2 接口实现</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205403805.png" alt=""></p><hr><h3 id="6-2-1-传输方法"><a href="#6-2-1-传输方法" class="headerlink" title="6.2.1 传输方法"></a>6.2.1 传输方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205432385.png" alt="image-20211129205432385"></p><p>两种方法：</p><ul><li>_fw：forward拿过来一个req</li><li>_bw：backward拿过来一个rsp</li></ul><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205521092.png" alt="image-20211129205521092"></p><h3 id="6-2-2-传输端口：端口类socket"><a href="#6-2-2-传输端口：端口类socket" class="headerlink" title="6.2.2 传输端口：端口类socket"></a>6.2.2 传输端口：端口类socket</h3><p>socket由port,export和imp组合而成</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205557115.png" alt="image-20211129205557115"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205653551.png" alt="image-20211129205653551"></p><h3 id="6-2-3-端口类socket继承于uvm-port-base"><a href="#6-2-3-端口类socket继承于uvm-port-base" class="headerlink" title="6.2.3 端口类socket继承于uvm_port_base"></a>6.2.3 端口类socket继承于uvm_port_base</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205707575.png" alt="image-20211129205707575"></p><h2 id="6-3-传输数据"><a href="#6-3-传输数据" class="headerlink" title="6.3 传输数据"></a>6.3 传输数据</h2><h3 id="6-3-1-传输数据类型uvm-tlm-generic-payload"><a href="#6-3-1-传输数据类型uvm-tlm-generic-payload" class="headerlink" title="6.3.1 传输数据类型uvm_tlm_generic_payload"></a>6.3.1 传输数据类型uvm_tlm_generic_payload</h3><p>严格使用uvm_tlm_generic_payload类进行数据传输</p><p>这样才能与systemc无缝连接</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205747604-16381906688471.png" alt="image-20211129205747604"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205825619.png" alt="image-20211129205825619"></p><h3 id="6-3-2-uvm-tlm-generic-payload内部变量"><a href="#6-3-2-uvm-tlm-generic-payload内部变量" class="headerlink" title="6.3.2 uvm_tlm_generic_payload内部变量"></a>6.3.2 uvm_tlm_generic_payload内部变量</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205855177.png" alt="image-20211129205855177"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129205938411.png" alt="image-20211129205938411"></p><h3 id="6-3-3-其他数据类型：两种解决方法"><a href="#6-3-3-其他数据类型：两种解决方法" class="headerlink" title="6.3.3 其他数据类型：两种解决方法"></a>6.3.3 其他数据类型：两种解决方法</h3><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210001509.png" alt="image-20211129210001509"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210352251.png" alt="image-20211129210352251"></p><h2 id="6-4-时间标记"><a href="#6-4-时间标记" class="headerlink" title="6.4 时间标记"></a>6.4 时间标记</h2><h3 id="6-4-1-uvm-tlm-tim"><a href="#6-4-1-uvm-tlm-tim" class="headerlink" title="6.4.1 uvm_tlm_tim"></a>6.4.1 uvm_tlm_tim</h3><p>原则上systemc可以自己创建一些时钟，当我们很少这样做，因为会大幅度降低仿真效率</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210411249.png" alt="image-20211129210411249"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210541718.png" alt="image-20211129210541718"></p><h2 id="6-5-通信代码示例"><a href="#6-5-通信代码示例" class="headerlink" title="6.5 通信代码示例"></a>6.5 通信代码示例</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210558006.png" alt="image-20211129210558006"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210851775.png" alt="image-20211129210851775"></p><ul><li>数据类型固定所以不需要再指定数据传输类型</li><li>自始至终rsq与rsp都是一个对象</li></ul><p>顶层代码：</p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211419275.png" alt="image-20211129211419275"></p><h2 id="6-6-通信代码示例（有标注版）"><a href="#6-6-通信代码示例（有标注版）" class="headerlink" title="6.6 通信代码示例（有标注版）"></a>6.6 通信代码示例（有标注版）</h2><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129210811424.png" alt="image-20211129210811424"></p><p><img src="UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B65%EF%BC%9ATLM%E9%80%9A%E4%BF%A1_%E5%8D%95%E5%90%91%E5%8F%8C%E5%90%91%E5%A4%9A%E5%90%91_%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93/image-20211129211211453.png" alt="image-20211129211211453"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV练习选修</title>
    <link href="/202111242221/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E7%BB%83%E4%B9%A0%E9%80%89%E4%BF%AE/"/>
    <url>/202111242221/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E7%BB%83%E4%B9%A0%E9%80%89%E4%BF%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-练习内容"><a href="#1-练习内容" class="headerlink" title="1 练习内容"></a>1 练习内容</h1><p>sv练习来自V1课程，因为V1在语法点上讲的比V2细致</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124222429387.png" alt="image-20211124222429387"></p><h2 id="lec1：类型练习"><a href="#lec1：类型练习" class="headerlink" title="lec1：类型练习"></a>lec1：类型练习</h2><ul><li>data_type.sv</li><li>interface_type.sv</li><li>string_type.sv</li><li>sv_for_design：sv中的设计<ul><li>always、always_comb、unique case</li></ul></li></ul><h2 id="lec2："><a href="#lec2：" class="headerlink" title="lec2："></a>lec2：</h2><ul><li>array_type.sv：数组</li><li>class_encapsulation.sv：类的封装</li><li>class_inheritance.sv：类的继承</li><li>package_usage.sv：包的使用</li></ul><h2 id="lec3："><a href="#lec3：" class="headerlink" title="lec3："></a>lec3：</h2><ul><li><p>constrained_random.sv：随即约束</p></li><li><p>interprocess_sync.sv：进程间通信</p></li><li>task_and_function.sv：</li><li>thread_control.sv：进程控制</li><li>virtual_methods.sv：虚方法</li></ul><h2 id="练习技巧"><a href="#练习技巧" class="headerlink" title="练习技巧"></a>练习技巧</h2><ul><li>每一个练习内有一个练习点，使用initial包住</li><li><p>全局initial同名的bit变量作为练习开关，如右图：<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124225912339.png" alt="image-20211124225912339"></p><ul><li>修改方法：1.编译前修改值；2.仿真时修改值</li></ul></li><li><p>编译时warning的查看方法：</p><ul><li>点击successful</li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125225129574.png" alt="image-20211125225129574"></li></ul></li><li>查询命令历史：<ul><li>上下键</li><li><code>&gt;history</code></li></ul></li><li>命令：<ul><li>编译命令：<code>&gt;vlog -sv xxx.sv</code>，vlog是编译命令，-sv是sv的形式，最后xxx.sv是具体文件</li><li>仿真命令：<code>&gt;vsim -voptargs=+acc work.xxx</code>最后xxx是具体模型名</li><li>从零开始加载模型，从零开始仿真：<code>&gt;restart</code></li><li>运行仿真：<code>&gt;run [time]</code></li><li>保存波形：<code>&gt;log -r /*</code> ，log是保存的意思，-r递归模式，/*表示从当前的顶层，即从当前顶层递归的去保存所有信号波形</li><li>仿真时修改静态信号的值（所有没有auto声明的都是静态变量）(linux的questasim有优化，解决方法见最后一节)<ul><li><code>&gt;restart</code></li><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125220012324.png" alt="image-20211125220012324"></li><li>freeze一直保持该值；Drive以硬件驱动模式保持（会与硬件产生冲突）；Depost更高优先级的硬件驱动（不会与硬件产生冲突）<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125220030623.png" alt="image-20211125220030623"></li></ul></li></ul></li></ul><h1 id="2-练习一指导"><a href="#2-练习一指导" class="headerlink" title="2 练习一指导"></a>2 练习一指导</h1><h2 id="2-1-data-type"><a href="#2-1-data-type" class="headerlink" title="2.1 data_type"></a>2.1 data_type</h2><h3 id="1-bytes与bit"><a href="#1-bytes与bit" class="headerlink" title="(1) bytes与bit"></a>(1) bytes与bit</h3><p>b0是byte四值逻辑(默认有符号数），b1是bit二值逻辑（默认无符号数），b2是有符号bit</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: signed_vs_unsigned<br>  <span class="hljs-keyword">byte</span> b0;<br>  <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] b1;<br>  <span class="hljs-keyword">bit</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] b2;<br>  <span class="hljs-keyword">wait</span>(b_signed_vs_unsigned == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;signed_vs_unsigned process block started&quot;</span>);<br>  b0 = <span class="hljs-number">&#x27;b1000_0000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;byte variable b0 = %d&quot;</span>, b0);<br>  b1 = b0;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit vector variable b1 = %d&quot;</span>, b1);<br>  b2 = b0;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit vector signed variable b2 = %d&quot;</span>, b2);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># signed_vs_unsigned process block started</span><br><span class="hljs-comment"># byte variable b0 = -128</span><br><span class="hljs-comment"># bit vector variable b1 = 128</span><br><span class="hljs-comment"># bit vector signed variable b2 = -128</span><br></code></pre></div></td></tr></table></figure><p>1000_0000为有符号的-128，无符号的128</p><p>有符号最高位是符号位，所以是-128，范围也就是-128~127</p><p>无符号最高位还是数，因此表示范围可以到2^8也就是255个数</p><h3 id="2-bit-vs-logic"><a href="#2-bit-vs-logic" class="headerlink" title="(2) bit_vs_logic"></a>(2) bit_vs_logic</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: bit_vs_logic<br>  <span class="hljs-keyword">bit</span> v1;<br>  <span class="hljs-keyword">logic</span> v2;<br>  <span class="hljs-keyword">wait</span>(b_bit_vs_logic == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit_vs_logic process block started&quot;</span>);<br><br>  v2 = <span class="hljs-number">&#x27;b1</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;b0</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;bx</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><br>  v2 = <span class="hljs-number">&#x27;bz</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;logic variable v2 = %d&quot;</span>, v2);<br>  v1 = v2;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;bit variable v1 = %d&quot;</span>, v1);<br><span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># logic variable v2 = 1</span><br><span class="hljs-comment"># bit variable v1 = 1</span><br><span class="hljs-comment"># logic variable v2 = 0</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br><span class="hljs-comment"># logic variable v2 = x</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br><span class="hljs-comment"># logic variable v2 = z</span><br><span class="hljs-comment"># bit variable v1 = 0</span><br></code></pre></div></td></tr></table></figure><p>四值变量中的x,z值转为二值变量时转为0</p><h3 id="3-enum-type：枚举类型的打印，与整数转枚举"><a href="#3-enum-type：枚举类型的打印，与整数转枚举" class="headerlink" title="(3) enum_type：枚举类型的打印，与整数转枚举"></a>(3) enum_type：枚举类型的打印，与整数转枚举</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: enum_type<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;IDLE, START, PROC, END&#125; state_t;<br>  state_t st1, st2;<br>  <span class="hljs-keyword">wait</span>(b_enum_type == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;enum_type process block started&quot;</span>);<br>  st1 = IDLE;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %0d (int)&quot;</span>, st1);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %s (string)&quot;</span>, st1); <span class="hljs-comment">// 推荐使用，有隐式转换implicit conversion</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st1 value = %s (string)&quot;</span>, st1<span class="hljs-variable">.name</span>());<br><br>  st2 = state_t&#x27;(<span class="hljs-number">1</span>);<span class="hljs-comment">//一个整数转为枚举类型，合法值legal value</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %0d (int)&quot;</span>, st2);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %s (string)&quot;</span>, st2<span class="hljs-variable">.name</span>());<br>  <br>  st2 = state_t&#x27;(<span class="hljs-number">4</span>);<span class="hljs-comment">//out of range</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %0d (int)&quot;</span>, st2);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;st2 value = %s (string)&quot;</span>, st2<span class="hljs-variable">.name</span>());<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p><code>%0d</code>：抛去输出中的0与空格，使输出更紧密</p><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># st1 value = 0 (int)</span><br><span class="hljs-comment"># st1 value = IDLE (string)</span><br><span class="hljs-comment"># st1 value = IDLE (string)</span><br><span class="hljs-comment"># st1 value = 1 (int)</span><br><span class="hljs-comment"># st1 value = START (string)</span><br><span class="hljs-comment"># st1 value = 4 (int)</span><br><span class="hljs-comment"># st1 value = START (string) //这里没有显示枚举类型，因为字符串为空</span><br></code></pre></div></td></tr></table></figure><p>补充：</p><ul><li>整形直接赋值枚举</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">st2 = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>结果：报错</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125222901318-16378505421341.png" alt="image-20211125222901318"></p><ul><li>使用$cast做转换（这种方法转换有返回值，推荐）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211125223023932.png" alt="image-20211125223023932"></p><h3 id="4-struct-type"><a href="#4-struct-type" class="headerlink" title="(4) struct_type"></a>(4) struct_type</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-4: struct type</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: struct_type<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">bit</span> is_write;<br>    <span class="hljs-keyword">int</span> id;<br>  &#125; trans_t;<br>  trans_t t1, t2, t3;<br>  <span class="hljs-keyword">wait</span>(b_struct_type == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;struct_type process block started&quot;</span>);<br>  t1 = &#x27;&#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t1 data content is %p&quot;</span>, t1);<br><br><br>  t2<span class="hljs-variable">.addr</span> = <span class="hljs-number">&#x27;h20</span>;<br>  t2<span class="hljs-variable">.data</span> = <span class="hljs-number">&#x27;h5566_7788</span>;<br>  t2<span class="hljs-variable">.is_write</span> = <span class="hljs-number">&#x27;b0</span>;<br>  t2<span class="hljs-variable">.id</span> = <span class="hljs-number">&#x27;h2000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t2 data content is %p&quot;</span>, t2);<br><br>  t3 = t2;<br>  t3<span class="hljs-variable">.data</span> = <span class="hljs-number">&#x27;h99AA_BBCC</span>;<br>  t3<span class="hljs-variable">.id</span> = <span class="hljs-number">&#x27;h3000</span>;<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t3 data content is %p&quot;</span>, t3);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;t2 data content is %p&quot;</span>, t2);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># struct_type process block started</span><br><span class="hljs-meta"># t1 data content is &#x27;&#123;addr:16, data:287454020, is_write:1, id:4096&#125;</span><br><span class="hljs-meta"># t2 data content is &#x27;&#123;addr:32, data:1432778632, is_write:0, id:8192&#125;</span><br><span class="hljs-meta"># t3 data content is &#x27;&#123;addr:32, data:2578103244, is_write:0, id:12288&#125;</span><br><span class="hljs-meta"># t2 data content is &#x27;&#123;addr:32, data:1432778632, is_write:0, id:8192&#125;</span><br></code></pre></div></td></tr></table></figure><p><code>%p</code>：十进制打印全部元素（数组，动态数组，队列，结构体），<strong>用的较多</strong></p><p>补充：</p><ul><li>struct packed：把struct串成一个vector</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> &#123;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">bit</span> is_write;<br>    <span class="hljs-keyword">int</span> id;<br>  &#125; trans_t;<br><br>t1 = &#x27;&#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<span class="hljs-comment">//正常</span><br>t1 = &#123;<span class="hljs-number">&#x27;h10</span>, <span class="hljs-number">&#x27;h1122_3344</span>, <span class="hljs-number">&#x27;b1</span>, <span class="hljs-number">&#x27;h1000</span>&#125;;<span class="hljs-comment">//warning并仿真后值不对应，此处&#123;&#125;内自动补全32位共128位与t1结构体73位不对应</span><br>t1 = &#123;<span class="hljs-number">8&#x27;h10</span>, <span class="hljs-number">32&#x27;h1122_3344</span>, <span class="hljs-number">1&#x27;b1</span>, <span class="hljs-number">32&#x27;h1000</span>&#125;;<span class="hljs-comment">//加位宽正常</span><br></code></pre></div></td></tr></table></figure><ul><li><ul><li>‘{a,b,c,d};并联成四个定长向量</li><li>{a,b,c,d};串联四个元素称为一个向量0</li></ul></li></ul><h2 id="2-2-string-type"><a href="#2-2-string-type" class="headerlink" title="2.2 string_type"></a>2.2 string_type</h2><h3 id="1-string-format"><a href="#1-string-format" class="headerlink" title="(1) string_format"></a>(1) string_format</h3><ul><li><p>判断字符串为空</p><p><code>if(str == &quot;&quot;)</code></p></li><li><p>字符串拼接</p><ul><li>方法一：<code>s3 = &#123;s1, &quot; to &quot;, s2&#125;; // concatenation operator &#39;&#123;...&#125;&#39;</code></li><li>方法二：<code>s4 = $sformatf(&quot;%s to %s&quot;, s1, s2); // system format function</code></li><li>方法三：<code>s5 = $psprintf(&quot;%s to %s&quot;, s1, s2); // system format function</code></li></ul></li><li>源码：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-1 understand how to formulate a new string</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: string_format<br>  <span class="hljs-keyword">string</span> s1, s2, s3, s4;<br>  <span class="hljs-keyword">wait</span>(b_string_format == <span class="hljs-number">1</span>);<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;string_format process block started&quot;</span>);<br>  s1 = <span class="hljs-string">&quot;Welcome&quot;</span>;<br>  s2 = <span class="hljs-string">&quot;www.rockeric.com&quot;</span>;<br><br>  s3 = &#123;s1, <span class="hljs-string">&quot; to &quot;</span>, s2&#125;; <span class="hljs-comment">// concatenation operator &#x27;&#123;...&#125;&#x27;</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: %s&quot;</span>, s3);<br><br>  s4 = <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s to %s&quot;</span>, s1, s2); <span class="hljs-comment">// system format function</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s4 content: %s&quot;</span>, s4);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><h3 id="2-string-builtin-function"><a href="#2-string-builtin-function" class="headerlink" title="(2) string_builtin_function"></a>(2) string_builtin_function</h3><p>拼接部分只是启示作用，正常直接{}就行</p><p>源码：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// TODO-2  understand how s3 is composed with s1 and s2</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>: string_builtin_function<br>  <span class="hljs-keyword">string</span> s1, s2, s3;<br>  <span class="hljs-keyword">int</span> i1;<br>  <span class="hljs-keyword">wait</span>(b_string_builtin_function == <span class="hljs-number">1</span>); <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;string_builtin_function process block started&quot;</span>);<br>  s1 = <span class="hljs-string">&quot;RockerIC is established in &quot;</span>;<br>  i1 = <span class="hljs-number">2015</span>;<br>  s2<span class="hljs-variable">.itoa</span>(i1); <span class="hljs-comment">// integer converted to string</span><br>  s3 = &#123;s1<span class="hljs-variable">.len</span>()+s2<span class="hljs-variable">.len</span>()&#123;<span class="hljs-string">&quot; &quot;</span>&#125;&#125;; <span class="hljs-comment">// try to comment this line and check the result</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: [%s]&quot;</span>, s3);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s1<span class="hljs-variable">.len</span>()+s2<span class="hljs-variable">.len</span>(); i++) <span class="hljs-keyword">begin</span><br>    s3[i] = i &lt; s1<span class="hljs-variable">.len</span>() ? s1[i] : s2[i-s1<span class="hljs-variable">.len</span>()]; <br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s3 content: [%s]&quot;</span>, s3);<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># string_builtin_function process block started</span><br><span class="hljs-comment"># s2 = 2015</span><br><span class="hljs-comment"># s3 content: [                               ]</span><br><span class="hljs-comment"># s3 content: [RockerIC is established in 2015]</span><br></code></pre></div></td></tr></table></figure><p>结论：</p><ul><li>整形转字符串：<code>itoa</code></li><li>字符串拼接的时候一定要用{}预留足够的位宽：<code>s3 = &#123;s1.len()+s2.len()&#123;&quot; &quot;&#125;&#125;;</code></li></ul><p>补充：</p><ul><li><p>使用自己拼接完成字符串复制</p><ul><li>```<br>  for(int i=0; i&lt;s1.len()+s2.len(); i++) begin<div class="hljs code-wrapper"><pre><code>s3[i] = i &lt; s1.len() ? &#123;s3,s1[i]&#125; : &#123;s3,s2[i-s1.len()]&#125;; </code></pre></div>  end<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><br>## <span class="hljs-number">2.3</span> interface_type<br><br>### 导入<br><br>程序结构<br><br>+ 一个结构体<br>+ 一个函数<br>+ <span class="hljs-keyword">module</span>里<br>  + 定义一个interface<br>  + 对interface例化<br>  + line-<span class="hljs-number">50</span>对接口数据进行修改<br><br>需要理解：<br><br>+ 接口的定义与例化<br>+ 接口内部定义的方法在接口外或接口内调用<br>+ 怎么准备transaction并进行驱动和监测<br><br>```verilog<br><br><span class="hljs-comment">// TODO-1 understand how the interface is defined and instantied</span><br><span class="hljs-comment">// TODO-2 check how to define methods inside interface and call them internally or externally</span><br><span class="hljs-comment">// TODO-3 understand how to prepare transactions, drive them and monitor them</span><br><span class="hljs-keyword">module</span> interface_type;<br>  typedef <span class="hljs-keyword">struct</span> &#123;<br>    bit<span class="hljs-literal">[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]</span> addr;<br>    bit<span class="hljs-literal">[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]</span> data;<br>    bit write;<br>    <span class="hljs-built_in">int</span> id;<br>  &#125; trans_t;<br><br>  <span class="hljs-comment">// struct print utility function</span><br>  <span class="hljs-keyword">function</span> void trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>, <span class="hljs-params">string</span> <span class="hljs-params">name</span> = <span class="hljs-string">&quot;trans&quot;</span>)</span>;<br>    <span class="hljs-built_in">string</span> s;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s struct content is as below \n&quot;</span>, <span class="hljs-params">name</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\taddr  = &#x27;h%2x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">addr</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\tdata  = &#x27;h%8x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">data</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\twrite = &#x27;b%0b \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">write</span>)</span>;<br>    s  = <span class="hljs-constructor">$sformatf(<span class="hljs-string">&quot;%s\tid    = &#x27;h%8x \n&quot;</span>, <span class="hljs-params">s</span>, <span class="hljs-params">t</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-constructor">$display(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-params">s</span>)</span>;<br>  endfunction<br><br>  interface intf1;<br>    logic <span class="hljs-literal">[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]</span> addr;<br>    logic <span class="hljs-literal">[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]</span> data;<br>    logic write;<br>    <span class="hljs-built_in">int</span> id;<br><br>    <span class="hljs-comment">// transaction drive task</span><br>    task drive<span class="hljs-constructor">_trans(<span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>)</span>;<br>      addr  &lt;= t.addr ;<br>      data  &lt;= t.data ;<br>      write &lt;= t.write;<br>      id    &lt;= t.id   ;<br>    endtask<br><br>    <span class="hljs-comment">// transaction monitor task</span><br>    task mon<span class="hljs-constructor">_trans(<span class="hljs-params">output</span> <span class="hljs-params">trans_t</span> <span class="hljs-params">t</span>)</span>;<br>      t.addr  = addr ;<br>      t.data  = data ;<br>      t.write = write;<br>      t.id    = id   ;<br>    endtask<br>  endinterface<br><br>  <span class="hljs-comment">// interface instantiation</span><br>  intf1 if1<span class="hljs-literal">()</span>;<br><br>  initial <span class="hljs-keyword">begin</span><br>    trans_t trans_in<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>, trans_mon<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>;<br>    <span class="hljs-comment">// stimulus preparation</span><br>    trans_in = <span class="hljs-character">&#x27;&#123;&#x27;</span>&#123;&#x27;h10, &#x27;h1122_3344, &#x27;b1, &#x27;h1000&#125;<br>                ,<span class="hljs-character">&#x27;&#123;&#x27;</span>h14, &#x27;h5566_7788, &#x27;b0, &#x27;h1001&#125;<br>                ,<span class="hljs-character">&#x27;&#123;&#x27;</span>h18, &#x27;h99AA_BBCC, &#x27;b1, &#x27;h1002&#125;<br>                &#125;;<br>    foreach(trans_in<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>;<br>      <span class="hljs-comment">// stimulus drive</span><br>      if1.drive<span class="hljs-constructor">_trans(<span class="hljs-params">trans_in</span>[<span class="hljs-params">i</span>])</span>;<br>      trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_in</span>[<span class="hljs-params">i</span>], $<span class="hljs-params">sformatf</span>(<span class="hljs-string">&quot;trans_in[%0d]&quot;</span>,<span class="hljs-params">i</span>)</span>);<br>      #<span class="hljs-number">10</span>;<br>      <span class="hljs-comment">// stimulus monitor</span><br>      if1.mon<span class="hljs-constructor">_trans(<span class="hljs-params">trans_mon</span>[<span class="hljs-params">i</span>])</span>;<br>      trans<span class="hljs-constructor">_print(<span class="hljs-params">trans_mon</span>[<span class="hljs-params">i</span>], $<span class="hljs-params">sformatf</span>(<span class="hljs-string">&quot;trans_mon[%0d]&quot;</span>,<span class="hljs-params">i</span>)</span>);<br><br>      <span class="hljs-comment">// transaction comparison</span><br>      <span class="hljs-keyword">if</span>(trans_in<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> === </span>trans_mon<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>        <span class="hljs-constructor">$display(<span class="hljs-string">&quot;trans_in[%0d] === trans_mon[%0d]&quot;</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-constructor">$error(<span class="hljs-string">&quot;trans_in[%0d] !== trans_mon[%0d]&quot;</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>endmodule<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>提示：</p><ul><li>接口内有时间概念</li><li>接口与struct放在module外面仿真时才能看见，而且这种方式<strong>更常见</strong><ul><li>接口中不能在类里面或包里面定义，因为他是软件的概念</li></ul></li><li>接口内部定义的函数与module里面定义的是一样的，换句话module里做一件事在interface也都是可以做</li></ul><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">run<br><span class="hljs-comment"># trans_in[0] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h10 </span><br><span class="hljs-comment"># data  = &#x27;h11223344 </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001000 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[0] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h10 </span><br><span class="hljs-comment"># data  = &#x27;h11223344 </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001000 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[0] === trans_mon[0]</span><br><span class="hljs-comment"># trans_in[1] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h14 </span><br><span class="hljs-comment"># data  = &#x27;h55667788 </span><br><span class="hljs-comment"># write = &#x27;b0 </span><br><span class="hljs-comment"># id    = &#x27;h00001001 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[1] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h14 </span><br><span class="hljs-comment"># data  = &#x27;h55667788 </span><br><span class="hljs-comment"># write = &#x27;b0 </span><br><span class="hljs-comment"># id    = &#x27;h00001001 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[1] === trans_mon[1]</span><br><span class="hljs-comment"># trans_in[2] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h18 </span><br><span class="hljs-comment"># data  = &#x27;h99aabbcc </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001002 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_mon[2] struct content is as below </span><br><span class="hljs-comment"># addr  = &#x27;h18 </span><br><span class="hljs-comment"># data  = &#x27;h99aabbcc </span><br><span class="hljs-comment"># write = &#x27;b1 </span><br><span class="hljs-comment"># id    = &#x27;h00001002 </span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># trans_in[2] === trans_mon[2]</span><br></code></pre></div></td></tr></table></figure><h1 id="Questasim-in-Linux"><a href="#Questasim-in-Linux" class="headerlink" title="Questasim in Linux"></a>Questasim in Linux</h1><p>使用linux上10.7版本的Questasim对仿真强制优化，从而看不见模块内部变量，无法进行仿真时修改</p><p>解决方法：</p><ul><li><code>vsim -voptargs=+acc work.xxx</code><ul><li>work.xxx xxx是仿真的文件名</li><li>-voptargs：vsim optimision arguments =+ access<ul><li>access：表示当前所有信号都可看到</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶3：组件家族（如何例化部分较为重要）</title>
    <link href="/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B63%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%AE%B6%E6%97%8F/"/>
    <url>/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B63%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p><strong>注意，本文内大部分组件介绍分为两节：</strong>第一节主要介绍该组件，第二节介绍该组件的定义示例</p><h1 id="0-组件家族"><a href="#0-组件家族" class="headerlink" title="0 组件家族"></a>0 组件家族</h1><h2 id="0-0-回顾"><a href="#0-0-回顾" class="headerlink" title="0.0 回顾"></a>0.0 回顾</h2><h3 id="上节课内容"><a href="#上节课内容" class="headerlink" title="上节课内容"></a>上节课内容</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124104754455.png" alt="image-20211124104754455"></p><p>UVM实验一到实验二的代码会突然增加，实验二会看到如何把SV中的组件过度到UVM的组件的，过度比较简单的组件</p><h3 id="SV验证环境回顾"><a href="#SV验证环境回顾" class="headerlink" title="SV验证环境回顾"></a>SV验证环境回顾</h3><p>SV实验四、实验五的时候</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105111186.png" alt="image-20211124105111186"></p><p>没有体现出各个agent的generator，</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105238593.png" alt="image-20211124105238593"></p><h2 id="0-1-概述"><a href="#0-1-概述" class="headerlink" title="0.1 概述"></a>0.1 概述</h2><p><strong>前言</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105324168.png" alt="image-20211124105324168"></p><p>为什么要把generator拆分成sequence(产生)和sequencer(发送)，入门进阶4会见讲</p><hr><p><strong>三个核心组件：</strong>stimulator、monitor、checker</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124105518697.png" alt="image-20211124105518697"></p><ul><li>uvm_agent, uvm_env, uvm_test：构成整个环境的层次结构</li><li>uvm_driver, uvm_random_stimulus, uvm_sequencer_base, uvm_sequencer：发送激励</li><li>uvm_monitor：监测激励</li><li>uvm_scoreboard, uvm_in_order_comparator, uvm_algorithm_comparator：数据比较</li><li>uvm_reg_predictor：UVM专门的，寄存器包，构建寄存器模型的时候（第五周会谈到）</li></ul><hr><p><strong>组件都有phase机制</strong>，九大phase共同完成环境的构建，并由uvm_root顶层控制（在后台运行，core_servicer）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124110131847.png" alt="image-20211124110131847"></p><h1 id="1-uvm-driver"><a href="#1-uvm-driver" class="headerlink" title="1 uvm_driver"></a>1 uvm_driver</h1><ul><li>学习思路：基于component又添加了什么成员方法</li><li>更具体的学习在第四周，这里简单了解</li></ul><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="大体功能"><a href="#大体功能" class="headerlink" title="大体功能"></a>大体功能</h3><p>uvm_driver与sv_driver类似的都要获取trans，sv的stimulator是从generator获取trans，uvm_driver从sequencer获取</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124142246033.png" alt="image-20211124142246033"></p><h3 id="类声明形式"><a href="#类声明形式" class="headerlink" title="类声明形式"></a>类声明形式</h3><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">uvm_driver</span> <span class="hljs-title">#</span>(<span class="hljs-params">type <span class="hljs-type">REQ</span>=uvm_sequence_item, type <span class="hljs-type">RSP</span>=<span class="hljs-type">REQ</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">uvm_component</span></span>;<br><span class="hljs-comment">//REQ参数：默认情况下为uvm_sequence_item</span><br><span class="hljs-comment">//RSP参数和REQ在默认情况下一样</span><br></code></pre></div></td></tr></table></figure><p>你不能直接使用uvm_driver，所有的dirver你必须自己去定义，然后继承于uvm_driver</p><h3 id="与component比较"><a href="#与component比较" class="headerlink" title="与component比较"></a>与component比较</h3><p>uvm_driver在uvm_component基础上<strong>没有扩展新的函数</strong>，而有一些新的通信端口和变量：</p><figure class="highlight leaf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs leaf">uvm_seq_item_pull_port <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">REQ</span>, <span class="hljs-variable">RSP</span>)</span></span> seq_item_port;//通信端口1<br>uvm_analysis_port <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">RSP</span>)</span></span> rsq_port;//通信端口2<br>REQ req;//变量1<br>RSP rsp;//变量2<br></code></pre></div></td></tr></table></figure><h3 id="端口的连接（第四周）"><a href="#端口的连接（第四周）" class="headerlink" title="端口的连接（第四周）"></a>端口的连接（第四周）</h3><p>driver类与sequencer类之间的通信时未来获取新的事务对象，这一操作时通过pull方式（即端口的连接）实现的</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>两种端口连接的方法<br>driver.seq_item_port.connect(sequencer.seq_item_export);<span class="hljs-regexp">//</span>req,rsp双向都可以（rsp的方式第四周讲）<br>driver.rsp_port.connect(sequencer.rsp_export);<span class="hljs-regexp">//</span>返回rsp<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124151813694.png" alt="image-20211124151813694"></p><h2 id="1-2-示例代码：如何定义一个driver"><a href="#1-2-示例代码：如何定义一个driver" class="headerlink" title="1.2 示例代码：如何定义一个driver"></a>1.2 示例代码：如何定义一个driver</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124151949354.png" alt="image-20211124151949354"></p><p><strong>经典步骤</strong>：</p><ol><li>extends</li><li>注册</li><li>new函数</li></ol><p><strong>虚接口</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">virtual</span> chip_if vif;<span class="hljs-comment">//接口指针，用来把激励发送到接口上</span><br></code></pre></div></td></tr></table></figure><p><strong>phase</strong></p><p>我们不一定全部写九大phase，只有在哦们真正要用的时候定义</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">extern task run<span class="hljs-constructor">_phase(<span class="hljs-params">uvm_phase</span> <span class="hljs-params">phase</span>)</span>;<span class="hljs-comment">//参考c++，在外部通过dut_driver::run_phase定义</span><br></code></pre></div></td></tr></table></figure><p>extern补充：.sv和.svh</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124153841240.png" alt="image-20211124153841240"></p><h1 id="2-uvm-monitor"><a href="#2-uvm-monitor" class="headerlink" title="2 uvm_monitor"></a>2 uvm_monitor</h1><h2 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124153914184.png" alt="image-20211124153914184"></p><p>我们定义的monitor完全继承于uvm_monitor，但也要老老实实的继承uvm_monitor</p><p><strong>PASSIVE模式：</strong>我不做任何主动修改内部设计的信号，不和激励一样。即要求我们的monitor永远只做监测</p><h2 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124154308328.png" alt="image-20211124154308328"></p><p><strong>虚接口</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">virtual</span> serial_if.monitor mi;<span class="hljs-comment">//使用vi中的一个modport</span><br></code></pre></div></td></tr></table></figure><h3 id="run-phase"><a href="#run-phase" class="headerlink" title="run_phase"></a>run_phase</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124154538786.png" alt="image-20211124154538786"></p><p><strong>执行步骤</strong></p><ul><li><p>我们要监测一个tr</p></li><li><p>首先我们要等待interface上一个信号<code>wait(mi.rts);</code></p></li><li><p>又等待一个下降沿</p></li><li>再等待一个时刻</li><li>接下来按照特定时刻<code>#(bit_period)</code>对数据进行监测</li><li>for之后检查协议</li><li>最后put</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124155629037.png" alt="image-20211124155629037"></p><h1 id="3-uvm-sequencer"><a href="#3-uvm-sequencer" class="headerlink" title="3 uvm_sequencer"></a>3 uvm_sequencer</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>my_sequencer所有组件功能都在父类uvm_sequencer，定义起来最简单</strong></p><p>sequencer就像一个管道一样，本身不产生激励，激励从sequence来的，然后激励传递给了driver</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124155807937.png" alt="image-20211124155807937"></p><hr><p>为什么不讲uvm_sequencer_base, uvm_sequencer_param_base<REQ,RSP> ,uvm_report_object类：</p><ul><li>因为它们都是中间类，中间类添加了单一职责，但它们在uvm继承上不是终点，不是直接面向用户的</li><li>如uvm_report_object在uvm_object基础上添加了report机制，而component又在uvm_report_object基础上添加了phase机制和override机制</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124160942941.png" alt="image-20211124160942941"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161005246.png" alt="image-20211124161005246"></p><p>第四周讲，sequencer没有那么简单，有路由器的作用</p><p>路由器：我们有很多很多sequence1…n，都传送到sequencer，再交给drv；因此需要sequencer有arbiter仲裁作用；同时接收信号传送回哪个sequence</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161226221.png" alt="image-20211124161226221"></p><hr><p>为什么sequence是obj，sequencer是component：</p><ul><li>sequence是动态产生的用完可以丢掉</li></ul><h2 id="3-2-示例代码：sequencer是我们所有组件定义起来最最简单的"><a href="#3-2-示例代码：sequencer是我们所有组件定义起来最最简单的" class="headerlink" title="3.2 示例代码：sequencer是我们所有组件定义起来最最简单的"></a>3.2 示例代码：sequencer是我们所有组件定义起来最最简单的</h2><p>my_sequencer所有组件功能都在父类uvm_sequencer</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161529897.png" alt="image-20211124161529897"></p><h2 id="4-uvm-agent（重要参考）"><a href="#4-uvm-agent（重要参考）" class="headerlink" title="4 uvm_agent（重要参考）"></a>4 uvm_agent（重要参考）</h2><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>简介与功能：agent就是一个标准的验证环境<strong>基本单位</strong>，包括了monitor，driver和sequencer</p><p>额外成员：见5.2</p><p>内部：具体实现了三个组建的例化(build)与连接(connect)</p><p>同时为了复用有时候只包括monitor不需要例化driver与sequencer</p><ul><li>uvm_active_passive_enum is_active为agent内一个成员<ul><li>is_active = UVM_ACTIVE时，uvm为ACTIVE态 agent需要发送激励</li><li>is_active = UVM_PASSIVE时，uvm为PASSIVE态 agent只做监测</li><li>is_active由谁控制<ul><li>由更高一层的环境控制，通过config_db来做</li></ul></li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124161740460.png" alt="image-20211124161740460"></p><h3 id="4-1-2-master与slave的概念"><a href="#4-1-2-master与slave的概念" class="headerlink" title="4.1.2 master与slave的概念"></a>4.1.2 master与slave的概念</h3><ul><li><p>master agent：</p><ul><li><p>register agent</p></li><li><p>channel agent</p></li></ul></li><li><p>slave agent：</p><ul><li>formatter agent，被动的做相应，被动发起grand信号，</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124164434848.png" alt="image-20211124164434848"></p><h2 id="4-2-示例代码"><a href="#4-2-示例代码" class="headerlink" title="4.2 示例代码"></a>4.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124164836919.png" alt="image-20211124164836919"></p><p><strong>成员</strong></p><ul><li>sequencer</li><li>driver</li><li>monitor</li><li>vif</li><li>is_active</li></ul><p><strong>phase</strong></p><ul><li>build</li><li>connect</li></ul><h3 id="4-2-2-phase"><a href="#4-2-2-phase" class="headerlink" title="4.2.2 phase"></a>4.2.2 phase</h3><p><strong>build_phase</strong></p><ul><li>创建组件/其他实例</li><li>根据is_active判断是否例化seqr与driver<ul><li>此处省略了一个从顶层(is_active)::get()的方法</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165025458.png" alt="image-20211124165025458"></p><p><strong>connect_phase</strong></p><ul><li>driver和sequencer之间做连接</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165048530.png" alt="image-20211124165048530"></p><h1 id="5-uvm-scoreboard"><a href="#5-uvm-scoreboard" class="headerlink" title="5 uvm_scoreboard"></a>5 uvm_scoreboard</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>功能：进行数据比较和报告，与SV checker类似；会接受来自多个monitor的监测数据，继而进行对比和报告</p><ul><li>scoreboard内部是否需要例化一些reference model?<ul><li>取决于实际情况，如果DUT复杂则需要自己写reference model且继承于uvm_component从而参与到组件构建过程中</li></ul></li></ul><p>额外成员：没有添加额外的成员变量和方法，与monitor类似，直接自定义一个类继承就行，特殊情况需要例化一些reference model</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124165551344.png" alt="image-20211124165551344"></p><h3 id="5-1-2-自带的数据比较方法"><a href="#5-1-2-自带的数据比较方法" class="headerlink" title="5.1.2 自带的数据比较方法"></a>5.1.2 自带的数据比较方法</h3><p>SV中推荐自己实现数据比较方法，uvm自带两个数据比较方法但了解即可实际工程中很少去用，因为他们的工作非常有限大部分需要自己实现</p><figure class="highlight leaf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs leaf">uvm_in_order_comparator <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">type</span> <span class="hljs-variable">T</span>)</span></span>//一个组件，往往放在sb<br>uvm_algorithm_comparator <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">type</span> <span class="hljs-variable">BEFORE</span>, <span class="hljs-variable">type</span> <span class="hljs-variable">AFTER</span>, <span class="hljs-variable">type</span> <span class="hljs-variable">TRANSFORMER</span>)</span></span><br></code></pre></div></td></tr></table></figure><ul><li>uvm_in_order_comparator（数据类型，完整性，顺序一样的时候比较）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172218854.png" alt="image-20211124172218854"></p><p>输入输出数据自动作比较</p><p>不推荐的原因是：你往往在数据比较的时候还有其他的逻辑</p><ul><li>uvm_algorithm_comparator（不同类型比较）</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172351965.png" alt="image-20211124172351965"></p><p>before，after两种类型</p><p>TRANSFORMER为bef转换成after的转换类</p><p>不适合MDCF比较</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124171724994.png" alt="image-20211124171724994"></p><h2 id="5-2-示例代码：如何定义一个sb-typedef在create时的作用-重要"><a href="#5-2-示例代码：如何定义一个sb-typedef在create时的作用-重要" class="headerlink" title="5.2 示例代码：如何定义一个sb|typedef在create时的作用(重要)"></a>5.2 示例代码：如何定义一个sb|typedef在create时的作用(重要)</h2><ul><li>在sb中通常会声明TLM端口供monitor传输数据（下周讲端口连接），这些端口(in_export,out_export)最终和monitor相连</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172717681.png" alt="image-20211124172717681"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124172727238.png" alt="image-20211124172727238"></p><p><strong>创建一个comparator</strong></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//写法1:使用typedef后的类型进行create</span><br>tyepdef uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)</span> comp_t;<br>comp_t m_comp;<br>...<br><span class="hljs-keyword">function</span> build_phase();<br>...<br>    m_comp = comp_t::type_id::create(<span class="hljs-string">&quot;m_comp&quot;</span>,<span class="hljs-keyword">this</span>);<br>    ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//写法2:带参数的声明，与带参数的create</span><br>uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)</span> m_comp;<br>...<br><span class="hljs-keyword">function</span> build_phase();<br>...<br>    m_comp = uvm_in_order_comparator <span class="hljs-variable">#(bus_xact)::type_id::create(&quot;m_comp&quot;,this)</span>;<br>    ...<br><span class="hljs-keyword">endfunction</span><br></code></pre></div></td></tr></table></figure><p><strong>端口接入comparator</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124173759946.png" alt="image-20211124173759946"></p><h1 id="6-uvm-env"><a href="#6-uvm-env" class="headerlink" title="6 uvm_env"></a>6 uvm_env</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>uvm_env<strong>一种结构化的容器</strong></p><p>简介：与SVenv没有区别，就是做一个层次，从环境层次层次，uvm_env可能包含多个uvm_agent或其他component</p><p>不同的组件<strong>共同</strong>构成一个完整的验证环境，并且这个黄健在将来服用中可以作为子环境被进一步集成到更高的环境中。如下图的验证结构中，就定义了一个高层的环境，它里包含sub_env、agent、scoreboard</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124173845213.png" alt="一种验证结构"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124185258724.png" alt="sub_env可以作为复用"></p><p>解释：</p><ul><li>sub_env原来验证M1模块，现在M1被集成到M2大的模块中。此时sub_env可以通过被封装在top_env继续对M1进行验证，同时接口也对应相连；对M2的其他部分，它们再与top_env中新添加的agent相连</li><li>对于sb：top_env的scoreboard是M2的，而M1对应的sb在原来的sub_env里面</li><li>对于顶层：只能由一个env</li></ul><h3 id="6-1-2-uvm-env的角色，以及与agent对比"><a href="#6-1-2-uvm-env的角色，以及与agent对比" class="headerlink" title="6.1.2 uvm_env的角色，以及与agent对比"></a>6.1.2 uvm_env的角色，以及与agent对比</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124190748961.png" alt="image-20211124190748961"></p><p>env可以嵌套而，agent一定不要去嵌套agent</p><h2 id="6-2-示例代码"><a href="#6-2-示例代码" class="headerlink" title="6.2 示例代码"></a>6.2 示例代码</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124191859795-16377527411321.png" alt="image-20211124191859795"></p><h1 id="7-uvm-test"><a href="#7-uvm-test" class="headerlink" title="7 uvm_test"></a>7 uvm_test</h1><h2 id="7-1-概论"><a href="#7-1-概论" class="headerlink" title="7.1 概论"></a>7.1 概论</h2><p>与SV test几乎没有差别</p><p>sv中test：sv测试以test为单位进行。test规定了测试场景，即规定了发送什么样的激励</p><p>uvm的test：也规定了发送什么样的激励，只不过激励是sequence产生的</p><p>uvm的结构：例化唯一的env顶层，并决定结构和连接关系</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124192241725.png" alt="image-20211124192241725"></p><h2 id="7-2-示例代码"><a href="#7-2-示例代码" class="headerlink" title="7.2 示例代码"></a>7.2 示例代码</h2><p>这里两个env只是做演示，工程里面应该把env1,env2与a1封装到一个top_env中</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211124193620637.png" alt="image-20211124193620637"></p><p>之后就是sv实验5的组件过度到uvm实验2，两个实验验证结构一致</p><p>验证结构到uvm实验3才会进行变化</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶4：结构_顶层方案_环境元素</title>
    <link href="/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B64%EF%BC%9A%E7%BB%93%E6%9E%84_%E9%A1%B6%E5%B1%82%E6%96%B9%E6%A1%88_%E7%8E%AF%E5%A2%83%E5%85%83%E7%B4%A0/"/>
    <url>/202111241036/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B64%EF%BC%9A%E7%BB%93%E6%9E%84_%E9%A1%B6%E5%B1%82%E6%96%B9%E6%A1%88_%E7%8E%AF%E5%A2%83%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><p>本节目录：</p><ul><li><p>UVM结构回顾</p></li><li><p>MCDF顶层验证方案</p></li><li><p>构建验证环境的内径</p></li></ul><h1 id="1-UVM结构回顾"><a href="#1-UVM结构回顾" class="headerlink" title="1 UVM结构回顾"></a>1 UVM结构回顾</h1><h2 id="1-1-uvm-top：（系统）"><a href="#1-1-uvm-top：（系统）" class="headerlink" title="1.1 uvm_top：（系统）"></a>1.1 uvm_top：（系统）</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">const</span> uvm_root uvm_top = uvm_root::get()<br></code></pre></div></td></tr></table></figure><p>uvm_top(uvm_root)，一个隐形的顶层，并不继承于object/component（因为要创建这些）</p><ul><li>uvm_top 是uvm_root类的<strong>唯一</strong>实例，即是UVM为界的“一” <ul><li>它由UVM创建和管理</li><li>它所在的域是uvm_pkg</li></ul></li><li>uvm_top是<strong>所有test组件的顶层</strong>，即永远是我们环境的最顶层<ul><li>所有验证环境中的组件在创建时都需要指明它的父一级</li><li>如果某些组件在创建时指定父一级的参数为“null”，那么它将直接隶属于uvm_top。不过这么做存在风险，也并不推荐</li></ul></li><li><strong>（主要作用）</strong>uvm_top提供一系列的方法来<strong>控制仿真</strong>，例如：九个phase机制、objection防止仿真退出机制（在run_phase中设置举手（尽量有且只有一个，防止退出避免额外协调，详情查看进阶2）等</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126150832349.png" alt="金字塔结构"></p><h2 id="1-2-uvm-test：-自定义"><a href="#1-2-uvm-test：-自定义" class="headerlink" title="1.2 uvm_test：(自定义)"></a>1.2 uvm_test：(自定义)</h2><ul><li><p>“test”类是用户<strong>自定义类</strong>的顶层结构</p></li><li><p><strong>所有的test类都应该继承于uvm_tes3</strong>，否则uvm_top将不识别，“后果很严重”一一无法启动test</p></li><li><strong>（主要作用）</strong>test的<strong>目标</strong>包括：<ul><li>提供不同的<strong>配置</strong>，包括环境结构配置、测试模式配置等，然后再创建验证环境</li><li>例化测试<strong>序列</strong>，并且挂载(attach)到目标sequencer,使其命令driver发送激励</li><li>补充：所有变量都要放在test里面，方便管理与维护</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126152704144.png" alt="image-20211126152704144"></p><p>为什么不放到env里面：test可以划分出静态与动态部分</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126153104909.png" alt="image-20211126153104909"></p><h2 id="1-3-构建验证环境的主要组件对比"><a href="#1-3-构建验证环境的主要组件对比" class="headerlink" title="1.3 构建验证环境的主要组件对比"></a>1.3 构建验证环境的主要组件对比</h2><p>主要由三类UVM构建模块（基类）共同组成验证环境</p><ul><li>uvm_component<ul><li>继承于uvm_report_object （进一步继承于uvm_object）,提供消息方法</li><li>所有的验证环境组件均继承于uvm_component</li><li>管理验证环境的层次</li></ul></li><li>uvm_env<ul><li>继承于 uvm_component</li><li><strong>没有额外的功能</strong>：如果拿到别人环境看到env，尽量少去动env而是去动test</li><li>用来为验证环境结构提供一个容器（container）</li></ul></li><li>uvm_test<ul><li>继承于 uvm_component</li><li><strong>没有额外的功能</strong></li><li>用来提供对uvm_env的<strong>额外配置以及挂载激励</strong></li></ul></li></ul><h2 id="1-4-uvm-component：是一个虚类不能例化，可以继承"><a href="#1-4-uvm-component：是一个虚类不能例化，可以继承" class="headerlink" title="1.4 uvm_component：是一个虚类不能例化，可以继承"></a>1.4 uvm_component：是一个虚类不能例化，可以继承</h2><h3 id="1-4-1-介绍"><a href="#1-4-1-介绍" class="headerlink" title="1.4.1 介绍"></a>1.4.1 介绍</h3><p>一个虚类(virtual class),所有环境组件均继承于该类。所有继承于该类的子类，我们称之为组件或者环境组件</p><p>该类提供已下接口或者API：</p><ul><li>结构， 例如get_full_name(), get_parent(), get_num_children()</li><li>阶段(phase)机制，例如build_phase(), connect_phase(), run_phase()</li><li>配置(configuration)机制，例如print_config(), print_override_info()</li><li>报告(report)机制，例如report_hook(), set_report_verbosity_level_hier ()</li><li>事务记录(transaction recording),例如record，用的比较少模块三会讲</li><li>工厂(factory)机制,例如set_inst_override(), set_type_override()</li></ul><p>由于环境中所有的组件都继承于uvm_component，因此也就可以使得UVM提供统一的方式来管理层次结构和组件方法</p><h3 id="1-4-2-构造函数：有关层次的说明"><a href="#1-4-2-构造函数：有关层次的说明" class="headerlink" title="1.4.2 构造函数：有关层次的说明"></a>1.4.2 构造函数：有关层次的说明</h3><p>对于组件的构建函数，固定形式为：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br></code></pre></div></td></tr></table></figure><ul><li>string name：用来声明当前例化组件的名称，用来自动和它所在的父一级层次组合为组件的整个层次名称，可以 <strong>get_full_name()</strong>方法获取</li><li>uvm_component parent：用来指示所例化的父一级句柄，通常用“this”来指代，即例化在当前的父一级组件中</li><li>注意与uvm_object的构建函数new(string name)进行区分，由于uvm_object<strong>不参与组件的层次构建</strong>，因此它只有一个形参， 而没有 uvm_component parent</li><li>凡是继承于uvm_component的组件，也应该保持同样的形式参 数列表</li></ul><h1 id="2-MCDF顶层验证方案"><a href="#2-MCDF顶层验证方案" class="headerlink" title="2 MCDF顶层验证方案"></a>2 MCDF顶层验证方案</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1  概述"></a>2.1  概述</h2><p>在SV模块中，四位verifier需要给MCDF (Multiple Channel Data Formatter)搭建验证环境，进而利用这些模块验证组件在顶层可以完成集成复用</p><p>MCDF的主要功能是将输入端的三个通道数据，通过数据整形和过滤，最终输出</p><p>将MCD结构分为四个模块：</p><ul><li>上行数据的通道从端(Channel Slave)</li><li>仲裁器(Arbiter)</li><li>整形器(Formatter)</li><li>控制寄存器(Control Registers)</li></ul><h2 id="2-2-子模块环境搭建方案"><a href="#2-2-子模块环境搭建方案" class="headerlink" title="2.2 子模块环境搭建方案"></a>2.2 子模块环境搭建方案</h2><h3 id="2-2-1-reg-env：对于寄存器的验证环境"><a href="#2-2-1-reg-env：对于寄存器的验证环境" class="headerlink" title="2.2.1 reg_env：对于寄存器的验证环境"></a>2.2.1 reg_env：对于寄存器的验证环境</h3><p>对于寄存器模块的验证环境reg_env,它的组织包括：</p><ul><li>reg_master_agent,提供寄存器接口驱动信号</li><li>reg_slave_agent,提供寄存器接口反馈信号</li><li>scoreboard,分另从reg_master_agent内的monitor和reg_slave_agent内 的monitor获取监测数据，并且进行数据比对</li></ul><hr><ul><li>reg_master_agent：对reg配置包括addr，data_w/r，cmd</li><li>reg_slave_agent：<ul><li>驱动channel_fifo_avaible</li><li>其他信号做监测</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126155046191.png" alt="image-20211126155046191"></p><h3 id="2-2-2-chnl-env：对channel"><a href="#2-2-2-chnl-env：对channel" class="headerlink" title="2.2.2 chnl_env：对channel"></a>2.2.2 chnl_env：对channel</h3><p>下图是验证一个channel</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126221535193.png" alt="image-20211126221535193"></p><p>数据通道从端的验证环境chnLenv的组件包括：</p><ul><li>chnl_master_agent,提供上行的激励数据</li><li>chnLslave.agent,提供用来模拟arbiter仲裁信号，并且接收流出数<br>据</li><li>reg_cfg_agent,提供用来模拟寄存器的配置信号，并且接收内置<br>FIFO的余量信号</li><li>scoreboard,分另ll从chnl_master_agent、chnl_slave_agent和reg_cfg_agent的monitor接受监测激据，并且对channel的流入流出 数据进行比对</li></ul><h3 id="2-3-arb-env"><a href="#2-3-arb-env" class="headerlink" title="2.3 arb_env"></a>2.3 arb_env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126222105799.png" alt="image-20211126222105799"></p><p>仲裁器的验证环境arb_env的组件包括：</p><ul><li>模拟channel输出接口的arbiter_master_agent的三个实例，用来对 arbiter提供并行数据输入，同时对arbiter反馈的仲裁信号做出响应</li><li>arbiter_slave_agent,用来接收arbiter的输出数据，模拟formatter 的行为，对arbiter的输出信号做出响应</li><li>reg_cfg_agent,提供用来模拟寄存器的配置信号，对三个channel 数据源分别做出不同的优先级配置</li><li>scoreboard,从三个arbiter_master_agent、arbiter_slave_agent 和reg_cfg_agent中的monitor获取监测数据，对arbiter的仲裁机制 做出预测，并且将输入输出数据按照预测的优先级做出比对</li></ul><h3 id="2-2-4-fmt-env"><a href="#2-2-4-fmt-env" class="headerlink" title="2.2.4 fmt_env"></a>2.2.4 fmt_env</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126222804346.png" alt="image-20211126222804346"></p><p>整形器的验证环境 fmt env 的组件包括：</p><ul><li>fmt_master_agent， 用来模拟arbiter的输出数据</li><li>fmt_slave_agent ，用来模拟MCDF的下行数据接收端</li><li>reg _cfg _agent ，用来模拟寄存器的配置信号，用来指定输出数据包的长</li><li>scoreboard ，从 fmt <em>master _agent 、 fmt_slave_agent 和 reg_cfg </em> agent 的 monitor 获取数据监测数据，通过数据包长度来预测输出的数据包，与formatter输出的数据包进行比对</li></ul><h2 id="2-3-环境集成方案"><a href="#2-3-环境集成方案" class="headerlink" title="2.3 环境集成方案"></a>2.3 环境集成方案</h2><p>两个方案没有谁好谁坏</p><h3 id="2-3-1-方案1"><a href="#2-3-1-方案1" class="headerlink" title="2.3.1 方案1"></a>2.3.1 方案1</h3><p>基本就是我们SV的环境，除了vitrual sequencer我们后期学</p><p>MCDF顶层验证环境复用了这些模块验证环境的组件：</p><ul><li>reg_master_agent</li><li>chnl_master_agent</li><li>fmt_slave_agent</li></ul><p>通过这三个激励组件可以有效生成新的激励序列，而将各个agent的 sequencer句柄合并在一处时，virtual sequencer的作用就体现出来了</p><p>我们可以通过这个中心化的序列分发管道，将各个agent的sequence也集中管理</p><p>MCDF的scoreboard提供了一个完整的数据通路覆盖方案，即从各个 agent的monitor数据监测端口将数据收集起来，同时建立MCDF的参 考模型，预测输出数据包，最终进行数据比对</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126223512492.png" alt="image-20211126223512492"></p><h4 id="集成代码"><a href="#集成代码" class="headerlink" title="集成代码"></a>集成代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211126223528514.png" alt="image-20211126223528514"></p><p> <img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095406294.png" alt="image-20211127095406294"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095443041.png" alt="image-20211127095443041"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127095837297.png" alt="image-20211127095837297"></p><p>sqr作用就是传递trans</p><p>virtual_sequencer拿着各个agent_sequencer句柄，相当于句柄的路由，进行中间的管理作用</p><h3 id="2-3-2-方案2"><a href="#2-3-2-方案2" class="headerlink" title="2.3.2 方案2"></a>2.3.2 方案2</h3><p>较为复杂一点，组件更多，多了cfg</p><ul><li><p>可以把例如：agent.slave配置成passive，agent.master配置成active</p></li><li><p>好处：</p><ul><li>子系统出问题agent.sb仍然可以工作</li><li>独立性好，别人的拿过来直接可以用，做之前进行cfg就可以</li><li>（可选）方案二大多数情况下还是需要一个顶层的sb检查，针对性检查（use case）</li></ul></li></ul><p>为什么arbiter也要放进来，因为可以单独检查arbiter</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127100007270.png" alt="image-20211127100007270"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127102738381.png" alt="image-20211127102738381"></p><h4 id="集成代码-1"><a href="#集成代码-1" class="headerlink" title="集成代码"></a>集成代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103114903.png" alt="image-20211127103114903"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103319241.png" alt="image-20211127103319241"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103357056.png" alt="image-20211127103357056"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127103456895.png" alt="image-20211127103456895"></p><h3 id="2-3-3-方案对比"><a href="#2-3-3-方案对比" class="headerlink" title="2.3.3 方案对比"></a>2.3.3 方案对比</h3><p>方案一与方案二相同的地方在于，顶层都需要新建 virtual sequencer 和 virtual sequence ，用来生成顶层的测试序列</p><p>而 virtual sequence也不是从零创建的，它本身也是利用原有模块环了有机的组合，最后协调生成了新的测试序列</p><p>从方案二可以看出， mcdf<em>env的子组件不再是uvm </em> agent类，而是各个模块的验证环境 uvm _ env 类</p><p>通过直接复用这些子环境，我们也间接复用了它们内部的 score board。在 build 阶段，我们需要将各个子环境中不需要再产生激励的 agent , 配置为 passive 模式，而默认情况 下这些 agent 均为 active 模式</p><p>这种复用方式使得我们无需再新建一个 MCDF scoreboard ，只需要确保 MCDF 的各个子模块均有 scoreboard 会检查功能，这样从整体上便可以覆盖完整的数据通路</p><hr><p>方案一中最大的额外投入在于需要新建一个scoreboard用来检查MCDF的整体功能</p><p>如果顶层设计没那么复杂，重新实现一个顶层scoreboard其复杂度还是可控的；但是如果将来的顶层环境更加复杂，那么复用底层的scoreboard就变得省时省力了</p><p>方案二的目的在于复用底层模块环境的scoreboard,减少顶层环境的额外成本。方案二不同于方案一的有下列几个地方：</p><ul><li>顶层环境的组件都直接复用了各个模块验证环境</li><li>顶层环境在集成模块验证环境时，需要将各个子模块中的agent配置为不同模式（ active或者passive） ,以此适应顶层场景</li><li>不再需要实现新的scoreboard,而是可以复用原有模块验证环境的scoreboard</li></ul><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>从上面框图和代码中观察到，UVM带来的环境复用，相比于之前SV验 证环境做到了下面的几个优势：</p><ul><li>各个模块的验证环境是独立封装的，对外不需要保留数据端口，因此便于环境 的进一步集成复用</li><li>UVM自身的phase机制，在顶层协调各个子环境时，无需考虑由于子环境 之间的例化顺序而导致的对象句柄引用悬空的问题</li><li>由于子环境的测试序列是相对独立的，这使得顶层在复用子环境测试序列而构 成virtual sequence时，不需要其它额外的迁移成本</li><li>UVM提供的config_db配置方式，使得整体环境的结构和运行模式都可以从树 状的config对象中获取，这也使得顶层环境可以在不同uvm_test进行集中管理配置</li></ul><hr><p>相比SV </p><p>数据接口：</p><ul><li><p>以前是用mailbox句柄</p></li><li><p>现在使用端口</p></li><li>为什么？<ul><li>使用mailbox会有跨层次问题</li></ul></li></ul><p>phase机制</p><p>子环境而是相对独立，具有sequence</p><p>config_db配置，使得结构和运行模式从树状config对象获取，对顶层环境再不同uvm_test进行集中管理</p><h1 id="3-构建验证环境的内径"><a href="#3-构建验证环境的内径" class="headerlink" title="3 构建验证环境的内径"></a>3 构建验证环境的内径</h1><h2 id="3-1-构建环境四要素"><a href="#3-1-构建环境四要素" class="headerlink" title="3.1 构建环境四要素"></a>3.1 构建环境四要素</h2><p>发送测试序列之前，首先需要创建一个结构化环境。将环境核心要素拆解开，分为四部分：</p><ul><li><p>单元组件的自闭性：完全的封装，不依赖其他组件，可以单独编译<strong>（非常重要）</strong></p></li><li><p>回归创建：type_id::create</p></li><li>通信都那口连接</li><li>顶层配置</li></ul><p>ps：在构建环境时，可从这四点查找是否缺少了某个组件</p><h2 id="3-2-四要素详细介绍"><a href="#3-2-四要素详细介绍" class="headerlink" title="3.2 四要素详细介绍"></a>3.2 四要素详细介绍</h2><h3 id="3-2-1-单元组件的自闭性"><a href="#3-2-1-单元组件的自闭性" class="headerlink" title="3.2.1 单元组件的自闭性"></a>3.2.1 单元组件的自闭性</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127110438497.png" alt="image-20211127110438497"></p><p>即以后你提供的env一定要独立</p><h3 id="3-2-2-回归创建"><a href="#3-2-2-回归创建" class="headerlink" title="3.2.2 回归创建"></a>3.2.2 回归创建</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127155259291.png" alt="image-20211127155259291"></p><p>SV：上一级的组件例化子一级的组件通过执行new()</p><p>UVM：通过build_phase</p><ul><li>保证了父级组件先于子级组件</li></ul><p>补充两种配置方式：</p><ul><li>config：build拿到后固化，即config只config一次</li><li>transaction：动态配置</li></ul><h3 id="3-2-3-通信端口连接"><a href="#3-2-3-通信端口连接" class="headerlink" title="3.2.3 通信端口连接"></a>3.2.3 通信端口连接</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127155944971.png" alt="image-20211127155944971"></p><h3 id="3-2-4-顶层配置（配置层次可参考本节叙述）"><a href="#3-2-4-顶层配置（配置层次可参考本节叙述）" class="headerlink" title="3.2.4 顶层配置（配置层次可参考本节叙述）"></a>3.2.4 顶层配置（配置层次可参考本节叙述）</h3><p><strong>顶层环境的变量部分</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160004104.png" alt="image-20211127160004104"></p><p>使用config_db字符串而不是直接用句柄</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160400298.png" alt="image-20211127160400298"></p><h4 id="如下放置到config-db数据库里面"><a href="#如下放置到config-db数据库里面" class="headerlink" title="如下放置到config_db数据库里面"></a>如下放置到config_db数据库里面</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160526167.png" alt="image-20211127160526167"></p><h4 id="子一级组件创建时拿出来"><a href="#子一级组件创建时拿出来" class="headerlink" title="子一级组件创建时拿出来"></a>子一级组件创建时拿出来</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160558859.png" alt="image-20211127160558859"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160728972.png" alt="image-20211127160728972"></p><h2 id="3-3-顶层配置结构"><a href="#3-3-顶层配置结构" class="headerlink" title="3.3 顶层配置结构"></a>3.3 顶层配置结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127160831321.png" alt="image-20211127160831321"></p><ul><li>rgm：寄存器模型</li><li>scbd</li><li>topcfg：传递rgm句柄，is_active，变量值等配置信息</li></ul><h2 id="3-4-环境元素分类"><a href="#3-4-环境元素分类" class="headerlink" title="3.4 环境元素分类"></a>3.4 环境元素分类</h2><p>uvm_test作为比uvm_env更高层次，将对test传递配置信息，包括构成环境的组件uvm_component在内环境元素可以分为以下部分：</p><ul><li>成员变量<ul><li>一般变量</li><li>结构变量</li><li>模式变量</li></ul></li><li>子组件<ul><li>固定组件</li><li>条件组件</li><li>引用组件</li></ul></li><li>子对象<ul><li>自生对象</li><li>克隆对象</li><li>引用对象</li></ul></li></ul><h2 id="3-5-环境元素详细介绍"><a href="#3-5-环境元素详细介绍" class="headerlink" title="3.5 环境元素详细介绍"></a>3.5 环境元素详细介绍</h2><h3 id="3-5-1-成员变量"><a href="#3-5-1-成员变量" class="headerlink" title="3.5.1 成员变量"></a>3.5.1 成员变量</h3><ul><li>一般变量：内部操作与外部访问</li><li>结构变量：内部子组件</li><li>模式变量：控制组件行为</li></ul><p>对u结构变量和模式变量使用int/enum进行定义</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163150402.png" alt="image-20211127163150402"></p><h3 id="3-5-2-子组件"><a href="#3-5-2-子组件" class="headerlink" title="3.5.2 子组件"></a>3.5.2 子组件</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163308958.png" alt="image-20211127163308958"></p><p>引用组件就是个句柄，有结构变量决定的组件叫结构组件</p><p>下图展示了谁是固定组件谁是引用组件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163340189.png" alt="image-20211127163340189"></p><h3 id="3-5-3-子对象"><a href="#3-5-3-子对象" class="headerlink" title="3.5.3 子对象"></a>3.5.3 子对象</h3><p>查看<strong>例如</strong>部分</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211127163509745.png" alt="image-20211127163509745"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门实验0</title>
    <link href="/202111212135/IC/uvm%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%AE%9E%E9%AA%8C0/"/>
    <url>/202111212135/IC/uvm%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%AE%9E%E9%AA%8C0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶2：核心基类_阶段_配置_消息机制</title>
    <link href="/202111181835/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B62%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%B1%BB_%E9%98%B6%E6%AE%B5_%E9%85%8D%E7%BD%AE_%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/202111181835/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B62%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%B1%BB_%E9%98%B6%E6%AE%B5_%E9%85%8D%E7%BD%AE_%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><h1 id="1-核心基类-uvm-object"><a href="#1-核心基类-uvm-object" class="headerlink" title="1 核心基类(uvm_object)"></a>1 核心基类(uvm_object)</h1><h2 id="1-1-核心基类指的就是uvm-object"><a href="#1-1-核心基类指的就是uvm-object" class="headerlink" title="1.1 核心基类指的就是uvm_object"></a>1.1 <strong>核心基类指的就是uvm_object</strong></h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119165852944.png" alt="image-20211119165852944"></p><ul><li><code>uvm_void</code>只是一个虚类(virtual class)，等待将来继承于他的子类去开垦</li><li>有两类<code>uvm_object</code>、<code>uvm_port_base</code>类继承于<code>uvm_void</code></li><li>uvm世界里面十大类八大类继承于<code>uvm_object</code></li><li><code>除了</code>uvm_port_base<IF>``类以外uvm里面的类都可以溯源到uvm_object类</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119170014086.png" alt="image-20211119170014086"></p><h2 id="1-2-uvm-object"><a href="#1-2-uvm-object" class="headerlink" title="1.2 uvm_object"></a>1.2 uvm_object</h2><p><strong>uvm_object核心方法</strong>：不用自己实现，uvm自动去实现</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">copy<span class="hljs-comment">;</span><br>clone<span class="hljs-comment">;</span><br>compare<span class="hljs-comment">;</span><br>print<br>pack/unpack<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119175234308.png" alt="image-20211119175234308"></p><p>uvm里面把sv的句柄拷贝和对象拷贝区分成了copy与clone，且同样需要src，dst object</p><h2 id="1-3-主要机制：域的自动化-field-automation"><a href="#1-3-主要机制：域的自动化-field-automation" class="headerlink" title="1.3 主要机制：域的自动化(field automation)"></a>1.3 主要机制：域的自动化(field automation)</h2><p><strong>域：</strong>UVM里任何的成员变量都可以称之为域(field)，在sv里面称之为属性property</p><p><strong>域的自动化：</strong>使得在注册时，声明之后可能会用到的对象拷贝、克隆、打印等操作的成员变量</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119175354669.png" alt="image-20211119175354669"></p><h3 id="1-3-2-代码"><a href="#1-3-2-代码" class="headerlink" title="1.3.2 代码"></a>1.3.2 代码</h3><p><strong>代码原文</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119200932044.png" alt="image-20211119200932044"></p><p><strong>上文代码解释</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201123177.png" alt="image-20211119201123177"></p><p>第一点：开始域自动化声明和结束声明</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl">`<span class="hljs-function"><span class="hljs-title">uvm_object_utils_begin</span>(<span class="hljs-variable">box</span>)</span><br>`<span class="hljs-function"><span class="hljs-title">uvm_object_utils_end</span>(<span class="hljs-variable">box</span>)</span><br></code></pre></div></td></tr></table></figure><hr><p>第二点：域的自动化声明方式：如下添加参与到自动化声明的变量（也是使用宏，<strong>提醒一下，宏是不用分号的</strong>）</p><p>宏函数参考表：P275页 表10.2</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_field_int(<span class="hljs-params">volume</span>, UVM_ALL_ON)</span><br>`uvm<span class="hljs-constructor">_field_enum(<span class="hljs-params">color_t</span>, <span class="hljs-params">color</span>, UVM_ALL_ON)</span><br>`uvm<span class="hljs-constructor">_field_string(<span class="hljs-params">name</span>, UVM_ALL_ON)</span><br></code></pre></div></td></tr></table></figure><hr><p>补充点：域自动化数据操作宏参数<code>UVM_ALL_ON</code>：是与之前数据变量对应的，数据操作的一个宏</p><p>数据操作宏参考表P276页 表10.3</p><p>对于小白来讲默认采取<code>UVM_ALL_ON</code>或<code>UVM_ALL_DEFAULT</code>就可以将所有数据操作(copy,compare,print,record,pack)都打开</p><h3 id="1-3-3-代码续"><a href="#1-3-3-代码续" class="headerlink" title="1.3.3 代码续"></a>1.3.3 代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201732071.png" alt="image-20211119201732071"></p><hr><p><strong>调用未定义的copy函数</strong></p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">b2.copy(b1)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119201852449.png" alt="image-20211119201852449"></p><p>b1的成员变量都拷贝到b2</p><p>SV的copy是自己实现的，uvm不需要</p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3 总结"></a>1.3.3 总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119202328296.png" alt="image-20211119202328296"></p><h2 id="1-4-核心方法之一：拷贝-copy-默认deepcopy-copy-do-copy"><a href="#1-4-核心方法之一：拷贝-copy-默认deepcopy-copy-do-copy" class="headerlink" title="1.4 核心方法之一：拷贝(copy)        默认deepcopy=copy()+do_copy()"></a>1.4 核心方法之一：拷贝(copy)        默认deepcopy=copy()+do_copy()</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119202538653.png" alt="image-20211119202538653"></p><ul><li>SV里面的copy先做对象的创建再做数据的copy —-&gt; UVM里面的clone</li><li>SV里面的数据copy拷贝 —&gt; UVM里面的copy拷贝即对象已经创建好就进行数据的拷贝</li><li>默认执行deepcopy即先执行copy()再调用回调函数do_copy()，do_copy()可在类里定义</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">_copy(<span class="hljs-params">uvm_object</span> <span class="hljs-params">obj</span>)</span>;<br></code></pre></div></td></tr></table></figure><p><strong>相同点都会对数据进行复制</strong></p><pre><code class=" mermaid">graph LRSV里面的copy先做对象的创建再做数据的copy ---&gt; UVM里面的cloneSV里面的数据copy拷贝 --&gt; UVM里面的copy拷贝即对象已经创建好就进行数据的拷贝</code></pre><h3 id="1-4-2-代码"><a href="#1-4-2-代码" class="headerlink" title="1.4.2 代码"></a>1.4.2 代码</h3><p><strong>定义ball类，在box类中对ball进行例化</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211119203055568.png" alt="image-20211119203055568"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120103356118.png" alt="image-20211120103356118"></p><ul><li>box类中的成员变量完全拷贝过去了</li><li>内部成员ball类b的成员变量没有完全拷贝<ul><li>原因：<ul><li>对于color_t 声明时使用<code>UVM_NOCOPY</code>不执行拷贝</li><li>对于diameter从10变成20，因为uvm的拷贝执行了do_copy</li></ul></li></ul></li></ul><h2 id="1-5-核心方法之一：比较-compare"><a href="#1-5-核心方法之一：比较-compare" class="headerlink" title="1.5 核心方法之一：比较(compare)"></a>1.5 核心方法之一：比较(compare)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120105837242.png" alt="image-20211120105837242"></p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">bit</span> compare (uvm_object rhs, uvm_comparer comparer=null);<br></code></pre></div></td></tr></table></figure><h3 id="1-5-2-例子"><a href="#1-5-2-例子" class="headerlink" title="1.5.2 例子"></a>1.5.2 例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110305745.png" alt="image-20211120110305745"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110429625.png" alt="image-20211120110429625"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120110557313.png" alt="image-20211120110557313"></p><ul><li>第三点当比较器为空uvm_comparer=null则会使用<strong>全局的默认比较器：uvm_default_comparer（详细参考1.6）</strong>，最大的错误次数为1，只要失败一次就返回</li></ul><h2 id="1-7-打印：print-直接打印，spring-返回字符串，do-print-回调"><a href="#1-7-打印：print-直接打印，spring-返回字符串，do-print-回调" class="headerlink" title="1.7 打印：print()直接打印，spring()返回字符串，do_print()回调"></a>1.7 打印：print()直接打印，spring()返回字符串，do_print()回调</h2><h3 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7.1"></a>1.7.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120111454285.png" alt="image-20211120111454285"></p><h3 id="1-7-2-例子"><a href="#1-7-2-例子" class="headerlink" title="1.7.2 例子"></a>1.7.2 例子</h3><p>声明了一个uvm_table_printer句柄local_printer<br>并使用   ；p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p’p</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120113914694.png" alt="image-20211120113914694"></p><ul><li>第一次print，没对打印机printer指定，uvm使用默认uvm_default_printer打印</li><li>第二次print，指定uvm_default_printer=uvm_default_line_printer，uvm使用uvm_default_line_printer打印</li><li>第三次print，指定uvm_default_printer=uvm_default_tree_printer，uvm使用uvm_default_tree_printer打印</li><li>第四次print，配置local_printer<code>local_printer.knobs.full_name=1</code>，并指定使用前面使用的local_printer</li></ul><hr><p>输出结果</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120151732202.png" alt="image-20211120151732202"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120151900842.png" alt="image-20211120151900842"></p><h2 id="1-8-打包和解包-pack-amp-unpack"><a href="#1-8-打包和解包-pack-amp-unpack" class="headerlink" title="1.8 打包和解包(pack&amp;unpack)"></a>1.8 打包和解包(pack&amp;unpack)</h2><h3 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8.1"></a>1.8.1</h3><p><strong>一般在纯粹的UVM环境里是用不到的</strong>，一般用不到</p><p><strong>把域(标量)打包成一个比特流动态数组</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152031282.png" alt="image-20211120152031282"></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-type">int</span> pack (<span class="hljs-keyword">ref</span> <span class="hljs-type">bit</span> bitstream[], <span class="hljs-keyword">input</span> uvm_packer packer=<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-type">int</span> unpack (<span class="hljs-keyword">ref</span> <span class="hljs-type">bit</span> bitstream[], <span class="hljs-keyword">input</span> uvm_packer packer=<span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><hr><p>如下：volume-32位、color-32位、box-24位 —-&gt;最终打包成32+32+24=88位比特流的数组</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152358177.png" alt="image-20211120152358177"></p><h3 id="1-8-2-为什么这么做"><a href="#1-8-2-为什么这么做" class="headerlink" title="1.8.2 为什么这么做"></a>1.8.2 为什么这么做</h3><p>仿真器与FPGA(或其他模型)连接</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120152756985.png" alt="image-20211120152756985"></p><p>sim UVM仿真器与FPGA(或其他模型)连接通信，到具体的物理接口上，数据以bitstream形式，通过PCIE/USB/JTAG/UART等协议传输</p><p>UVM的pack&amp;unpack是simUVM(软件侧)对数据打包的方法</p><p>对应FPGA或SystemC模型或不同语言也是通过相关硬件模块实现</p><h2 id="1-6-全局对象"><a href="#1-6-全局对象" class="headerlink" title="1.6 全局对象"></a>1.6 全局对象</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211120111057485.png" alt="image-20211120111057485"></p><p><strong>uvm_top</strong>为全局的顶层，与其他全局对象处于并列位置</p><p>如果不想用默认比较器uvm_default_comparer可以创建一个<code>uvm_comparer</code>对象</p><p>（补充：uvm_factory不要去修改）</p><h2 id="1-9-使用到的方法总结"><a href="#1-9-使用到的方法总结" class="headerlink" title="1.9 使用到的方法总结"></a>1.9 使用到的方法总结</h2><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">class</span>.sprint<br>`uvm_info<br></code></pre></div></td></tr></table></figure><h1 id="2-phase机制"><a href="#2-phase机制" class="headerlink" title="2 phase机制"></a>2 phase机制</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121104044563.png" alt="image-20211121104044563"></p><p>解决的问题：</p><ul><li>例化先后关系</li><li>例化之前进行配置</li><li>UVM仿真阶段层次化</li></ul><h2 id="2-2-执行机制"><a href="#2-2-执行机制" class="headerlink" title="2.2 执行机制"></a>2.2 执行机制</h2><h3 id="2-2-1"><a href="#2-2-1" class="headerlink" title="2.2.1"></a>2.2.1</h3><p><strong>一共有九个phase，对应九个方法，只有uvm_component具备</strong>，即如果你的类型是个组件的话一定会有phase机制</p><p><strong>主要用到build, connect, run, report</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121105434100.png" alt="image-20211121105434100"></p><ul><li>执行顺序自顶向下，从build到final</li><li>只有run是任务，其他的是函数，函数意味着要立即返回</li></ul><h3 id="2-2-2-uvm-phase形参、例子、工厂创建对象的实例"><a href="#2-2-2-uvm-phase形参、例子、工厂创建对象的实例" class="headerlink" title="2.2.2 uvm_phase形参、例子、工厂创建对象的实例"></a>2.2.2 uvm_phase形参、例子、工厂创建对象的实例</h3><p><strong>uvm_phase形参用于传入当前phase</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121105541924.png" alt="image-20211121105541924"></p><hr><p><strong>执行方法名：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> void <span class="hljs-constructor">T_phase(<span class="hljs-params">uvm_phase</span> <span class="hljs-params">phase</span>)</span>;<br></code></pre></div></td></tr></table></figure><p>uvm_phase phase指的传入当前phase</p><hr><p><strong>工厂机制创建：</strong></p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">handle</span> = subcomp::type_id::create(<span class="hljs-string">&quot;c1&quot;</span>,this)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>this指的是c1或c2的parent，这里是创建这些对象的外部类，对应的topcomp</p><hr><p><strong>该例子例化的类结构图</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133437198.png" alt="image-20211121133437198"></p><h4 id="2-2-2-2-执行结果"><a href="#2-2-2-2-执行结果" class="headerlink" title="2.2.2.2 执行结果"></a>2.2.2.2 执行结果</h4><p>从结果看，<strong>执行顺序：自顶向下</strong>（先创建顶层实例，在创建底层实例）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133528289.png" alt="image-20211121133528289"></p><h2 id="2-3-九个主要phase：run-phase的功能"><a href="#2-3-九个主要phase：run-phase的功能" class="headerlink" title="2.3 九个主要phase：run_phase的功能"></a>2.3 九个主要phase：run_phase的功能</h2><h3 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3.1"></a>2.3.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133758460.png" alt="image-20211121133758460"></p><ul><li>上电</li><li>复位</li><li>寄存器配置</li><li>发送主要测试内容</li><li>等待DUT完成测试</li></ul><h3 id="2-3-2-进一步细分run-phase为12个分支phase"><a href="#2-3-2-进一步细分run-phase为12个分支phase" class="headerlink" title="2.3.2 进一步细分run_phase为12个分支phase"></a>2.3.2 进一步细分run_phase为12个分支phase</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121133908469.png" alt="image-20211121133908469"></p><ul><li>pre_reset_phase</li><li>reset_phase</li><li>post_reset_phase</li><li>pre_configure_phase</li><li>post_comfigure_phase</li><li>pre_main_phase</li><li>main_phase</li><li>post_main_phase</li><li>pre_shutdown_phase</li><li>shutdown_phase</li><li>post_shutdown_phase</li></ul><h3 id="2-3-3-run-phase与12分支phase关系"><a href="#2-3-3-run-phase与12分支phase关系" class="headerlink" title="2.3.3 run_phase与12分支phase关系"></a>2.3.3 run_phase与12分支phase关系</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121134135788.png" alt="image-20211121134135788"></p><p><strong>建议不要使用12个分支phase</strong></p><p>当环境中同时存在run_phase与分支phase时：</p><p>run_phase和定义的分支会同时运行为两个线程，且两个线程都结束时才进入下一个phase</p><h2 id="2-4-UVM编译和运行顺序"><a href="#2-4-UVM编译和运行顺序" class="headerlink" title="2.4 UVM编译和运行顺序"></a>2.4 UVM编译和运行顺序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121134507421.png" alt="image-20211121134507421"></p><p>run是task所以可以消耗时间</p><h2 id="2-5-UVM仿真开始：run-test"><a href="#2-5-UVM仿真开始：run-test" class="headerlink" title="2.5 UVM仿真开始：run_test()"></a>2.5 UVM仿真开始：run_test()</h2><h3 id="2-5-1"><a href="#2-5-1" class="headerlink" title="2.5.1"></a>2.5.1</h3><p>类比SV中仿真开始</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121142237253.png" alt="image-20211121142237253"></p><ul><li><p>方法一：<strong>run_test(“xxxx-test”)</strong></p></li><li><p>方法二：run_test()参数为空，仿真时传递参数<code>+UVM_TESTNAME=&lt;test_name&gt;</code></p></li></ul><h3 id="2-5-2-UVM世界的诞生：run-test"><a href="#2-5-2-UVM世界的诞生：run-test" class="headerlink" title="2.5.2 UVM世界的诞生：run_test()"></a>2.5.2 UVM世界的诞生：run_test()</h3><p>run_test()从uvm_root创建了一个UVM世界，是唯一的顶层</p><p>run_test(string test_name=””);源码如下：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121142724706.png" alt="image-20211121142724706"></p><ul><li><p>先拿到一个coreservice_t</p></li><li><p>再用拿到的coreservice_t拿到全局顶层top</p></li><li>再调用顶层的run_test(test_name)</li></ul><p>即run_test(str)调用顶层，顶层top创建test，test再创建下面的哥哥结构</p><h3 id="2-5-3-uvm-top承担的责任"><a href="#2-5-3-uvm-top承担的责任" class="headerlink" title="2.5.3 uvm_top承担的责任"></a>2.5.3 uvm_top承担的责任</h3><p>uvm_top承担的责任非常重要，但无需我们去实现</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121144411570.png" alt="image-20211121144411570"></p><ul><li>uvm_top是uvm_root类的全局唯一一个实例</li><li>uvm_top是uvm里面例化的任何一个实例的顶层<ul><li>对于component来讲，parent定为null则默认顶层为uvm_top，称为其子组件</li></ul></li><li>uvm_top控制各个phase的执行顺序</li><li>uvm_top完成使用层次名索引的功能；配置部分都在uvm_top里面</li></ul><h3 id="2-5-4-uvm-top调用run-test，uvm-top做了什么"><a href="#2-5-4-uvm-top调用run-test，uvm-top做了什么" class="headerlink" title="2.5.4 uvm_top调用run_test，uvm_top做了什么"></a>2.5.4 uvm_top调用run_test，uvm_top做了什么</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121145217232.png" alt="image-20211121145217232"></p><ul><li>objection机制是用来控制仿真退出的</li><li>创建uvm_test_top是为了调用各个组件的phase方法，进行安排</li></ul><h2 id="2-6-UVM仿真结束：我们的组件需要至少有一个能够挂起run-phase"><a href="#2-6-UVM仿真结束：我们的组件需要至少有一个能够挂起run-phase" class="headerlink" title="2.6 UVM仿真结束：我们的组件需要至少有一个能够挂起run_phase"></a>2.6 UVM仿真结束：我们的组件需要至少有一个能够挂起run_phase</h2><h3 id="2-6-1"><a href="#2-6-1" class="headerlink" title="2.6.1"></a>2.6.1</h3><p><strong>控制（实现阻碍仿真退出）仿真退出只有一种方式，就是objection机制</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121150059484.png" alt="image-20211121150059484"></p><p>uvm_objection机制实际上就是个计数器，在SV中是semapho旗语</p><h3 id="2-6-2-uvm-objection用来实现反停止的方法"><a href="#2-6-2-uvm-objection用来实现反停止的方法" class="headerlink" title="2.6.2 uvm_objection用来实现反停止的方法"></a>2.6.2 uvm_objection用来实现反停止的方法</h3><h3 id="2-6-1raise挂起、drop落下"><a href="#2-6-1raise挂起、drop落下" class="headerlink" title="2.6.1raise挂起、drop落下"></a>2.6.1raise挂起、drop落下</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121150748646.png" alt="image-20211121150748646"></p><p>我们一般在run的阶段会把仿真挂起，对各<strong>个组件来说至少有一个需要把objection挂起防止uvm退出</strong>，如下：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151047519.png" alt="image-20211121151047519"></p><p>如果uvm在run_phase时没有任何组件挂起，则会直接跳到report阶段</p><h3 id="2-6-2-2-例子代码"><a href="#2-6-2-2-例子代码" class="headerlink" title="2.6.2.2 例子代码"></a>2.6.2.2 例子代码</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151418897.png" alt="image-20211121151418897"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">phase.raise_objection(this);<span class="hljs-regexp">//</span>this指的是把当前组件挂起phase.drop_objection(this);<span class="hljs-regexp">//</span>this指的是把当前组件落下<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151343183.png" alt="image-20211121151343183"></p><h4 id="2-6-2-3-例子代码2：你需要把你的挂起代码放在run-phase-的第一行执行"><a href="#2-6-2-3-例子代码2：你需要把你的挂起代码放在run-phase-的第一行执行" class="headerlink" title="2.6.2.3 例子代码2：你需要把你的挂起代码放在run_phase()的第一行执行"></a>2.6.2.3 例子代码2：你需要把你的挂起代码放在run_phase()的第一行执行</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151552696.png" alt="image-20211121151552696"></p><p>错误的，直接全部跳过了</p><p>你需要把你的挂起代码放在run_phase()的第一行执行</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151711248.png" alt="image-20211121151711248"></p><h3 id="2-6-4-你可以在component、test、sequence中进行挂起操作"><a href="#2-6-4-你可以在component、test、sequence中进行挂起操作" class="headerlink" title="2.6.4 你可以在component、test、sequence中进行挂起操作"></a>2.6.4 你可以在component、test、sequence中进行挂起操作</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151809157-16374790902901.png" alt="image-20211121151809157"></p><h1 id="3-config机制"><a href="#3-config机制" class="headerlink" title="3 config机制"></a>3 config机制</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121151834681.png" alt="image-20211121151834681"></p><p>config不同参数来选择：组件类型、组件实例数目、组件之间的连接、组件的运行模式；或是修改更细节的内容</p><h3 id="3-1-2-uvm-config-db配置类"><a href="#3-1-2-uvm-config-db配置类" class="headerlink" title="3.1.2 uvm_config_db配置类"></a>3.1.2 uvm_config_db配置类</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121153004400.png" alt="image-20211121153004400"></p><p>可以把一个变量从任何一个层次传递到其他层次，甚至底层组件没有创建也可以传递</p><p>可传递内容：</p><ul><li>interface指针(SV中set_interface函数传递的)</li><li>单一变量或句柄的配置</li></ul><p>传递形式(成功返回1，失败返回0)：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">uvm_config_db#(T)::<span class="hljs-keyword">set</span>(uvm_component cntxt, <span class="hljs-built_in">string</span> inst_name, <span class="hljs-built_in">string</span> field_name, T value);<br>uvm_config_db#(T)::<span class="hljs-keyword">get</span>(uvm_component cntxt, <span class="hljs-built_in">string</span> inst_name, <span class="hljs-built_in">string</span> field_name, <span class="hljs-keyword">inout</span> T value);<br></code></pre></div></td></tr></table></figure><ul><li><h1 id="号对应参数类内容（参考SV第七讲）"><a href="#号对应参数类内容（参考SV第七讲）" class="headerlink" title="号对应参数类内容（参考SV第七讲）"></a>号对应参数类内容（参考SV第七讲）</h1></li><li><p>由层次索引</p><ul><li>string inst_name没有例化则就直接写空字符串“”</li></ul></li><li><p>(后面是错误的笔记)先set再创建，就会生成相应设置后的类</p></li></ul><h2 id="3-3-interface传递"><a href="#3-3-interface传递" class="headerlink" title="3.3 interface传递"></a>3.3 interface传递</h2><h3 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121154614767.png" alt="image-20211121154614767"></p><p>SV中使用层次化的interface所以完成传递，即调用每一层的set_interface进行层层传递，非常不好</p><ul><li>一定要对interface与vitural interface区分开，传递的过程中应该是virtual interface即传递指针</li></ul><h3 id="3-3-2-例子代码"><a href="#3-3-2-例子代码" class="headerlink" title="3.3.2 例子代码"></a>3.3.2 例子代码</h3><p>下面例子</p><ul><li><p>在build_phase里get vif</p></li><li><p>在test1的initial中进行set，且set一定要发生在run_test()之前确保了可以成功传递</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121155052295.png" alt="image-20211121155052295"></p><p>注意<code>virtual interface</code>，在软件中都得使用virtual interface</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121164443607.png" alt="image-20211121164443607"></p><p>get(this,””,”vif”,vif)前三个参数完成的层次为“root.test.c1.vif”。其中第二个参数代表的时实例名，由于这里还没有进行例化所以用空字符串代替</p><h3 id="3-3-3-例子代码续"><a href="#3-3-3-例子代码续" class="headerlink" title="3.3.3 例子代码续"></a>3.3.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171501531.png" alt="image-20211121171501531"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171442924.png" alt="image-20211121171442924"></p><p>uvm_config_db里面就是一些关系数组，做了中间的变量存放，通过set,get改变值：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171600469.png" alt="image-20211121171600469"></p><h2 id="3-4-变量设置"><a href="#3-4-变量设置" class="headerlink" title="3.4 变量设置"></a>3.4 变量设置</h2><h3 id="3-4-1-3-4-2-例子代码"><a href="#3-4-1-3-4-2-例子代码" class="headerlink" title="3.4.1 , 3.4.2 例子代码"></a>3.4.1 , 3.4.2 例子代码</h3><p>下面例子</p><ul><li><p>在build_phase里get vif</p></li><li><p>在test1的initial中进行set，再进行create</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121171945087.png" alt="image-20211121171945087"></p><h3 id="3-4-3-例子代码续"><a href="#3-4-3-例子代码续" class="headerlink" title="3.4.3 例子代码续"></a>3.4.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172019437.png" alt="image-20211121172019437"></p><h2 id="3-5-object传递"><a href="#3-5-object传递" class="headerlink" title="3.5 object传递"></a>3.5 object传递</h2><h3 id="3-5-1"><a href="#3-5-1" class="headerlink" title="3.5.1"></a>3.5.1</h3><p>当变量比较多的时候，一个一个写不方便</p><p>可以把这些变量封装到uvm_object类里面，类例化，传递该对象句柄</p><ul><li>先set再create</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172401435.png" alt="image-20211121172401435"></p><h3 id="3-5-2-例子代码"><a href="#3-5-2-例子代码" class="headerlink" title="3.5.2 例子代码"></a>3.5.2 例子代码</h3><ul><li>可以父类uvm_oject传递：此时注意get时父类句柄转换为子类</li><li>可以直接以继承过来的子类进行传递</li><li>set , get 严格类型一致</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121172535029.png" alt="image-20211121172535029"></p><p>注意代码<code>void`($cast(cfg, tmp))</code>把父类句柄转成子类句柄，从而访问子类句柄里的成员变量</p><h3 id="3-5-2-例子代码续"><a href="#3-5-2-例子代码续" class="headerlink" title="3.5.2 例子代码续"></a>3.5.2 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121173653346.png" alt="image-20211121173653346"></p><h3 id="类型要完全一致：底层get是父类句柄-uvm-objection-顶层set也得是该父类句柄"><a href="#类型要完全一致：底层get是父类句柄-uvm-objection-顶层set也得是该父类句柄" class="headerlink" title="类型要完全一致：底层get是父类句柄(uvm_objection)顶层set也得是该父类句柄"></a>类型要完全一致：底层get是父类句柄(uvm_objection)顶层set也得是该父类句柄</h3><h2 id="3-6-总结与建议"><a href="#3-6-总结与建议" class="headerlink" title="3.6 总结与建议"></a>3.6 总结与建议</h2><h3 id="3-6-1-总结"><a href="#3-6-1-总结" class="headerlink" title="3.6.1 总结"></a>3.6.1 总结</h3><ul><li><p><strong>set,get成对出现</strong></p></li><li><p>类型严格一致</p></li><li>路径中的*星号表通配符，意思是任意路径</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121174228374.png" alt="image-20211121174228374"></p><h3 id="3-6-1-建议"><a href="#3-6-1-建议" class="headerlink" title="3.6.1 建议"></a>3.6.1 建议</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121174345564.png" alt="image-20211121174345564"></p><h1 id="4-消息管理"><a href="#4-消息管理" class="headerlink" title="4 消息管理"></a>4 消息管理</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>一个好的验证系统应具有消息管理特性：</p><ul><li>一种标准化的方式打印</li><li>过滤信息（按重要级别）</li><li>打印通道</li></ul><p>这些特性UVM都有支持，UVM提供一系列丰富的类和方法来生成和过滤消息：</p><ul><li>消息方法</li><li>消息处理</li><li>消息机制</li></ul><p>类似的SV中的report package</p><h2 id="4-2-消息方法"><a href="#4-2-消息方法" class="headerlink" title="4.2 消息方法"></a>4.2 消息方法</h2><h3 id="4-2-1"><a href="#4-2-1" class="headerlink" title="4.2.1"></a>4.2.1</h3><p>在UVM环境中或者<strong>环境外</strong>，只要引入uvm_pkg，均可以通过下面的方法来按照消息的严重级别和冗余度来打印消息</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_info(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_MEDIUM, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_warning(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_MEDIUM, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_error(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_LOW, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> uvm_report_fatal(<span class="hljs-keyword">string</span> id, <span class="hljs-keyword">string</span> message, <span class="hljs-keyword">int</span> verbosity = UVM_NONE, <span class="hljs-keyword">string</span> filename = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><ul><li><p>id：消息的名称是什么</p></li><li><p>message：消息的内容是什么</p></li><li><p>verbosity：消息的重要性/冗余程度</p></li><li><p>filename：消息发生时该程序文件的名称（留空就行，一般系统自动添加）</p></li><li><p>line：消息发生时该程序的行号（留空就行，一般系统自动添加）</p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121175458444.png" alt="image-20211121175458444"></p><h3 id="4-2-2-verbosity冗余度：UVM-NONE"><a href="#4-2-2-verbosity冗余度：UVM-NONE" class="headerlink" title="4.2.2 verbosity冗余度：UVM_NONE"></a>4.2.2 verbosity冗余度：UVM_NONE</h3><p>冗余度：代表消息重要不重要，与我们的直观认识相反</p><ul><li>UVM_NONE：最重要，没有任何bur/filter可以过滤</li><li>UVM_LOW</li><li>UVM_MEDIUM</li><li>UVM_HIGH</li><li>UVM_FULL：更容易被过滤</li><li>UVM_DEBUG：更容易被过滤</li></ul><h2 id="4-3-消息处理"><a href="#4-3-消息处理" class="headerlink" title="4.3 消息处理"></a>4.3 消息处理</h2><h3 id="4-4-1-处理方式"><a href="#4-4-1-处理方式" class="headerlink" title="4.4.1 处理方式"></a>4.4.1 处理方式</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121175515039.png" alt="image-20211121175515039"></p><h3 id="4-4-2-消息宏"><a href="#4-4-2-消息宏" class="headerlink" title="4.4.2 消息宏"></a>4.4.2 消息宏</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180007597.png" alt="image-20211121180007597"></p><p>谁提供的这些消息？：uvm_report_object</p><ul><li>我们可以用组件的方法进行调用</li><li>使用宏进行调用（更推荐）</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`uvm_info(ID, MESSAGE, VERBOSITY)</span><br><span class="hljs-meta">`uvm_warning(ID, MESSAGE)</span><br><span class="hljs-meta">`uvm_error(ID, MESSAGE)</span><br><span class="hljs-meta">`uvm_fatal(ID, MESSAGE)</span><br></code></pre></div></td></tr></table></figure><p>对于w,e,f不用传verbosity，他们默认是UVM_LOW，较高等级了</p><h2 id="4-4-消息机制"><a href="#4-4-消息机制" class="headerlink" title="4.4 消息机制"></a>4.4 消息机制</h2><p><strong>消息处理是uvm_report_handler类完成的</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180526774.png" alt="image-20211121180526774"></p><ul><li><code>set_max_quit_count</code>对ERROR消息计数停止上限</li></ul><h2 id="4-5-消息处理中的回调函数"><a href="#4-5-消息处理中的回调函数" class="headerlink" title="4.5 消息处理中的回调函数"></a>4.5 消息处理中的回调函数</h2><p><strong>回调函数有如下固定形式，在任何地方实现都可以</strong></p><p>一般来说一定要定义<strong>report_hook</strong>，其他看细分要求</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180714439.png" alt="image-20211121180714439"></p><h3 id="4-5-2-例子代码"><a href="#4-5-2-例子代码" class="headerlink" title="4.5.2 例子代码"></a>4.5.2 例子代码</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180827395.png" alt="image-20211121180827395"></p><ul><li><strong>build_phase</strong><ul><li>set_report_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_CALL_HOOK);//只有error会打印调用回调函数</li><li>set_report_verbosity_level(UVM_LOW);//只有冗余为uvm_low会被打印1<ul><li>此处error2为HIGH则不会打印也不会调用回调函数</li></ul></li></ul></li></ul><h3 id="4-5-3-回调函数返回值："><a href="#4-5-3-回调函数返回值：" class="headerlink" title="4.5.3 回调函数返回值："></a>4.5.3 <strong>回调函数返回值：</strong></h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121181339630.png" alt="image-20211121181339630"></p><p>report_hook返回值为1时，继续执行分类report_error_hook否则不再继续调用</p><p>一般来说一定要定义<strong>report_hook</strong></p><h3 id="4-5-3-例子代码续"><a href="#4-5-3-例子代码续" class="headerlink" title="4.5.3 例子代码续"></a>4.5.3 例子代码续</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121180842859.png" alt="image-20211121180842859"></p><h3 id="4-5-4-隐藏在后台的uvm-report-handler与uvm-report-server"><a href="#4-5-4-隐藏在后台的uvm-report-handler与uvm-report-server" class="headerlink" title="4.5.4 隐藏在后台的uvm_report_handler与uvm_report_server"></a>4.5.4 隐藏在后台的uvm_report_handler与uvm_report_server</h3><p>对每一个组件都有report_handler实例，它们把消息申请到<strong>全局</strong>的实例report_server</p><p>report_server和factory一样的，放在coserver下面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211121181735130.png" alt="image-20211121181735130"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM入门和进阶1：验证方法学概述_类库地图_工厂机制_覆盖方法</title>
    <link href="/202111171106/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B61%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%AD%A6%E6%A6%82%E8%BF%B0_%E7%B1%BB%E5%BA%93%E5%9C%B0%E5%9B%BE_%E5%B7%A5%E5%8E%82%E6%9C%BA%E5%88%B6_%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95/"/>
    <url>/202111171106/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B61%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%AD%A6%E6%A6%82%E8%BF%B0_%E7%B1%BB%E5%BA%93%E5%9C%B0%E5%9B%BE_%E5%B7%A5%E5%8E%82%E6%9C%BA%E5%88%B6_%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考文档链接：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p><h1 id="1-验证方法学概述"><a href="#1-验证方法学概述" class="headerlink" title="1 验证方法学概述"></a>1 验证方法学概述</h1><h2 id="1-1-我们所处的验证时代"><a href="#1-1-我们所处的验证时代" class="headerlink" title="1.1 我们所处的验证时代"></a>1.1 我们所处的验证时代</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111111480.png" alt="image-20211117111111480"></p><p>原有HDL受限于静态例化，同时随即约束短板<br>验证技术应该更为灵活化</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111401950.png" alt="image-20211117111401950"></p><p> Verilog1.0-&gt;Verilog2.0———&gt;SystemVerilog3.0(基于verilog发展的所以一上来就是3.0)</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117111706037.png" alt="image-20211117111706037"></p><h2 id="1-2-UVM的优势"><a href="#1-2-UVM的优势" class="headerlink" title="1.2 UVM的优势"></a>1.2 UVM的优势</h2><p>Universal(通用)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114327436.png" alt="image-20211117114327436"></p><p>精力集中到：设计验证计划，减轻创建测试环境</p><h3 id="1-3UVM的发展历程与演变"><a href="#1-3UVM的发展历程与演变" class="headerlink" title="1.3UVM的发展历程与演变"></a>1.3UVM的发展历程与演变</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114426035.png" alt="image-20211117114426035"></p><ul><li>UVM 1.0就是基于OVM</li><li>UVM1.1 UVM1.2</li><li>UVM1.2重大里程碑，被纳为标准</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114539211.png" alt="image-20211117114539211"></p><p>注意哪些是新方法，哪些是旧方法(一些旧方法已注销)</p><h2 id="1-4-学习路线-共五周"><a href="#1-4-学习路线-共五周" class="headerlink" title="1.4 学习路线(共五周)"></a>1.4 学习路线(共五周)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114931874.png" alt="image-20211117114931874"></p><p>同v2SV一样，参考如何构建环境进行学习</p><p>五周学习不会超过50个类，非常核心的也就二十到三十个类之间大概十分之一，剩下的谁在用（UVM自动调用）</p><h1 id="2-类库地图"><a href="#2-类库地图" class="headerlink" title="2 类库地图"></a>2 类库地图</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117114959864.png" alt="image-20211117114959864"></p><ul><li><p>SV通过句柄一层一层的实现访问，UVM有替代</p></li><li><p>创建、访问、修改、配置都是可以重用的，所以反到类库当中</p></li><li><p>标准化减轻了构建验证环境的负担</p></li></ul><h3 id="SV与UVM对验证环境的共同需求"><a href="#SV与UVM对验证环境的共同需求" class="headerlink" title="SV与UVM对验证环境的共同需求"></a>SV与UVM对验证环境的共同需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134433441.png" alt="image-20211117134433441"></p><h2 id="2-2-UVM世界-10大核心类"><a href="#2-2-UVM世界-10大核心类" class="headerlink" title="2.2 UVM世界(10大核心类)"></a>2.2 UVM世界(10大核心类)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134654558.png" alt="image-20211117134654558"></p><p>对象的生成是动态的，需要UVM帮助去创建，如②提供对底层组建的创建与访问</p><p>环境中层次之间的创建，链接，层次间组建的控制方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134917565.png" alt="image-20211117134917565"></p><h2 id="2-3-UVM世界讲解"><a href="#2-3-UVM世界讲解" class="headerlink" title="2.3 UVM世界讲解"></a>2.3 UVM世界讲解</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134941044.png" alt="image-20211117134941044"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117134654558.png" alt="image-20211117134654558"></p><p>核心基类：</p><p>​    ① uvm_void与<strong>uvm_object(非常核心)</strong>：会提空基本的方法，比如：拷贝、创建、打印</p><p>​    ② 工厂类：注册、创建、覆盖我们的一些类型</p><p>​    ③ 事务和序列类：发送激励，帮助实现测试场景。<br>事务类：组件之间数据类型的定义，数据是如何产生</p><p>​    ④ 结构创建类：uvm_component(uvm组件类，重要，因为第五个所有的类型都继承于uvm_component。我们在UVM会经常提到这个类是继承于object还是component)</p><p>​    ⑤  环境组件类</p><p>​    ⑥ 通信管道类：fifo , channel 与SV学到的队列和信箱类比<br><strong>组件</strong>间相连用<strong>端口</strong>，发送数据的存储到通信<strong>管道</strong>内（因此第四周学通信管道和事务接口）</p><p>​    ⑦ 消息报告类：消息如何打印，消息是怎么样控制的</p><p>​    ⑧ 寄存器模型类(第五周学)</p><p>​    ⑨ 线程同步类：与SVevent对比</p><p>​    ⑩ 事务接口类(稍微特殊) ：<br>有一些port后缀，代表端口，端口用来做通信的<br>这些端口是验证组件之间要通信的话他们之间往往需要端口，即⑩类与⑤类有关系，在组件之间例化，通过端口连接<br>⑩类还比较特殊再不继承于object而直接继承void</p><h3 id="组件类、管道类、接口类的关系"><a href="#组件类、管道类、接口类的关系" class="headerlink" title="组件类、管道类、接口类的关系"></a>组件类、管道类、接口类的关系</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117141338198.png" alt="image-20211117141338198"></p><h1 id="3-工厂机制"><a href="#3-工厂机制" class="headerlink" title="3 工厂机制"></a>3 工厂机制</h1><h2 id="3-1-概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式-design-pattern"><a href="#3-1-概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式-design-pattern" class="headerlink" title="3.1 概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式(design pattern)"></a>3.1 概述：工厂机制是UVM的魅力所在，也是一种典型的设计模式(design pattern)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117142434126.png" alt="image-20211117142434126"></p><h2 id="3-2-工厂的意义"><a href="#3-2-工厂的意义" class="headerlink" title="3.2 工厂的意义"></a>3.2 工厂的意义</h2><h3 id="3-2-1-替换、注册、配置"><a href="#3-2-1-替换、注册、配置" class="headerlink" title="3.2.1 替换、注册、配置"></a>3.2.1 替换、注册、配置</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117144807092.png" alt="image-20211117144807092"></p><ul><li><p>工厂为了：替换实例或注册过的类，为配置和覆盖(override)带来灵活性</p></li><li><p><strong>覆盖</strong>：替换实例或类型。被替换的实例或类型应满足注册(registration)和多态(polymorphism)的要求</p></li><li><p>UVM验证环境两部分：</p><ul><li>一部分构成了环境层次：通过uvm_component完成</li><li>一部分构成了环境属性(如配置)：通过uvm_object完成</li><li>uvm_component与uvm_object对比</li></ul><h3 id="3-2-2-注册"><a href="#3-2-2-注册" class="headerlink" title="3.2.2 注册"></a>3.2.2 注册</h3></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117145329019.png" alt="image-20211117145329019"></p><p>依赖于工厂创建对象</p><p>创建对象之前工厂需要模具/蓝图（类进行注册）：SV的new与注册的区别在哪，因为有一个覆盖的好处</p><h2 id="3-3-uvm-component与uvm-object"><a href="#3-3-uvm-component与uvm-object" class="headerlink" title="3.3 uvm_component与uvm_object"></a>3.3 uvm_component与uvm_object</h2><p><strong>工厂我们一共就注册两大类型：uvm_component与uvm_object</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117145646932.png" alt="image-20211117145646932"></p><ul><li><p>验证不动产</p><ul><li>性质：构成验证环境的</li><li>在uvm_component都有对应</li></ul></li><li><p>非不动产</p><ul><li>性质：帮助实现验证场景，在验证过程中动态产生</li><li>transcation事务级传输对象数据包，这些类在UVM统一由uvm_object表示</li></ul></li></ul><h3 id="3-3-2-uvm-component-object-的例化"><a href="#3-3-2-uvm-component-object-的例化" class="headerlink" title="3.3.2 uvm_{component, object}的例化"></a>3.3.2 uvm_{component, object}的例化</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117151628452.png" alt="image-20211117151628452"></p><p><strong>工厂提供的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建uvm_component对象</span><br>comp_type::type_id::<span class="hljs-built_in">create</span>(string name, uvm_component parent);<br><span class="hljs-comment">//创建uvm_object对象</span><br>object_type::type_id::<span class="hljs-built_in">create</span>(string name);<br></code></pre></div></td></tr></table></figure><p><strong>type_id</strong>是你注册到工厂里面的类型</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">comp_type::type_id::<span class="hljs-built_in">create</span>(val1,val2);<br><span class="hljs-comment">//type_id是你注册到工厂里面的类型</span><br><span class="hljs-comment">//create调用方法</span><br></code></pre></div></td></tr></table></figure><h4 id="creat与new"><a href="#creat与new" class="headerlink" title="creat与new"></a>creat与new</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117160636008.png" alt="image-20211117160636008"></p><p><strong>使用new或者create都能完成例化</strong>，但在UVM中我们用create，他是工厂提供的创建实例方式</p><h3 id="3-3-4-工程提供的便利——创建分两步：①注册-registration-、②创建-create"><a href="#3-3-4-工程提供的便利——创建分两步：①注册-registration-、②创建-create" class="headerlink" title="3.3.4 工程提供的便利——创建分两步：①注册(registration)、②创建(create)"></a>3.3.4 工程提供的便利——创建分两步：①注册(registration)、②创建(create)</h3><h4 id="注册两个宏"><a href="#注册两个宏" class="headerlink" title="注册两个宏"></a>注册两个宏</h4><p>`uvm_component_utils(comp_name);</p><p>`uvm_object_utils(obj_name);</p><h4 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h4><ul><li>定义：extends</li><li>注册：宏</li><li>构建：new</li></ul><h4 id="第一个例子-继承于component类"><a href="#第一个例子-继承于component类" class="headerlink" title="第一个例子(继承于component类)"></a>第一个例子(继承于component类)</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117151917395.png" alt="image-20211117151917395"></p><p>泛式：形式不变，内容变</p><p><strong>第一步：注册环节</strong>，第一个泛式</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_component_utils(<span class="hljs-params">comp1</span>)</span>;<span class="hljs-comment">//使用宏。固定的泛式，把当前的comp1类型注册到工厂里</span><br></code></pre></div></td></tr></table></figure><p><strong>第二步：new函数</strong>，new函数参数是第二个泛式，参数不能添加新的参数也不能减少原有的参数</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-keyword">new</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name=<span class="hljs-string">&quot;comp1&quot;</span>, uvm_component parent=<span class="hljs-literal">null</span></span>)</span>;<span class="hljs-comment">//parent是说例化当前实例的组件</span><br></code></pre></div></td></tr></table></figure><p>各个phase函数第二周学</p><h4 id="第二个例子-继承于uvm-object类"><a href="#第二个例子-继承于uvm-object类" class="headerlink" title="第二个例子(继承于uvm_object类)"></a>第二个例子(继承于uvm_object类)</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117155253185.png" alt="image-20211117155253185"></p><p>泛式：形式不变，内容变</p><p><strong>第一步：注册环节</strong>，第一个泛式</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">`uvm<span class="hljs-constructor">_object_utils(<span class="hljs-params">obj1</span>)</span>;<span class="hljs-comment">//使用宏。固定的泛式，把当前的obj1类型注册到工厂里</span><br></code></pre></div></td></tr></table></figure><p><strong>第二步：new函数</strong>，new函数参数是第二个泛式</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-keyword">new</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name=<span class="hljs-string">&quot;obj1&quot;</span></span>)</span>;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p>各个phase函数第二周学</p><h3 id="3-3-5-工厂提供的便利"><a href="#3-3-5-工厂提供的便利" class="headerlink" title="3.3.5 工厂提供的便利"></a>3.3.5 工厂提供的便利</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117160759991.png" alt="image-20211117160759991"></p><h2 id="3-4-工厂机制：工厂类"><a href="#3-4-工厂机制：工厂类" class="headerlink" title="3.4 工厂机制：工厂类"></a>3.4 工厂机制：工厂类</h2><p>不一定会出现在你的代码里面，但帮你规划了你的类</p><h3 id="3-4-1-uvm-coreservice-t类"><a href="#3-4-1-uvm-coreservice-t类" class="headerlink" title="3.4.1 uvm_coreservice_t类"></a>3.4.1 uvm_coreservice_t类</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117161530640.png" alt="image-20211117161530640"></p><ul><li><p>uvm_factory成员类：<strong>唯一并全局</strong>，负责注册、覆盖、例化</p></li><li><p>report_server成员类：<strong>唯一并全局</strong>，消息统筹和报告</p></li><li><p>tr_database成员类：<strong>全局</strong>，用于记录transaction记录</p></li><li>get_root成员方法：返回UVM环境的结构顶层对象</li></ul><p><strong>uvm_coreservice_t,uvm_factory并不是uvm_component或uvm_object</strong>，没有例化在UVM环境结构中</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162456418.png" alt="image-20211117162456418"></p><p>目前学习的实例uvm_default_factory是已经存在的，不需要自己做例化</p><h3 id="3-4-2-注册宏-uvm下划线-component-object-下划线utils"><a href="#3-4-2-注册宏-uvm下划线-component-object-下划线utils" class="headerlink" title="3.4.2 注册宏`uvm下划线{component, object}下划线utils"></a>3.4.2 注册宏`uvm下划线{component, object}下划线utils</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162932344.png" alt="image-20211117162932344"></p><hr><p>注册机制与create，以下自学：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117162949271.png" alt="image-20211117162949271"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117163120240.png" alt="image-20211117163120240"></p><h3 id="3-4-3-注册后的对象创建-component或者object"><a href="#3-4-3-注册后的对象创建-component或者object" class="headerlink" title="3.4.3 注册后的对象创建(component或者object)"></a>3.4.3 注册后的对象创建(component或者object)</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173114760.png" alt="image-20211117173114760"></p><p><strong>注意有无parent关系到是否可以看到UVM结构</strong></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173140816.png" alt="image-20211117173140816"></p><p>创建后放置到类型库中</p><p>创建时，创建的类型如果没有被覆盖，则直接使用该类型的基础类型</p><h3 id="3-5-6-componetn-object与工厂有关的方法（三类创建方法）"><a href="#3-5-6-componetn-object与工厂有关的方法（三类创建方法）" class="headerlink" title="3.5.6 componetn/object与工厂有关的方法（三类创建方法）"></a>3.5.6 componetn/object与工厂有关的方法（三类创建方法）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173443440.png" alt="image-20211117173443440"></p><p>用<strong>object/component组件(uvm_component)去创建</strong>对象的方法：</p><ul><li>create()</li><li>create_component()</li><li>get()</li><li>get_type_name()</li><li>set_inst_override()</li><li>set_type_override()</li></ul><hr><p>一旦创建，会把当前类型的图纸，放入到类型库里面</p><p>如果没有覆盖类型，则用工厂去创建</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173544207.png" alt="image-20211117173544207"></p><p>用<strong>工厂去创建</strong>也有很多方法：</p><ul><li><p><strong>使用typeid::创建</strong></p></li><li><p><strong>create_component_by_name()</strong></p></li><li><strong>create_component_by_name()</strong></li><li><strong>create_object_by_name()</strong></li><li><strong>create_object_by_type()</strong></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173802217.png" alt="image-20211117173802217"></p><hr><p>我们<strong>只需要使用这些就可以了</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117173843219.png" alt="image-20211117173843219"></p><h1 id="4-覆盖方法"><a href="#4-覆盖方法" class="headerlink" title="4 覆盖方法"></a>4 覆盖方法</h1><h2 id="4-1-工厂提供的便利——覆盖-override"><a href="#4-1-工厂提供的便利——覆盖-override" class="headerlink" title="4.1 工厂提供的便利——覆盖(override)"></a>4.1 工厂提供的便利——覆盖(override)</h2><h3 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1"></a>4.1.1</h3><p><strong>从原来所属类型创建一个新的替换类型</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117174947637.png" alt="image-20211117174947637"></p><ul><li>无需修改原始代码，保持了原始代码封装性</li><li><strong>新的替换类型必须与原有类型兼容</strong></li></ul><h3 id="4-1-2-举例说明"><a href="#4-1-2-举例说明" class="headerlink" title="4.1.2 举例说明"></a>4.1.2 举例说明</h3><p>你想要修改一个成型验证平台，你想修改driver</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175034720.png" alt="image-20211117175034720"></p><p>如果你修改driver很容易影响到别人，因此不能轻易修改代码</p><p>如果driver是VIP，内部代码不开放的</p><hr><p><strong>使用新的类型driver2替换driver</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175408088.png" alt="image-20211117175408088"></p><h3 id="4-1-3-覆盖实现的要求"><a href="#4-1-3-覆盖实现的要求" class="headerlink" title="4.1.3 覆盖实现的要求"></a>4.1.3 覆盖实现的要求</h3><ul><li>原有类型与新类型都需要注册</li><li>使用create()也就是工厂创建对象</li><li>新的替换类型必须与原有类型兼容</li></ul><hr><ul><li>覆盖发生时，可以使用类型覆盖或实例覆盖</li></ul><p><strong><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117175547831.png" alt="image-20211117175547831"></strong></p><h3 id="4-2-相关函数"><a href="#4-2-相关函数" class="headerlink" title="4.2 相关函数"></a>4.2 相关函数</h3><h3 id="4-2-1-set-type-override-替换类型"><a href="#4-2-1-set-type-override-替换类型" class="headerlink" title="4.2.1 set_type_override()//替换类型"></a>4.2.1 set_type_override()//替换类型</h3><ul><li>函数原型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_type_override(uvm_object_wrapper override_type, <span class="hljs-keyword">bit</span> replace =<span class="hljs-number">1</span> );<span class="hljs-comment">//一个静态函数</span><br></code></pre></div></td></tr></table></figure><ul><li>函数形参</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">uvm_object_wrapper<span class="hljs-comment">//注册过后的某一个类在工厂中注册时的句柄</span><br>new_type::get_type()<span class="hljs-comment">//找到uvm_object_wrapper的方法</span><br></code></pre></div></td></tr></table></figure><ul><li>调用方法</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">orig_type::type_id::set_type_override(new_type::get_type())<br><span class="hljs-comment">//orig_type:原始类型</span><br><span class="hljs-comment">//type_id:类型id</span><br></code></pre></div></td></tr></table></figure><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182321158.png" alt="image-20211117182321158"></p><h3 id="4-2-2-set-inst-override-替换实例"><a href="#4-2-2-set-inst-override-替换实例" class="headerlink" title="4.2.2 set_inst_override()//替换实例"></a>4.2.2 set_inst_override()//替换实例</h3><ul><li>函数原型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_inst_override(uvm_object_wrapper override_type, <span class="hljs-keyword">string</span> inst_path , uvm_component parent=<span class="hljs-literal">null</span> );<span class="hljs-comment">//一个静态函数</span><br></code></pre></div></td></tr></table></figure><ul><li>函数形参</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">inst_path<span class="hljs-comment">//当前替换实例的路径</span><br>parent()<span class="hljs-comment">//缺省时为绝对路径，有值传递是使用&#123;parent.get_full_name(),&#x27;.&#x27;,inst_path&#125;为目标路径，实际代码中常常直接写入上面的inst_path</span><br></code></pre></div></td></tr></table></figure><ul><li>调用方法</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">orig_type::type_id::set_inst_override(new_type::get_type(), <span class="hljs-string">&quot;orig_inst_path&quot;</span>)<br><span class="hljs-comment">//orig_type:原始类型</span><br><span class="hljs-comment">//type_id:类型id</span><br></code></pre></div></td></tr></table></figure><ul><li>路径解释</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">string inst_path = <span class="hljs-string">&quot;root.test.env.checker&quot;</span><span class="hljs-regexp">//</span>法一直接写<br><span class="hljs-regexp">//</span>法二通过句柄直接拿到路径，去掉双引号<br><br></code></pre></div></td></tr></table></figure><p><strong>句柄所代表的结构层级</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182619069.png" alt="image-20211117182619069"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211117182936862.png" alt="image-20211117182936862"></p><h2 id="4-3-如何使用覆盖相关的函数"><a href="#4-3-如何使用覆盖相关的函数" class="headerlink" title="4.3 如何使用覆盖相关的函数"></a>4.3 如何使用覆盖相关的函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118171633289.png" alt="image-20211118171633289"></p><p>不止一个类提供与覆盖有关的函数，然而名称与参数列表可能各不相同：</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">uvm_component::set_&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span>&#123;<span class="hljs-variable">_by_type</span>&#125;<br>uvm_component_registry::set_&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br>uvm_object_registry::<span class="hljs-built_in">set</span>&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br>uvm_factory::<span class="hljs-built_in">set</span>&#123;<span class="hljs-built_in">type</span>, inst&#125;<span class="hljs-variable">_override</span><br></code></pre></div></td></tr></table></figure><p>但我们推荐的就是使用typeid来调用<code>set_&#123;type, inst&#125;_override</code></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">orig_type::type_id<br></code></pre></div></td></tr></table></figure><h2 id="4-4-覆盖实例"><a href="#4-4-覆盖实例" class="headerlink" title="4.4 覆盖实例"></a>4.4 覆盖实例</h2><p><strong>定义例子comp1类</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172022625.png" alt="image-20211118172022625"></p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-keyword">import</span> uvm_pkg::*; <span class="hljs-regexp">//</span>想要使用uvm类型必须<span class="hljs-keyword">import</span>这个，questa已经自动编译了这个pkg,vcs则需要实现编译一下<br>`<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uvm_macros,svh&quot;</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>定义例子2comp2类</strong></p><p>后面将1使用comp2替代comp1</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172138765.png" alt="image-20211118172138765"></p><hr><p><strong>进行覆盖</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118172222740.png" alt="image-20211118172222740"></p><ul><li>c1通过new实例化的没有受到影响，没有经过工厂</li><li>c2通过工厂create实例化的，因此成为了替换后的类型</li></ul><hr><p><strong>如果没有</strong><code>comp1::type_id::set_type_override(comp2::get_type());</code><strong>进行覆盖</strong></p><p>则c1,c2指向的都是comp1类型对象</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118181347671.png" alt="image-20211118181347671"></p><h2 id="4-5-解释为什么comp2要继承comp1"><a href="#4-5-解释为什么comp2要继承comp1" class="headerlink" title="4.5 解释为什么comp2要继承comp1"></a>4.5 解释为什么comp2要继承comp1</h2><p>例化时：</p><ol><li>去找comp1的查找表</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182032108.png" alt="image-20211118182032108"></p><ol><li>发现覆盖类型不为空，把comp1的类型替换为comp2的类型 </li></ol><hr><p><strong>能不能comp2与comp1没有继承关系</strong>：不能，你的override会有问题</p><p><strong>因此，必须要有继承关系在</strong></p><hr><p><strong>定义成员函数(除了new)能不能不用virtual</strong>：不能</p><p><strong>例化时comp2仍然是父类comp1的句柄</strong>，调用方法则会调用父类的方法</p><h2 id="4-6-确保正确覆盖的代码要求"><a href="#4-6-确保正确覆盖的代码要求" class="headerlink" title="4.6 确保正确覆盖的代码要求"></a>4.6 确保正确覆盖的代码要求</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182636783.png" alt="image-20211118182636783"></p><h2 id="4-7-parent-wins"><a href="#4-7-parent-wins" class="headerlink" title="4.7 parent wins"></a>4.7 parent wins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118182738070.png" alt="image-20211118182738070"></p><ul><li>覆盖发生在例化之前，即</li></ul><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">comp1<span class="hljs-type">::type_id</span><span class="hljs-type">::set_type_override</span>(comp2<span class="hljs-type">::get_type</span>());<br>c2 = comp1<span class="hljs-type">::type_id</span><span class="hljs-type">::create</span>(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-built_in">null</span>);<br></code></pre></div></td></tr></table></figure><ul><li>多次对同一对象override：谁的层次高听谁的(顶层test起作用了)，<strong>即在配置过程中，谁层次高听谁的</strong></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118183046598.png" alt="image-20211118183046598"></p><h2 id="4-8-总结：factory三要素：注册、创建和覆盖"><a href="#4-8-总结：factory三要素：注册、创建和覆盖" class="headerlink" title="4.8 总结：factory三要素：注册、创建和覆盖"></a>4.8 总结：factory三要素：注册、创建和覆盖</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211118183138887.png" alt="image-20211118183138887"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCDT测试结构</title>
    <link href="/202111161414/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/MCDT%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%84/"/>
    <url>/202111161414/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/MCDT%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MCDT"><a href="#1-MCDT" class="headerlink" title="1 MCDT"></a>1 MCDT</h1><p>多通道数据传送器，mult-channel data transmitter</p><p>迷你版的MCDF</p><h2 id="1-1-MCDT测试平台结构"><a href="#1-1-MCDT测试平台结构" class="headerlink" title="1.1 MCDT测试平台结构"></a>1.1 MCDT测试平台结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116141617844.png" alt="image-20211116141617844"></p><h2 id="1-2-主要验证组件"><a href="#1-2-主要验证组件" class="headerlink" title="1.2 主要验证组件"></a>1.2 主要验证组件</h2><h3 id="1-2-1-stimulator"><a href="#1-2-1-stimulator" class="headerlink" title="1.2.1 stimulator"></a>1.2.1 stimulator</h3><p>stimulator激励发生器，是验证环境的重要部件，在一些场合中，它也被称为driver(驱动器)、BFM(bus function model , 总线功能模块)、behavioral(行为模型)或者generator(发生器)</p><p>stimulator主要职责是模拟与DUT相邻设计的接口协议，只需要关注于如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT</p><p>stimulator不应违反协议，但布局属于真实的硬件行为，还可以给出更多丰富的只要协议允许的激励场景</p><p>从stimulator同DUT的连接关系来看，我们可以进一步分为两种：<strong>initiator(发生器)</strong>、<strong>responder(响应器)</strong></p><p> initiator是主动发出数据，responder被动接受响应</p><p>就我们要验证的MCDT来看，与下行通道从端(channel slave)的连接，这种stimulator属于initiator功能是主动发起接口数据传输</p><h3 id="1-2-2-monitor"><a href="#1-2-2-monitor" class="headerlink" title="1.2.2 monitor"></a>1.2.2 monitor</h3><p>Monitor(监测器)的主要功能是用来观察DUT的边界或者内部信号，并且经过打包整理传送给其他验证平台的组件，例如checker(比较器)</p><p>从监测信号的层次来划分monitor的功能，它们可以分为观察DUT边界信号和观察DUT内部信号：</p><ul><li>观察DUT边界信号。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据内容，以及检查总线时序是否符合协议</li><li>观察DUT内部信号。从<strong>灰盒验证</strong>的手段来看，往往需要探视DUT内部信号，用来指导stimulator的激励发送，或者完成覆盖率收集，又或者完成内部功能的检查</li></ul><h3 id="1-2-3-checker"><a href="#1-2-3-checker" class="headerlink" title="1.2.3 checker"></a>1.2.3 checker</h3><p><em>无论从实现难度和维护人力上讲，checker(比较器)都应该是最需要事件投入的验证组件</em></p><p>checker肩负了<strong>模拟设计行为</strong>和<strong>功能检查</strong>的任务</p><p>内部往往有缓存器，<strong>缓存</strong>从各个monitor收集到的数据</p><p>将DUT输入接口侧的数据汇集给内置的<strong>reference model</strong>(参考模型)。Reference model在这里扮演了模拟硬件功能的角色，也是需要较多精力维护的部分，因为验证者需要在熟悉硬件的功能的情况下实现该模型，而又不应参考真实硬件的逻辑</p><hr><p>通过数据比较的方法，检查实际收集到的DUT输出端接口数据是否同reference model产生的期望数据一致</p><p>对于设计内部的关键功能模块，也有相对应的线程进行独立的检查</p><p>在检查过程中，可以将检查成功的信息统一纳入到检查报告中，便于仿真后的追溯。如果检查失败，也可以采取暂停仿真同时报告错误信息的方式，进行在线调试</p><h2 id="3-理解验证环境结构的第三个要点"><a href="#3-理解验证环境结构的第三个要点" class="headerlink" title="3 理解验证环境结构的第三个要点"></a>3 理解验证环境结构的第三个要点</h2><h3 id="1-3-1-学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分"><a href="#1-3-1-学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分" class="headerlink" title="1.3.1 学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分"></a>1.3.1 学会区分哪一部分属于硬件、哪一部分属于软件、哪一部分属于软硬件交互的部分</h3><ul><li><p>硬件部分：代验设计mcdt</p></li><li><p>软件部分</p><ul><li>验证环境：激励发生器、检测器、比较器等</li><li>为什么上述是软件部分：由于它们都是类的实例构成</li></ul></li><li>软硬件交互部分<ul><li>接口interface</li><li>软硬件之间数据通信依赖于此接口</li></ul></li></ul><h3 id="1-3-2-弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信"><a href="#1-3-2-弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信" class="headerlink" title="1.3.2 弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信"></a>1.3.2 弄清楚验证环境中各个验证组件之间的位置层次关系以及它们之间是否有数据通信</h3><p>例如：我们对mcdt的数据通道发送数据，必须通过channel_interface，而驱动channel_interface的组件时<strong>channel_initiator</strong></p><p>channel_initiator，它从channel_generator获得需要发送的<strong>随机数据</strong>，而这些数据内容按照我们之前了解的接口时序协议驱动到接口上面</p><p>而channel_generator与channel_initiator之间存在数据通信关系，前者创建随机数据事务<strong>transcation</strong>实例，并发送到initiator，这种通信关系利用到之前学的sv通信要素<strong>mailbox</strong></p><p>channel_monitor与MCDT_monitor需要在各自接口上检测到MCDT的接口数据，并且写入到transcation实例中，发送到checker</p><p>最后checker将输入和输出数据做数据检查，从monitor到checker的数据通信也是基于事物的，也是mailbox实现</p><p>可以从这种验证组件之间的通信关系，验证组建之间的通信都是基于<strong>事务级</strong>的传送，而验证组件和硬件端口之间的通信必须以来接口，通过硬件时序才能实现</p><h3 id="1-3-3-能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的"><a href="#1-3-3-能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的" class="headerlink" title="1.3.3 能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的"></a>1.3.3 能够理解情节，仿真时如何开始运转，各个验证组件如何展开工作，而最后仿真又是结束的</h3><p>也可将这一要点理解为，验证如何展开运行</p><p>在接下来各个核心验证组件，和环境集成的代码中，我们理解到，每一个验证组件他们的单一职责是什么，各个验证组件如何运转的，仿真是如何开始如何结束的</p><hr><p>channel_initiator与channel_monitor一一对应</p><p>initiator与monitor被封装在agent中</p><p>由于arbiter不需要握手，因此只外置了mcdt monitor而不需要mcdt responder，即不需要任何数据反馈</p><p>两种类型的Monitor都将检测到的数据写入transcation实例并发送到mcdt_checker</p><p>mcdt_checker内置若开FIFO，接受从MCDT的输入端和输出端检测到的数据</p><p>由于checker输入和输出端FIFO中存储的数据类型一致，这也给做数据比较带来了方便</p><h1 id="2-实现stiumlator"><a href="#2-实现stiumlator" class="headerlink" title="2 实现stiumlator"></a>2 实现stiumlator</h1><h2 id="2-1-目前实现结构图"><a href="#2-1-目前实现结构图" class="headerlink" title="2.1 目前实现结构图"></a>2.1 目前实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116141617844.png" alt="目前实现结构图"></p><p>还没实现，所以一片空白</p><h2 id="2-2-如何实现channel-generator-channel-initiator"><a href="#2-2-如何实现channel-generator-channel-initiator" class="headerlink" title="2.2 如何实现channel_generator,channel_initiator"></a>2.2 如何实现channel_generator,channel_initiator</h2><p>generator：产生数据</p><p>initiator：将这些数据解析并驱动到interface的驱动组件</p><p>transcation:用来定义一个抽象数据的数据包内容</p><h2 id="2-3-channel-transcation"><a href="#2-3-channel-transcation" class="headerlink" title="2.3 channel_transcation"></a>2.3 channel_transcation</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116172647941.png" alt="image-20211116172647941"></p><p>数据成员有若干个<code>rand</code>形变量</p><p>并针对数据成员声明了有效的数据约束，用来对单个随机变量或多个随机变量之间加以约束</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">data:</span>容纳一个数据包所有数据的动态数组data<br><span class="hljs-symbol">ch_id:</span>channel_id表示数据源<br><span class="hljs-symbol">pkg_id:</span>package_id表示数据所在数据包的packageid<br><span class="hljs-symbol">data_nidel:</span>控制数据包内相邻数据间隔周期的<br><span class="hljs-symbol">pkg_nidel:</span>相邻数据包间隔周期<br><span class="hljs-symbol">rsp:</span>用来表示反馈的(非随机)<br><span class="hljs-symbol">obj_id:</span>当前实例id(非随机)<br></code></pre></div></td></tr></table></figure><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116173239063.png" alt="image-20211116173239063"></p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">new:</span>构造函数<br><span class="hljs-symbol">clone:</span>当前实例克隆，包括两个操作：①创建新的实例②当前示例的数据成员拷贝到新实例对应成员，最后返回句柄<br></code></pre></div></td></tr></table></figure><h2 id="2-4-channel-initiator"><a href="#2-4-channel-initiator" class="headerlink" title="2.4 channel_initiator"></a>2.4 channel_initiator</h2><h3 id="2-4-1-定义"><a href="#2-4-1-定义" class="headerlink" title="2.4.1 定义"></a>2.4.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116173441139.png" alt="image-20211116173441139"></p><p>从channel_generator获取，channel_transcation数据，并且将其中的数据驱动到接口interface上</p><p>成员变量包括：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">name</span><br>虚接口:channel_interfadce<br>与channel_generator做数据通信的两个mailbox句柄,request_mailbox,response_maibox<br></code></pre></div></td></tr></table></figure><p>成员方法</p><figure class="highlight ceylon"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ceylon">chnl<span class="hljs-number">_</span>initiator的<span class="hljs-keyword">new</span>函数中，它将参数赋值给了成员变量<br>set<span class="hljs-number">_</span><span class="hljs-keyword">interface</span>函数作用是为了从外部获得接口指针，并赋值于自己的虚接口成员变量，在类似句柄或者虚接口赋值过程中经常会做句柄或虚接口是否为空的判断，以免发生空句柄赋值<br></code></pre></div></td></tr></table></figure><h3 id="2-4-2-任务：run运行任务"><a href="#2-4-2-任务：run运行任务" class="headerlink" title="2.4.2 任务：run运行任务"></a>2.4.2 任务：run运行任务</h3><p>chnl_initiator的run是个task任务</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116182335043.png" alt="image-20211116182335043"></p><p>它表示，该组件在验证环境开始时的职责就是调用driver任务，在接口上做数据驱动激励，在driver任务中他会等待系统复位信号释放后，利用forever循环语句不断地从request_mailbox中获取激励数据，并且将其通过chnl_write方法写出到接口上面，待发送完毕之后，还要克隆request数据再将其数据成员response值为1</p><p>并且将反馈数据respose句柄通过resposen_mailbox写回到generator，如此完成了initiator和generator之间的<strong>事务数据握手</strong></p><p>需要注意：Initiator或许和返回数据的两个句柄requestmb,respnosemb并没有在initiator中例化，而是在稍后的generator中例化的</p><h3 id="2-4-3-任务：chnl-write，chnl-idle"><a href="#2-4-3-任务：chnl-write，chnl-idle" class="headerlink" title="2.4.3  任务：chnl_write，chnl_idle"></a>2.4.3  任务：chnl_write，chnl_idle</h3><ul><li>chnl_write数据驱动</li><li>chnl_idle数据复位</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116183030785.png" alt="image-20211116183030785"></p><p>chnl_write ：</p><ul><li>从chnl_transcation对象中抽取动态数据data中的每一个子成员</li><li>在时钟上升沿，将其与valid信号一同置为有效发送到接口上面，且按照协议要求只在ch_ready为高时认为此次数据发送完好处呢</li><li>在相邻数据之间插入若干空闲周期</li></ul><p>chnl_idle：</p><ul><li>在时钟上升沿，将接口中的valid与data同时置为零</li></ul><h3 id="2-4-4-为什么没有channel-transcation没有体现在结构图中"><a href="#2-4-4-为什么没有channel-transcation没有体现在结构图中" class="headerlink" title="2.4.4  为什么没有channel_transcation没有体现在结构图中"></a>2.4.4  为什么没有channel_transcation没有体现在结构图中</h3><p>为什么没有channel_transcation没有体现在结构图中，是因为它作为chnl_init与chnl_gen之间通信的数据事务，并非验证结构中的成员</p><h2 id="2-5-channel-generator"><a href="#2-5-channel-generator" class="headerlink" title="2.5 channel_generator"></a>2.5 channel_generator</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116192157072.png" alt="image-20211116192157072"></p><p>与trans相似的是都有rand变量与相应约束</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>函数例化两个信箱<br></code></pre></div></td></tr></table></figure><h3 id="2-5-2-任务：run运行任务"><a href="#2-5-2-任务：run运行任务" class="headerlink" title="2.5.2 任务：run运行任务"></a>2.5.2 任务：run运行任务</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116192705880.png" alt="image-20211116192705880"></p><ul><li>调用了多次创建数据事务，并且发送个chnl_init的任务</li><li>发送完之后，调用用来控制仿真结束的旗语<code>run_stop_flags.put</code>,返回了一把钥匙</li></ul><h3 id="2-5-3-任务：send-trans"><a href="#2-5-3-任务：send-trans" class="headerlink" title="2.5.3 任务：send_trans"></a>2.5.3 任务：send_trans</h3><ul><li>chnl_init先创建了事务实例request，并调用randomize函数王城随机化</li><li>将随机化的实例request放到rsq_mb中，这个放入的句柄稍后被initor取出</li><li>同时genor从rsp_mb中等待initor返回的response事务</li></ul><p><strong>利用这两个组件完成initor与genor的一次握手</strong></p><p>如何理解：genor的约束变量与创建并随机化的实例rsq做的组合，进而将约束完成层次化的控制传递</p><h2 id="2-6-chnl-initiator与chnl-generator"><a href="#2-6-chnl-initiator与chnl-generator" class="headerlink" title="2.6 chnl_initiator与chnl_generator"></a>2.6 chnl_initiator与chnl_generator</h2><p>chnl_initor与chnl_gen or通过mailbox连接，在最后一张环境集成中讲解</p><h1 id="3-实现monitor与checker"><a href="#3-实现monitor与checker" class="headerlink" title="3 实现monitor与checker"></a>3 实现monitor与checker</h1><h2 id="3-1-目前实现结构图"><a href="#3-1-目前实现结构图" class="headerlink" title="3.1 目前实现结构图"></a>3.1 目前实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116193349393.png" alt="目前实现结构图"></p><h2 id="3-1-monitor"><a href="#3-1-monitor" class="headerlink" title="3.1 monitor"></a>3.1 monitor</h2><p>两种检测器：</p><ul><li>channel_monitor依靠对应的channel_interface，从接口获取写入每个通道从端的数据，并打包整理写入到监测数据中</li><li>MCDT_monitor依靠另外接口，获取MCDT最终送出去的数据，也打包整理写入到监测数据中</li></ul><p>有时候monitor和stiumlator可以选择相同的trans，做数据解析或写入</p><p>实验中用自定义的结构体monitor_data用于存放检测到的数据，也被chnl_monitor和MCDT_monitor同时使用</p><h2 id="3-2-monitor-data"><a href="#3-2-monitor-data" class="headerlink" title="3.2 monitor data"></a>3.2 monitor data</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116201845632.png" alt="image-20211116201845632"></p><p>只定义两个成员，因为对于两个Monitor没有数据包的概念，每个数据之间不存在联系，因此用chnl_trans做监测数据的事务类型是不妥的</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>只是单数据而不是数组，不同于chnl_trans定义的动态数组</span><br><span class="hljs-title">id</span><br></code></pre></div></td></tr></table></figure><h2 id="3-3-channel-monitor"><a href="#3-3-channel-monitor" class="headerlink" title="3.3 channel_monitor"></a>3.3 channel_monitor</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116201820105.png" alt="image-20211116201820105"></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">name变量，在<span class="hljs-keyword">new</span><span class="hljs-type"></span>中赋值，用于后期的数据打印的消息中标记每个chnl_monitor名字<br>chnl_intf，同chnl_initiator，由外部传入接口指针<br>mon_mb：用于发送检测到书的mailbox句柄，没有例化，利用句柄，最终写到了checker中的mailbox实例<br></code></pre></div></td></tr></table></figure><h3 id="3-3-2-任务run"><a href="#3-3-2-任务run" class="headerlink" title="3.3.2 任务run"></a>3.3.2 任务run</h3><p>chnl_monitor同initiator与generator，在验证环境运行时执行工作，所以也有任务run</p><p>用于不断地等待输出数据事件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116202603263.png" alt="image-20211116202603263"></p><p>用于判断什么时候的采集数据是有效的：时钟上升沿的同时，valid===1并且ready===1</p><p>注意三个等号，用来判断四值逻辑变量</p><p>chnl_data数据写入到监测数据中，并通过mon_mb写入到checker中的监测数据缓存里面</p><h2 id="3-4-MCDT-Monitor"><a href="#3-4-MCDT-Monitor" class="headerlink" title="3.4 MCDT Monitor"></a>3.4 MCDT Monitor</h2><h3 id="3-4-1-定义"><a href="#3-4-1-定义" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p>成员变量和方法与chnl_mon类似，只是传入的指针接口是<strong>mcdt_interface</strong>，因为该接口监控与驱动的数据内容不同于chnl_interface</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116202955592.png" alt="image-20211116202955592"></p><h3 id="3-4-2-任务：mon-trans"><a href="#3-4-2-任务：mon-trans" class="headerlink" title="3.4.2 任务：mon_trans"></a>3.4.2 任务：mon_trans</h3><p>不断地等待有效的输出数据事件</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203146373.png" alt="image-20211116203146373"></p><p>由于MCDT的输出数据同时还包括id信息，所以需要将mcdt_data , mcdt_id都写入到检测数据中</p><h1 id="4-checker"><a href="#4-checker" class="headerlink" title="4 checker"></a>4 checker</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203423848.png" alt="目前实现的结构"></p><h2 id="3-4-checker"><a href="#3-4-checker" class="headerlink" title="3.4 checker"></a>3.4 checker</h2><h3 id="3-4-1-定义-1"><a href="#3-4-1-定义-1" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116203656979.png" alt="image-20211116203656979"></p><p>成员变量包括</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">name</span><br><span class="hljs-attribute">error_count</span>：用于对错误比较技术<br><span class="hljs-attribute">cmp_count</span>：对所有比较技术<br><span class="hljs-attribute">in_mbs</span>[<span class="hljs-number">3</span>]：三个输入端监测数据的mailbox<br><span class="hljs-attribute">out_mb</span>：一个输出端检测数据的mailbox<br></code></pre></div></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>中分别对name、error_count、cmp_count做初始化<br>例化了所有的mb实例<br></code></pre></div></td></tr></table></figure><h3 id="3-4-2-任务：run"><a href="#3-4-2-任务：run" class="headerlink" title="3.4.2 任务：run"></a>3.4.2 任务：run</h3><p>运行方法，调用单一的指责方法do_compare()</p><hr><h3 id="3-4-3-任务：do-compare"><a href="#3-4-3-任务：do-compare" class="headerlink" title="3.4.3 任务：do_compare"></a>3.4.3 任务：do_compare</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116204108341.png" alt="image-20211116204108341"></p><p>是数据比较的核心</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">每次从输出端缓存mb中获取一个输出数据<br>凭借该输出数据ID判断从哪一个输入端缓存中获取数据<br>都获取数据之后进行比较<br>比较错误借助$<span class="hljs-keyword">error</span>打印错误信息,error_cnt计数<br>比较成功打印成功信息<br>无论成功失败每次比较给cmp_cnt计数<br></code></pre></div></td></tr></table></figure><h1 id="5-实现顶层环境和测试用例"><a href="#5-实现顶层环境和测试用例" class="headerlink" title="5 实现顶层环境和测试用例"></a>5 实现顶层环境和测试用例</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116210118259.png" alt="目前实现结构图"></p><h2 id="5-1-agent"><a href="#5-1-agent" class="headerlink" title="5.1 agent"></a>5.1 agent</h2><p>基本的验证单元，或者被称为<strong>代理</strong>，本身不具备特定职责，只是在内部例化了initiator和monitor，并将它们作为小队组织在一起，这么做是因为无论激励还是监测，在验证环境中都是必不可少的，且每一个接口都对应着一个initiator和monitor</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211317271.png" alt="image-20211116211317271"></p><p>成员变量都在new中得到初始化和例化</p><p>也具备set_interface函数</p><hr><p><strong>任务：</strong>set_interface</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211721080.png" alt="image-20211116211721080"></p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">除了自身获得虚接口，还会进一步传递给initiator和<span class="hljs-literal">monitor</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>任务：</strong>run</p><p>并不承担其他职责而是负责唤醒initiator和monitor的run任务起到承上启下的作用</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116211908782.png" alt="image-20211116211908782"></p><h2 id="5-2-顶层环境mdct-root-test"><a href="#5-2-顶层环境mdct-root-test" class="headerlink" title="5.2 顶层环境mdct_root_test"></a>5.2 顶层环境mdct_root_test</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212050647.png" alt="image-20211116212050647"></p><h3 id="5-2-1-定义"><a href="#5-2-1-定义" class="headerlink" title="5.2.1 定义"></a>5.2.1 定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212312316.png" alt="image-20211116212312316"></p><p>成员对象包括：</p><ul><li>三个channel_generator(chnl_generator gen)</li><li>三个channle_agent(chnl_agent agent)</li><li>一个mcdt_monitor(mcdt_monitor mcdt_mon)</li><li>一个mcdt_check(mcdt_checker chker)</li></ul><p>成员变量：</p><ul><li>成员变量name</li><li>控制generator停止产生激励数据的<strong>事件</strong>generator_stop_event(gen_stop_e)</li></ul><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type"></span>对所有组件进行例化，将所有组件数据通信关系进行连接<br></code></pre></div></td></tr></table></figure><h3 id="5-2-2-new（续）"><a href="#5-2-2-new（续）" class="headerlink" title="5.2.2 new（续）"></a>5.2.2 new（续）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116212633341.png" alt="image-20211116212633341"></p><p>在连接组件之前对组件先进行例化</p><p>参照组件之间的通信关系，完成mailbox句柄赋值</p><h3 id="5-2-3-gen-stop-callback-run-stop-callback"><a href="#5-2-3-gen-stop-callback-run-stop-callback" class="headerlink" title="5.2.3 gen_stop_callback , run_stop_callback"></a>5.2.3 gen_stop_callback , run_stop_callback</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116213437000.png" alt="image-20211116213437000"></p><p>gen_stop_callback：</p><ul><li><p>mcdt_root_test是父类，没有对gen_stop_callback这个回调函数填充</p></li><li><p>如果成员变量，gen_stop_event被触发之后并且已经停止了，gen产生数据之后，还需要做什么额外的回调处理</p></li></ul><p>run_stop_callback：</p><ul><li>默认填充</li><li>等待三个generator在发送完所有激励数据后，且每个generator均交换了一把钥匙，可以从旗语run_stop_flags.get获得三把钥匙；接下来利用$finish结束仿真</li><li>mcdt_root_test是父类，没有对gen_stop_callback这个回调函数填充</li><li>run_stop_callback结合channel_generator发送完数据给旗语run_stop_flag交还钥匙的逻辑共同完成了对结束仿真的时序控制</li></ul><h3 id="5-2-4-run-顶层环境的运行任务"><a href="#5-2-4-run-顶层环境的运行任务" class="headerlink" title="5.2.4 run(顶层环境的运行任务)"></a>5.2.4 run(顶层环境的运行任务)</h3><p>起到调度整体环境组建的作用</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116224255876.png" alt="image-20211116224255876"></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">调用do<span class="hljs-emphasis">_config任务，该任务决定产生多少个什么样的随机数据事务</span><br><span class="hljs-emphasis">触发各个agent、mcdt_monitor、checker让他们各自开始执行</span><br><span class="hljs-emphasis">通识准备了等候gen_stop_</span>e的事件，并强行停止gen产生激励事物的线程<br></code></pre></div></td></tr></table></figure><p>使用并行线程<code>fork...join_none</code>语句，为的是启动程序而不阻碍各个程序执行</p><p>但本例没有用到这一特性</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225039863.png" alt="image-20211116225039863"></p><p>除了generator以外都进入到run的运行任务，但他们并没有走多远，因为他们没有generator生成的trans</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">因此最后使用<span class="hljs-string">``</span>fork<span class="hljs-params">...</span><span class="hljs-keyword">join</span><span class="hljs-string">``</span>控制generator开始运行<br>并且产生和发送随机事务给initiator<br>结束后调用run_stop_callback()<br></code></pre></div></td></tr></table></figure><h3 id="5-2-5-set-interface"><a href="#5-2-5-set-interface" class="headerlink" title="5.2.5 set_interface"></a>5.2.5 set_interface</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225450808.png" alt="image-20211116225450808"></p><p>set_interface：同channel_agent一致，主要做虚接口传递</p><p>do_config：</p><ul><li>空函数，在子类中填充</li><li>用于随机化控制产生多少个，什么样内容的随机数据transcation</li></ul><h2 id="5-3-父类实现结构图"><a href="#5-3-父类实现结构图" class="headerlink" title="5.3 父类实现结构图"></a>5.3 父类实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116225710606.png" alt="目前实现结构图"></p><p>至此我们使用顶层盒子mcdt_root_test封装了这些组件</p><p>并通过.run运行任务</p><h2 id="5-4-do-config重定义"><a href="#5-4-do-config重定义" class="headerlink" title="5.4 do_config重定义"></a>5.4 do_config重定义</h2><p>在触发组件运行之前，需确定需要产生什么样的数据激励(重定义do_config函数)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230019374.png" alt="image-20211116230019374"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230104837.png" alt="image-20211116230104837"></p><p>通过对三个generator随机化，指定了各个chnl_gen需要产生的数据事务器(trans)的数量、数据之间和数据包之间的空闲周期、每个数据包的数据容量中</p><p>在随机化过程中，通过立即断言判断随机化是否成功。如果失败使用$fatal报告错误信息并停止仿真</p><h2 id="5-5-最后实现结构图"><a href="#5-5-最后实现结构图" class="headerlink" title="5.5 最后实现结构图"></a>5.5 最后实现结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211116230119510.png" alt="目前实现结构图"></p><p><strong>没有激励，整个环境无法运转</strong></p><p><strong>所有激励发送结束以后可以结束仿真</strong></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld | SV实验0 | SV实验1</title>
    <link href="/202111151136/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/202111151136/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1 创建工程"></a>1 创建工程</h3><p>不会新建项目文件夹需要自己mkdir</p><h3 id="2-创建sv文件"><a href="#2-创建sv文件" class="headerlink" title="2 创建sv文件"></a>2 创建sv文件</h3><ul><li>你想做任何工作，要在module里面才能运行</li><li>initial包括所有过程语句</li></ul><h3 id="3-gvim编辑"><a href="#3-gvim编辑" class="headerlink" title="3 gvim编辑"></a>3 gvim编辑</h3><h3 id="4-Project-gt-compile"><a href="#4-Project-gt-compile" class="headerlink" title="4 Project-&gt;compile"></a>4 Project-&gt;compile</h3><h3 id="5-Library-gt-simulate-without-optimization"><a href="#5-Library-gt-simulate-without-optimization" class="headerlink" title="5 Library-&gt;simulate without optimization"></a>5 Library-&gt;simulate without optimization</h3><p>编译到库里面（前面新建的时候默认work），之后在库里面仿真</p><p><strong>好像会出错</strong>，因此这里不使用without optimization，直接命令行vsim work.tb</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vsim work.tb<br></code></pre></div></td></tr></table></figure><h3 id="6-run"><a href="#6-run" class="headerlink" title="6 run"></a>6 run</h3><p>命令行输入run</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">run<br></code></pre></div></td></tr></table></figure><h1 id="SV实验0"><a href="#SV实验0" class="headerlink" title="SV实验0"></a>SV实验0</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><p>认识什么是设计功能描述文档</p><p>是设计功能描述文档</p><h2 id="2-设计结构"><a href="#2-设计结构" class="headerlink" title="2.设计结构"></a>2.设计结构</h2><h3 id="2-1-MCDF"><a href="#2-1-MCDF" class="headerlink" title="2.1 MCDF"></a>2.1 MCDF</h3><p>多通道数据整形器MCDF, mult-channel data formatter</p><p>FIFO的margin信号提示内部缓存余量</p><ul><li>Arbiter：仲裁</li><li>Formatter：Formatter输出明显比输入多，时序与输入不同</li><li>Registers：功能寄存器，起到配置MCDF作用<ul><li>使能具体channel（哪个channel工作）</li><li>channel优先级</li><li>输出数据包长度</li><li>….</li></ul></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223932224.png" alt=""></p><h3 id="2-2-实验0实现结构"><a href="#2-2-实验0实现结构" class="headerlink" title="2.2 实验0实现结构"></a>2.2 实验0实现结构</h3><p>降低难度要求</p><p><img src="../../../../img/SV实验一/image-20211122214540946.png" alt="image-20211122214540946"></p><h3 id="2-3-需要准备的源代码"><a href="#2-3-需要准备的源代码" class="headerlink" title="2.3 需要准备的源代码"></a>2.3 需要准备的源代码</h3><p>每次运行一个实验前把mcdt三个<strong>设计</strong>文件（arbiter.v, mcdt.v, slave_fifo.v)，与tb.v文件都放在一个文件夹里面</p><h2 id="3-实验步骤"><a href="#3-实验步骤" class="headerlink" title="3.实验步骤"></a>3.实验步骤</h2><p>有人会问只编译tb那<strong>DUT</strong>怎么办，实际上DUT就在tb里面</p><p><strong>实验1，实验2是在实验0很简单的基础上一步一步修改</strong></p><h3 id="3-1熟悉questasim"><a href="#3-1熟悉questasim" class="headerlink" title="3.1熟悉questasim"></a>3.1熟悉questasim</h3><ul><li>前面没重点</li></ul><hr><ul><li><strong>库</strong>（questasim-&gt;library）<ul><li>与sv中的package的区别（在SVpackage中讲的）</li><li>同时库和你的工程是完全两个概念</li></ul></li></ul><p><img src="../../../../img/SV实验一/image-20211122220405589.png" alt="image-20211122220405589"></p><p>work里面包含编译后的module</p><p>双击这些module可以运行仿真，但单个module运行没有作用</p><hr><ul><li><strong>transcript</strong>可以输入命令</li></ul><h3 id="3-2编译"><a href="#3-2编译" class="headerlink" title="3.2编译"></a>3.2编译</h3><ul><li>先编译设计<ol><li>编译底层的模块：arbiter和slave_fifo</li><li>编译上层的mcdt</li></ol></li><li>再编译tb文件</li></ul><h3 id="3-3-simulate"><a href="#3-3-simulate" class="headerlink" title="3.3 simulate"></a>3.3 simulate</h3><p>藩镇建议simulate without optimazition：不逻辑优化的仿真</p><h3 id="3-4-Add-Wave"><a href="#3-4-Add-Wave" class="headerlink" title="3.4 Add Wave"></a>3.4 Add Wave</h3><p>shift从上到下选中，右键Add Wave</p><p><img src="../../../../img/SV实验一/image-20211122230540347.png" alt="image-20211122230540347"></p><p>此时右边会出现波形窗口</p><h3 id="3-5-运行1us"><a href="#3-5-运行1us" class="headerlink" title="3.5 运行1us"></a>3.5 运行1us</h3><p><img src="../../../../img/SV实验一/image-20211122230907458.png" alt="image-20211122230907458"></p><h3 id="3-6-放大波形显示"><a href="#3-6-放大波形显示" class="headerlink" title="3.6 放大波形显示"></a>3.6 放大波形显示</h3><ul><li>键盘敲击F：整个波形适应窗口显示</li><li>鼠标滚轮按住拖动：放大区间内波形</li></ul><h3 id="可选-调整sim结构窗口内容"><a href="#可选-调整sim结构窗口内容" class="headerlink" title="(可选)调整sim结构窗口内容"></a>(可选)调整sim结构窗口内容</h3><p>sim结构窗口内容中有：module，task，过程块，语句等等</p><p>当我们不需要看这么多东西时我们怎么设置</p><p><img src="../../../../img/SV实验一/image-20211122230042510.png" alt="image-20211122230042510"></p><p><img src="../../../../img/SV实验一/image-20211122230053149.png" alt="image-20211122230053149"></p><hr><p>或者</p><h3 id="可选-object"><a href="#可选-object" class="headerlink" title="(可选)object"></a>(可选)object</h3><p>窗口显示信号</p><p><img src="../../../../img/SV实验一/image-20211122230319699.png" alt="image-20211122230319699"></p><ul><li>In：输入信号，后缀_i</li><li>Out：输出信号，后缀_o</li><li>Internal：内部信号，后缀_s</li></ul><h3 id="可选-Wave窗口不显示路径"><a href="#可选-Wave窗口不显示路径" class="headerlink" title="(可选)Wave窗口不显示路径"></a>(可选)Wave窗口不显示路径</h3><p><img src="../../../../img/SV实验一/image-20211122230719067.png" alt="image-20211122230719067"></p><p><img src="../../../../img/SV实验一/image-20211122230724187.png" alt="image-20211122230724187"></p><h1 id="三个小实验"><a href="#三个小实验" class="headerlink" title="三个小实验"></a>三个小实验</h1><p>f</p><h1 id="SV实验1"><a href="#SV实验1" class="headerlink" title="SV实验1"></a>SV实验1</h1>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机linux系统忘记密码修改root或其他用户密码的方法</title>
    <link href="/202111151029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E7%B3%BB%E7%BB%9F%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9root%E6%88%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/202111151029/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Linuxessay/debug/%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E7%B3%BB%E7%BB%9F%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9root%E6%88%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机linux系统忘记密码修改root或其他用户密码的方法"><a href="#虚拟机linux系统忘记密码修改root或其他用户密码的方法" class="headerlink" title="虚拟机linux系统忘记密码修改root或其他用户密码的方法"></a>虚拟机linux系统忘记密码修改root或其他用户密码的方法</h1><span id="more"></span><p>本文基于centos7环境进行操作，由于centos的版本是有差异的，继续之前请确定好版本。</p><h2 id="解决方法一（可能存在权限问题）"><a href="#解决方法一（可能存在权限问题）" class="headerlink" title="解决方法一（可能存在权限问题）"></a>解决方法一（可能存在权限问题）</h2><p>(1) 重启系统，在开机过程中，快速按下键盘上的方向键↑和↓。目的是告知引导程序，我们需要在引导页面选择不同的操作，以便让引导程序暂停</p><p>以下是暂停后的界面，可以查看下方的英文可知↑和↓的作用。 </p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112334445.png" alt="image-20211115112334445"></p><p>(2) 使用↑和↓将选择行设置为第一行（背景高亮即为选中），按下键盘上的e，进入编辑模式</p><p>(3) 将光标一直移动到 <code>LANG=en_US.UTF-8</code>后面，空格，再追加<code>init=/bin/sh</code>。这里特别注意，需要写在UTF-8后，保持在同一行，并注意空格。有些虚拟机由于屏幕太小，会自动添加\换行，这个是正常的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">init=/bin/sh<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112557239.png" alt="image-20211115112557239"></p><p>(4) 按下CTRL+X进行引导启动，成功后进入该界面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115112624497.png" alt="image-20211115112624497"></p><p>(5) 输入以下命令</p><ul><li>挂载根目录  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mount -o remount, rw /<br></code></pre></div></td></tr></table></figure><ul><li>选择要修改密码的用户名，这里选择root用户进行修改，可以更换为你要修改的用户  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">passwd root<br></code></pre></div></td></tr></table></figure><ul><li>输入2次一样的新密码，注意输入密码的时候屏幕上不会有字符出现。  </li></ul><p>如果输入的密码太简单，会提示警告（BAD PASSWORD：Thepassword fails the dictionary check – it is too simplistic/systematic），可以无视它，继续输入密码，不过建议还是设置比较复杂一些的密码，以保证安全性</p><ul><li>如果已经开启了SElinux，则需要输入以下命令  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch /.autorelabel<br></code></pre></div></td></tr></table></figure><ul><li>最后输入以下命令重启系统即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> /sbin/init <br></code></pre></div></td></tr></table></figure><h2 id="解决方法二（未测试）"><a href="#解决方法二（未测试）" class="headerlink" title="解决方法二（未测试）"></a>解决方法二（未测试）</h2><p>(1)(2)(3)(4) 前四步同方法一</p><p>(5) 输入以下命令</p><p>输入以下命令</p><ul><li>挂载根目录  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mount -o remount, rw /<br></code></pre></div></td></tr></table></figure><ul><li>选择要修改密码的用户名，这里选择root用户进行修改，可以更换为你要修改的用户  </li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">passwd root<br></code></pre></div></td></tr></table></figure><ul><li>输入2次一样的新密码，注意输入密码的时候屏幕上不会有字符出现。  </li></ul><p>如果输入的密码太简单，会提示警告（BAD PASSWORD：Thepassword fails the dictionary check – it is too simplistic/systematic），可以无视它，继续输入密码，不过建议还是设置比较复杂一些的密码，以保证安全性</p><ul><li>vi etc/selinux/config 把 enforcing 改为 disable</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vi etc/selinux/config<br></code></pre></div></td></tr></table></figure><ul><li>最后输入以下命令重启系统即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> /sbin/init 或 <span class="hljs-built_in">exec</span> /sbin/reboot<br></code></pre></div></td></tr></table></figure><h3 id="方法一解决权限问题，同时也是方法二更改enforcing为disable"><a href="#方法一解决权限问题，同时也是方法二更改enforcing为disable" class="headerlink" title="方法一解决权限问题，同时也是方法二更改enforcing为disable"></a>方法一解决权限问题，同时也是方法二更改enforcing为disable</h3><ul><li>查看SElinux状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">方法1：<br>[root@localhost ~]<span class="hljs-comment"># /usr/sbin/sestatus -v</span><br>SELinux status:                 enabled<br>SELinuxfs mount:                /selinux<br>Current mode:                   enforcing<br><br>方法2：<br>[root@localhost ~]<span class="hljs-comment"># getenforce</span><br>Enforcing<br></code></pre></div></td></tr></table></figure><ul><li>关闭SELinux</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1、临时关闭（不用重启机器）：<br>setenforce 0    <span class="hljs-comment">#设置SELinux 成为permissive模式</span><br><span class="hljs-comment">#setenforce 1    #设置SELinux 成为enforcing模式</span><br><br><br>2、修改配置文件需要重启机器：<br>vi /etc/selinux/config<br>将SELINUX=enforcing改为SELINUX=disabled<br>重启<br></code></pre></div></td></tr></table></figure><h3 id="仅仅求改某个文件的权限？"><a href="#仅仅求改某个文件的权限？" class="headerlink" title="仅仅求改某个文件的权限？"></a>仅仅求改某个文件的权限？</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">chown root:root /usr/bin/passwd<br>chmod u=rwx,go=rx,u+s /usr/bin/passwd<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解决方法</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解决方法</tag>
      
      <tag>Linux</tag>
      
      <tag>Centos</tag>
      
      <tag>账户</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo执行hexo d时报错：OpenSSL SSL_read：Connection was aborted , errno 10053</title>
    <link href="/202111141924/%E9%80%9A%E7%9F%A5notify/hexo_d%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <url>/202111141924/%E9%80%9A%E7%9F%A5notify/hexo_d%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo执行hexo-d时报错：OpenSSL-SSL-read-Connection-was-aborted-errno-10053"><a href="#hexo执行hexo-d时报错：OpenSSL-SSL-read-Connection-was-aborted-errno-10053" class="headerlink" title="hexo执行hexo d时报错：OpenSSL SSL_read: Connection was aborted, errno 10053"></a>hexo执行hexo d时报错：OpenSSL SSL_read: Connection was aborted, errno 10053</h1><span id="more"></span><p>git遇到fatal: unable to access ‘<a href="https://github.com/xxx/xxx/’:OpenSSL">https://github.com/xxx/xxx/’:OpenSSL</a> SSL_read: Connection was aborted, errno 10053的问题</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Git默认限制推送的大小，运行命令更改限制大小即可</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>增加缓冲</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config http.postBuffer 524288000<br></code></pre></div></td></tr></table></figure><ol><li>更改网络认证设置</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global http.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解决方法</tag>
      
      <tag>GIT</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDA工具学习目录</title>
    <link href="/202111141521/IC/sv%E5%AD%A6%E4%B9%A0/EDAessay/ic/sv%E5%AD%A6%E4%B9%A0/EDA%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/"/>
    <url>/202111141521/IC/sv%E5%AD%A6%E4%B9%A0/EDAessay/ic/sv%E5%AD%A6%E4%B9%A0/EDA%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="EDA工具"><a href="#EDA工具" class="headerlink" title="EDA工具"></a>EDA工具</h1><p>三家公司</p><ul><li>Synopsys：<ul><li>VCS(常用且好用)</li></ul></li><li>Canddence<ul><li>irun</li></ul></li><li>Mentor：<ul><li>modelsim(用于FPGA)</li><li>questasim(linux用于ic验证)</li></ul></li></ul><h2 id="我的虚拟机环境"><a href="#我的虚拟机环境" class="headerlink" title="我的虚拟机环境"></a>我的虚拟机环境</h2><h3 id="1-已安装IC工具及命令"><a href="#1-已安装IC工具及命令" class="headerlink" title="1 已安装IC工具及命令"></a>1 已安装IC工具及命令</h3><p><strong>Synopsys：</strong></p><ul><li>vcs(-SP2)</li><li>vcs_mx（-SP2）</li><li>vcs_mx（-1）</li><li>verdi</li><li>dve</li><li>pt</li><li>icc2</li><li>dc</li><li>dv（dc的gui）</li><li>spyglass</li><li>synplify</li></ul><hr><p><strong>Cadence：</strong></p><ul><li>IC617：virtuoso</li><li>INCISIVE152：irun、simvision、imc等</li></ul><hr><p><strong>Mentor：</strong></p><ul><li>questasim10.7c（带UVM）</li></ul><hr><p><strong>开源工具：</strong></p><ul><li>iverilog</li><li>gtkwave（有问题用不了）</li></ul><hr><p><strong>FPGA：</strong></p><ul><li>vivado2019.1</li></ul><hr><p><strong>工艺库：</strong></p><ul><li>TSMC_018</li><li>TSMC_013</li><li>smic180</li></ul><hr><p><strong>其他：</strong></p><ul><li>git</li><li>gvim</li></ul><h3 id="2-工具所在目录"><a href="#2-工具所在目录" class="headerlink" title="2 工具所在目录"></a>2 工具所在目录</h3><p>​    工具均在home下</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115215509575.png" alt="image-20211115215509575"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115215520781.png" alt="image-20211115215520781"></p><h3 id="3-vivado与vcs"><a href="#3-vivado与vcs" class="headerlink" title="3 vivado与vcs"></a>3 vivado与vcs</h3><p>​    vivado与第三方仿真工具之间是有版本要求的，需要按照Xilinx官方要求进行匹配，Vivado2019.1与VCS-MX2018.09-1匹配，目前环境中默认使用VCS-MX2018.09-1，并且已编译好Vivado IP库；<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/640.webp" alt="图片"></p><h3 id="4-联网"><a href="#4-联网" class="headerlink" title="4 联网"></a>4 联网</h3><p>​    默认是断开网络的，需要联网时，保证电脑联网，然后在虚拟机中点击“链接”；<br>​    注意：联网会影响仿真速度；<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/640-16369845593362.webp" alt="图片"></p><h2 id="补充-基于standcell的ASIC设计流程"><a href="#补充-基于standcell的ASIC设计流程" class="headerlink" title="补充(基于standcell的ASIC设计流程)"></a>补充(基于standcell的ASIC设计流程)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115120359764.png" alt="image-20211115120359764"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211115120515745.png" alt="image-20211115120515745"></p><h1 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h1><span id="more"></span><p>x.x.x代表文件夹目录</p><p>(x)代表具体文件</p><h2 id="1-SV-2pro"><a href="#1-SV-2pro" class="headerlink" title="1 SV 2pro"></a>1 SV 2pro</h2><h3 id="1-1-Questasim"><a href="#1-1-Questasim" class="headerlink" title="1.1 Questasim"></a>1.1 Questasim</h3><h4 id="1-014-Questasim基本使用"><a href="#1-014-Questasim基本使用" class="headerlink" title="(1) 014 Questasim基本使用"></a>(1) 014 Questasim基本使用</h4><p>03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><h4 id="2-Questasim安装教程"><a href="#2-Questasim安装教程" class="headerlink" title="(2) Questasim安装教程"></a>(2) Questasim安装教程</h4><p>04配套软件安装教程</p><h4 id="3-Questasim使用指导HelloWord"><a href="#3-Questasim使用指导HelloWord" class="headerlink" title="(3) Questasim使用指导HelloWord"></a>(3) Questasim使用指导HelloWord</h4><p>04配套软件安装教程</p><h3 id="1-2-DVT"><a href="#1-2-DVT" class="headerlink" title="1.2 DVT"></a>1.2 DVT</h3><h4 id="1-DVT-帮助理解实验代码"><a href="#1-DVT-帮助理解实验代码" class="headerlink" title="(1) DVT 帮助理解实验代码"></a>(1) DVT 帮助理解实验代码</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152600764.png" alt="image-20211114152600764"></p><h3 id="1-3-VCS"><a href="#1-3-VCS" class="headerlink" title="1.3 VCS"></a>1.3 VCS</h3><h4 id="1-015-Linux-VCS编译仿真步骤"><a href="#1-015-Linux-VCS编译仿真步骤" class="headerlink" title="(1) 015 Linux VCS编译仿真步骤"></a>(1) 015 Linux VCS编译仿真步骤</h4><p>03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><h2 id="2-SV-2pro增量"><a href="#2-SV-2pro增量" class="headerlink" title="2 SV 2pro增量"></a>2 SV 2pro增量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152258160.png" alt="image-20211114152258160"></p><h3 id="2-1-DVT"><a href="#2-1-DVT" class="headerlink" title="2.1 DVT"></a>2.1 DVT</h3><h4 id="2-1-1-DVTEclipse集成开发环境"><a href="#2-1-1-DVTEclipse集成开发环境" class="headerlink" title="2.1.1 DVTEclipse集成开发环境"></a>2.1.1 DVTEclipse集成开发环境</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154032282.png" alt="image-20211114154032282"></p><h4 id="2-1-2-DVT工具项目运用"><a href="#2-1-2-DVT工具项目运用" class="headerlink" title="2.1.2 DVT工具项目运用"></a>2.1.2 DVT工具项目运用</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154145512.png" alt="image-20211114154145512"></p><h3 id="2-2-Tcl"><a href="#2-2-Tcl" class="headerlink" title="2.2 Tcl"></a>2.2 Tcl</h3><h4 id="2-2-1-CDV覆盖率驱动验证-Tcl基础"><a href="#2-2-1-CDV覆盖率驱动验证-Tcl基础" class="headerlink" title="2.2.1 CDV覆盖率驱动验证-Tcl基础"></a>2.2.1 CDV覆盖率驱动验证-Tcl基础</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154353695.png" alt="image-20211114154353695"></p><h3 id="2-3-CDV-验证流程管理"><a href="#2-3-CDV-验证流程管理" class="headerlink" title="2.3 CDV + 验证流程管理"></a>2.3 CDV + 验证流程管理</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154507425.png" alt="image-20211114154507425"></p><h3 id="2-4-Questasim仿真常用命令，Questasim脚本"><a href="#2-4-Questasim仿真常用命令，Questasim脚本" class="headerlink" title="2.4 Questasim仿真常用命令，Questasim脚本"></a>2.4 Questasim仿真常用命令，Questasim脚本</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114153740868.png" alt="image-20211114153740868"></p><h3 id="2-5-自动化流程辅助实现RA寄存器"><a href="#2-5-自动化流程辅助实现RA寄存器" class="headerlink" title="2.5 自动化流程辅助实现RA寄存器"></a>2.5 自动化流程辅助实现RA寄存器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154539950.png" alt="image-20211114154539950"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154549930.png" alt="image-20211114154549930"></p><h4 id="要点：MCDF验证结构自动生成"><a href="#要点：MCDF验证结构自动生成" class="headerlink" title="要点：MCDF验证结构自动生成"></a>要点：MCDF验证结构自动生成</h4><h3 id="2-6-Quseta-VRM"><a href="#2-6-Quseta-VRM" class="headerlink" title="2.6 Quseta VRM"></a>2.6 Quseta VRM</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154623889.png" alt="image-20211114154623889"></p><h3 id="2-7-VRM术语-XML基本语法-RMDB文件"><a href="#2-7-VRM术语-XML基本语法-RMDB文件" class="headerlink" title="2.7 VRM术语 + XML基本语法 + RMDB文件"></a>2.7 VRM术语 + XML基本语法 + RMDB文件</h3><h4 id="2-7-1-VRM术语"><a href="#2-7-1-VRM术语" class="headerlink" title="2.7.1 VRM术语"></a>2.7.1 VRM术语</h4><h4 id="2-7-2-XML基本语法"><a href="#2-7-2-XML基本语法" class="headerlink" title="2.7.2 XML基本语法"></a>2.7.2 XML基本语法</h4><h4 id="2-7-3-RMDB文件"><a href="#2-7-3-RMDB文件" class="headerlink" title="2.7.3 RMDB文件"></a>2.7.3 RMDB文件</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114154637793.png" alt="image-20211114154637793"></p><h3 id="3-选学"><a href="#3-选学" class="headerlink" title="3 选学"></a>3 选学</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114152229178.png" alt="image-20211114152229178"></p><h3 id="3-1-VCS仿真器操作指导"><a href="#3-1-VCS仿真器操作指导" class="headerlink" title="3.1 VCS仿真器操作指导"></a>3.1 VCS仿真器操作指导</h3><h4 id="1-VSC常用操作1-5"><a href="#1-VSC常用操作1-5" class="headerlink" title="(1) VSC常用操作1-5"></a>(1) VSC常用操作1-5</h4><h4 id="2-Verdi启动仿真"><a href="#2-Verdi启动仿真" class="headerlink" title="(2) Verdi启动仿真"></a>(2) Verdi启动仿真</h4><h3 id="3-2-Vim"><a href="#3-2-Vim" class="headerlink" title="3.2 Vim"></a>3.2 Vim</h3><h3 id="3-3-SVTAPB-VIP"><a href="#3-3-SVTAPB-VIP" class="headerlink" title="3.3 SVTAPB:VIP"></a>3.3 SVTAPB:VIP</h3><p><strong>VIP是指的别人提供给你的IP，是不开放的</strong></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114160013930.png" alt="封面图片"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114160331274.png" alt="封面图片"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>EDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>学习</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV|UVM 学习实验目录</title>
    <link href="/202111141520/IC/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/"/>
    <url>/202111141520/IC/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="SV实验"><a href="#SV实验" class="headerlink" title="SV实验"></a>SV实验</h1><h2 id="实验文件目录"><a href="#实验文件目录" class="headerlink" title="实验文件目录"></a>实验文件目录</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211114145633503.png" alt="image-20211114145633503"></p><h2 id="视频目录"><a href="#视频目录" class="headerlink" title="视频目录"></a>视频目录</h2><h3 id="DT帮助理解实验代码"><a href="#DT帮助理解实验代码" class="headerlink" title="DT帮助理解实验代码"></a>DT帮助理解实验代码</h3><p>目录：03学前指导</p><h3 id="实验0："><a href="#实验0：" class="headerlink" title="实验0："></a>实验0：</h3><p>目录：03【SV精通1】数据类型、过程方法、设计连接、验证结构</p><p>范围：</p><ul><li>014 Questasim基本使用</li><li>015 [选学] Linux VCS编译仿真步骤</li></ul><h3 id="实验1："><a href="#实验1：" class="headerlink" title="实验1："></a>实验1：</h3><p>目录1：07【SV精通2】接口采样驱动、测试结束开始、调试方法</p><p>范围：</p><ul><li>040 实验1验证结构</li><li>041 实验1代码讲解</li><li>实验一 思考如何发送更快更紧密的数据</li></ul><p>目录2：08【SV练习选修】练习一指导</p><p>范围：</p><ul><li><p>01-数据类型-1</p></li><li><p>02-数据类型-2</p></li><li>03-数据类型-3</li><li>04-字符串类型</li><li>05-接口类型</li></ul><h3 id="实验2："><a href="#实验2：" class="headerlink" title="实验2："></a>实验2：</h3><p>目录：09【SV精通3】类的方法和继承、动态对象、包的使用</p><p>范围：</p><ul><li>053 实验2验证结构</li><li>054 实验2代码讲解</li></ul><p>目录2：15【SV练习选修】练习二指导</p><ul><li>1数组类型-1</li><li>2数组类型-2</li><li>3类的封装</li><li>4类的继承</li><li>5包的使用</li></ul><h3 id="实验3："><a href="#实验3：" class="headerlink" title="实验3："></a>实验3：</h3><p>目录：12【SV精通4】实验3代码讲解</p><p>范围：</p><ul><li><p>068 实验3代码讲解1</p></li><li><p>069 实验3代码讲解2</p></li><li>070 实验3代码讲解3</li><li>071 实验3代码讲解4</li><li>072-9-13 直播答疑4</li><li>v2.1 lab3 fifo_full_test详解</li><li>v2.1 lab3 数据通过形象进行传输的理解</li><li>v2.1 lab3 时序逻辑采样和组合逻辑采样区别</li><li>v2.1 lab3 为什么不需要拷贝obj_id</li></ul><h3 id="实验4："><a href="#实验4：" class="headerlink" title="实验4："></a>实验4：</h3><p>目录：15【SV精通5】实验4代码详解</p><p>范围：</p><ul><li>085 实验4代码讲解1</li><li>086 实验4代码讲解2</li><li>087 实验4代码讲解3</li><li>088 实验4代码讲解4</li><li>089 实验4代码讲解5</li><li>090-9-20 直播答疑5</li></ul><h3 id="实验5："><a href="#实验5：" class="headerlink" title="实验5："></a>实验5：</h3><p>目录：17【SV精通7】高级话题</p><p>范围：</p><ul><li>103 实验5代码讲解1</li><li>104 实验5代码讲解2</li></ul><h1 id="UVM实验"><a href="#UVM实验" class="headerlink" title="UVM实验"></a>UVM实验</h1><h2 id="入门实验0"><a href="#入门实验0" class="headerlink" title="入门实验0"></a>入门实验0</h2><p>目录：24【UVM入门进阶2】核心基类、阶段、配置、消息机制</p><p>范围：</p><ul><li>101-UVM入门实验0讲解.mp4</li></ul><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>目录：24【UVM入门进阶2】核心基类、阶段、配置、消息机制</p><p>范围：</p><ul><li>102-UVM入门实验1讲解1</li><li>103-UVM入门实验1讲解2</li><li>v2.2 lab1 object创建名字传入问题</li></ul><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>目录：26【UVM入门进阶4】结构_、顶层方案、环境元素</p><p>范围：</p><ul><li>112-UVM入门实验2代码讲解1</li><li>112-UVM入门实验2代码讲解2</li><li>v2.2 lab2 创建对象返回的句柄为何要做转化</li><li>v2.2 lab2 为什么配置应先于组件创建</li><li>v2.2 lab2 组件的phase如何自动执行</li></ul><p>内容：</p><ul><li>把SV验证结构利用UVM机制进行改造</li><li>uvm结构在uvm_root下呈现树状结构<ul><li>没有做结构图是因为结构没有变化，只是SV组件替代到UVM组件 </li></ul></li></ul><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><p>目录：28【UVM入门进阶6】TLM2通信_同步通信</p><p>范围：</p><ul><li>122-UVM入门实验3代码讲解</li><li>v2.2 lab3 TLM端口通信缓存与信箱的比较</li><li>v2.2 lab3 回调与继承的应用区别</li></ul><p>内容：</p><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><p>目录：30【UVM入门进阶8】Sequencer仲裁_Sequence层次化</p><p>范围：</p><ul><li>132-UVM入门实验4代码讲解</li><li>v2.2 lab4 测试场景为什么在序列而不在test</li><li>v2.2 lab4 从SEQ到DRV的Item传输类型转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>uvm学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通7：高级话题|SV理论知识完结🎉</title>
    <link href="/202111122204/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A07%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <url>/202111122204/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A07%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h1><h2 id="概述：类型转换分为静态动态两种转换"><a href="#概述：类型转换分为静态动态两种转换" class="headerlink" title="概述：类型转换分为静态动态两种转换"></a>概述：类型转换分为静态动态两种转换</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112220604793.png" alt="image-20211112220604793"></p><p><strong>静态转换：</strong><code>int&#39;(4.0) //实数转成一个整形</code>,是否成功无从得知</p><p>动态转换：<code>$cast(tgt , src)</code>右边的转成左边的类型，可以把中间的”,”理解成”=”</p><h2 id="2-动态转换"><a href="#2-动态转换" class="headerlink" title="2 动态转换"></a>2 动态转换</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112220950634.png" alt="image-20211112220950634"></p><p>子类句柄转父类句柄：<code>h1=h2</code>，但转换成的父类句柄无法访问子类成员</p><p>父类句柄转子类句柄：<code>$cast(h2,h1)</code></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221319401.png" alt="image-20211112221319401"></p><p>答案：AB</p><h2 id="3-子类句柄赋值于父类句柄"><a href="#3-子类句柄赋值于父类句柄" class="headerlink" title="3 子类句柄赋值于父类句柄"></a>3 子类句柄赋值于父类句柄</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221502557.png" alt="image-20211112221502557"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221514473.png" alt="image-20211112221514473"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221558027.png" alt="image-20211112221558027"></p><p>A</p><hr><h2 id="4-父类句柄转换为子类句柄"><a href="#4-父类句柄转换为子类句柄" class="headerlink" title="4 父类句柄转换为子类句柄"></a>4 父类句柄转换为子类句柄</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221659539.png" alt="image-20211112221659539"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221721147.png" alt="image-20211112221721147"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221750376.png" alt="image-20211112221750376"></p><p>可以成功因为bad指向子类对象<br>tr也指向子类对象</p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112221916497.png" alt="image-20211112221916497"></p><p>答案：B</p><hr><h1 id="二、虚方法：virtual"><a href="#二、虚方法：virtual" class="headerlink" title="二、虚方法：virtual"></a>二、虚方法：virtual</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222220698.png" alt="image-20211112222220698"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222415541.png" alt="image-20211112222415541"></p><p><strong>为什么虚方法：</strong></p><p>父类句柄只能调用父类成员，子类句柄只能调用子类成员<br>当子类句柄赋值给父类句柄时，父类句柄调用的是父类中的<strong>同名成员</strong><br>想要调用，必须要把父类句柄转成子类句柄进行调用，<strong>不够简洁容易出错</strong></p><p>虚方法：</p><p>动态绑定(dynamic binding) / SV中称动态方法查找(dynamic method lookup)</p><h2 id="2-非虚函数的调用：即override覆盖写法-同名函数-，不是我们期望的"><a href="#2-非虚函数的调用：即override覆盖写法-同名函数-，不是我们期望的" class="headerlink" title="2 非虚函数的调用：即override覆盖写法(同名函数)，不是我们期望的"></a>2 非虚函数的调用：即override覆盖写法(同名函数)，不是我们期望的</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222914131.png" alt="image-20211112222914131"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222926037.png" alt="image-20211112222926037"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112222943787.png" alt="image-20211112222943787"></p><h2 id="3-虚函数的调用"><a href="#3-虚函数的调用" class="headerlink" title="3 虚函数的调用"></a>3 虚函数的调用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223140274.png" alt="image-20211112223140274"></p><p>为了实现动态绑定，我们应该将父类方法定义为虚函数</p><h3 id="声明为：virtual"><a href="#声明为：virtual" class="headerlink" title="声明为：virtual"></a>声明为：virtual</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223250929.png" alt="image-20211112223250929"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223310179.png" alt="image-20211112223310179"></p><h2 id="4-建议：定义父类方法时，直接声明为虚方法"><a href="#4-建议：定义父类方法时，直接声明为虚方法" class="headerlink" title="4 建议：定义父类方法时，直接声明为虚方法"></a>4 建议：定义父类方法时，直接声明为虚方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223353297.png" alt="image-20211112223353297"></p><p><strong>子类无需再次声明，只需父类声明即可</strong></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112223634781.png" alt="image-20211112223634781"></p><p>答案：A</p><p>C是错的，没有虚成员的概念，<strong>请牢记！！！</strong>，没有任何办法可以通过父类句柄找到子类对象中的变量</p><p>D不能使用不同类型参数</p><h1 id="三、对象拷贝"><a href="#三、对象拷贝" class="headerlink" title="三、对象拷贝"></a>三、对象拷贝</h1><h2 id="1-赋值和拷贝"><a href="#1-赋值和拷贝" class="headerlink" title="1 赋值和拷贝"></a>1 赋值和拷贝</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193044171.png" alt="image-20211113193044171"></p><h2 id="2-声明变量和创建对象"><a href="#2-声明变量和创建对象" class="headerlink" title="2 声明变量和创建对象"></a>2 声明变量和创建对象</h2><p>是两个过程，也可以一步完成</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">Packet p1;<br>p1 = <span class="hljs-keyword">new</span>();<br></code></pre></div></td></tr></table></figure><p>new不可以有返回值，也不可定义为虚函数</p><h2 id="3-从p1拷贝到p2：浅拷贝shallow-copy"><a href="#3-从p1拷贝到p2：浅拷贝shallow-copy" class="headerlink" title="3 从p1拷贝到p2：浅拷贝shallow copy"></a>3 从p1拷贝到p2：浅拷贝shallow copy</h2><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">Packet p1;<br>Packet p2;<br>p1 = new();<br>p2 = new() p1;//把p1的值拷贝给p2，并通过new创建对象<br></code></pre></div></td></tr></table></figure><h2 id="4-对象的拷贝让人当心"><a href="#4-对象的拷贝让人当心" class="headerlink" title="4 对象的拷贝让人当心"></a>4 对象的拷贝让人当心</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193450909.png" alt="image-20211113193450909"></p><p>不要与<strong>句柄的拷贝搞混</strong>：子类变父类，父类变子类</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193553972.png" alt="image-20211113193553972"></p><h2 id="5-自定义拷贝函数：自己声明定义的赋值函数与copy函数"><a href="#5-自定义拷贝函数：自己声明定义的赋值函数与copy函数" class="headerlink" title="5 自定义拷贝函数：自己声明定义的赋值函数与copy函数"></a>5 自定义拷贝函数：自己声明定义的赋值函数与copy函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193642312.png" alt="image-20211113193642312"></p><h3 id="父类copy"><a href="#父类copy" class="headerlink" title="父类copy"></a>父类copy</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193656716.png" alt="image-20211113193656716"></p><ul><li>copy_data()用于数据赋值</li><li>copy()用于创建对象和返回句柄</li></ul><p><strong>子类对象copy会创建一个子类的对象，但返回的是父类类型的句柄</strong></p><h3 id="子类copy（重点1）"><a href="#子类copy（重点1）" class="headerlink" title="子类copy（重点1）"></a>子类copy（重点1）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113193915025.png" alt="image-20211113193915025"></p><ul><li><p>t是子类句柄，直接带入copy_data隐式转换成父类句柄</p></li><li><p>super.copy_data调用父类的copy_data，</p></li><li><p>填入一行代码：<code>$cast(h,t);</code>，<strong>h.def才能把子类同名变量赋值</strong></p></li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113194409221.png" alt="image-20211113194409221"></p><p><strong>即：子类中用到的同名变量要转换成子类句柄进行copy</strong>，如果直接t.def，则会导致赋值到父类的def中</p><h3 id="module中（重点2）"><a href="#module中（重点2）" class="headerlink" title="module中（重点2）"></a>module中（重点2）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113194616350.png" alt="image-20211113194616350"></p><p><strong>子类对象copy会创建一个子类的对象，但返回的是父类类型的句柄</strong></p><p><code>$cast(h,wr.copy());</code></p><p>最终结果是：</p><ul><li>wr = new () ; //创建了一个test_wr子类对象</li><li>h句柄通过wr.copy获得了拷贝过的一个未命名对象的父类句柄，并通过$cast完成父类转到h子类句柄上</li><li>所以存在wr，h两个句柄分别指向的不同的子类对象</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113195519471.png" alt="image-20211113195519471"></p><p><strong>copy,copy_data声明为虚函数很重要</strong></p><p>遵循只拷贝改类的域成员的原则：</p><ul><li>子类的copy_data里的方法：<ul><li>调用父类的copy_data，为了更好的复用</li><li>拷贝子类中数据</li></ul></li></ul><h1 id="四、回调函数-callback-钩子函数"><a href="#四、回调函数-callback-钩子函数" class="headerlink" title="四、回调函数(callback,钩子函数)"></a>四、回调函数(callback,钩子函数)</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113200203617.png" alt="image-20211113200203617"></p><p>复用：水平复用、垂直复用</p><p>为什么回调：解决<strong>直接修改父类</strong>会牵一发而动全身的情况，通过<strong>预留回调函数</strong>入口在子函数补充完成对父类方法的修改</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113200733862.png" alt="image-20211113200733862"></p><h2 id="2-实例：定义虚类和虚函数virtual-class-amp-virtual-function"><a href="#2-实例：定义虚类和虚函数virtual-class-amp-virtual-function" class="headerlink" title="2 实例：定义虚类和虚函数virtual class &amp; virtual function"></a>2 实例：定义虚类和虚函数virtual class &amp; virtual function</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113201009701.png" alt="image-20211113201009701"></p><p>虚类（或者说类的一个模板），虚类是不能例化的，为了你不例化这个类</p><hr><p>同时你也可以不定义虚类就定义普通的，事实上目前我们可以这样做简单</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113201219936.png" alt="image-20211113201219936"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203045002.png" alt="image-20211113203045002"></p><p>把callback类型的句柄放在队列<code>Driver_cbs cbs</code> 里面</p><p>按行分析：</p><ul><li>agt2drv.get(tr)//拿到一个transcation</li><li>foreach挨个调用句柄，如果返回的drop是1则不会执行<code>transmit(tr)</code>（即不会发送tr了），直接continue到forever入口处</li><li>transmit(tr)//发送transcation</li></ul><p>大致意思：</p><p>重点是callback作用是可能返回drop<strong>进一步控制driver的行为</strong>，driver什么时候可以发送什么时候不发送</p><h4 id="定义了一个类：虚类不可以例化但能继承"><a href="#定义了一个类：虚类不可以例化但能继承" class="headerlink" title="定义了一个类：虚类不可以例化但能继承"></a>定义了一个类：虚类不可以例化但能继承</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203307071.png" alt="image-20211113203307071"></p><p>drop声类型可以ref也可以output</p><ul><li><p>drop = 1 ：1%概率</p></li><li><p>drop = 0 ：99%概率</p></li></ul><h3 id="要使用回调函数了（看标红的代码）"><a href="#要使用回调函数了（看标红的代码）" class="headerlink" title="要使用回调函数了（看标红的代码）"></a>要使用回调函数了（看标红的代码）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203723480.png" alt="image-20211113203723480">7</p><ul><li>begin…end里面考虑要不要修改driver行为<ul><li><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113203928872.png" alt="image-20211113203928872"></li></ul></li></ul><h2 id="3-如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）"><a href="#3-如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）" class="headerlink" title="3 如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）"></a>3 如何使用回调函数（记一下，因为UVM中的回调和这个的步骤一摸一样）</h2><ul><li>预留回调函数入口</li><li>定义回调类和回调函数</li><li>例化及添加回调类实例</li></ul><h2 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113204202872.png" alt="image-20211113204202872"></p><p>答案：ABCD</p><h1 id="五、参数化的类：类似于C-模板"><a href="#五、参数化的类：类似于C-模板" class="headerlink" title="五、参数化的类：类似于C++模板"></a>五、参数化的类：类似于C++模板</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113204317704.png" alt="image-20211113204317704"></p><p><strong>类型也可以做参数</strong></p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2 例子"></a>2 例子</h2><h3 id="（1-一个简单的mailbox"><a href="#（1-一个简单的mailbox" class="headerlink" title="（1) 一个简单的mailbox"></a>（1) 一个简单的mailbox</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113205418610.png" alt="image-20211113205418610"></p><p>只能操作整形</p><h3 id="使用参数化的类：-type-T-int-声明参数化的类，同时默认类型int"><a href="#使用参数化的类：-type-T-int-声明参数化的类，同时默认类型int" class="headerlink" title="使用参数化的类： # (type T = int)//声明参数化的类，同时默认类型int"></a>使用参数化的类： <code># (type T = int)</code>//声明参数化的类，同时默认类型int</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113205639763.png" alt="image-20211113205639763"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113210058383.png" alt="image-20211113210058383"></p><h2 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113210148500.png" alt="image-20211113210148500"></p><p>答案：ABD</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通6：验证的量化与功能覆盖率</title>
    <link href="/202111121646/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A06-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E9%87%8F%E5%8C%96%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <url>/202111121646/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A06-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E9%87%8F%E5%8C%96%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、覆盖率"><a href="#一、覆盖率" class="headerlink" title="一、覆盖率"></a>一、覆盖率</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112165259519.png" alt="image-20211112165259519"></p><h2 id="2-覆盖率反馈回路"><a href="#2-覆盖率反馈回路" class="headerlink" title="2 覆盖率反馈回路"></a>2 覆盖率反馈回路</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172014070.png" alt="image-20211112172014070"></p><ul><li>随机约束(constrained random tests) 很窄的时候会变成定向测试(directed testcase)</li><li>Many runs , different seeds ： 跑多次使用不同的种子</li><li>Functionall Coverage ： 功能覆盖率</li><li>Identify holes：分析漏洞</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172300816.png" alt="image-20211112172300816"></p><p>即一开始可以使用定向测试</p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172336045.png" alt="image-20211112172336045"></p><p>答案：AB</p><h2 id="3-漏洞率曲线"><a href="#3-漏洞率曲线" class="headerlink" title="3 漏洞率曲线"></a>3 漏洞率曲线</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112193838775.png" alt="image-20211112193838775"></p><p><strong>漏洞率下降时</strong>，应寻找各种不同的办法去测试可能的边界情况(corner case)</p><h2 id="4-功能覆盖率步骤"><a href="#4-功能覆盖率步骤" class="headerlink" title="4 功能覆盖率步骤"></a>4 功能覆盖率步骤</h2><h1 id="二、-覆盖率类型"><a href="#二、-覆盖率类型" class="headerlink" title="二、 覆盖率类型"></a>二、 覆盖率类型</h1><h2 id="1-代码覆盖率"><a href="#1-代码覆盖率" class="headerlink" title="1 代码覆盖率"></a>1 代码覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172457412-16367090980413.png" alt="image-20211112172457412"></p><p><strong>工具分析，编译时添加选项，不需要额外代码</strong></p><ul><li>行覆盖率</li><li>路径覆盖率</li><li>反转覆盖率</li><li>状态机覆盖率</li></ul><p><strong>最终结果用于衡量设计代码</strong>，关注点在设计代码的分析上，而不是测试平台</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112172807856.png" alt="image-20211112172807856"></p><p><strong>代码覆盖率100%是必要不充分条件</strong></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112173008178.png" alt="image-20211112173008178"></p><p>答案：C</p><p>实际情况常常达不到100%，我们会：1、设置编译器这部分达不到；2、设置100%的阈值</p><h2 id="2-断言覆盖率"><a href="#2-断言覆盖率" class="headerlink" title="2 断言覆盖率"></a>2 断言覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112173150029.png" alt="image-20211112173150029"></p><p>可以使用SV的程序性代码：<code>assert</code></p><p>但使用SVA更简单</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112193553513.png" alt="image-20211112193553513"></p><p>断言除了用于信号和状态的检查外，还可以用作覆盖率收集</p><p>只有代码覆盖率会自动收集，断言覆盖率需要自己定义</p><h2 id="3-功能覆盖率（重要）"><a href="#3-功能覆盖率（重要）" class="headerlink" title="3 功能覆盖率（重要）"></a>3 功能覆盖率（重要）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112194059827.png" alt="image-20211112194059827"></p><h3 id="功能覆盖率关系图"><a href="#功能覆盖率关系图" class="headerlink" title="功能覆盖率关系图"></a>功能覆盖率关系图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112194448584.png" alt="image-20211112194448584"></p><p>不止仿真，形式验证、加速都可以收集覆盖率</p><p>pass：功能测试有没有通过</p><h3 id="功能覆盖率步骤"><a href="#功能覆盖率步骤" class="headerlink" title="功能覆盖率步骤"></a>功能覆盖率步骤</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195017497.png" alt="image-20211112195017497"></p><p><strong>合并覆盖率</strong></p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195116210.png" alt="image-20211112195116210"></p><p>答案：BCD</p><h1 id="三、功能覆盖策略"><a href="#三、功能覆盖策略" class="headerlink" title="三、功能覆盖策略"></a>三、功能覆盖策略</h1><h2 id="1-收集信息而非数据"><a href="#1-收集信息而非数据" class="headerlink" title="1 收集信息而非数据"></a>1 收集信息而非数据</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195304711.png" alt="image-20211112195304711"></p><p>着眼于感兴趣的状态，而不是具体数值</p><h2 id="2-只测量需要的内容"><a href="#2-只测量需要的内容" class="headerlink" title="2 只测量需要的内容"></a>2 只测量需要的内容</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195645515.png" alt="image-20211112195645515"></p><ul><li><p>什么时候打开覆盖率收集，什么时候关闭</p></li><li><p>只收集哪些？功能点…</p></li><li><p>合理的定义覆盖率采样事件</p></li></ul><h2 id="3-验证的完备性：代码覆盖率与功能覆盖率的关系"><a href="#3-验证的完备性：代码覆盖率与功能覆盖率的关系" class="headerlink" title="3 验证的完备性：代码覆盖率与功能覆盖率的关系"></a>3 验证的完备性：代码覆盖率与功能覆盖率的关系</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112195858313.png" alt="image-20211112195858313"></p><p>目标是同时<strong>驱动</strong>高的代码覆盖率和功能覆盖率</p><h3 id="Functional-Coverage-amp-Code-Coverage-figure"><a href="#Functional-Coverage-amp-Code-Coverage-figure" class="headerlink" title="Functional Coverage &amp; Code Coverage figure"></a>Functional Coverage &amp; Code Coverage figure</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112200010561.png" alt="image-20211112200010561"></p><ul><li>Need more FC points ,including corner cases : 部分代码代表的功能还没有提取，需要定义更多的功能覆盖率</li><li>Is design complete ? : （最常见的）某些感兴趣的状态还是没有被测试到，分析我们的功能覆盖率哪些没有测试到，针对他们去添加修改约束和性能测试</li></ul><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112200059155.png" alt="image-20211112200059155"></p><p>答案：CD</p><h1 id="四、覆盖组-关键词covergroup"><a href="#四、覆盖组-关键词covergroup" class="headerlink" title="四、覆盖组(关键词covergroup)"></a>四、覆盖组(关键词covergroup)</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><ul><li><code>covergroup</code>与类相似，一次定义多次例化</li><li><code>covergroup</code>可定义在类、interface、module中</li><li><code>covergroup</code>包含一个或多个<code>coverpoint</code>，所有points全部同一时间采集</li><li><code>covergroup</code>可采样任何可见变量，例如程序变量、接口信号、设计端口</li><li>一个类里面面可包含多个<code>covergroup</code></li><li>你拥有多个独立的<code>covergroup</code>时，每个<code>covergroup</code>可以根据需要自行使能或禁止</li><li>每个<code>covergroup</code>可以定义单独的触发采样时间，允许从多个源头收集数据</li><li><code>covergroup</code>必须例化后才能收集数据</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">CovPort ck = <span class="hljs-keyword">new</span> ();<br>ck<span class="hljs-variable">.start</span>();<span class="hljs-comment">//new之后默认已经启动，只有stop只有才需要重启</span><br>ck<span class="hljs-variable">.stop</span>();<br>ck<span class="hljs-variable">.sample</span>();<span class="hljs-comment">//采样</span><br></code></pre></div></td></tr></table></figure><h2 id="2-在类里定义covergroup"><a href="#2-在类里定义covergroup" class="headerlink" title="2 在类里定义covergroup"></a>2 在类里定义covergroup</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112201312010.png" alt="image-20211112201312010"></p><h3 id="两种例化方式"><a href="#两种例化方式" class="headerlink" title="两种例化方式"></a>两种例化方式</h3><p><strong>第一种：</strong>实例名和类名一致，但类名还是类名，实例名也是实例名，但没法例化多次</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">covergroup</span> CovPort;<br>....<br>CovPort = <span class="hljs-keyword">new</span> ();<span class="hljs-comment">//和类的例化不太一样</span><br></code></pre></div></td></tr></table></figure><p><strong>第二种（建议）：</strong>实例名与类名不一致，我们定义类也是用这种，可以例化多次</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">CovPort cg1 = <span class="hljs-keyword">new</span>();<br></code></pre></div></td></tr></table></figure><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p><strong>第一种</strong>采样方式（手动）</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">cg1<span class="hljs-variable">.sample</span>();<br></code></pre></div></td></tr></table></figure><p><strong>第二种</strong>采样方式：<strong>covergroup的采样触发</strong>等待某些特定的信号（自动）</p><h2 id="3-covergroup的采样触发"><a href="#3-covergroup的采样触发" class="headerlink" title="3 covergroup的采样触发"></a>3 covergroup的采样触发</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202040146.png" alt="image-20211112202040146"></p><h3 id="使用事件触发"><a href="#使用事件触发" class="headerlink" title="使用事件触发"></a>使用事件触发</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202147138.png" alt="image-20211112202147138"></p><p>借助已有事件，比如已有的时钟或event</p><h2 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202248248.png" alt="image-20211112202248248"></p><p>答案：ABC</p><h1 id="五、数据采样"><a href="#五、数据采样" class="headerlink" title="五、数据采样"></a>五、数据采样</h1><h2 id="1-概述：仓bin"><a href="#1-概述：仓bin" class="headerlink" title="1 概述：仓bin"></a>1 概述：仓bin</h2><p>定义coverpoint时，SV会创建很多仓，可以是自己定义的bin，也可以是自动生成的bin，推荐自己定义</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112202342351.png" alt="image-20211112202342351"></p><h2 id="2-coverpoint-和-bin"><a href="#2-coverpoint-和-bin" class="headerlink" title="2 coverpoint 和 bin"></a>2 coverpoint 和 bin</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210126670.png" alt="image-20211112210126670"></p><h2 id="3-bin的创建和应用"><a href="#3-bin的创建和应用" class="headerlink" title="3 bin的创建和应用"></a>3 bin的创建和应用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210244773.png" alt="image-20211112210244773"></p><h2 id="4-命名coverpoint和bin"><a href="#4-命名coverpoint和bin" class="headerlink" title="4 命名coverpoint和bin"></a>4 命名coverpoint和bin</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210343326.png" alt="image-20211112210343326"></p><p><strong>misc</strong> = default</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210432170-16367222726244.png" alt="image-20211112210432170"></p><h2 id="5-条件覆盖率：iff关键词给coverpoint添加额外条件"><a href="#5-条件覆盖率：iff关键词给coverpoint添加额外条件" class="headerlink" title="5 条件覆盖率：iff关键词给coverpoint添加额外条件"></a>5 条件覆盖率：iff关键词给coverpoint添加额外条件</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112210817547.png" alt="image-20211112210817547"></p><p>关注port变量，不单单要触发采样条件<code>ck.sample()</code>，还要<code>(!bus_if.reset)</code>即已经复位</p><p>为什么ck要先关闭：因为要操作复位信号</p><h2 id="6-翻转覆盖率：-gt-符号"><a href="#6-翻转覆盖率：-gt-符号" class="headerlink" title="6 翻转覆盖率：=&gt; 符号"></a>6 翻转覆盖率：=&gt; 符号</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211158581.png" alt="image-20211112211158581"></p><h3 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211257808.png" alt="image-20211112211257808"></p><p>答案：ABD</p><h2 id="7-wildcard覆盖率：把X-Z或？当成0，1的通配"><a href="#7-wildcard覆盖率：把X-Z或？当成0，1的通配" class="headerlink" title="7 wildcard覆盖率：把X,Z或？当成0，1的通配"></a>7 wildcard覆盖率：把X,Z或？当成0，1的通配</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211500653.png" alt="image-20211112211500653"></p><h2 id="8-忽略某些bin：关键词ignore-bins"><a href="#8-忽略某些bin：关键词ignore-bins" class="headerlink" title="8 忽略某些bin：关键词ignore_bins"></a>8 忽略某些bin：关键词ignore_bins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211609744.png" alt="image-20211112211609744"></p><p>使用<code>ignore_bins</code>定义bin</p><h2 id="9-非法某些bin：关键词illegal-bins"><a href="#9-非法某些bin：关键词illegal-bins" class="headerlink" title="9 非法某些bin：关键词illegal_bins"></a>9 非法某些bin：关键词illegal_bins</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211746972.png" alt="image-20211112211746972"></p><h2 id="10-交叉覆盖率：关键词cross"><a href="#10-交叉覆盖率：关键词cross" class="headerlink" title="10 交叉覆盖率：关键词cross"></a>10 交叉覆盖率：关键词cross</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112211810842.png" alt="image-20211112211810842"></p><h3 id="1-排除部分cross-bin：ignore-bins-binsof-intersect"><a href="#1-排除部分cross-bin：ignore-bins-binsof-intersect" class="headerlink" title="(1) 排除部分cross bin：ignore_bins + binsof + intersect"></a>(1) 排除部分cross bin：ignore_bins + binsof + intersect</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112212537184.png" alt="image-20211112212537184"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">binsof</span><span class="hljs-params">(覆盖率组变量A)</span></span> itersect &#123;整形&#125;<br><span class="hljs-comment">//与7有关的“A”组合</span><br><br></code></pre></div></td></tr></table></figure><hr><p><code>ignore_bins md = binsof(port) intersect&#123;0&#125; &amp;&amp; binsof(kind) intersect &#123;[9:11]&#125;</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112212947981.png" alt="image-20211112212947981"></p><hr><p><code>ignore_bins lo = binsof(kind.lo)//lo在前面定义了bin lo = &#123;[8:$]&#125;</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213224109.png" alt="image-20211112213224109"></p><h3 id="2-精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof"><a href="#2-精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof" class="headerlink" title="(2) 精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof"></a>(2) 精细的交叉覆盖率指定：交叉后bin由于过于多了，我们更常用指定，只用binsof</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213515343.png" alt="image-20211112213515343"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213606529.png" alt="image-20211112213606529"></p><p>尽量不做排除法，而是指定法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213705741.png" alt="image-20211112213705741"></p><h3 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112213730283.png" alt="image-20211112213730283"></p><p>答案：ABC</p><p>D错是因为，如果不连续（漏掉）某些bin，SV可能会自动帮你填充如：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112214020363.png" alt="image-20211112214020363"></p><p>456没有关心</p><h4 id="采样到illegal-bins仿真会停止"><a href="#采样到illegal-bins仿真会停止" class="headerlink" title="采样到illegal_bins仿真会停止"></a>采样到illegal_bins仿真会停止</h4><h1 id="六、覆盖选项"><a href="#六、覆盖选项" class="headerlink" title="六、覆盖选项"></a>六、覆盖选项</h1><h2 id="1-单个实例的覆盖率：查看单个覆盖率option-per-instance-1"><a href="#1-单个实例的覆盖率：查看单个覆盖率option-per-instance-1" class="headerlink" title="1 单个实例的覆盖率：查看单个覆盖率option.per_instance = 1"></a>1 单个实例的覆盖率：查看单个覆盖率option.per_instance = 1</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112214219083.png" alt="image-20211112214219083"></p><h2 id="2-添加注释-option-commet-string"><a href="#2-添加注释-option-commet-string" class="headerlink" title="2 添加注释 option.commet = string*"></a>2 添加注释 option.commet = string*</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215446401.png" alt="："></p><h2 id="3-覆盖次数限定：option-at-least"><a href="#3-覆盖次数限定：option-at-least" class="headerlink" title="3 覆盖次数限定：option.at_least"></a>3 覆盖次数限定：option.at_least</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215549608.png" alt="image-20211112215549608"></p><h2 id="4-覆盖率目标：option-goal"><a href="#4-覆盖率目标：option-goal" class="headerlink" title="4 覆盖率目标：option.goal"></a>4 覆盖率目标：option.goal</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215611103.png" alt="image-20211112215611103"></p><h2 id="5-covergroup方法"><a href="#5-covergroup方法" class="headerlink" title="5 covergroup方法"></a>5 covergroup方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215640227.png" alt="image-20211112215640227"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">get_coverage()<span class="hljs-comment">//所有group加权以后的覆盖率</span><br>get_inst_coverage()<span class="hljs-comment">//特定覆盖组实例覆盖率</span><br><span class="hljs-comment">//返回的0-100实数就是百分比</span><br>set_inst_name(<span class="hljs-keyword">string</span>)设置覆盖组名称<br></code></pre></div></td></tr></table></figure><h1 id="七、数据分析"><a href="#七、数据分析" class="headerlink" title="七、数据分析"></a>七、数据分析</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p><strong>获得总体覆盖率</strong>：使用系统函数，或使用<code>get_inst_coverage()</code></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112215930314.png" alt="image-20211112215930314"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通5：线程的控制和同步</title>
    <link href="/202111112121/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-2%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5/"/>
    <url>/202111112121/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-2%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程的使用"><a href="#一、线程的使用" class="headerlink" title="一、线程的使用"></a>一、线程的使用</h1><h2 id="1-程序和模块"><a href="#1-程序和模块" class="headerlink" title="1 程序和模块"></a>1 程序和模块</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112113901134.png" alt="image-20211112113901134"></p><p><em>硬件之间有很多过程快，它们之间的通信可以理解为不同逻辑/时序块之间的通信或者同步，是通过信号变化来完成的</em></p><p>verilog通过always,initial过程语句块和<strong>信号</strong>连接建立进程间通信</p><p>将module看作独立的过程快，它们之间的同步通过</p><ul><li>信号的变化(event触发)</li><li>等待特定事件(时钟周期)</li><li>时间(固定延时)完成</li></ul><h3 id="module示意图"><a href="#module示意图" class="headerlink" title="module示意图"></a>module示意图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112114323500.png" alt="image-20211112114323500"></p><p>不同模块可以看作不同进程</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115621758.png" alt="image-20211112115621758"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115724226.png" alt="image-20211112115724226"></p><p>答案：AB</p><h2 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2 什么是线程"></a>2 什么是线程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112115825884.png" alt="image-20211112115825884"></p><p>线程可以结束，也可以选择不结束</p><hr><h3 id="测试题：降低仿真时的内存负载"><a href="#测试题：降低仿真时的内存负载" class="headerlink" title="测试题：降低仿真时的内存负载"></a>测试题：降低仿真时的内存负载</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112120037482.png" alt="image-20211112120037482"></p><p>答案：ABCD</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112120538650.png" alt="image-20211112120538650"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join</span><span class="hljs-comment">//里面的语句都是并行的</span><br><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join_any</span><br><span class="hljs-keyword">fork</span>..<span class="hljs-variable">.join_none</span><br></code></pre></div></td></tr></table></figure><h2 id="3-线程概念澄清"><a href="#3-线程概念澄清" class="headerlink" title="3 线程概念澄清"></a>3 线程概念澄清</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124235862.png" alt="image-20211112124235862"></p><h1 id="二、线程的控制"><a href="#二、线程的控制" class="headerlink" title="二、线程的控制"></a>二、线程的控制</h1><h2 id="1-fork并行线程语句块"><a href="#1-fork并行线程语句块" class="headerlink" title="1 fork并行线程语句块"></a>1 fork并行线程语句块</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124359432.png" alt="image-20211112124359432"></p><p>对比图</p><ul><li><p>join等待所有子线程运行结束后进行后面的主线程</p></li><li><p>join_any任何一个线程结束就直接就直接进行主线程（其他T1,T2线程也继续运行）</p></li><li><p>join_none开辟子线程后直接进行之后的主线程</p></li></ul><h2 id="2-fork…join"><a href="#2-fork…join" class="headerlink" title="2 fork…join"></a>2 fork…join</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124750443.png" alt="image-20211112124750443"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124830167.png" alt="image-20211112124830167"></p><h2 id="3-join-any"><a href="#3-join-any" class="headerlink" title="3 join_any"></a>3 join_any</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124915926.png" alt="image-20211112124915926"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112124956438-16366925968321.png" alt="image-20211112124956438"></p><h2 id="4-fork…join-none"><a href="#4-fork…join-none" class="headerlink" title="4 fork…join_none"></a>4 fork…join_none</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125112200.png" alt="image-20211112125112200">4</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125139712.png" alt="image-20211112125139712"></p><h2 id="5-等待所有衍生线程：wait-fork"><a href="#5-等待所有衍生线程：wait-fork" class="headerlink" title="5 等待所有衍生线程：wait fork"></a>5 等待所有衍生线程：wait fork</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125421840.png" alt="image-20211112125421840"></p><p><code>wait fork</code></p><h2 id="6-停止单个线程、停止多个线程：disable"><a href="#6-停止单个线程、停止多个线程：disable" class="headerlink" title="6 停止单个线程、停止多个线程：disable"></a>6 停止单个线程、停止多个线程：disable</h2><h3 id="停止单个线程"><a href="#停止单个线程" class="headerlink" title="停止单个线程"></a>停止单个线程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112125517978.png" alt="image-20211112125517978"></p><h3 id="停止多个线程"><a href="#停止多个线程" class="headerlink" title="停止多个线程"></a>停止多个线程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132512284.png" alt="image-20211112132512284"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">disable</span> <span class="hljs-keyword">fork</span>;<span class="hljs-comment">//停止所有衍生子线程</span><br></code></pre></div></td></tr></table></figure><h3 id="停止多次被调用的任务"><a href="#停止多次被调用的任务" class="headerlink" title="停止多次被调用的任务"></a>停止多次被调用的任务</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132611826.png" alt="image-20211112132611826"></p><p>disable会停止所有<strong>同名</strong>线程</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112132651261.png" alt="image-20211112132651261"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133030715.png" alt="image-20211112133030715"></p><h2 id="7-僵尸线程"><a href="#7-僵尸线程" class="headerlink" title="7 僵尸线程"></a>7 僵尸线程</h2><p>join_none , join_any 的线程，父线程很快结束后，子线程仍在运行，子线程不会被回收，称这些子线程为僵尸线程</p><ul><li>因此需要给fork起名字，给他手动disable关掉</li><li>父线程触发event使得外部程序disable子线程</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112163246395.png" alt="image-20211112163246395"></p><h1 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>SV一共就三种线程通信方法，三个要素只有event不需要用new，但仍然可以看作一个对象因为同样需要调用方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133200873.png" alt="image-20211112133200873"></p><p>线程之间通过mailbox搅浑数据，SV称之为IPC(Interprocess Communication)</p><h2 id="2-event事件"><a href="#2-event事件" class="headerlink" title="2 event事件"></a>2 event事件</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p>verilog中一个线程总是要等待一个带@操作符的时间。这个操作符是边沿敏感的，所以它总是阻塞着、等待的时间变化</p><p>SV中抽象出来，称为<code>event</code>，其他线程可以通过<code>-&gt;</code>操作符<strong>触发</strong>事件，结束对线程的阻塞（constraint里面也学过箭头）</p><p>三个要素只有event不需要用new，但仍然可以看作一个对象因为同样需要调用方法</p><h3 id="2-在event的边沿阻塞"><a href="#2-在event的边沿阻塞" class="headerlink" title="(2) 在event的边沿阻塞"></a>(2) 在event的边沿阻塞</h3><h4 id="直接-e"><a href="#直接-e" class="headerlink" title="直接 @ e ;"></a>直接 <code>@ e ;</code></h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133804979.png" alt="image-20211112133804979"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112133852009.png" alt="image-20211112133852009"></p><p>@ event 的时候事件时，因为事件只在当前时间步长保持，所以会丢失event</p><p>delta cycle使得同一时间内没法确认是t1先执行还是t2先执行，这样的化肯定有一个线程等不到事件</p><p>triggered是一个类似留言的功能，即询问事件是否<strong>被</strong>触发过</p><p><strong>修改内容：</strong></p><ul><li>event 触发在 wait triggered之前则不会等待到</li><li>event 触发在 wait triggered 时或之后才会等待到</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162540357.png" alt="image-20211112162540357"></p><h5 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h5><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">事件的触发状态只会在当前时间步长保持，一但仿真开始向前运行，就会失去这个状态。也就是说，在仿真时间20的这个时间步长中（可以把它想象成1ns或1ps），事件是处于触发状态的，到21仿真时间后触发状态消失。在上面的代码中，两个阻塞等待<span class="hljs-meta">@和.triggered都是和事件触发同时发生的，出现了竞争条件，结果是虽然触发和等待发生在同一个仿真时间，但是还有执行顺序，根据代码顺序，先执行事件的触发，由于</span><span class="hljs-meta">@事件控制是边沿敏感的，等到执行</span><span class="hljs-meta">@语句时，事件的触发的“上升沿”已经消失，所以</span><span class="hljs-meta">@并没有被触发，而</span><span class="hljs-meta">@和.triggered的不同就在于此，</span><span class="hljs-meta">@是边沿敏感，后者是电平敏感，所以在整个20仿真时间步长中，wait语句都能被触发。</span><br>触发和等待在同一时间开始的话就不要用<span class="hljs-meta">@改用.triggered，当然如果触发进程在等待进程（的仿真时间）之前发生，那这两种等待都不会收到trigger。</span><br>其实将Thread2initial块移动到Thread1 initial块之前，也能让<span class="hljs-meta">@阻塞等待被触发，这就是因为</span><span class="hljs-meta">@的执行顺序在触发事件之前</span><br></code></pre></div></td></tr></table></figure><h4 id="修改为-wait-e-triggered"><a href="#修改为-wait-e-triggered" class="headerlink" title="修改为 wait(e.triggered)"></a>修改为 <code>wait(e.triggered)</code></h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141011384.png" alt="image-20211112141011384"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161825960.png" alt="image-20211112161825960"></p><p>triggered引起阻塞（@e 是电平敏感，当event被触发则该语句一直运行）</p><h3 id="3-通知的需求"><a href="#3-通知的需求" class="headerlink" title="(3) 通知的需求"></a>(3) 通知的需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141711216.png" alt="image-20211112141711216"></p><h3 id="把-bit-变成-event"><a href="#把-bit-变成-event" class="headerlink" title="把 bit 变成 event"></a>把 bit 变成 event</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141828286.png" alt="image-20211112141828286"></p><h4 id="扩展：多次触发"><a href="#扩展：多次触发" class="headerlink" title="扩展：多次触发"></a>扩展：多次触发</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112141911727.png" alt="image-20211112141911727"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162011904.png" alt="image-20211112162011904"></p><h3 id="4-，wait-triggered-和-wait-triggered-比较总结"><a href="#4-，wait-triggered-和-wait-triggered-比较总结" class="headerlink" title="(4) @ ，wait triggered() 和 wait triggered 比较总结"></a>(4) @ ，wait triggered() 和 wait triggered 比较总结</h3><ul><li><p>wait trigger()方法只能等待一次</p></li><li><p>等待event反复可以用@，也可以wait trigger状态变量</p></li><li><p>当你学习了UVM的event，UVM的event也有trigger状态，同时trigger状态可以清除掉</p><ul><li>SV比较老旧没有清除trigger语句</li></ul></li></ul><h3 id="5-wait-order与事件合并"><a href="#5-wait-order与事件合并" class="headerlink" title="(5) wait_order与事件合并"></a>(5) wait_order与事件合并</h3><p>参考博客：<a href="https://blog.csdn.net/weixin_43249032/article/details/84035517">https://blog.csdn.net/weixin_43249032/article/details/84035517</a></p><hr><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112162647861.png" alt="image-20211112162647861"></p><p>答案：CD</p><p>多次触发</p><h2 id="3-semaphore旗语"><a href="#3-semaphore旗语" class="headerlink" title="3 semaphore旗语"></a>3 semaphore旗语</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p><strong>实现对统一资源的访问和控制</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112143230138.png" alt="image-20211112143230138"></p><ul><li>new()：创建实例，参数指定创建钥匙数，无参数表示没有</li><li>get()：获取一把或多把钥匙</li><li>put()：返回一把或多把钥匙，没有参数默认一把</li><li>try_get()：非阻塞的获取钥匙，1表示由足够多钥匙0表示钥匙不够</li></ul><h3 id="2-例子：总线访问，实现只有一个设备进行访问"><a href="#2-例子：总线访问，实现只有一个设备进行访问" class="headerlink" title="(2) 例子：总线访问，实现只有一个设备进行访问"></a>(2) 例子：总线访问，实现只有一个设备进行访问</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112143627456.png" alt="image-20211112143627456"></p><p>sequencer都是对总想进行访问的</p><p>可以理解为stimulator</p><p><strong>用完钥匙一定要归还</strong>，如果不归还，get会阻塞产生死锁</p><h3 id="3-资源共享需求"><a href="#3-资源共享需求" class="headerlink" title="(3) 资源共享需求"></a>(3) 资源共享需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144750770.png" alt="image-20211112144750770"></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144846154.png" alt="image-20211112144846154"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112144925767.png" alt="image-20211112144925767"></p><p><strong>先到先得的原则</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145005924.png" alt="image-20211112145005924"></p><h4 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145046709.png" alt="image-20211112145046709"></p><p>答案：ABCD</p><h4 id="进阶：semaphora过于自由，使用时需要限制"><a href="#进阶：semaphora过于自由，使用时需要限制" class="headerlink" title="进阶：semaphora过于自由，使用时需要限制"></a>进阶：semaphora过于自由，使用时需要限制</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112145739949.png" alt="image-20211112145739949"></p><p>carkeep：车管家</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150028598.png" alt="image-20211112150028598"></p><h2 id="4-mailbox信箱子"><a href="#4-mailbox信箱子" class="headerlink" title="4 mailbox信箱子"></a>4 mailbox信箱子</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p><strong>主要是放置数据进行缓存</strong>，线程同步用event，信息传递用mailbox</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150157938.png" alt="image-20211112150157938"></p><ul><li>new：例化，可选参数size不一样了时存储的最大容量，0是无限大</li><li>put()：放入数据</li><li>get()：移除数据</li><li>peek()：只拷贝，不删除</li><li>try_put , try_get , try_peek</li></ul><h3 id="2-在进程间使用信箱通信"><a href="#2-在进程间使用信箱通信" class="headerlink" title="(2) 在进程间使用信箱通信"></a>(2) 在进程间使用信箱通信</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150442051.png" alt="image-20211112150442051"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112150506986-16367007075342.png" alt="image-20211112150506986"></p><p>细节在于为何mailbox是1，可以保证每次不需要传递过多数据，顺序不会变化</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112155326431.png" alt="image-20211112155326431"></p><h3 id="3-数据通信的需求：实际情况"><a href="#3-数据通信的需求：实际情况" class="headerlink" title="(3) 数据通信的需求：实际情况"></a>(3) 数据通信的需求：实际情况</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160103076.png" alt="image-20211112160103076"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160108460.png" alt="image-20211112160108460"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160027584.png" alt="image-20211112160027584"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160133669.png" alt="image-20211112160133669"></p><p>答案：ABCD</p><h3 id="4-数据通信的需求（续）"><a href="#4-数据通信的需求（续）" class="headerlink" title="(4) 数据通信的需求（续）"></a>(4) 数据通信的需求（续）</h3><p>对于mailbox的用法，同FIFO类似</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160219361.png" alt="image-20211112160219361"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160322083.png" alt="image-20211112160322083"></p><p><code>把mailbox替换成队列</code></p><h4 id="mailbox与quence的区别（重要）"><a href="#mailbox与quence的区别（重要）" class="headerlink" title="mailbox与quence的区别（重要）"></a>mailbox与quence的区别（重要）</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160515785.png" alt="image-20211112160515785"></p><h4 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160642148.png" alt="image-20211112160642148"></p><p>答案：BC</p><h3 id="5-mailbox-其他特性"><a href="#5-mailbox-其他特性" class="headerlink" title="(5) mailbox 其他特性"></a>(5) mailbox 其他特性</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160735856.png" alt="image-20211112160735856"></p><h3 id="6-进程同步的需求"><a href="#6-进程同步的需求" class="headerlink" title="(6) 进程同步的需求"></a>(6) 进程同步的需求</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160808988.png" alt="image-20211112160808988"></p><h4 id="event同步"><a href="#event同步" class="headerlink" title="event同步"></a>event同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160902694.png" alt="image-20211112160902694"></p><h4 id="semaphora同步"><a href="#semaphora同步" class="headerlink" title="semaphora同步"></a>semaphora同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112160949039.png" alt="image-20211112160949039"></p><h4 id="mailbox同步"><a href="#mailbox同步" class="headerlink" title="mailbox同步"></a>mailbox同步</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161021129.png" alt="image-20211112161021129"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161050057.png" alt="image-20211112161050057"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161101075.png" alt="image-20211112161101075"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211112161126705.png" alt="image-20211112161126705"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识5-2：UVM简介</title>
    <link href="/202111112121/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-3%EF%BC%9AUVM%E7%AE%80%E4%BB%8B/"/>
    <url>/202111112121/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-3%EF%BC%9AUVM%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>为什么现在讲：</p><p>实验四、实验五、带着UVM思维考虑</p><p>实验四实验五mcdf阶段，DUT变大了，我们主要讲如何将验证结构extend，对mcdf进行扩展</p><h1 id="一、UVM简介"><a href="#一、UVM简介" class="headerlink" title="一、UVM简介"></a>一、UVM简介</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111212500649.png" alt="image-20211111212500649"></p><p>sv标准：2002—&gt;2012—&gt;2017</p><p>2011年：UVM发布(Universal Verification Methodology)，各种M指的是Methodology</p><p>UVM是验证敲门砖</p><p>动态仿真，性能验证和效能验证都和动态仿真（功能验证）有关</p><p>动态仿真离不开硬件加速</p><p>静态</p><hr><p><strong>语言趋势</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213037283.png" alt="image-20211111213037283"></p><hr><p>UVM吸取了各种M(AVM,OVM,UVM)的优点，且不绑定某一语言</p><p>为什么：<strong>验证方法注重可重用的类</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213047259.png" alt="image-20211111213047259"></p><p><strong>底下一定要多画结构</strong></p><hr><p><strong>UVM什么数字的都可以验</strong></p><p>他就是库，基于SV提供的一系列方法类库，提供一系列基础类库，UVM提供的类库和基本的验证结构可以很快的构建起来验证平台</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111213507233.png" alt="image-20211111213507233"></p><hr><h3 id="学习UVM的路线"><a href="#学习UVM的路线" class="headerlink" title="学习UVM的路线"></a>学习UVM的路线</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111215918881.png" alt="image-20211111215918881"></p><p> mcdf相比mcdt来讲：大家共有channel和arbiter；mcdf多了个寄存器模块和Formatter模块，设计变复杂了</p><p>寄存器功能：配置功能、反应硬件状态，所以说既可写又可读，本身是硬件的一部分</p><h3 id="UVM类库"><a href="#UVM类库" class="headerlink" title="UVM类库"></a>UVM类库</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111220320176.png" alt="image-20211111220320176"></p><p>P260页</p><p><strong>分成了总共十大类</strong>：注意分类逻辑和处理场景</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111220422340.png" alt="image-20211111220422340"></p><h3 id="UVM类"><a href="#UVM类" class="headerlink" title="UVM类"></a>UVM类</h3><p>按照类库地图可以分为以下几类：</p><ul><li>核心基类：为什么克隆啊，自动定义的，自动的做比较，自动的打印</li><li>工厂(factory)类</li><li>事务(transactoin)和序列(sequence)类：SV中的事务和序列有机的组合起来</li><li>结构创建(structure creation)类</li><li>环境组件(environment component)类：SV里面的stimulator,monitor,driver,isdfsdtor,checker</li><li>通信管道(channel)类：mailbox(实验三里面讲过)</li><li>信息报告(message report)类：(实验四讲独立信息报告的包)</li><li>寄存器模型(register model)类：独立的我们不讲了</li><li>线程同步(thread synchronization)类：旗语等等</li><li>书屋接口(transaction interface)类：发送数据包两个mailBox接起来，为什么要有接口呢？</li></ul><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221214108.png" alt="image-20211111221214108"></p><p>答案：BCD</p><h1 id="二、UVM组件"><a href="#二、UVM组件" class="headerlink" title="二、UVM组件"></a>二、UVM组件</h1><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221245763.png" alt="image-20211111221245763"></p><p>MCDF中的组件按功能分为：激励器(stimulator)、监视器(monitor)、检查器(checker)</p><p><code>uvm_component</code>是非常重要的核心类，<strong>环境的组件类</strong></p><h3 id="1-环境组件类"><a href="#1-环境组件类" class="headerlink" title="(1) 环境组件类"></a>(1) 环境组件类</h3><p>方框里面的都继承于<code>uvm_component</code></p><ul><li>uvm_drivert：我们也学到了</li><li>uvm_monitort：我们也学到了</li><li>uvm_sequencer：不熟悉，承担了一部分generator的功能，目前我们的generator既要产生激励又要发送激励，sequener承担了发送激励的一部分，产生激励由另外一个类承担了</li><li>uvm_agent：我们也学到了</li><li>uvm_scoreboard：就是我们写的checker类</li><li>uvm_env</li><li>uvm_test</li></ul><p>其中uvm_env和uvm_test的差别会体现在实验三和实验四里面</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221535268.png" alt="image-20211111221535268"></p><h2 id="2、构建MCDF顶层验证环境：构建UVM最终结构图"><a href="#2、构建MCDF顶层验证环境：构建UVM最终结构图" class="headerlink" title="2、构建MCDF顶层验证环境：构建UVM最终结构图"></a>2、构建MCDF顶层验证环境：构建UVM最终结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111221954118.png" alt="image-20211111221954118"></p><p>目前这张图是我们到模块二的时候UVM应该是怎么样的形式</p><hr><p><strong>测试题</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111222034799.png" alt="image-20211111222034799"></p><p>答案：ABCD</p><p>sequencer是agent里面的常客，产生激励在上图中看不到，因为此时产生激励不属于UVM的结构，属于动态的产生激励的过程，属于sequence(和sequencer就差了一个字母)，我们后来学</p><hr><h1 id="三、UVM环境"><a href="#三、UVM环境" class="headerlink" title="三、UVM环境"></a>三、UVM环境</h1><h2 id="1、phase机制"><a href="#1、phase机制" class="headerlink" title="1、phase机制"></a>1、phase机制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h3><p>我们讲完组件，就需要例化了吧，再进行组件之间的连接，最后运行</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111222431847.png" alt="image-20211111222431847"></p><p>SV中我们通过new()函数没法解决一个重要问题，就是无法保证例化的先后关系，即在验证层次中没法保证先例化顶层，再例化下一层</p><p>我们必须小心的不断通过new()里面进行嵌套，这个连接也成为了问题，需要确保上层例化了再对底层进行连接</p><p>UVM可以事先进行配置，不用等待例化（即phase机制）</p><p>phase机制名词上解释是阶段机制，就是按照阶段进行</p><h3 id="2-phase机制函数表"><a href="#2-phase机制函数表" class="headerlink" title="(2) phase机制函数表"></a>(2) phase机制函数表</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111224701109.png" alt="image-20211111224701109"></p><p><strong>在各个组件内部只需要去填充预定义好的方法</strong>，这些方法有的是函数、有的是任务</p><p>phase机制解决了，例化的先后关系，从而只需要在对应组件中定义需要的任务</p><h3 id="3-phase机制流程图"><a href="#3-phase机制流程图" class="headerlink" title="(3) phase机制流程图"></a>(3) phase机制流程图</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225028176.png" alt="image-20211111225028176"></p><p><strong>总共九个阶段</strong>：图中少了一个final阶段（其他的是除了黄色快的阶段与函数表一一对应）</p><p>不一定都要在每个组件中实现所有方法，只需要实现对你有帮助的，其他阶段不定义就是空置的</p><p>黄色部分先不讲</p><h2 id="2、创建测试平台：流程图"><a href="#2、创建测试平台：流程图" class="headerlink" title="2、创建测试平台：流程图"></a>2、创建测试平台：流程图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225406992.png" alt="image-20211111225406992"></p><hr><p><strong>测试题</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111225444256.png" alt="image-20211111225444256"></p><p>答案：ABCD</p><p>函数是不消耗时间的所以B是对的，new函数也不消耗时间</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>uvm学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
      <tag>缩写</tag>
      
      <tag>地图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识5-1：验证方法</title>
    <link href="/202111101732/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <url>/202111101732/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A05-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的方法"><a href="#一、验证的方法" class="headerlink" title="一、验证的方法"></a>一、验证的方法</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110173623922.png" alt="image-20211110173623922"></p><p>SystemC也会讲到</p><p>利用多种工具把覆盖率合并起来</p><p>通过脚本进行整合</p><h3 id="1、动态比较与脚本"><a href="#1、动态比较与脚本" class="headerlink" title="1、动态比较与脚本"></a>1、动态比较与脚本</h3><p><strong>（1） 动态比较（线上比对）</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110185101311.png" alt="image-20211110185101311"></p><pre><code class=" mermaid">graph LRstim激励 --&gt; DUTstim激励 --&gt;moniterDUT --&gt; 输出DUT --&gt; monitermoniter --&gt; checker</code></pre><p><strong>（2） 线下比对</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110190008403.png" alt="image-20211110190008403"></p><pre><code class=" mermaid">graph LRstim激励 --&gt; DUTstim激励 --&gt;moniterDUT --&gt; 输出DUT --&gt; monitermoniter --&gt; input文本moniter --&gt; output文本input文本 --&gt; Cmod算法模型Cmod算法模型 --&gt; output2文本output2文本 --&gt; 脚本处理output文本 --&gt; 脚本处理</code></pre><h2 id="2、主要方法分类"><a href="#2、主要方法分类" class="headerlink" title="2、主要方法分类"></a>2、主要方法分类</h2><ul><li>动态仿真(dynamic simulation)</li><li>静态检查(formail check)：不止包括形式验证，与形式验证有联系有差别</li><li>虚拟模型(virtual prototype)：ESL/SystemC</li><li>硬件加速(hardware acceleration)</li><li>电源功耗(power consumption)：UPF/CPF</li><li>性能评估(performance evaluation)</li></ul><p>一般这几种方法都会做</p><h1 id="二、具体介绍"><a href="#二、具体介绍" class="headerlink" title="二、具体介绍"></a>二、具体介绍</h1><h2 id="1、动态仿真"><a href="#1、动态仿真" class="headerlink" title="1、动态仿真"></a>1、动态仿真</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110190714272.png" alt="image-20211110190714272"></p><ul><li>定向测试</li><li>随机测试：比对：线上比对和线下比对</li><li>参考模型检查</li><li>断言检查</li></ul><p>检查方式：参考模型检查和断言检查</p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110193630426.png" alt="image-20211110193630426"></p><h2 id="2、静态检查"><a href="#2、静态检查" class="headerlink" title="2、静态检查"></a>2、静态检查</h2><p><strong>本身不需要仿真，工具选择至关重要</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110193740585.png" alt="image-20211110193740585"></p><ul><li>语法检查(syntax check)</li><li>语义检查(linting check)</li><li>跨时钟域检查(CDC , Cross-clock Domain Check)：一个设计中有两个以上的时钟信号，从一个时钟区域到另一个区域的同步问题</li><li>形式验证(formoal verification)</li></ul><h3 id="1-语法检查"><a href="#1-语法检查" class="headerlink" title="(1) 语法检查"></a>(1) 语法检查</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194018595.png" alt="image-20211110194018595"></p><h3 id="2-语义检查linting-check"><a href="#2-语义检查linting-check" class="headerlink" title="(2) 语义检查linting check"></a>(2) 语义检查linting check</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194102113.png" alt="image-20211110194102113"></p><ul><li><p>做完语法检查再语义检查</p></li><li><p>使用专用工具</p></li><li><p>主要内容：</p></li><li><ul><li>常见设计错误</li><li>影响覆盖率收敛的问题</li><li>可能会产生X值以及受其影响的设计部分（寄存器忘记复位会产生X）</li></ul></li></ul><h3 id="3-跨时钟域检查"><a href="#3-跨时钟域检查" class="headerlink" title="(3) 跨时钟域检查"></a>(3) 跨时钟域检查</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194619901.png" alt="image-20211110194619901"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110194626550.png" alt="image-20211110194626550"></p><p><strong>重点：</strong></p><ul><li>无法通过常规的验证方法分析(即仿真的时候看不出来，门级仿真时的暴漏也是概论问题)</li><li>常规的验证方法验证（动态仿真）的是RTL阶段，无法体现建立保持时间，拿一个异步信号对另一个信号检查不会体现出来，建立保持时间在门级时暴露出来</li></ul><p><strong>为什么门级才暴漏，RTL就要做检查：</strong></p><ul><li>越往后耗费精力越大</li><li>门级问题仅仅有可能会发现（概率问题）</li></ul><p><strong>我们是怎么做的：</strong></p><ul><li>在早期RTL阶段识别出来跨时钟域电路有没有合适的同步处理（即跨时钟域检查CDC），保证所有跨时钟域信号能正确的同步</li><li>相关工具：Spyglass、0-In(Mentor)</li></ul><h3 id="4-形式验证"><a href="#4-形式验证" class="headerlink" title="(4) 形式验证"></a>(4) 形式验证</h3><ul><li>等价检查(EC , Equivalence Check)：LEC属于其中之一，用来保证两个电路的行为是等价的，可以用来检查不同抽象级的电路是否一致，例如RTL级和网表</li><li>属性检查(PC , Property Check)，又称模型检查(MC , Model Check)：电路行为通过验证语言来描述其属性property，随后通过静态方式来证明所有状态空间下都满足该条件，否则举出反例(counter example)来证明设计行为不符合属性描述(property description)</li></ul><p>属性检查用到的方法：SVA(SystemVerilog Assertion)、PSL(Property Specification Language)，不止SVA可以做属性检查PSL也可以。通过一些数学方法，证明在所有状态空间都满足属性的描述，若不满足，使用形式验证工具就会给出反例</p><p>SVA不止可以用在形式验证中做属性检查，也可以用在动态仿真里</p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110200421837.png" alt="image-20211110200421837"></p><p>答案：没说</p><h2 id="3、虚拟模型"><a href="#3、虚拟模型" class="headerlink" title="3、虚拟模型"></a>3、虚拟模型</h2><p>同样的一种对硬件抽象的模型，只不过抽象级更高</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110200648852.png" alt="image-20211110200648852"></p><p>虚拟模型是由SystemC构建的，软件基于虚拟模型来完成早期软件开发</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110203115942.png" alt="image-20211110203115942"></p><h3 id="目前软件是怎么做的第一段"><a href="#目前软件是怎么做的第一段" class="headerlink" title="目前软件是怎么做的第一段"></a>目前软件是怎么做的第一段</h3><p>什么时候开发：</p><h4 id="传统（古老方式）："><a href="#传统（古老方式）：" class="headerlink" title="传统（古老方式）："></a>传统（古老方式）：</h4><p>我们的RTL、Gate和TO，硬件走完了，系统比较稳定了，再到到板上测试</p><pre><code class=" mermaid">graph LRsoftware流程RTL--&gt;Gate --&gt; TO--&gt;流片--&gt;测试板上运行</code></pre><h4 id="现在的方式（没标注流片）："><a href="#现在的方式（没标注流片）：" class="headerlink" title="现在的方式（没标注流片）："></a>现在的方式（没标注流片）：</h4><pre><code class=" mermaid">graph LRsoftware流程RTL --系统比较稳定的时候--&gt;上板子fpga原型开发/EMO模拟器上面--&gt; Gate --&gt; TO --&gt; FinalESL --&gt; Final</code></pre><h3 id="第二段就是Fpga我们的原型开发"><a href="#第二段就是Fpga我们的原型开发" class="headerlink" title="第二段就是Fpga我们的原型开发"></a>第二段就是Fpga我们的原型开发</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110204201542.png" alt="image-20211110204201542"></p><p>开发ESL往往是一些算法的人，一些系统工程师，与designer不同，如果ESL相差不大可以基于ESL开发软件，但流片后仍然需要修改（ESL抽象级过高，如等待状态的时间无法确定）</p><h3 id="接上文第三段"><a href="#接上文第三段" class="headerlink" title="接上文第三段"></a>接上文第三段</h3><p>SystemC是可综合的，构建ESL的模型，可以经过verilog或直接跳过直接生成网表，使得算法直接综合为网表</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110204844698.png" alt="image-20211110204844698"></p><p>为什么我们一般不用这种方式：</p><ul><li><p>软件架构一般很大，硬件架构迭代很慢</p></li><li><p>ESL对于目前来说无法验证，机器翻译映射出来的内容很难理解</p></li></ul><h3 id="第四段"><a href="#第四段" class="headerlink" title="第四段"></a>第四段</h3><p>子系统落后于进度，测试用例没法做了，碰到这种情况把ESL暂时替代RTL的模型</p><p>一个SystemC可以非常抽象，可以没有时序没有硬件端口，但有些语法可以让你实现端口和时序</p><p>因此无论如何需要改造的，暂时性嵌入罢了</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110205930657.png" alt="image-20211110205930657"></p><p>系统工程师需要写ESL模型和功能描述文档，即ESL模型功能代表希望实现的模型，这种模型不仅可以嵌入到SOC上辅助功能验证赶上进度，同时集成到UVM和SV中做RefenceModel，红宝书17章17.2节UV.r的这样一个包</p><p>更早暴漏功能问题，提早完成窗口需求</p><h3 id="虚拟模型流程"><a href="#虚拟模型流程" class="headerlink" title="虚拟模型流程"></a>虚拟模型流程</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110210340141.png" alt="image-20211110210340141"></p><p>RTL—&gt;SystemC模型：不同公司开发流程不一样，有一帮人（虚拟建模组），从RTL中抽取称为SC模型，这种不能做RefenceModel，但可以做硬件模型因为理论上一致，有助于软件开发</p><p>虚拟模型岗位不多</p><h2 id="4、硬件加速"><a href="#4、硬件加速" class="headerlink" title="4、硬件加速"></a>4、硬件加速</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110210738434.png" alt="image-20211110210738434"></p><p>仿真速度存在限制</p><p>软件团队把代码瘦身然后交给硬件团队</p><h3 id="主要硬件加速平台"><a href="#主要硬件加速平台" class="headerlink" title="主要硬件加速平台"></a>主要硬件加速平台</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111202935736.png" alt="image-20211111202935736"></p><ul><li>FPGA：专门为软件提供，为什么：主要因为速度快是emulatior的几千到上万倍</li><li>专用模拟器(emulatior)：又是是仿真器的上千倍速度；由主流EDA公司提供（可以理解为FPGA+仿真器？）</li></ul><p><strong>速度比较：</strong></p><p>FPGA &gt; emulation &gt; simulation仿真</p><p><strong>比较：</strong></p><p>模拟器的调试比fpga方便，且速度比反正快，用于测试硬件（提高仿真速度）</p><p>FPGA往往是硬件已经得到充分验证后，用它做软件开发，而不是硬件验证</p><p>仿真器和模拟器都可以设置断点，而FPGA不可以</p><p><strong>EDA提供的模拟器如何实现：</strong>绝大多数模拟器内部都是FPGA，EDA公司只是基于定制的FPGA基础上做了软件开发，明白信号如何查看，且具有仿真器技术；为什么EDA公司做这个：附加值高</p><p>IC公司里模拟器资源宝贵，每个人使用要排队</p><h2 id="5、效能验证"><a href="#5、效能验证" class="headerlink" title="5、效能验证"></a>5、效能验证</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111204524451.png" alt="image-20211111204524451"></p><h3 id="1-效能验证分类"><a href="#1-效能验证分类" class="headerlink" title="(1) 效能验证分类"></a>(1) 效能验证分类</h3><p>这里我们主要针对硅前设计阶段进行效能验证，涉及的流程可分为两个部分</p><ul><li><p>功能验证：主要采用PA(Power Aware)( 主要包括由UPF(Unified Power Format) 或者CPF(Comment Power Format) ) 方式，通过与仿真器结合，模拟电源域的开关进行设计检查</p><ul><li><p>需要进入相关环境中跑仿真</p></li><li><p>多个电源域需要考虑不同电源域之间会不会有影响，什么时候开关某些电源域</p></li></ul></li><li><p><strong>功耗预测与优化：</strong>通过第三方功耗分析工具，结合仿真数据(FSDB/VCD/SAIF)，进行功耗预测，并给出分析结果</p><ul><li>不同仿真器保存下来数据格式不同(FSDB/VCD/SAIF)</li><li>数据交给第三方工具分析，进行功耗预测</li><li>RTL、Gate级都可以做预测，在门级做功耗预测真准确，RTL也要预测因为越早测结果越早分析越早优化硬件和软件</li></ul></li></ul><h3 id="2-效应验证-UPF-CPF-：从硬件或软件角度，我们一般会采用到的节能技术"><a href="#2-效应验证-UPF-CPF-：从硬件或软件角度，我们一般会采用到的节能技术" class="headerlink" title="(2) 效应验证(UPF/CPF)：从硬件或软件角度，我们一般会采用到的节能技术"></a>(2) 效应验证(UPF/CPF)：从硬件或软件角度，我们一般会采用到的节能技术</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111205708266.png" alt="image-20211111205708266"></p><ul><li><p><strong>多核与聚合结构：</strong>大小核结构</p><ul><li>高性能用大核心，低性能用小核心，但带来问题是面积增大<ul><li>扩展：原来每个子系统中心需要有核心进行调度控制各个子系统，中心的核心太慢了怎么办，把中心核变成小核，其他各个系统都带个核心自己控制，这就是一个聚合的结构</li></ul></li></ul></li><li><p><strong>多电压域：</strong>工作频率高电压高，频率低电压低</p></li></ul><h2 id="6、性能验证"><a href="#6、性能验证" class="headerlink" title="6、性能验证"></a>6、性能验证</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111210734687.png" alt="image-20211111210734687"></p><p>性能测试提前，硅前硅后使用相同测试用例，结果相差不大</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111211511327.png" alt="image-20211111211511327"></p><p>还是新颖概念，没有统一标准，更多的是在衡量指标（指标是由架构和系统工程师定的）</p><pre><code class=" mermaid">graph LR验证顺序功能验证 --&gt; 效能验证 --&gt; 性能验证</code></pre><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211111211818512.png" alt="image-20211111211818512"></p><p>答案：ABCD</p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110230643036.png" alt="miku"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通4：随机约束分布_约束块控制_数组约束_随机控制</title>
    <link href="/202111071946/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-2%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%88%86%E5%B8%83_%E7%BA%A6%E6%9D%9F%E5%9D%97%E6%8E%A7%E5%88%B6_%E6%95%B0%E7%BB%84%E7%BA%A6%E6%9D%9F_%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6/"/>
    <url>/202111071946/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-2%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%88%86%E5%B8%83_%E7%BA%A6%E6%9D%9F%E5%9D%97%E6%8E%A7%E5%88%B6_%E6%95%B0%E7%BB%84%E7%BA%A6%E6%9D%9F_%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、随机约束和分布"><a href="#一、随机约束和分布" class="headerlink" title="一、随机约束和分布"></a>一、随机约束和分布</h1><h2 id="1、为什么要有随机"><a href="#1、为什么要有随机" class="headerlink" title="1、为什么要有随机"></a>1、为什么要有随机</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194951207.png" alt="image-20211107194951207"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213400187.png" alt="image-20211107213400187"></p><h2 id="2、我们要随机什么"><a href="#2、我们要随机什么" class="headerlink" title="2、我们要随机什么"></a>2、我们要随机什么</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213528100.png" alt="image-20211107213528100"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107213622944.png" alt="image-20211107213622944"></p><p>AC</p><h2 id="3、声明随机变量的类"><a href="#3、声明随机变量的类" class="headerlink" title="3、声明随机变量的类"></a>3、声明随机变量的类</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107220825182.png" alt="image-20211107220825182"></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::<span class="hljs-built_in">randomize</span>();<span class="hljs-comment">//随机化变量，返回值0成功1失败</span><br></code></pre></div></td></tr></table></figure><p>rand、randc以及constranint同随机变量一起在类中声明</p><p><strong>一般随机都会伴随着约束</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107220949467.png" alt="image-20211107220949467"></p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">assert</span></span>(<span class="hljs-variable">p.randomize</span>());一般用这种写法进行随机化</span><br></code></pre></div></td></tr></table></figure><h2 id="4、什么是约束"><a href="#4、什么是约束" class="headerlink" title="4、什么是约束"></a>4、什么是约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222030463.png" alt="image-20211107222030463"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222043352.png" alt="image-20211107222043352"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222056315.png" alt="image-20211107222056315"></p><p>AB</p><p>C不对的原因是位宽对不上</p><h3 id="什么是约束（续）：约束不能产生冲突"><a href="#什么是约束（续）：约束不能产生冲突" class="headerlink" title="什么是约束（续）：约束不能产生冲突"></a>什么是约束（续）：约束不能产生冲突</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222236599.png" alt="image-20211107222236599"></p><h2 id="5、权重的分布：dist"><a href="#5、权重的分布：dist" class="headerlink" title="5、权重的分布：dist"></a>5、权重的分布：dist</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222507828.png" alt="image-20211107222507828"></p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-symbol">:/</span>或<span class="hljs-symbol">:</span>=<br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222547302.png" alt="image-20211107222547302"></p><p><code>:=</code>意味着常量相加</p><p><code>:/</code>意味着比例平分</p><h2 id="六、集合成员和inside运算符"><a href="#六、集合成员和inside运算符" class="headerlink" title="六、集合成员和inside运算符"></a>六、集合成员和inside运算符</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222830531.png" alt="image-20211107222830531"></p><p><code>inside</code>规定区间</p><p><code>$</code>表示最大值或最小值</p><h2 id="7、条件约束"><a href="#7、条件约束" class="headerlink" title="7、条件约束"></a>7、条件约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107222948156.png" alt="image-20211107222948156"></p><h2 id="8、双向约束"><a href="#8、双向约束" class="headerlink" title="8、双向约束"></a>8、双向约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107223027629.png" alt="image-20211107223027629"></p><p><strong>约束是声明语句，是并行的</strong></p><p>不同约束之间会产生冲突，如子类继承父类的约束(约束也可以继承)</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107223222650.png" alt="image-20211107223222650"></p><h1 id="二、约束块控制"><a href="#二、约束块控制" class="headerlink" title="二、约束块控制"></a>二、约束块控制</h1><h2 id="1、打开或关闭约束"><a href="#1、打开或关闭约束" class="headerlink" title="1、打开或关闭约束"></a>1、打开或关闭约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152432117.png" alt="image-20211110152432117"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">constraint_mode()<span class="hljs-comment">//打开或关闭约束</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152538507.png" alt="image-20211110152538507"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">p<span class="hljs-variable">.constrain_mode</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//关闭p内全部约束</span><br>p<span class="hljs-variable">.c_short</span><span class="hljs-variable">.constrain_mode</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//打开c_short约束</span><br></code></pre></div></td></tr></table></figure><p>与条件约束的不同，条件约束是在一个约束内进行判断，约束控制可以控制多个约束</p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110152844072.png" alt="image-20211110152844072"></p><p>D</p><h2 id="2、内嵌约束"><a href="#2、内嵌约束" class="headerlink" title="2、内嵌约束"></a>2、内嵌约束</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153056081.png" alt="image-20211110153056081"></p><p>使用<code>randomize() with</code>来增加临时约束，<strong>参考下图绿色部分</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153157520.png" alt="image-20211110153157520"></p><h3 id="重要-测试题：soft软约束"><a href="#重要-测试题：soft软约束" class="headerlink" title="(重要)测试题：soft软约束"></a>(重要)测试题：soft软约束<img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153224798.png" alt="image-20211110153224798"></h3><p>soft红色标注部分，没有soft选B，有soft选C</p><p>软约束<code>soft</code>，约束有冲突时soft声明的约束不起作用</p><h1 id="三、随机函数"><a href="#三、随机函数" class="headerlink" title="三、随机函数"></a>三、随机函数</h1><h3 id="1、无论是rand还是constraint能出现的范围就是类"><a href="#1、无论是rand还是constraint能出现的范围就是类" class="headerlink" title="1、无论是rand还是constraint能出现的范围就是类"></a>1、无论是rand还是constraint能出现的范围就是类</h3><p><strong>我们更希望把随机变量用<code>rand</code>或<code>randc</code>修饰，把他们封装到类里面</strong>：类是变量的自洽体，可以把相关的变量放在类里，变量之间的约束关系也可以方便的放在类里面</p><p><strong>无论是rand还是constraint能出现的范围就是类</strong></p><h3 id="2、randomize-预定义函数的解释，以及pre-randomize-和post-randomize-可自定义"><a href="#2、randomize-预定义函数的解释，以及pre-randomize-和post-randomize-可自定义" class="headerlink" title="2、randomize()预定义函数的解释，以及pre_randomize()和post_randomize()可自定义"></a>2、randomize()预定义函数的解释，以及pre_randomize()和post_randomize()可自定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110153907765.png" alt="image-20211110153907765"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">pre_randomzie();<br>post_randomzie();<br></code></pre></div></td></tr></table></figure><p>randomize() 回调函数</p><h3 id="3、系统函数：随机数函数"><a href="#3、系统函数：随机数函数" class="headerlink" title="3、系统函数：随机数函数"></a>3、系统函数：随机数函数</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110154802930.png" alt="image-20211110154802930"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-built_in">$random</span>()<br>$urandom()<br>$urandom_range()<br></code></pre></div></td></tr></table></figure><h2 id="4、-随机化个别变量"><a href="#4、-随机化个别变量" class="headerlink" title="4、 随机化个别变量"></a>4、 随机化个别变量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110155807524.png" alt="image-20211110155807524"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">randomize(变量名)<span class="hljs-comment">//只会随机化指定变量名，不会随机化其他</span><br></code></pre></div></td></tr></table></figure><p><strong>你不管随机化哪些指定变量，所有作用的约束依然有效</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110160424516.png" alt="image-20211110160424516"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110160520930.png" alt="image-20211110160520930"></p><h3 id="所有的约束条件都必须满足，否则约束失败"><a href="#所有的约束条件都必须满足，否则约束失败" class="headerlink" title="所有的约束条件都必须满足，否则约束失败"></a>所有的约束条件都必须满足，否则约束失败</h3><p>答案选C<br>A不对的原因是因为med&lt;hi不满足<br>low=报错 是因为randomize无法产生非rand的low的值，med,hi保持一开始的0</p><h1 id="四、数组约束"><a href="#四、数组约束" class="headerlink" title="四、数组约束"></a>四、数组约束</h1><h2 id="1、数组的大小"><a href="#1、数组的大小" class="headerlink" title="1、数组的大小"></a>1、数组的大小</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110161515221.png" alt="image-20211110161515221"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">rand</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] d[];<br><span class="hljs-keyword">constraint</span> d_size&#123;d<span class="hljs-variable">.size</span>() <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]&#125; &#125;<br></code></pre></div></td></tr></table></figure><p>随机化内容：</p><ul><li>动态数组的长度</li><li>动态数组的内容</li></ul><p>随机化时应：对数组的大小给定范围，防止生成大体积或空数组(不限制动态数组范围，则数组无意义）</p><p>可以使用约束的方法：<code>sum()</code>,<code>product()</code>,<code>and()</code>,<code>or()</code>,<code>xor()</code></p><h3 id="2、约束数组中的元素"><a href="#2、约束数组中的元素" class="headerlink" title="2、约束数组中的元素"></a>2、约束数组中的元素</h3><p><code>`foreach</code>更方便，使用它进行约束</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162030080.png" alt="image-20211110162030080"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162040215.png" alt="image-20211110162040215"></p><h2 id="3、产生唯一元素值的数组与randc"><a href="#3、产生唯一元素值的数组与randc" class="headerlink" title="3、产生唯一元素值的数组与randc"></a>3、产生唯一元素值的数组与randc</h2><h3 id="1-不是使用randc，而是嵌套循环"><a href="#1-不是使用randc，而是嵌套循环" class="headerlink" title="(1) 不是使用randc，而是嵌套循环"></a>(1) 不是使用randc，而是嵌套循环</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162134117.png" alt="image-20211110162134117"></p><p><strong>randc不能使数组内每一个元素都不同，而是每一次randomize后随机数都不同</strong></p><h3 id="2-利用randc变量来辅助生成：randc类比扑克牌"><a href="#2-利用randc变量来辅助生成：randc类比扑克牌" class="headerlink" title="(2) 利用randc变量来辅助生成：randc类比扑克牌"></a>(2) 利用randc变量来辅助生成：randc类比扑克牌</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110162943509.png" alt="image-20211110162943509"></p><p>randomize之前，自动先调用pre_randomize()</p><h3 id="3-SV新标准解决数组问题，关键词：unique"><a href="#3-SV新标准解决数组问题，关键词：unique" class="headerlink" title="(3) SV新标准解决数组问题，关键词：unique"></a>(3) SV新标准解决数组问题，关键词：unique</h3><p>unique限定一个数组，使其独一无二</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110165836345.png" alt="image-20211110165836345"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110165907602.png" alt="image-20211110165907602"></p><p>经常出错，答案是D</p><p>原因不是因为动态数组没有new，关键是动态数组有限定语<code>rand</code>，rand添加后指示<code>randomize</code>会帮助你例化填充这个元素</p><p>foreach这个约束不存在，不合理，需要增加if(i&lt;=da.size()-2()</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170350783.png" alt="image-20211110170350783"></p><h2 id="4、随机化句柄数组"><a href="#4、随机化句柄数组" class="headerlink" title="4、随机化句柄数组"></a>4、随机化句柄数组</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170428370.png" alt="image-20211110170428370"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110170436764.png" alt="image-20211110170436764"></p><h3 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110171819881.png" alt="image-20211110171819881"></p><p>答案：B</p><p>RandStuff类里面没有被rand修饰的变量，因此作为句柄被上级对象随机的过程中无法对内部的变量值随机</p><p>为什么MAX_SIZE个例化，因为保证randomize所有句柄都指向一个对象都是合法的</p><h1 id="五、随机控制"><a href="#五、随机控制" class="headerlink" title="五、随机控制"></a>五、随机控制</h1><h2 id="1、随机序列：关键词，randsequence-atomic"><a href="#1、随机序列：关键词，randsequence-atomic" class="headerlink" title="1、随机序列：关键词，randsequence,atomic"></a>1、随机序列：关键词，randsequence,atomic</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172410044.png" alt="image-20211110172410044"></p><p><strong>没有用UVM之前，用这个产生激励</strong>，因此可做了解</p><p><code>randsequence(stream)</code></p><p><code>stream</code>是一个入口，可能会分别进入到，cfg_read,mem_read,io_read分支中，且进入的权重和可能性不一样</p><p>类比case语句</p><h2 id="2、随机控制：randcase"><a href="#2、随机控制：randcase" class="headerlink" title="2、随机控制：randcase"></a>2、随机控制：randcase</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172755254.png" alt="image-20211110172755254"></p><p><code>randcase</code>：一个随机决策树</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211110172828044.png" alt="image-20211110172828044"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识4：验证的管理</title>
    <link href="/202111021710/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <url>/202111021710/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A04-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的周期"><a href="#一、验证的周期" class="headerlink" title="一、验证的周期"></a>一、验证的周期</h1><h2 id="1-一个验证菜鸟在第一家公司第一个月的经历"><a href="#1-一个验证菜鸟在第一家公司第一个月的经历" class="headerlink" title="1.一个验证菜鸟在第一家公司第一个月的经历"></a>1.一个验证菜鸟在第一家公司第一个月的经历</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171144078.png" alt="image-20211102171144078"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171236404.png" alt="image-20211102171236404"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171321066.png" alt="image-20211102171321066"></p><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171354986.png" alt="image-20211102171354986"></p><p><strong>AB</strong></p><h2 id="2-验证里程碑（RTL0-3，GLS，T0）"><a href="#2-验证里程碑（RTL0-3，GLS，T0）" class="headerlink" title="2.验证里程碑（RTL0~3，GLS，T0）"></a>2.验证里程碑（RTL0~3，GLS，T0）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171515725.png" alt="image-20211102171515725"></p><h3 id="RTL0：验证文档规范"><a href="#RTL0：验证文档规范" class="headerlink" title="RTL0：验证文档规范"></a>RTL0：验证文档规范</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171712289.png" alt="image-20211102171712289"></p><p>验证功能能规范</p><h3 id="RTL1：UVM模型"><a href="#RTL1：UVM模型" class="headerlink" title="RTL1：UVM模型"></a>RTL1：UVM模型</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102171821935.png" alt="image-20211102171821935"></p><h3 id="RTL2：绝大多数核心节点的验证"><a href="#RTL2：绝大多数核心节点的验证" class="headerlink" title="RTL2：绝大多数核心节点的验证"></a>RTL2：绝大多数核心节点的验证</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102172042991.png" alt="image-20211102172042991"></p><h3 id="RTL3"><a href="#RTL3" class="headerlink" title="RTL3"></a>RTL3</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102172218157.png" alt="image-20211102172218157"></p><h3 id="GTS"><a href="#GTS" class="headerlink" title="GTS"></a>GTS</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105220900718.png" alt="image-20211105220900718"></p><p>RTL仿真与网表仿真？</p><h3 id="T0"><a href="#T0" class="headerlink" title="T0"></a>T0</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221532996.png" alt="image-20211105221532996"></p><h3 id="进入公司一定要看一下处于哪个验证周期"><a href="#进入公司一定要看一下处于哪个验证周期" class="headerlink" title="进入公司一定要看一下处于哪个验证周期"></a>进入公司一定要看一下处于哪个验证周期</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221654082.png" alt="image-20211105221654082"></p><h3 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221740561.png" alt="image-20211105221740561"></p><h1 id="二、验证三要素"><a href="#二、验证三要素" class="headerlink" title="二、验证三要素"></a>二、验证三要素</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221901393.png" alt="image-20211105221901393"></p><h2 id="2-时间管理"><a href="#2-时间管理" class="headerlink" title="2. 时间管理"></a>2. 时间管理</h2><h3 id="1-早行动"><a href="#1-早行动" class="headerlink" title="(1) 早行动"></a>(1) 早行动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105221924054.png" alt="image-20211105221924054"></p><h3 id="2-时间管理之少依赖（对设计的依赖）"><a href="#2-时间管理之少依赖（对设计的依赖）" class="headerlink" title="(2) 时间管理之少依赖（对设计的依赖）"></a>(2) 时间管理之少依赖（对设计的依赖）</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222546866.png" alt="image-20211105222546866"></p><h3 id="3-大局观"><a href="#3-大局观" class="headerlink" title="(3) 大局观"></a>(3) 大局观</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222759615.png" alt="image-20211105222759615"></p><h3 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105222915443.png" alt="image-20211105222915443"></p><h2 id="3-人力资源安排"><a href="#3-人力资源安排" class="headerlink" title="3. 人力资源安排"></a>3. 人力资源安排</h2><h3 id="1-团队建设"><a href="#1-团队建设" class="headerlink" title="(1) 团队建设"></a>(1) 团队建设</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223159744.png" alt="image-20211105223159744"></p><h3 id="2-团队建设"><a href="#2-团队建设" class="headerlink" title="(2) 团队建设"></a>(2) 团队建设</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223327167.png" alt="image-20211105223327167"></p><h3 id="3-技术和管理"><a href="#3-技术和管理" class="headerlink" title="(3) 技术和管理"></a>(3) 技术和管理</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223508287.png" alt="image-20211105223508287"></p><h2 id="4-任务拆分和重组"><a href="#4-任务拆分和重组" class="headerlink" title="4. 任务拆分和重组"></a>4. 任务拆分和重组</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223719610.png" alt="image-20211105223719610"></p><h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105223728950.png" alt="image-20211105223728950"></p><h3 id="任务重组"><a href="#任务重组" class="headerlink" title="任务重组"></a>任务重组</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105224058382.png" alt="image-20211105224058382"></p><h3 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105224959292.png" alt="image-20211105224959292"></p><h1 id="三、-验证的收敛"><a href="#三、-验证的收敛" class="headerlink" title="三、 验证的收敛"></a>三、 验证的收敛</h1><h2 id="1-概述：回归测试及考虑因素"><a href="#1-概述：回归测试及考虑因素" class="headerlink" title="1.概述：回归测试及考虑因素"></a>1.概述：回归测试及考虑因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211105225537751.png" alt="image-20211105225537751"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107190623890.png" alt="image-20211107190623890"></p><ul><li>回归流程</li><li>回归质量</li><li>回归效率</li></ul><h2 id="2-回归流程"><a href="#2-回归流程" class="headerlink" title="2. 回归流程"></a>2. 回归流程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107190939681.png" alt="image-20211107190939681"></p><h3 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191052968.png" alt="image-20211107191052968"></p><p>B</p><h2 id="3-回归的质量"><a href="#3-回归的质量" class="headerlink" title="3. 回归的质量"></a>3. 回归的质量</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191259842.png" alt="image-20211107191259842"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191309701.png" alt="image-20211107191309701"></p><h2 id="4-回归效率"><a href="#4-回归效率" class="headerlink" title="4. 回归效率"></a>4. 回归效率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191426112.png" alt="image-20211107191426112"></p><p>后期收益明显降低</p><h3 id="回归效率的提升"><a href="#回归效率的提升" class="headerlink" title="回归效率的提升"></a>回归效率的提升</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191520676.png" alt="image-20211107191520676"></p><h3 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107191904194.png" alt="image-20211107191904194"></p><p>ABCD</p><h1 id="四、问题的跟踪"><a href="#四、问题的跟踪" class="headerlink" title="四、问题的跟踪"></a>四、问题的跟踪</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192037682.png" alt="image-20211107192037682"></p><h2 id="2-追踪的问题类型"><a href="#2-追踪的问题类型" class="headerlink" title="2. 追踪的问题类型"></a>2. 追踪的问题类型</h2><ul><li>系统功能定义问题</li><li>硬件设计问题</li><li>芯片验证环境问题</li><li>综合时序问题</li><li>硅前工具问题</li><li>引用库和IP问题</li></ul><h2 id="3-追踪工具"><a href="#3-追踪工具" class="headerlink" title="3. 追踪工具"></a>3. 追踪工具</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192309290.png" alt="image-20211107192309290"></p><h3 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192334890.png" alt="image-20211107192334890"></p><p>ABCD</p><h2 id="4-工具的功能"><a href="#4-工具的功能" class="headerlink" title="4. 工具的功能"></a>4. 工具的功能</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192413094.png" alt="image-20211107192413094"></p><p>记录、分类、派发、查找、追溯、报告</p><h2 id="5-追踪流程"><a href="#5-追踪流程" class="headerlink" title="5. 追踪流程"></a>5. 追踪流程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192552504.png" alt="image-20211107192552504"></p><h1 id="五、团队建设"><a href="#五、团队建设" class="headerlink" title="五、团队建设"></a>五、团队建设</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192636754.png" alt="image-20211107192636754"></p><h2 id="七个好习惯：追求百分百"><a href="#七个好习惯：追求百分百" class="headerlink" title="七个好习惯：追求百分百"></a>七个好习惯：追求百分百</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192732790.png" alt="image-20211107192732790"></p><h2 id="七个好习惯：保持面向对象的开发习惯"><a href="#七个好习惯：保持面向对象的开发习惯" class="headerlink" title="七个好习惯：保持面向对象的开发习惯"></a>七个好习惯：保持面向对象的开发习惯</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107192929505.png" alt="image-20211107192929505"></p><h2 id="七个好习惯：合理复用"><a href="#七个好习惯：合理复用" class="headerlink" title="七个好习惯：合理复用"></a>七个好习惯：合理复用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193033349.png" alt="image-20211107193033349"></p><h2 id="七个好习惯：保持创新"><a href="#七个好习惯：保持创新" class="headerlink" title="七个好习惯：保持创新"></a>七个好习惯：保持创新</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193430794.png" alt="image-20211107193430794"></p><h2 id="七个好习惯：高效的沟通"><a href="#七个好习惯：高效的沟通" class="headerlink" title="七个好习惯：高效的沟通"></a>七个好习惯：高效的沟通</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193513702.png" alt="image-20211107193513702"></p><h2 id="七个好习惯：突破责任边界"><a href="#七个好习惯：突破责任边界" class="headerlink" title="七个好习惯：突破责任边界"></a>七个好习惯：突破责任边界</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193754756.png" alt="image-20211107193754756"></p><h1 id="六、验证的专业化"><a href="#六、验证的专业化" class="headerlink" title="六、验证的专业化"></a>六、验证的专业化</h1><h2 id="1、对验证的偏见"><a href="#1、对验证的偏见" class="headerlink" title="1、对验证的偏见"></a>1、对验证的偏见</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193905835.png" alt="image-20211107193905835"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107193923570.png" alt="image-20211107193923570"></p><h2 id="2、验证面临的现状"><a href="#2、验证面临的现状" class="headerlink" title="2、验证面临的现状"></a>2、验证面临的现状</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194054454.png" alt="image-20211107194054454"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194123229.png" alt="image-20211107194123229"></p><h2 id="3、验证经验的积累和突破"><a href="#3、验证经验的积累和突破" class="headerlink" title="3、验证经验的积累和突破"></a>3、验证经验的积累和突破</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211107194231093.png" alt="image-20211107194231093"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用系统函数</title>
    <link href="/202111011730/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    <url>/202111011730/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>stop() //停止运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通3：类的方法和继承_动态对象_包的使用</title>
    <link href="/202110311523/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-2%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF_%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1_%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/202110311523/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-2%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF_%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1_%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类和对象的概述"><a href="#一、类和对象的概述" class="headerlink" title="一、类和对象的概述"></a>一、类和对象的概述</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><ul><li>property属性</li><li>function功能</li><li>class类</li><li>object对象</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031152459545.png" alt="image-20211031152459545"></p><h2 id="2-为什么验证需要有OOP"><a href="#2-为什么验证需要有OOP" class="headerlink" title="2.为什么验证需要有OOP"></a>2.为什么验证需要有OOP</h2><ul><li>激励生成器(stimulus generator)：生成激励内容</li><li>驱动器(driver)：将激励以时序形式发送给DUT</li><li>监控器(monitor)：监测信号并记录数据</li><li>比较器(checker)：比较数据</li></ul><p>验证环境的不同组件其功能和所需处理的数据内容是不同的</p><p>不同环境中同一类型组件所具备的功能和数据内容类似</p><h2 id="3-第一个激励数据类-transaction失误类"><a href="#3-第一个激励数据类-transaction失误类" class="headerlink" title="3. 第一个激励数据类(transaction失误类)"></a>3. 第一个激励数据类(transaction失误类)</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Transaction;<br><span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] addr, crc, data[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display;<br>$dispaly(<span class="hljs-string">&quot;Transcation:%h&quot;</span>,addr);<br>    <span class="hljs-keyword">endfunction</span>:display<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc;<br>    crc = addr ^ data<span class="hljs-variable">.xor</span>;<br>    <span class="hljs-keyword">endfunction</span>:calc_clc<br><span class="hljs-keyword">endclass</span>:Transcation<br></code></pre></div></td></tr></table></figure><h3 id="1-类里面变量的定义（重要）"><a href="#1-类里面变量的定义（重要）" class="headerlink" title="(1) 类里面变量的定义（重要）"></a>(1) 类里面变量的定义（重要）</h3><p>应该是软件的变量，缺省类型为<code>var</code>，不能是<code>reg</code>或<code>wire</code>等硬件类型</p><h3 id="2-软件与硬件的媒介：接口"><a href="#2-软件与硬件的媒介：接口" class="headerlink" title="(2) 软件与硬件的媒介：接口"></a>(2) 软件与硬件的媒介：接口</h3><p>virtual interface（接口指针）可以传递到类里面，类通过接口可以获得硬件中的信号</p><h3 id="对象和module的不同"><a href="#对象和module的不同" class="headerlink" title="对象和module的不同"></a>对象和module的不同</h3><ul><li><p>module里面的变量都是静态的，而对象是动态的生成</p></li><li><p>module里面定义方法只能在<strong>过程快</strong>中调用，class可以通过class嵌套class来调用，但class里面不能出现always和innashao</p></li><li><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031155036528.png" alt="image-20211031155036528"></p></li><li></li></ul><h2 id="4-OPP概念要素"><a href="#4-OPP概念要素" class="headerlink" title="4.OPP概念要素"></a>4.OPP概念要素</h2><ul><li>Class</li><li>Object</li><li>Handle句柄(指针)，为什么称之为指针？在SV中除了对象外没有类似的操作了，</li><li>Property</li><li>Method</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031154901529.png" alt="image-20211031154901529"></p><h2 id="5-创建对象-构造函数"><a href="#5-创建对象-构造函数" class="headerlink" title="5. 创建对象+构造函数"></a>5. 创建对象+构造函数</h2><p>构造函数<code>new()</code>是系统预定义函数，不需要指定返回值，函数会隐式地返回例化后的对象指针</p><p>注意构造函数<code>new()</code>是小括号，动态数组<code>new[$]</code>是中括号</p><p>创建对象：开辟了新的内存空间，用来存放新的成员变量和方法</p><p>构造函数可以定义形参缺省值，同C++</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031155932848.png" alt="image-20211031155932848"></p><h4 id="谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）"><a href="#谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）" class="headerlink" title="谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）"></a>谁在前，谁在后？（关于定义初始值，构造函数值冲突时，谁会覆盖的问题）</h4><p>答案10</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160033614.png" alt="image-20211031160033614"></p><h2 id="6-声明和例化的区分——句柄的传递"><a href="#6-声明和例化的区分——句柄的传递" class="headerlink" title="6. 声明和例化的区分——句柄的传递"></a>6. 声明和例化的区分——句柄的传递</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Transcation</span> t<span class="hljs-number">1</span> ,t<span class="hljs-number">2</span>;//不是例化，只是声明句柄t<span class="hljs-number">1</span>,t<span class="hljs-number">2</span><br><span class="hljs-attribute">t1</span> = new ();//这里才是例化，例化对象将其句柄赋予t<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160521161-16356675228628.png" alt="image-20211031160521161"></p><h2 id="7-对象的销毁：SV也有自动回收内存空间的机制"><a href="#7-对象的销毁：SV也有自动回收内存空间的机制" class="headerlink" title="7. 对象的销毁：SV也有自动回收内存空间的机制"></a>7. 对象的销毁：SV也有自动回收内存空间的机制</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160539755-16356675733889.png" alt="image-20211031160539755"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031160840083.png" alt="image-20211031160840083"></p><p>选B，在module里面定义的即便是initial里面的都是静态的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031161055070.png" alt="image-20211031161055070"></p><p>下图加了个automatic就不存在了，答案是D</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162639036.png" alt="image-20211031162639036"></p><h2 id="8-句柄的使用（空指针很危险）"><a href="#8-句柄的使用（空指针很危险）" class="headerlink" title="8.句柄的使用（空指针很危险）"></a>8.句柄的使用（空指针很危险）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162727269.png" alt="image-20211031162727269"></p><h2 id="9-静态变量（static进行声明）"><a href="#9-静态变量（static进行声明）" class="headerlink" title="9. 静态变量（static进行声明）"></a>9. 静态变量（static进行声明）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031162757018.png" alt="image-20211031162757018"></p><p><strong>引用方式有两种</strong></p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span>::<span class="hljs-keyword">var</span><span class="hljs-comment">//直接类名引用</span><br><span class="hljs-keyword">object</span>.<span class="hljs-keyword">var</span><span class="hljs-comment">//通过例化的对象引用</span><br></code></pre></div></td></tr></table></figure><h2 id="10-静态方法"><a href="#10-静态方法" class="headerlink" title="10. 静态方法"></a>10. 静态方法</h2><p>同C++，无法调用动态成员变量</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163108643.png" alt="image-20211031163108643"></p><h1 id="二、类的成员"><a href="#二、类的成员" class="headerlink" title="二、类的成员"></a>二、类的成员</h1><h2 id="1-概述-默认public，主动声明protected-local"><a href="#1-概述-默认public，主动声明protected-local" class="headerlink" title="1. 概述(默认public，主动声明protected,local)"></a>1. 概述(默认public，主动声明protected,local)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163245473.png" alt="image-20211031163245473"></p><ul><li><p>秉承单一职责原则(SRP , Single Responsibility Principle)</p></li><li><p><code>protected</code>,<code>local</code>进行封装，称为开放封闭原则(OCP , Open Closed Principle)</p></li></ul><h3 id="local-私有成员"><a href="#local-私有成员" class="headerlink" title="local 私有成员"></a>local 私有成员</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163611076.png" alt="image-20211031163611076"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163703340.png" alt="image-20211031163703340"></p><p>选D</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163715150.png" alt="image-20211031163715150"></p><h3 id="public-protected-local"><a href="#public-protected-local" class="headerlink" title="public,protected,local"></a>public,protected,local</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031163925657.png" alt="image-20211031163925657"></p><h2 id="2-类的封装"><a href="#2-类的封装" class="headerlink" title="2. 类的封装"></a>2. 类的封装</h2><h3 id="类与结构体的异同"><a href="#类与结构体的异同" class="headerlink" title="类与结构体的异同"></a>类与结构体的异同</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164238926.png" alt="image-20211031164238926"></p><h3 id="类与模块的异同"><a href="#类与模块的异同" class="headerlink" title="类与模块的异同"></a>类与模块的异同</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164321237.png" alt="image-20211031164321237"></p><p>答案A</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164516245.png" alt="image-20211031164516245"></p><h2 id="3-类的定义位置，嵌套类，this，类的编译顺序"><a href="#3-类的定义位置，嵌套类，this，类的编译顺序" class="headerlink" title="3. 类的定义位置，嵌套类，this，类的编译顺序"></a>3. 类的定义位置，嵌套类，this，类的编译顺序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164644625.png" alt="image-20211031164644625"></p><h1 id="三、类的继承"><a href="#三、类的继承" class="headerlink" title="三、类的继承"></a>三、类的继承</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031164924500.png" alt="image-20211031164924500"></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cat</span></span>;<br><span class="hljs-keyword">protected</span> data;<br>function f1();<br>;<span class="hljs-comment">//statements</span><br>endfunction;<br>endclass<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">black_cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">cat</span></span>;<br>function <span class="hljs-keyword">new</span>();<br><br>endfunction<br>endclass<br></code></pre></div></td></tr></table></figure><h2 id="2-验证环境中的案例1"><a href="#2-验证环境中的案例1" class="headerlink" title="2. 验证环境中的案例1"></a>2. 验证环境中的案例1</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031171609238.png" alt="image-20211031171609238"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031171616311.png" alt="image-20211031171616311"></p><p><strong>要把数据发送到DUT，我们需要有以下基本元素和数据处理方法，我们将它们封装到Transaction类中</strong></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Transcation;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] src , dst , data[<span class="hljs-number">8</span>]; <span class="hljs-comment">//随机成员变量</span><br><span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<span class="hljs-comment">//二次处理后的成员数据</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc();<br>crc = src ^ dst ^ data<span class="hljs-variable">.xor</span>;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> prefix=<span class="hljs-string">&quot;&quot;</span>);<br>$dispaly(<span class="hljs-string">&quot;%sTr:src=%h,dst-%h,crc=%h&quot;</span>,prefix,src,dst,crc);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172140615.png" alt="image-20211031172140615"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172214276.png" alt="image-20211031172214276"></p><p><strong>BadTr</strong>:使用super索引父类中的同名函数，默认情况下两个类的同名函数没有关系</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> BadTr <span class="hljs-keyword">extends</span> Transcation;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> bad_crc; <br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> calc_crc();<br><span class="hljs-keyword">super</span><span class="hljs-variable">.calc_crc</span>();<span class="hljs-comment">//compute good CRC</span><br><span class="hljs-keyword">if</span>(bad_crc)<br>crc=~crc;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> prefix=<span class="hljs-string">&quot;&quot;</span>);<br>        dispaly(<span class="hljs-string">&quot;%sBadTr:bad_crc=%b&quot;</span>,prefix,bad_crc);<br><span class="hljs-keyword">super</span><span class="hljs-variable">.display</span>();<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></div></td></tr></table></figure><h2 id="3-验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数"><a href="#3-验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数" class="headerlink" title="3. 验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数"></a>3. 验证环境中的案例2：子类在定义new函数时应该首先调用父类的new函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031172855646.png" alt="image-20211031172855646"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031173019135.png" alt="image-20211031173019135"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031173037085.png" alt="image-20211031173037085"></p><p><strong>特别注意：子类在定义new函数时应该首先调用父类的new函数</strong></p><ul><li><p>子类实例在初始化时首先会调用父类的构造函数</p></li><li><p>当父类构造函数完成时会见子类实例对象按照定义时进行默认值初始化，如果没有默认值则不初始化</p></li><li>在成员变量默认赋值后，才会进入用户定义中的new函数中</li></ul><h2 id="4-成员覆盖：子类和父类同名变量和方法"><a href="#4-成员覆盖：子类和父类同名变量和方法" class="headerlink" title="4.成员覆盖：子类和父类同名变量和方法"></a>4.成员覆盖：子类和父类同名变量和方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102152001680.png" alt="image-20211102152001680"></p><p>按照句柄类型来确定作用域：即各管各的，定义同名后，直接调用是子类的，super.是父类的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102152214429.png" alt="image-20211102152214429"></p><p>t是父类句柄，只能指向父类对象内的成员</p><h3 id="成员索引顺序"><a href="#成员索引顺序" class="headerlink" title="成员索引顺序"></a>成员索引顺序</h3><p>调用子类成员时，现在子类里面搜，子类里面没有相应成员则去父类里面搜</p><p>允许同名成员出现，不会覆盖，只是调用最先找到的成员（即子类内成员）</p><p>子类对象赋值给父类句柄时，父类无法访问子类成员变量，只能访问父类内对象</p><h1 id="四、句柄的使用"><a href="#四、句柄的使用" class="headerlink" title="四、句柄的使用"></a>四、句柄的使用</h1><h2 id="1-句柄的传递"><a href="#1-句柄的传递" class="headerlink" title="1. 句柄的传递"></a>1. 句柄的传递</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102153533672.png" alt="image-20211102153533672"></p><p><strong>形参中的类，总是句柄，而不是例化的对象</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102153622156.png" alt="image-20211102153622156"></p><h3 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154016268.png" alt="image-20211102154016268"></p><p>$display(t.addr)最后会报错</p><p>分析如上：<br>function (形参)，形参<strong>默认方向是input</strong>，声明完句柄后句柄的值为null，在function中完成例化，但并未被传递出去（没有返回出去）</p><h2 id="2-句柄的动态修改"><a href="#2-句柄的动态修改" class="headerlink" title="2. 句柄的动态修改"></a>2. 句柄的动态修改</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154327828.png" alt="image-20211102154327828"></p><p>笑死，不就是八吗，路桑是不是弱智啊</p><h1 id="五、包的使用"><a href="#五、包的使用" class="headerlink" title="五、包的使用"></a>五、包的使用</h1><h2 id="1-包的意义，相关的类可以组织在同一命名空间中"><a href="#1-包的意义，相关的类可以组织在同一命名空间中" class="headerlink" title="1. 包的意义，相关的类可以组织在同一命名空间中"></a>1. 包的意义，相关的类可以组织在同一命名空间中</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102154752523.png" alt="image-20211102154752523"></p><p>多个module、Interface和program之间共享数据的方法</p><p><strong>命名空间实际上就是个package</strong></p><h2 id="2-包的定义"><a href="#2-包的定义" class="headerlink" title="2. 包的定义"></a>2. 包的定义</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155152726.png" alt="image-20211102155152726"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> reg_pkg;<br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;xxx_1.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> &quot;xxx_2.sv&quot;</span><br>...<br><span class="hljs-keyword">endpackage</span><br></code></pre></div></td></tr></table></figure><h3 id="包-域，不用担心重名冲突"><a href="#包-域，不用担心重名冲突" class="headerlink" title="包+域，不用担心重名冲突"></a>包+域，不用担心重名冲突</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155412032.png" alt="image-20211102155412032"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mcdf_tb;<br>regs_pkg::monitor mon1 = <span class="hljs-keyword">new</span>();<br>arb_pkg::monitor mon2 = <span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="3-包与库的区分，包-package-库-library"><a href="#3-包与库的区分，包-package-库-library" class="headerlink" title="3. 包与库的区分，包(package)库(library)"></a>3. 包与库的区分，包(package)库(library)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102155543142.png" alt="image-20211102155543142"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102160948179.png" alt="image-20211102160948179"></p><p>package编译到library里面</p><h2 id="4-包的命名规则"><a href="#4-包的命名规则" class="headerlink" title="4.包的命名规则"></a>4.包的命名规则</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161023204.png" alt="image-20211102161023204"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161034379.png" alt="image-20211102161034379"></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">module</span> mcdf)tb;<br><span class="hljs-keyword">import</span> regs_pkg::*;<span class="hljs-comment">//类似于 using namespace xx;</span><br><span class="hljs-keyword">import</span> arb_pkg::*;<br>    regs_mon mon1 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>();<br>    arb_mon mon2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>();<br>endmodule<br></code></pre></div></td></tr></table></figure><h2 id="5-包的使用：包不用例化，包就是个容器"><a href="#5-包的使用：包不用例化，包就是个容器" class="headerlink" title="5.包的使用：包不用例化，包就是个容器"></a>5.包的使用：包不用例化，包就是个容器</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211102161534955.png" alt="image-20211102161534955"></p><ul><li><p>包就像一个library一样，只不过比Library低一个层级，你把定义好的东西放到包里面</p></li><li><p><strong>package</strong>里面不能定义与硬件相关的部分（module,interface,program都不能)</p></li><li><p>类是包的好朋友，包是类的归宿，我们会把类都放到包里面</p></li><li>一个完整的磨矿验证环境<strong>组件类</strong>，应该由一个对应的模块包来封装</li></ul><h2 id="软件的东西一定要放到包里面"><a href="#软件的东西一定要放到包里面" class="headerlink" title="软件的东西一定要放到包里面"></a>软件的东西一定要放到包里面</h2>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识3：验证计划概述</title>
    <link href="/202110292211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%AF%84%E4%BC%B0/"/>
    <url>/202110292211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A03-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、计划的概述"><a href="#一、计划的概述" class="headerlink" title="一、计划的概述"></a>一、计划的概述</h1><h2 id="1-验证计划是什么"><a href="#1-验证计划是什么" class="headerlink" title="1. 验证计划是什么"></a>1. 验证计划是什么</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029214110766.png" alt="image-20211029214110766"></p><h2 id="2-验证计划的步骤"><a href="#2-验证计划的步骤" class="headerlink" title="2. 验证计划的步骤"></a>2. 验证计划的步骤</h2><ul><li>创建验证<strong>计划</strong></li><li>选择验证<strong>方法</strong></li><li><strong>人力</strong>资源调配</li><li>构建验证<strong>平台</strong>和环境组件</li><li>开发测试<strong>用例</strong></li></ul><h2 id="3-收集的材料"><a href="#3-收集的材料" class="headerlink" title="3.收集的材料"></a>3.收集的材料</h2><ul><li>结构功能描述</li><li>设计的各种操作使用模式</li><li>在正常输入和错误输入情形下设计的行为</li><li>设计的接口</li><li>一些边界情况下设计的行为</li><li>设计在实际使用中的场景描述</li></ul><h2 id="4-为芯片开发带来的好处"><a href="#4-为芯片开发带来的好处" class="headerlink" title="4. 为芯片开发带来的好处"></a>4. 为芯片开发带来的好处</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031102808812-16356472902941.png" alt="image-20211031102808812"></p><h2 id="5-影响计划的因素"><a href="#5-影响计划的因素" class="headerlink" title="5. 影响计划的因素"></a>5. 影响计划的因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103102280-16356474658782.png" alt="image-20211031103102280"></p><h1 id="二、计划的内容"><a href="#二、计划的内容" class="headerlink" title="二、计划的内容"></a>二、计划的内容</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li>技术部分+项目部分</li><li>验证的功能点+验证层次+测试用例+验证方法+覆盖率要求</li><li>使用工具+人力安排+进度安排+风险评估</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103403323-16356476453873.png" alt="image-20211031103403323"></p><h2 id="2-验证的功能"><a href="#2-验证的功能" class="headerlink" title="2. 验证的功能"></a>2. 验证的功能</h2><ul><li>基本功能：时钟、电源、复位、寄存器访问和基本特性（模块级别验证）</li><li>互动功能：与其他模块互动的特性（更高一层）</li><li>次要功能：一般在项目后期验证：性能验证、效能验证，对芯片本身没有致命影响</li></ul><h2 id="3-验证的层次"><a href="#3-验证的层次" class="headerlink" title="3. 验证的层次"></a>3. 验证的层次</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103916405.png" alt="image-20211031103916405"></p><h2 id="4-验证的方法"><a href="#4-验证的方法" class="headerlink" title="4. 验证的方法"></a>4. 验证的方法</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104023829.png" alt="image-20211031104023829"></p><p>白盒不行，需要查看内部信号，无法复用，尽量黑盒</p><p>为什么UVM</p><h2 id="5-测试用例"><a href="#5-测试用例" class="headerlink" title="5. 测试用例"></a>5. 测试用例</h2><ul><li>更随机的测试方法，尽可能遍历可能的各种状态空间？</li><li>适中的随机约束，倾向于更贴近使用场景的随即激励？</li><li>采用定向测试，针对一些边界情况可以更有效地完善覆盖率？</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104336692.png" alt="image-20211031104336692"></p><p>一开始比较明确的数据输入，所以随即约束域比较窄(<strong>参考测试题4</strong>)</p><p>基本功能验证-&gt;完备功能验证-&gt;边界情况验证</p><h2 id="6-覆盖率的要求"><a href="#6-覆盖率的要求" class="headerlink" title="6. 覆盖率的要求"></a>6. 覆盖率的要求</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104723866-16356484448824-16356484477695.png" alt="image-20211031104723866"></p><p>FPGA测试也可以提高覆盖率</p><h2 id="7-工具的选择"><a href="#7-工具的选择" class="headerlink" title="7. 工具的选择"></a>7. 工具的选择</h2><ul><li>仿真工具</li><li>形式验证工具</li><li>验证IP</li><li>断言IP</li><li>调试器（UVM比SV调试方法多）</li><li>硬件加速器（与FPGA结合进行验证）</li><li>高层次验证语言(High-level Verification Language , HVL)</li></ul><h2 id="8-人力的安排"><a href="#8-人力的安排" class="headerlink" title="8. 人力的安排"></a>8. 人力的安排</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105138438-16356487022966.png" alt="image-20211031105138438"></p><h2 id="9-进度的安排"><a href="#9-进度的安排" class="headerlink" title="9. 进度的安排"></a>9. 进度的安排</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105225645.png" alt="image-20211031105225645"></p><h2 id="10-风险评估"><a href="#10-风险评估" class="headerlink" title="10. 风险评估"></a>10. 风险评估</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105340461.png" alt="image-20211031105340461"></p><p>芯片结构不稳定、工具的不稳定、人力的不稳定、模块交付时间的不稳定因素</p><h1 id="三、计划的实现"><a href="#三、计划的实现" class="headerlink" title="三、计划的实现"></a>三、计划的实现</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110244344.png" alt="image-20211031110244344"></p><p>创建验证计划-&gt;开发测试环境-&gt;覆盖率分析-&gt;覆盖率漏洞反馈-&gt;修改验证计划</p><h2 id="2-如何指定验证计划"><a href="#2-如何指定验证计划" class="headerlink" title="2. 如何指定验证计划"></a>2. 如何指定验证计划</h2><ul><li>邀请相关人员参加会议</li><li>开会讨论</li><li>确定测试场景</li><li>创建验证环境</li></ul><h2 id="3-相关人员"><a href="#3-相关人员" class="headerlink" title="3. 相关人员"></a>3. 相关人员</h2><p>设计、测试、规后测试、软件开发、系统人员、验证经理（项目经理）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110529866-16356495319797.png" alt="image-20211031110529866"></p><p> 系统人员和软件人员可能会有不一样，这个时候更多的听软件的，因为他需要使用</p><h2 id="4-开会讨论"><a href="#4-开会讨论" class="headerlink" title="4. 开会讨论"></a>4. 开会讨论</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111002143.png" alt="image-20211031111002143"></p><p>一份验证计划的模板（或组织结构）应包括下面的结构</p><ul><li>设计功能简要描述</li><li>硬件实现框图</li><li>待验证的功能点</li><li>验证环境搭建</li><li>测试用例构成</li><li>编译脚本和回归测试</li><li>覆盖率分析</li></ul><h2 id="5-确定测试场景"><a href="#5-确定测试场景" class="headerlink" title="5. 确定测试场景"></a>5. 确定测试场景</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111242666.png" alt="image-20211031111242666"></p><p>PA(Power Aware)场景</p><h2 id="6-创建验证环境"><a href="#6-创建验证环境" class="headerlink" title="6. 创建验证环境"></a>6. 创建验证环境</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111500738.png" alt="image-20211031111500738"></p><h1 id="四、计划进程的评估"><a href="#四、计划进程的评估" class="headerlink" title="四、计划进程的评估"></a>四、计划进程的评估</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在验证过程中，我们需要不断更新验证进度，从各项参数综合评估验证的完整性，我们通过收集以下信息来评估验证计划的实施进程：</p><ul><li>回归测试通过率(regressioin pass rate)</li><li>代码覆盖率(code coverage)</li><li>断言覆盖率(assertion coverage)</li><li>功能覆盖率(function coverage)</li><li>缺陷曲线(bug curve)</li><li>寄存器覆盖率(在v3里？)</li></ul><h2 id="2-回归测试通过率"><a href="#2-回归测试通过率" class="headerlink" title="2. 回归测试通过率"></a>2. 回归测试通过率</h2><ul><li>一份回归测试表是将测试设计所有功能点的用例合并为一个测试集</li><li>回归测试表主要功能是用来<strong>在设计经过缺陷修复或者性能提升后，测试原有的所有功能点</strong>，切薄设计依然可以正常工作</li><li>这种王府的测试方式不仅在于确保设计变化不会影响之前的功能，也可以用来避免修改后的设计对于别的模块造成的功能失效</li><li>设计的维护不仅在于按照设计需求提供新的功能，也要确保新功能不会影响到原有功能</li></ul><p>在回归测试中发现漏洞时的解决办法：</p><ul><li>回归测试表中的测试用例需要确保是可以重现激励场景的</li><li>这一点对于定向测试方法（c/c++）是容易实现的，而对随即约束的测试而言，我们需要在测试中显示出每次测试使用到的随机种子，只有通过这个<strong>特定</strong>的随机种子，我们才可以<strong>重新</strong>产生之前的激励，跟踪调试失败用例（即重现用例</li></ul><h3 id="验证层次：模块-gt-子系统-gt-芯片"><a href="#验证层次：模块-gt-子系统-gt-芯片" class="headerlink" title="验证层次：模块-&gt;子系统-&gt;芯片"></a>验证层次：模块-&gt;子系统-&gt;芯片</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113315394.png" alt="image-20211031113315394"></p><h3 id="层次解释"><a href="#层次解释" class="headerlink" title="层次解释"></a>层次解释</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113423306.png" alt="image-20211031113423306"></p><h2 id="3-代码覆盖率"><a href="#3-代码覆盖率" class="headerlink" title="3.代码覆盖率"></a>3.代码覆盖率</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113635742.png" alt="image-20211031113635742"></p><p>常见的代码覆盖率：</p><ul><li>语句覆盖率(statement coverage)</li><li>条件覆盖率(condition coverage)</li><li>决策覆盖率(branch coverage)</li><li>事件覆盖率(event coverage)</li><li>跳转覆盖率(toggle coverage)</li><li>状态机覆盖率(finite stage machine coverage)</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113843620.png" alt="image-20211031113843620"></p><h2 id="4-断言覆盖率（在第三模块专门说到）"><a href="#4-断言覆盖率（在第三模块专门说到）" class="headerlink" title="4. 断言覆盖率（在第三模块专门说到）"></a>4. 断言覆盖率（在第三模块专门说到）</h2><p>不单单可以在验证方面，可以在硬件加速、形式验证中都可以实现覆盖率收集</p><p>基于验证方法的不同将断言分辨率分为：</p><ul><li>基于动态仿真或者硬件加速的断言覆盖率</li><li>基于形式验证的静态断言覆盖率</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031114018415.png" alt="image-20211031114018415"></p><h2 id="5-功能覆盖率"><a href="#5-功能覆盖率" class="headerlink" title="5. 功能覆盖率"></a>5. 功能覆盖率</h2><p>衡量设计的各项功能是否实现，主要关注设计的输入、输出和内部状态</p><p>内部状态：通过对信号的单一覆盖、交叉覆盖、时序覆盖来检查功能是否被触发</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151435108.png" alt="image-20211031151435108"></p><h2 id="6-缺陷曲线"><a href="#6-缺陷曲线" class="headerlink" title="6. 缺陷曲线"></a>6. 缺陷曲线</h2><p><strong>通过时间坐标和特定时间段数量绘制出缺陷曲线</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151826994.png" alt="image-20211031151826994"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151921297.png" alt="image-20211031151921297"></p><h1 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h1><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029214325797.png" alt="image-20211029214325797"></p><ol><li>A</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031102846977.png" alt="image-20211031102846977"></p><ol><li>AB</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031103707035.png" alt="image-20211031103707035"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031104616381.png" alt="image-20211031104616381"></p><ol><li>ABCD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031105555906.png" alt="image-20211031105555906"></p><ol><li>BC</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031110755561.png" alt="image-20211031110755561"></p><ol><li>ABCD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031111535630.png" alt="image-20211031111535630"></p><ol><li>CD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031113529638.png" alt="image-20211031113529638"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151705463.png" alt="image-20211031151705463"></p><ol><li>ABD</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211031151949489.png" alt="image-20211031151949489"></p><p>应该是总的缺陷数量</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV学习0-1：EDA的使用</title>
    <link href="/202110292004/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A00-1%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/202110292004/IC/sv%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8Cessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A00-1%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Questasim"><a href="#一、Questasim" class="headerlink" title="一、Questasim"></a>一、Questasim</h1><h2 id="1-hello-world"><a href="#1-hello-world" class="headerlink" title="1 hello world"></a>1 hello world</h2><h3 id="1-编译会把它放到库里面，然后再库里仿真"><a href="#1-编译会把它放到库里面，然后再库里仿真" class="headerlink" title="1.编译会把它放到库里面，然后再库里仿真"></a>1.编译会把它放到库里面，然后再库里仿真</h3><ol><li>上图为编译前，status为？</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029195944381-16355087926651.png" alt="image-20211029195944381"></p><ol><li>编译成功后（编译成功后放到库里面，再做仿真）</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029200052177-16355088533832.png" alt="image-20211029200052177"></p><ol><li>在库里的work中运行仿真without Optimization</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029201949489-16355099905323.png" alt="image-20211029201949489"></p><ol><li>最后运行仿真，其中Now:是指的仿真时间</li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029202357250-16355102398214.png" alt="image-20211029202357250"></p><h3 id="2-为什么是100ns"><a href="#2-为什么是100ns" class="headerlink" title="2. 为什么是100ns?"></a>2. 为什么是100ns?</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029205535026-16355121365295.png" alt="image-20211029205535026"></p><p>单步步长为100ns</p><h3 id="3-run代表的仿真继续执行-其他run命令"><a href="#3-run代表的仿真继续执行-其他run命令" class="headerlink" title="3. run代表的仿真继续执行_其他run命令"></a>3. run代表的仿真继续执行_其他run命令</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029205857374-16355123404767.png" alt="image-20211029205857374"></p><ul><li>run  时间</li><li>run  -all</li><li>run -continue </li></ul><p>run -all 为啥会有的时候成功有的时候没成功</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211029210236017.png" alt="image-20211029210236017"></p><p>如果仿真已经运行完，则run -all没结果<br>如果仿真被暂停或没运行完，run -all才有结果</p><h1 id="二、VCS"><a href="#二、VCS" class="headerlink" title="二、VCS"></a>二、VCS</h1><p>compile,elabration,run,rungui,clean</p><p>编译文件：</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211123215651722.png" alt="image-20211123215651722"></p><p>执行顺序：</p><ol><li><p>make comp</p></li><li><p>make elab</p></li><li><p>make run：bash模式运行，在后台</p></li><li>make rung：gui模式运行</li></ol>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通2：接口采样驱动_测试结束开始_调试方法1</title>
    <link href="/202110151604/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-2%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%87%87%E6%A0%B7%E9%A9%B1%E5%8A%A8_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9D%9F%E5%BC%80%E5%A7%8B_%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/202110151604/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-2%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%87%87%E6%A0%B7%E9%A9%B1%E5%8A%A8_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9D%9F%E5%BC%80%E5%A7%8B_%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>主要内容：</p><ul><li>接口</li><li>采样和数据驱动</li><li>测试的开始和结束</li><li>调试方法</li></ul><h2 id="注意重点"><a href="#注意重点" class="headerlink" title="注意重点"></a>注意重点</h2><p>采样：输入</p><p>驱动：输出</p><p>一般的采样是直接采样</p><p>而采样可以对于Interface采样，在clocking下采样</p><p>采样和驱动都可以通过并行的initial块进行监控具体可参考第二章第二节的几个例子：initital forever</p><h2 id="学习的定义和系统函数"><a href="#学习的定义和系统函数" class="headerlink" title="学习的定义和系统函数"></a>学习的定义和系统函数</h2><ul><li>interface</li><li>clocking</li><li>program</li><li>run 0 //命令</li><li>$stop()</li><li>$finish()</li><li>$exit()</li></ul><h1 id="一、接口-interface"><a href="#一、接口-interface" class="headerlink" title="一、接口(interface)"></a>一、接口(interface)</h1><h2 id="1-什么是接口"><a href="#1-什么是接口" class="headerlink" title="1 什么是接口"></a>1 什么是接口</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="(1) 简介"></a>(1) 简介</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190705553.png" alt="image-20211016190705553"></p><p><strong>硬件很重要，可以在软硬环境传递：如图上第三点</strong></p><h3 id="2-有无接口的测试方法对比"><a href="#2-有无接口的测试方法对比" class="headerlink" title="　(2) 有无接口的测试方法对比"></a>　(2) 有无接口的测试方法对比</h3><p>测试arbiter现有经典方法</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190936562.png" alt="image-20211016190936562"></p><p>使用了interface后的测试关系</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016190958859.png" alt="image-20211016190958859">‘</p><h3 id="3-interface代码定义"><a href="#3-interface代码定义" class="headerlink" title="(3) interface代码定义"></a>(3) interface代码定义</h3><p><strong>下图对应design</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191110431.png" alt="image-20211016191110431"></p><ul><li><p>可作为形参在module的参数列表中声明，不需要声明方向</p></li><li><p>通过一个点表明层次关系（例如arbif.rst）</p></li></ul><hr><p><strong>下图对应testbench（要有壳子把design和testbench包起来）</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191323553.png" alt="image-20211016191323553"></p><ul><li>也是用initital作为驱动，</li><li>arbif.clk作为始终驱动，$finish结束仿真</li></ul><hr><p><strong>下图对应top</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191622363.png" alt="image-20211016191622363"></p><h2 id="2-接口的优势"><a href="#2-接口的优势" class="headerlink" title="2 接口的优势"></a>2 接口的优势</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191704811.png" alt="image-20211016191704811"></p><ul><li>更易于维护和使用</li><li>接口作为软(class)硬(module)的媒介</li><li>对于多组相同的总线，例化更为灵活</li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016191941795.png" alt=""></p><p>对最后一条：stimulator拿到接口的指针对其进行驱动</p><h2 id="3-接口的定义和使用"><a href="#3-接口的定义和使用" class="headerlink" title="3 接口的定义和使用"></a>3 接口的定义和使用</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016192730438.png" alt="image-20211016192730438"></p><ul><li>用法与module类似</li><li>interface不定义任何端口信号，定义：复位、时钟等公共信号</li><li>interface可以添加参数提高复用性</li><li>例化的时候和module一样</li></ul><h1 id="二、采样和数据驱动"><a href="#二、采样和数据驱动" class="headerlink" title="二、采样和数据驱动"></a>二、采样和数据驱动</h1><h2 id="1-竞争问题"><a href="#1-竞争问题" class="headerlink" title="1 竞争问题"></a>1 竞争问题</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194430737.png" alt="image-20211016194430737"></p><p><strong>避免竞争：使用非阻塞赋值或者特定的信号延迟来解决同步问题</strong></p><hr><p><strong>对于真实的物理环境下会有延迟</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195117342.png" alt="image-20211016195117342"></p><ul><li>clk时钟驱动数据a会有延迟：对应上图中间的”X”</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194954692.png" alt="image-20211016194954692"></p><p><strong>延迟只会在门级仿真的时候才会体现出来，我们RTL的时候没有</strong></p><p>那怎么办：我们只能每一个都加上一个最小单位的延迟（delta-cycle）</p><h3 id="时间片和delta-cycle："><a href="#时间片和delta-cycle：" class="headerlink" title="时间片和delta-cycle："></a>时间片和delta-cycle：</h3><p>run 1m , s, ms, us, ns, ps, fs, 0<br>0就是时间片，一个时间片里又包括无穷个delta-cycle，在仿真时无法用最小的时间单位衡量</p><h3 id="delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）"><a href="#delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）" class="headerlink" title="delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）"></a>delta-cycle的进一步了解（了解其对数据驱动和采样有很大帮助）</h3><p>有两个时钟第一个时钟五纳秒翻转一次</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195832325.png" alt="image-20211016195832325"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195852932.png" alt="image-20211016195852932"></p><h3 id="race-sv"><a href="#race-sv" class="headerlink" title="race.sv"></a>race.sv</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202543007.png" alt="image-20211016202543007"></p><h4 id="EDA如何显示delta-cycle"><a href="#EDA如何显示delta-cycle" class="headerlink" title="EDA如何显示delta-cycle"></a>EDA如何显示delta-cycle</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202836218.png" alt="image-20211016202836218"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016202911254.png" alt="image-20211016202911254"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016203031929.png" alt="image-20211016203031929"></p><ul><li>仿真采样存在不稳定性</li></ul><p><strong>如何避免：</strong></p><ul><li>添加认为延迟</li><li>采样时间前的某段时刻进行采样</li></ul><h2 id="2-接口中的clocking-时钟块"><a href="#2-接口中的clocking-时钟块" class="headerlink" title="2 接口中的clocking 时钟块"></a>2 接口中的clocking 时钟块</h2><h3 id="1-clocking学习背景modport在clocking中，不用额外去学"><a href="#1-clocking学习背景modport在clocking中，不用额外去学" class="headerlink" title="(1) clocking学习背景modport在clocking中，不用额外去学"></a>(1) clocking学习背景modport在clocking中，不用额外去学</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016214722868.png" alt="image-20211016214722868"></p><ul><li>modport有方向</li><li>clocking基于时钟进行采样，使得testbench不在苦恼于如何即使准确的对信号进行驱动和采样，消除了信号竞争问题</li></ul><hr><h3 id="2-clocking代码定义"><a href="#2-clocking代码定义" class="headerlink" title="(2) clocking代码定义"></a>(2) clocking代码定义</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016215024641.png" alt=""></p><ul><li>第一行@(信号)：定义上升沿事件</li><li>第二行指定的是：默认情况下所有的输出相比较上升沿后2ns延迟，对所有输入信号在上升沿之前10ns做一个采样。和电路里面建立保持时间差不多</li><li>第三行：我们要对data,ready和enable信号做采样了，且以及声明方向了</li><li>属于输出驱动额外强调在时钟下降沿</li><li><h1 id="1step-过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内"><a href="#1step-过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内" class="headerlink" title="1step 过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内"></a>1step 过上一个单位的step表示，可以看作一个时间片或者上升沿上一个时间片之间的采样域内</h1></li></ul><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016215612699.png" alt="image-20211016215612699"></p><ul><li>对于时钟而言可以定义在：module，Interface,program中</li><li>clocking内列举的信号是由interface或其他的地方去定义</li><li>对于时钟块他只声明而不定义</li><li>没有定义的画默认输入在事件前1step，驱动在事件后#0（一个时钟片相当于无穷多个step，肯定比step大）</li><li>处理定义默认的采样和驱动时间，可以用新的时间对默认事件覆盖</li></ul><h3 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="(3) 一个例子"></a>(3) 一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220043661.png" alt="image-20211016220043661"></p><h3 id="4-一个例子：利用clocking的采样"><a href="#4-一个例子：利用clocking的采样" class="headerlink" title="(4) 一个例子：利用clocking的采样"></a>(4) 一个例子：利用clocking的采样</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220306611.png" alt="image-20211016220306611"></p><ul><li><p>用了三个initial，第一个做驱动，第二三个做采样</p></li><li><p>@ck 等价于 @(posedge clk)</p></li><li>@ck 意思是在clocking这个变化事件</li><li>第二个在时钟的每一个上升沿直接对vld做采样@ck</li><li>在每一个上升沿利用clocking块进行采样</li></ul><p><strong>输出结果</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220901083.png" alt="image-20211016220901083"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220934039.png" alt="image-20211016220934039"></p><h3 id="5-一个例子：利用clocking的驱动"><a href="#5-一个例子：利用clocking的驱动" class="headerlink" title="(5)一个例子：利用clocking的驱动"></a>(5)一个例子：利用clocking的驱动</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221247525.png" alt="image-20211016221247525"></p><p>@ck ck.grt &lt;= 1 ; //<strong>利用clocking</strong>在每个上升沿<strong>进行驱动</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221400065.png" alt="image-20211016221400065"></p><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="(6) 结论"></a>(6) 结论</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221421817.png" alt="image-20211016221421817"></p><h1 id="三、测试的开始和结束"><a href="#三、测试的开始和结束" class="headerlink" title="三、测试的开始和结束"></a>三、测试的开始和结束</h1><h2 id="1-介绍：各个设计自身可以作为一个大的线程"><a href="#1-介绍：各个设计自身可以作为一个大的线程" class="headerlink" title="1.介绍：各个设计自身可以作为一个大的线程"></a>1.介绍：各个设计自身可以作为一个大的线程</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016221528823.png" alt="image-20211016221528823"></p><p>但是如果只提供复位和时钟信号，整个仿真会一直持续下去并不会主动结束，这时候需要verilog系统函数主动结束仿真</p><h2 id="2-系统函数结束仿真"><a href="#2-系统函数结束仿真" class="headerlink" title="2. 系统函数结束仿真"></a>2. 系统函数结束仿真</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222523208.png" alt="image-20211016222523208"></p><h3 id="finish-直接结束仿真"><a href="#finish-直接结束仿真" class="headerlink" title="$finish():直接结束仿真"></a>$finish():直接结束仿真</h3><h3 id="stop-暂停仿真，可以再次启动"><a href="#stop-暂停仿真，可以再次启动" class="headerlink" title="$stop():暂停仿真，可以再次启动"></a>$stop():暂停仿真，可以再次启动</h3><h2 id="3-仿真开始"><a href="#3-仿真开始" class="headerlink" title="3.仿真开始"></a>3.仿真开始</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222747548.png" alt="image-20211016222747548"></p><p><strong>下文参考答案一章</strong></p><h2 id="4-program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少"><a href="#4-program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少" class="headerlink" title="4. program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少"></a>4. program隐式结束：program已经是软件的领域，是SV为了设计与验证隔离推出，而在UVM中有更好的控制手段失去了program的意义了，用的很少</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016223616175.png" alt="image-20211016223616175"></p><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225255238.png" alt="image-20211016225255238"></p><h5 id="program相当于把initial的内容封装到program里面了"><a href="#program相当于把initial的内容封装到program里面了" class="headerlink" title="program相当于把initial的内容封装到program里面了"></a>program相当于把initial的内容封装到program里面了</h5><p>最终放到tb里面，最终仿真自动结束，不需要调用$finish</p><h2 id="5-program显式-强制-结束：-exit-专门对program的结束函数"><a href="#5-program显式-强制-结束：-exit-专门对program的结束函数" class="headerlink" title="5.program显式(强制)结束：$exit()专门对program的结束函数"></a>5.program显式(强制)结束：$exit()专门对program的结束函数</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225510071.png" alt="image-20211016225510071"></p><h4 id="具体例子-1"><a href="#具体例子-1" class="headerlink" title="具体例子"></a>具体例子</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225608127.png" alt="image-20211016225608127"></p><h2 id="6-program和module"><a href="#6-program和module" class="headerlink" title="6. program和module"></a>6. program和module</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225657272.png" alt="image-20211016225657272"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225749237.png" alt="image-20211016225749237"></p><h1 id="四、调试方法"><a href="#四、调试方法" class="headerlink" title="四、调试方法"></a>四、调试方法</h1><h2 id="1-使用库、仿真和过程方法"><a href="#1-使用库、仿真和过程方法" class="headerlink" title="1. 使用库、仿真和过程方法"></a>1. 使用库、仿真和过程方法</h2><h2 id="2-不同仿真器是共通的"><a href="#2-不同仿真器是共通的" class="headerlink" title="2. 不同仿真器是共通的"></a>2. 不同仿真器是共通的</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230130087.png" alt="image-20211016230130087"></p><h2 id="3-库窗口"><a href="#3-库窗口" class="headerlink" title="3. 库窗口"></a>3. 库窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230346911.png" alt="image-20211016230346911"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230400490.png" alt="image-20211016230400490"></p><p><strong>可以创建属于自己的库</strong></p><p>实验里面默认library</p><p><strong>所有的文件编译都离不开库</strong></p><h2 id="4-仿真窗口"><a href="#4-仿真窗口" class="headerlink" title="4.仿真窗口"></a>4.仿真窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230631471.png" alt="image-20211016230631471"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230729220.png" alt="image-20211016230729220"></p><p><strong>最大帮助是用来看层次</strong></p><h2 id="5-过程窗口"><a href="#5-过程窗口" class="headerlink" title="5. 过程窗口"></a>5. 过程窗口</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230800874.png" alt="image-20211016230800874"></p><p>hang-on：仿真进入死循环<br>active,ready</p><h2 id="6-查看信号和波形"><a href="#6-查看信号和波形" class="headerlink" title="6. 查看信号和波形"></a>6. 查看信号和波形</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016230924609.png" alt="image-20211016230924609"></p><h2 id="7-打印消息：-display"><a href="#7-打印消息：-display" class="headerlink" title="7. 打印消息：$display"></a>7. 打印消息：$display</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231000603.png" alt="image-20211016231000603"></p><p>尽量格式化，字符串赋值和拼接</p><h2 id="8-设置断点（verify重点）"><a href="#8-设置断点（verify重点）" class="headerlink" title="8. 设置断点（verify重点）"></a>8. 设置断点（verify重点）</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231107723.png" alt="image-20211016231107723"></p><h3 id="理解程序执行顺序"><a href="#理解程序执行顺序" class="headerlink" title="理解程序执行顺序"></a>理解程序执行顺序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231202857.png" alt="image-20211016231202857"></p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231351379.png" alt="image-20211016231351379"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231402018.png" alt="image-20211016231402018"></p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h3 id="1-ABCD"><a href="#1-ABCD" class="headerlink" title="1.ABCD"></a>1.ABCD</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194056429.png" alt="image-20211016194056429"></p><p>哪些事情不能做：模块里面可以例化模块和接口，但是接口里面不可以例化模块可以例化接口</p><h3 id="2-b-1"><a href="#2-b-1" class="headerlink" title="2. b=1"></a>2. b=1</h3><p>a被综合成4位寄存器，使用非阻塞赋值可以确定b是flip-flop，而这里不确定b被综合成什么</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016194629074.png" alt="image-20211016194629074"></p><h3 id="3-对应delta-cycle小节"><a href="#3-对应delta-cycle小节" class="headerlink" title="3.对应delta-cycle小节"></a>3.对应delta-cycle小节</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016195852932.png" alt="image-20211016195852932"></p><h3 id="4-clocking：C都可以"><a href="#4-clocking：C都可以" class="headerlink" title="4 .clocking：C都可以"></a>4 .clocking：C都可以</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016220131851.png" alt="image-20211016220131851"></p><h3 id="5-仿真开始，run0：A？"><a href="#5-仿真开始，run0：A？" class="headerlink" title="5. 仿真开始，run0：A？"></a>5. 仿真开始，run0：A？</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222747548.png" alt="image-20211016222747548"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222828300.png" alt="image-20211016222828300"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016222954064.png" alt="image-20211016222954064"></p><h3 id="6-哪些可以在program中定义-AC"><a href="#6-哪些可以在program中定义-AC" class="headerlink" title="6.哪些可以在program中定义 AC"></a>6.哪些可以在program中定义 AC</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016225928352.png" alt="image-20211016225928352"></p><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231351379.png" alt="image-20211016231351379"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231402018.png" alt="image-20211016231402018"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211016231520344.png" alt="image-20211016231520344"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识2：验证环境的结构和组件</title>
    <link href="/202110112211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6/"/>
    <url>/202110112211/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A02-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>mcdf</p><h1 id="一、测试平台"><a href="#一、测试平台" class="headerlink" title="一、测试平台"></a>一、测试平台</h1><p>testbench整个验证系统的总称：包括各个组件、组件支架的连接、测试平台的配置和控制<br>整个SV教学由verilog定向测试逐步过渡到SV，用SV去实现一些组件，用一些通信方法实现连接</p><p>更系统地来讲，tb还包括编译仿真、结果分析报告和覆盖率检查等<br>makefile可以更快的编译、更快的跑仿真</p><p>狭义上来讲，我们主要关注验证平台的结构和组件，他们可以产生设计所需要的各种输入，在此基础上捕捉各种行为，进行设计功能检查</p><h2 id="测试平台结构图"><a href="#测试平台结构图" class="headerlink" title="测试平台结构图"></a>测试平台结构图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011221829069.png" alt="image-20211011221829069"></p><p>实验0的MCDT，中间的DUT（Design on the Test）也叫DUV(Design on the verification)</p><p>实验0我们有.tb,.mcdt但没有专门模块产生激励，只有过程块产生激励，同时缺少检测模块，比较简单</p><p>实验1、实验2就比较完整了</p><p>由上述结构图得知：</p><ul><li>各组件之间相互独立（sv是，uvm也是）</li><li>验证组件设计之间需要连接</li><li>验证组件设计之间需要通信</li><li>验证环境需要时钟和复位信号驱动</li></ul><h2 id="验证语言的调查趋势"><a href="#验证语言的调查趋势" class="headerlink" title="验证语言的调查趋势"></a>验证语言的调查趋势</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011222931432.png" alt="image-20211011222931432"></p><p>verilog是下降的，vmm是什么是synopsys vera开发的</p><p>C\C++一定不会消亡，系统级都是C\C++</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223128157.png" alt="image-20211011223128157"></p><h1 id="二、关于硬件的设计描述"><a href="#二、关于硬件的设计描述" class="headerlink" title="二、关于硬件的设计描述"></a>二、关于硬件的设计描述</h1><h2 id="MCDF简介"><a href="#MCDF简介" class="headerlink" title="MCDF简介"></a>MCDF简介</h2><ul><li>遵循硬件设计描述的方式，介绍它的<strong>结构、功能‘寄存器和时序</strong></li><li>熟悉硬件描述的方式，也是验证基本技能</li><li>MCDF(multi-channel data formatter)多通道数据整形器， 它可以<strong>将上行uplink多个通道数据经过内部FIFO，最终以数据包data packet的形式送出</strong></li><li>上行数据和下行数据的接口协议不同</li><li>多通道数据整合器也有寄存器读写接口，可以支持更多的控制（寄存器可以对硬件配置同时获取其状态，一个成熟的硬件都要有）</li></ul><p>我们designer拿到datasheet设计代码，我们verificor也要看</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011223932224.png" alt="image-20211011223932224"></p><h2 id="具体一个硬件设计应该包含的内容"><a href="#具体一个硬件设计应该包含的内容" class="headerlink" title="具体一个硬件设计应该包含的内容"></a>具体一个硬件设计应该包含的内容</h2><h3 id="系统信号接口（小括号0代表有一位）"><a href="#系统信号接口（小括号0代表有一位）" class="headerlink" title="系统信号接口（小括号0代表有一位）"></a>系统信号接口（小括号0代表有一位）</h3><ul><li>CLK(0)：时钟信号</li><li>RSTN(0)：复位信号低位有效</li></ul><h3 id="通道从端接口（x为通道ID）"><a href="#通道从端接口（x为通道ID）" class="headerlink" title="通道从端接口（x为通道ID）"></a>通道从端接口（x为通道ID）</h3><ul><li>CHx_DATA(31:0)：通道数据输入</li><li>CHx_VALID(0)：通道数据有效标志信号，高位有效</li><li>CHx_READY(0)：通道数据接收信号，高位表示接收成功</li></ul><h3 id="整形器接口"><a href="#整形器接口" class="headerlink" title="整形器接口"></a>整形器接口</h3><p>输出方向</p><ul><li>FMT_CHID(1:0)：整形数据包的通道ID，当前数据包是哪个channel</li><li>FMT_LENGTH(4:0)：整形数据包长度信号</li><li>FMT_REQ(0)：整形数据包发送请求</li></ul><p>输入方向对于Formater</p><ul><li>FMT_GRANT(0)：整形数据包被允许发送的接受标示</li></ul><p>输出方向</p><ul><li>FMT_DATA(31:0)：数据输出端口</li><li>FMT_START(0)：数据包起始标示</li><li>FMT_END(0)：数据包结束标示</li></ul><h3 id="控制寄存器接口"><a href="#控制寄存器接口" class="headerlink" title="控制寄存器接口"></a>控制寄存器接口</h3><p>控制模块需要一些数值</p><p>往mcdt是输入方向，对于激励是需要输出的</p><ul><li>CMD(1:0)：寄存器读写命令（肯定不止一个寄存器，因此需要有这个）</li><li>CMD_ADDR(7:0)：寄存器地址</li><li>CMD_DATA_IN(31:0)：寄存器写入数据</li></ul><p>对于mcdt是输出方向</p><ul><li>CMD_DATA_OUT(31:0)：寄存器读出数据</li></ul><h3 id="还没讲Arbiter，暂时不讲"><a href="#还没讲Arbiter，暂时不讲" class="headerlink" title="还没讲Arbiter，暂时不讲"></a>还没讲Arbiter，暂时不讲</h3><p>因为全部包括在MCDF里面，并没有裸露到MCDF外面的边界boundary上，对小白来说暂时不重要</p><h2 id="MCDF的接口时序"><a href="#MCDF的接口时序" class="headerlink" title="MCDF的接口时序"></a>MCDF的接口时序</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011225732579.png" alt="image-20211011225732579"></p><h3 id="控制寄存器接口时序"><a href="#控制寄存器接口时序" class="headerlink" title="控制寄存器接口时序"></a>控制寄存器接口时序</h3><p>地址要写清楚，还有cmd命令，可以看到WR和CMD_DATA_IN同时变换</p><p>发起RD时会在下一拍返回</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011225818268.png" alt="image-20211011225818268"></p><p>为什么地址是00,04,08….那01,02去哪了<br>因为32位寄存器，按照一个word寻址的</p><p>不同寄存器，指令覆盖，对应读取</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011230131279.png" alt="image-20211011230131279"></p><h3 id="整形器时序"><a href="#整形器时序" class="headerlink" title="整形器时序"></a>整形器时序</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011230250266.png" alt="image-20211011230250266"></p><p>数据包以req为准，他请求发送，它拉高chid,length都要变化<br>下行会给我们一个grant表示同意<br>又过了一拍start拉高表示formater真正开始发送数据<br>同时data有数据<br>end最后也起来了</p><h2 id="MCDF寄存器描述"><a href="#MCDF寄存器描述" class="headerlink" title="MCDF寄存器描述"></a>MCDF寄存器描述</h2><h3 id="前三个称为读写或控制寄存器，地址分别为00-04-08"><a href="#前三个称为读写或控制寄存器，地址分别为00-04-08" class="headerlink" title="前三个称为读写或控制寄存器，地址分别为00,04,08"></a>前三个称为读写或控制寄存器，地址分别为00,04,08</h3><p> <img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012163813840.png" alt="image-20211012163813840"></p><ul><li><p>优先级和arbiter有关</p></li><li><p>bit(31:6)是保留位，也叫reserverd bits，无法写入，一直为0</p></li></ul><h3 id="只读寄存器"><a href="#只读寄存器" class="headerlink" title="只读寄存器"></a>只读寄存器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012170644158.png" alt="image-20211012170644158"></p><p>写也不能写的，表示一个状态</p><h1 id="三、激励发生器（SV中stimulator，UVM中driver）"><a href="#三、激励发生器（SV中stimulator，UVM中driver）" class="headerlink" title="三、激励发生器（SV中stimulator，UVM中driver）"></a>三、激励发生器（SV中stimulator，UVM中driver）</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012171456403.png" alt="image-20211012171456403"></p><p>能够以<strong>真实的接口协议</strong>来发送激励给DUT</p><p>且比真实硬件激励跟丰富</p><h3 id="stimulator的接口"><a href="#stimulator的接口" class="headerlink" title="stimulator的接口"></a>stimulator的接口</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172140710.png" alt="image-20211012172140710"></p><p>主要是同DUT之间（边界而不是dut内部）的连接，此外还要有时钟和复位的输 入<br>也应该存储接口数据生成历史的功能<br>精细的stimulator还可以有其他配置接口用来控制接口数据</p><h3 id="stimulator分类：initiator发起器、responder响应器"><a href="#stimulator分类：initiator发起器、responder响应器" class="headerlink" title="stimulator分类：initiator发起器、responder响应器"></a>stimulator分类：initiator发起器、responder响应器</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172410023.png" alt="image-20211012172410023"></p><h2 id="stimulator位置及实现考虑因素"><a href="#stimulator位置及实现考虑因素" class="headerlink" title="stimulator位置及实现考虑因素"></a>stimulator位置及实现考虑因素</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172619391.png" alt="image-20211012172619391"></p><h3 id="channel-initiator"><a href="#channel-initiator" class="headerlink" title="channel initiator"></a>channel initiator</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012172731288.png" alt="image-20211012172731288"></p><ul><li>握手信号，需要遵守协议</li><li>相邻数据间没有数据包限制，所以也要考虑发送数据快慢</li><li>channel里面有FIFO，实现FIFO状态可遍历</li></ul><h3 id="register-initiator"><a href="#register-initiator" class="headerlink" title="register initiator"></a>register initiator</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173107232.png" alt="image-20211012173107232"></p><ul><li>cmd默认状态应该是idle，但没有规定默认值，考虑idle值是随机时寄存器是否稳定</li><li>寄存器读写上，考虑连续指令</li><li>读写寄存器所有比特位测试都应覆盖</li><li>只读状态寄存器需要测试是否为不可写入的设定，同时需要测试读出的数值是否真实反应硬件状态</li></ul><h3 id="Formatter-responder"><a href="#Formatter-responder" class="headerlink" title="Formatter responder"></a>Formatter responder</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173350752.png" alt="image-20211012173350752"></p><ul><li><strong>三种协议相对复杂的一个</strong>，侧重是否充分遍历</li></ul><h1 id="四、监测器"><a href="#四、监测器" class="headerlink" title="四、监测器"></a>四、监测器</h1><p>需要捕捉时序，接口+内部</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012173551040.png" alt="image-20211012173551040"></p><p>Monitor（监视器）主要功能观察DUT的边界或者内部信号</p><p>对于DUT边界信号，如系统信号（时钟）；总线信号，总线时序</p><p>对于DUT内部信号。从灰盒验证的手段，</p><p>为什么检测内部信号：完成覆盖率手机、内部功能检查</p><h3 id="监视器组件结构方案"><a href="#监视器组件结构方案" class="headerlink" title="监视器组件结构方案"></a>监视器组件结构方案</h3><h4 id="全局式"><a href="#全局式" class="headerlink" title="全局式"></a>全局式</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181105759.png" alt="image-20211012181105759"></p><p>虚线指的是内部关键信号，实线关键信号</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181256390.png" alt="image-20211012181256390"></p><p>左下角mcdf monitor是检测内部信号的，独立的。其他的Monitor都对应的一组</p><h3 id="监视器结构方案比较"><a href="#监视器结构方案比较" class="headerlink" title="监视器结构方案比较"></a>监视器结构方案比较</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181357668.png" alt="image-20211012181357668"></p><p>独立性、复用性、可维护性、封装性</p><h2 id="内部信号监测建议"><a href="#内部信号监测建议" class="headerlink" title="内部信号监测建议"></a>内部信号监测建议</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012181753692.png" alt="image-20211012181753692"></p><ul><li>应灰盒而不是白盒</li><li>观察的信号尽可能少，且应是状态信号而不是中间变量（不稳定）</li><li>能基于接口信息计算的就别去检测内部信号，这种方式有悖于假定设计有缺陷的验证思想</li></ul><h1 id="五、比较器checker"><a href="#五、比较器checker" class="headerlink" title="五、比较器checker"></a>五、比较器checker</h1><ul><li>难+维护人力多</li><li>checker肩负了模拟设计行为和功能检查的任务</li></ul><h2 id="checker主要功能"><a href="#checker主要功能" class="headerlink" title="checker主要功能"></a>checker主要功能</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012182110589.png" alt="image-20211012182110589"></p><ul><li>主要用于缓存</li><li>汇聚到内置的reference model，需要实现这样一个模型并花费大量精力维护且不应该参考真实硬件逻辑</li><li>通过数据比较</li><li>对关键功能模块，使用对应线程独立检查</li><li>检查成功信息纳入到检查报告，失败暂停仿真同时报告错误信息的方式进行在线调试</li></ul><h2 id="实现方式：线上比较、线下比较4"><a href="#实现方式：线上比较、线下比较4" class="headerlink" title="实现方式：线上比较、线下比较4"></a>实现方式：线上比较、线下比较4</h2><ul><li>online check</li><li>offline check</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012182508883.png" alt="image-20211012182508883"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183042018.png" alt="image-20211012183042018"></p><p>一开始经常做定向测试，线下测试也Ok，功能复杂起来了就把checker添加到环境里面进行Online check</p><p>这种<strong>预测</strong>的过程称为predictor，同时是reference model也会内置缓存存放DUT输入数</p><h2 id="比较器的组件结构"><a href="#比较器的组件结构" class="headerlink" title="比较器的组件结构"></a>比较器的组件结构</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183433571.png" alt="image-20211012183433571"></p><p>在结构图下方的一大块是checker</p><p>除了上面介绍的reference model 、formatter FIFO 和 data checker 之外考虑checker对应其他不同模块，进行更细化的检查：</p><ul><li>channel checker</li><li>arbiter checker</li><li>register checker</li><li>formater checker</li></ul><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183658129.png" alt="image-20211012183658129"></p><p>不难发现checker，monitor，stimulator与MCDF内部的各个模块有着一一对应的关系</p><p>但我们这里<strong>不建议</strong>分布式（分散搁置checker）</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183857292.png" alt="image-20211012183857292"></p><p>这里建议集群搁置</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012183956070.png" alt="image-20211012183956070"></p><h2 id="比较器总结"><a href="#比较器总结" class="headerlink" title="比较器总结"></a>比较器总结</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184108611.png" alt="image-20211012184108611"></p><ul><li>对于复杂的系统验证，集中管理stimulator和checker</li><li>monitor相对独立，只需要把数据交给checker</li><li>monitor和stimulator（上图有错不是checker）一一对应，进一步将这部分封装在agent单元中，checker则最终集群搁置在中心化的位置</li></ul><h1 id="六、验证结构"><a href="#六、验证结构" class="headerlink" title="六、验证结构"></a>六、验证结构</h1><p>stimulator-&gt;driver<br>checker-&gt;scoreboard</p><h2 id="实际情景"><a href="#实际情景" class="headerlink" title="实际情景"></a>实际情景</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184518880.png" alt="image-20211012184518880"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184705760.png" alt="image-20211012184705760"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184758284.png" alt="image-20211012184758284"></p><hr><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012184929023.png" alt="image-20211012184929023"></p><p><strong>1：1.5</strong></p><p>系统越往高，验证工作量越大，子系统设计的工作量越来越少</p><h2 id="项目计划表"><a href="#项目计划表" class="headerlink" title="项目计划表"></a>项目计划表</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012191702668.png" alt="image-20211012191702668"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211012191940230.png" alt="image-20211012191940230"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV精通1：数据类型_过程方法_设计连接_验证结构</title>
    <link href="/202110112004/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E8%BF%87%E7%A8%8B%E6%96%B9%E6%B3%95_%E8%AE%BE%E8%AE%A1%E8%BF%9E%E6%8E%A5_%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84/"/>
    <url>/202110112004/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E8%BF%87%E7%A8%8B%E6%96%B9%E6%B3%95_%E8%AE%BE%E8%AE%A1%E8%BF%9E%E6%8E%A5_%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211113212246487.png" alt="image-20211113212246487"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>精通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准相关与常见命名</title>
    <link href="/202110111818/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/01%E6%A0%87%E5%87%86%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D/"/>
    <url>/202110111818/IC/sv%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/01%E6%A0%87%E5%87%86%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="变量定义相关"><a href="#变量定义相关" class="headerlink" title="变量定义相关"></a>变量定义相关</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210928171853.png"/></p><h2 id="常见命名"><a href="#常见命名" class="headerlink" title="常见命名"></a>常见命名</h2><ul><li>mux,mmultiplexer：多路选择器</li><li>sel：多路选择器的那个选择</li><li>idle：状态机的一种状态，初始态、空闲态</li><li>MCDF：多通道数据整合器(一种设计)，可以将上行(uplink)多个通道数据经过内部FIFO最终以数据包的形式送出</li><li>Arbiter：仲裁</li><li>Formater：整形器</li><li>port/module_function_i/o/s(s是指内部信号)</li></ul><h2 id="其他命名"><a href="#其他命名" class="headerlink" title="其他命名"></a>其他命名</h2><ul><li>verifier</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>每个always只能有一个@(event-expression)</li><li>always @(敏感信号) always赋值的右值必须出现在敏感列表里，如果没有则会生成一个则会在综合时生成一个隐形锁存器</li><li>一定要避免生成锁存器，如果提示产生锁存器则代码一定在哪里有bug</li><li>reg和integer的赋值只能在always语句里，且不能在多个always语句中对同一个reg赋值</li><li>如果某个信号赋值为”‘bx”综合器会把其接生成无关状态，因而综合器为其生成的硬件电路最简洁</li><li>所有块的（非beginend,forkend语句）的声明语句右面要有<code>;</code>，如<code>class Transaction;</code>，不过如果后面跟着个冒号取名字就不用写冒号了</li><li>同理也存在<code>endfunction:随便起个名字</code>的命名块</li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>标准</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00学前指导：VerilogHDL</title>
    <link href="/202110111718/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/00%E5%AD%A6%E5%89%8D%E6%8C%87%E5%AF%BC%EF%BC%9AVerilogHDL/"/>
    <url>/202110111718/IC/sv%E5%AD%A6%E4%B9%A0/%E7%B2%BE%E9%80%9Aessay/ic/sv%E5%AD%A6%E4%B9%A0/00%E5%AD%A6%E5%89%8D%E6%8C%87%E5%AF%BC%EF%BC%9AVerilogHDL/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011172207954.png" alt="image-20211011172207954"></p><p>总体学习图</p><h1 id="一、Verilog-HDL设计速学指导"><a href="#一、Verilog-HDL设计速学指导" class="headerlink" title="一、Verilog HDL设计速学指导"></a>一、Verilog HDL设计速学指导</h1><h2 id="课程推荐"><a href="#课程推荐" class="headerlink" title="课程推荐"></a>课程推荐</h2><p>【电子】Verilog硬件描述语言 西安电子科技大学 蔡觉平等主讲 <a href="https://www.bilibili.com/video/BV12y4y1v7V3">https://www.bilibili.com/video/BV12y4y1v7V3</a></p><p>2020公开课【数字电路与逻辑设计】-华中科技大学 <a href="https://www.bilibili.com/video/BV197411u7dZ">https://www.bilibili.com/video/BV197411u7dZ</a></p><p>没有必要全都学，三无基础重点放在v2.1v2.2</p><h2 id="教材推荐"><a href="#教材推荐" class="headerlink" title="教材推荐"></a>教材推荐</h2><p>数电推荐：邬春明 《数字电路与逻辑设计》<br>verilog推荐：蔡觉平《Verilog HDL数字集成电路设计原理与应用》</p><h2 id="数电速学"><a href="#数电速学" class="headerlink" title="数电速学"></a>数电速学</h2><!-- ![image-20211011173233003](https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173233003.png) --><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173947985.png" alt="image-20211011173947985"></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011174326415.png" alt="image-20211011174326415"></p><p><strong>数电和逻辑-4 触发器（时序电路基础） 数电和逻辑-5 时许逻辑电路</strong></p><h2 id="Verilog-速学"><a href="#Verilog-速学" class="headerlink" title="Verilog 速学"></a>Verilog 速学</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173318582.png" alt="image-20211011173318582"></p><p>2.1-2.4参考蔡老师课本</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173150821.png" alt="image-20211011173150821"></p><p>insert</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173248125.png" alt="image-20211011173248125"><br>Modelsim很多是为了做设计，Questasim为了跑验证，基本一致的一家的</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011173259382.png" alt="image-20211011173259382"></p><h1 id="二、查找学习SV语法的方法"><a href="#二、查找学习SV语法的方法" class="headerlink" title="二、查找学习SV语法的方法"></a>二、查找学习SV语法的方法</h1><p>带数字的是绿皮书章节</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011182644186.png" alt="image-20211011182644186"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="SV精通1（硬件偏多）"><a href="#SV精通1（硬件偏多）" class="headerlink" title="SV精通1（硬件偏多）"></a>SV精通1（硬件偏多）</h3><p>sv中使用always非常之少但也要学  </p><p>第一周是建立一个基本概念，</p><h3 id="SV精通2（硬软过度）"><a href="#SV精通2（硬软过度）" class="headerlink" title="SV精通2（硬软过度）"></a>SV精通2（硬软过度）</h3><ul><li><p>接口-&gt;从硬件过渡到软件</p></li><li><p>有了接口会讲到采样和驱动，时钟块，SV里面的开始和结1束</p></li><li><p>与verilog的program对比</p></li><li>quseta 的helloworld</li></ul><h3 id="SV精通3（软件友好）"><a href="#SV精通3（软件友好）" class="headerlink" title="SV精通3（软件友好）"></a>SV精通3（软件友好）</h3><p>第一周讲的是设计往验证过度</p><p>第二周讲的设计转到验证需要接口，作为激励和采样</p><p>第三周对验证环境进行创建</p><p> <strong>绿皮书没有讲到包的使用，较为重要这里学</strong></p><h3 id="SV精通4"><a href="#SV精通4" class="headerlink" title="SV精通4"></a>SV精通4</h3><p>进入到随机，为什么学完类学随机？</p><ul><li>我们会把做随机的数变量封装在类里</li></ul><p>为什不用系统函数？</p><ul><li>随机的精髓在于约束，自由随机没有意义，对多个变量约束会有真正意义</li></ul><p>多个变量的约束可以会映射到真实世界里</p><p> 随机会伴随着约束，约束我们会添加到类里面</p><p>约束添加到类意外时内嵌的约束</p><p>因此我们会讲到随机数的控制即：随机函数</p><p>最后讲到最常用到的数组约束，因为数组用到的太多了，更是<strong>难点</strong></p><h3 id="SV精通5（线程）"><a href="#SV精通5（线程）" class="headerlink" title="SV精通5（线程）"></a>SV精通5（线程）</h3><p>SV里面涉及到并行，真实的物理世界里面的信号在任何时刻并行</p><p>我想在同一个时间点对软件发送多个数据</p><p>用软件并行的方式和软件去做token4</p><p>emailbox做一个基本的存储、事件做一个基本的驱动、旗语对一个敏感资源进行保护</p><h3 id="SV精通6"><a href="#SV精通6" class="headerlink" title="SV精通6"></a>SV精通6</h3><p>谈到覆盖率和高级的一部分了</p><p>覆盖率的收集，</p><p>覆盖率有点像SV的收尾，我们想用一个宏观的高级的语言为设计构建验证环境，在构建后区别固定每次都是随机的，每次都是不同的数据，这样会出现没发现的bug，但我们组合出来的情况会非常多，因此我们增加加约束且应该是合理的激励，即便是合理的激励，我们要知道合理的激励的有效组合到底数据有没有发生过，激励有没有发生过，这些激励对关键信号有没有发生</p><p>你不能依赖眼睛去观察，应该是一种自动化的手段，这里面牵扯到覆盖率</p><p>覆盖率我门会讲到：<strong>代码覆盖率、功能覆盖率</strong></p><p>代码覆盖率是编译器仿真器，按照要求添加后，会把覆盖率要求添加上来</p><p>功能覆盖率需要认为定义，是我们的<strong>重点 </strong>，我们要知道我们关心哪些信号，关心那些事件把他们作为事件， 把他们作为定义；作为定义例化；我们需要指导什么样的时间段要采样到这些数据，为什么要采样到这些数据；采样的这些数据在不同的测试用例里面，不断地测试，不断地采样到这些数据，最终汇总起来，我们才能有一个<strong>量化</strong>的数据在里面，才能知道到底我们产生了什么样的激励、这些激励帮我们触发了那些状态、这些状态最终是否满足要求、还有哪些状态没有被触发。这几点是验证行业这里两年标准化的重要一点</p><h3 id="SV精通7"><a href="#SV精通7" class="headerlink" title="SV精通7"></a>SV精通7</h3><p>第六周还有高阶的一点是这里</p><p>这几点必须要讲到，对应UVM的各种场景，只有了解了才能明白那些是UVM的规范、哪些是SV的知识</p><p>各个点SV和UVM对应起来有区别</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011194152963.png" alt="image-20211011194152963"></p><h1 id="三、查找学习SV语法的方法"><a href="#三、查找学习SV语法的方法" class="headerlink" title="三、查找学习SV语法的方法"></a>三、查找学习SV语法的方法</h1><h2 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011204144473.png" alt="image-20211011204144473"></p><p><strong>到底哪些知识点是verilog哪些是sv?</strong></p><p>verilog：</p><p>绝大部分知识点在蔡老师《Verilog HDL数字集成电路设计原理与应用》这本书里，比较薄</p><p>SV语法：</p><ul><li>常见语法大类看绿皮书</li><li>细致语法看IEEE SystemVerilog标准手册</li><li>语法的应用，结合V2.1讲义和实验内容，完成从语法点到实际应用</li></ul><p><strong>学SV时你需要会分清楚那些事verilog那些事SV</strong></p><p>SV新扩展内容只占了10%，主要是验证扩展内容“for vefryication”，因此SV标准手册很少提到verilog，IEEE2012和2017版本差别不大</p><p>当我们拿到手册时，我们的思路是，如何知道细碎的语法点？</p><p>自己多应用吧</p><p>语法手册当作字典。没有人把字典读完。</p><h2 id="查看SV的方法、类’验证结构可以利用DVT-Eclipse"><a href="#查看SV的方法、类’验证结构可以利用DVT-Eclipse" class="headerlink" title="查看SV的方法、类’验证结构可以利用DVT Eclipse"></a>查看SV的方法、类’验证结构可以利用DVT Eclipse</h2><p>学了v2.4以后可以把项目都移植过去</p><h2 id="如何看手册"><a href="#如何看手册" class="headerlink" title="如何看手册"></a>如何看手册</h2><p>最常用的：第三章（只是介绍）</p><p>第四章不建议前期看，直接去第六章去看（数据类型），第六章每一节都很必要(var类型在定义wire或reg等其他类型时默认了)<br>scope &amp; lifetime 域和生命周期</p><p>第七章讲的各种类型的数组 </p><p>第八章和类相关</p><p>第九章是process在verilog中讲过<br>timing control?</p><p>第十一章Operators需要用到，以及优先级，以及默认无符号的可以通过signed 主动声明</p><p>第十五章进程间的通信</p><p>十六章讲断言</p><p>十七章Checker不再用，我们不再用SV中的Checker做检查</p><p>十八章随机数的产生，注意随机种子，其实不看也行</p><p>十九章V2.1第六周的内容相关，功能覆盖率</p><p>二十章二十一章系统函数有必要，找不到则在Verilog中找</p><p>二十二章编译向导在Verilog中提到，讲那些编译编那些编译不编</p><p>第二部分：层次化构建，更靠近设计部分的东西</p><p>二十三章模块是怎么定义的</p><p>二十四章Programs几乎不怎么用</p><p>二十五张Interface重点看一下，virtual interface其实指的是接口指针</p><p>二十六章package怎么定义，module里面import package，以及order。26.7讲内嵌的一些方法，始于以下标准库</p><p>二十七章Generate动态的参数来例化多少个模块以及语句，</p><p>第三部分：api的接口</p><p>暂时放一边</p><p>第四部分：附录</p><p>暂时放一边</p><p>重点在，第六章开始</p><h2 id="使用DVT"><a href="#使用DVT" class="headerlink" title="使用DVT"></a>使用DVT</h2><p>DVT如何去引用之前定义好的，建立好的实验导入进去，用DVT查找最大的好处是用来查找UVM</p><h1 id="四、DVT帮助理解实验代码"><a href="#四、DVT帮助理解实验代码" class="headerlink" title="四、DVT帮助理解实验代码"></a>四、DVT帮助理解实验代码</h1><h1 id="五、UVM入门进阶学习路线"><a href="#五、UVM入门进阶学习路线" class="headerlink" title="五、UVM入门进阶学习路线"></a>五、UVM入门进阶学习路线</h1><h2 id="路线图-1"><a href="#路线图-1" class="headerlink" title="路线图"></a>路线图</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011194929424.png" alt="image-20211011194929424"></p><p>一旦进入UVM中，牵扯到的知识面广，没有办法用sv一样剥离开，里面有很多复杂的类和语法支撑他</p><p>地图里面十个大类，日常生活中用到不到百分之三十，要知道哪些类重要</p><h2 id="UVM核心机制"><a href="#UVM核心机制" class="headerlink" title="UVM核心机制"></a>UVM核心机制</h2><p>(1) 一开始介绍核心机制，以后看见UVM的验证代码里面用了某种机制实现的就在这里提到了</p><p>(2) 工厂一定要用到，UVM使用到的所有类型都要用到工厂</p><p>(3) 覆盖方法不一定会遇到，深入以后一定跑不了</p><p>(4) 核心基类：uvmobject/uvmcompoment，compoment继承于object，第二周的组件结构都是componment的内容，object不属于验证结构的一部分，在激励组织里面的sequentce,item属于object类型<br>什么时候compoment什么时候object?<br>不会轻易死亡的是compoment<br>在仿真的某一时间开始某一时间结束掉的是object</p><p>(5) phase机制，九大phase,十二个小的phase，对应在sv里面的创建部分</p><p>(6) config机制是sv的一个痛点，sv中要对验证组件进行配置时，必须先对组件进行配置。到了UVM中在组件没有创建前，把config保存到中间的某一个database，后来的底层部件在从这里get</p><p>(7) 消息机制，SV里面的report，是提前熟悉UVM里消息机制的</p><p>以上这些必须熟悉，不以后不好学</p><h2 id="UVM组件结构和环境构建"><a href="#UVM组件结构和环境构建" class="headerlink" title="UVM组件结构和环境构建"></a>UVM组件结构和环境构建</h2><p>容易理解，似曾相识<br>scoreboard对应chater<br>driver对应simulator<br>sequencer仲裁的功能</p><h2 id="TLM通信"><a href="#TLM通信" class="headerlink" title="TLM通信"></a>TLM通信</h2><h2 id="激励的组织和传输机制"><a href="#激励的组织和传输机制" class="headerlink" title="激励的组织和传输机制"></a>激励的组织和传输机制</h2><h2 id="寄存器模型组织及应用"><a href="#寄存器模型组织及应用" class="headerlink" title="寄存器模型组织及应用"></a>寄存器模型组织及应用</h2><h1 id="八、验证流程管理"><a href="#八、验证流程管理" class="headerlink" title="八、验证流程管理"></a>八、验证流程管理</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20211011203447304.png" alt="image-20211011203447304"></p><h2 id="DVT-Eclipse"><a href="#DVT-Eclipse" class="headerlink" title="DVT Eclipse"></a>DVT Eclipse</h2><p>SV/UVM v2.1提到，很好用</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>精通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>指导</tag>
      
      <tag>sv学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora使用帮助</title>
    <link href="/202110111507/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/typora%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"/>
    <url>/202110111507/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7essay/tools/typora%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不得不感叹typora是真的优美啊，之前一直用有道云记笔记，感觉多端同步挺舒服的，自己也烂的转移，终于到今天打脸了</p><p>下载就64MB，拜学校图书馆网速能跑炸测速网，平均速度68MB/s所赐一秒钟，真就一秒钟下完了</p><p>一打开界面就只有菜单栏和中间一大片的空白canvas，连图标都没有显示。侧边的文件栏也很有直觉可以切换视图，列表视图显示文件夹下所有markdown，树视图就直接文件夹层级了，点开的过度动画很有美感，可以直接打开文件夹，直呼过瘾</p><p>文档编写时markdown的显示与代码融合在一起，不过也可以底边切换成源代码格式，标题在写作模式也可以直接点开，是真的好用！配合以前装的PicGo直接ctrl v完成图片上传，舒服！</p><p>不得不边用便赞叹开发者的匠心，每一处细节都考虑的如此精确</p><h1 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h1><h3 id="关于enter与shift-enter"><a href="#关于enter与shift-enter" class="headerlink" title="关于enter与shift+enter"></a>关于enter与shift+enter</h3><p>本质上Shift+Enter和Enter的换行效果就是“换行符”和“段落标记”的区别，前者不分段，后者分段。在HTML中，前者表示为<code>&lt;br&gt;</code>标记，后者表示为<code>&lt;p&gt;</code>标记对应的结束标记<code>&lt;/p&gt;</code></p><p>之所以另起一段的换行效果与“单行换行”有区别，原因是css样式里往往将段落元素<code>&lt;p&gt;</code>的间距加大了，类似于加大了段间距。题主可以试着找一找有没有Typora的css样式模板把段间距改没了的，或者实在不行自己动手改原有的模板</p><h3 id="Typora-PicGo-Core"><a href="#Typora-PicGo-Core" class="headerlink" title="Typora+PicGo-Core"></a>Typora+PicGo-Core</h3><ol><li>按下图所示勾选<code>插入图片时</code>的选项，并在<code>上传服务设定</code>选择<code>PicGo-Core(command line)</code>，点击<code>下载或更新</code>按钮下载插件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f34bc8b782d6127ed0b3d2889b43058e.png" alt="图片1"></p><ol><li>安装插件：安装完成后，到软件安装目录，使用命令行分别安装三个插件</li></ol><ul><li>windows系统一般在C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\文件夹，文件名为picgo.exe；</li><li>linux系统一般在~/.config/Typora/picgo/linux/文件夹，文件名为picgo；</li></ul><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">.\picgo.exe <span class="hljs-keyword">install</span> smms-user<br>.\picgo.exe <span class="hljs-keyword">install</span> gitee-uploader<br>.\picgo.exe <span class="hljs-keyword">install</span> github-plus<br></code></pre></div></td></tr></table></figure><ol><li>修改typora配置文件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/6828e8cc3a78d6a8293d7124ee847f7e.png" alt=""></p><p>gitee仓库如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs &#123;">  &quot;picBed&quot;: &#123;<br>    &quot;current&quot;: &quot;gitee&quot;,<br>    &quot;uploader&quot;: &quot;gitee&quot;,<br>    &quot;gitee&quot;: &#123;<br>      &quot;branch&quot;: &quot;master&quot;,<br>      &quot;customPath&quot;: &quot;yearMonth&quot;,<br>      &quot;customUrl&quot;: &quot;&quot;,<br>      &quot;path&quot;: &quot;仓库下的文件夹&quot;,<br>      &quot;repo&quot;: &quot;用户id/仓库名&quot;,<br>      &quot;token&quot;: &quot;gitee上申请的私人令牌&quot;<br>    &#125;<br>  &#125;,<br>  &quot;picgoPlugins&quot;: &#123;<br>    &quot;picgo-plugin-gitee-uploader&quot;: true<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>阿里云仓库如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs &#123;">  &quot;picBed&quot;: &#123;<br>   &quot;uploader&quot;: &quot;aliyun&quot;,<br>    &quot;aliyun&quot;: &#123;<br>    &quot;accessKeyId&quot;: &quot;&quot;,<br>    &quot;accessKeySecret&quot;: &quot;&quot;,<br>    &quot;bucket&quot;: &quot;&quot;, // 存储空间名<br>    &quot;area&quot;: &quot;&quot;, // 存储区域代号<br>    &quot;path&quot;: &quot;img/&quot;, // 自定义存储路径<br>    &quot;customUrl&quot;: &quot;&quot;, // 自定义域名，注意要加 http://或者 https://<br>    &quot;options&quot;: &quot;&quot; // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+<br>    &#125;<br>  &#125;,<br>  &quot;picgoPlugins&quot;: &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>current</strong>为当前的图床，uploader表示上传用的图床，这里两个都设置为gitee；<br><strong>master</strong>表示主分支，一般用做图床的仓库是个单独的仓库，此处保持master就好；<br><strong>path</strong>为仓库下的文件夹，repo为仓库名，假如如有一个仓库名为a，图片存在这个仓库下的b文件夹，<strong>你的用户id是linux（浏览器地址栏仓库名前的字符串）</strong>，则path为b、repo为linux/a；<br><strong>token</strong>为私人令牌，需要在gitee网站申请，申请的token只出现一次，点击复制按钮将其粘贴到配置文件中即可，一个用户可以有多个token，可以在gitee网站管理自己的token。</p><p><strong>使用的插件都要在<code>picgoPlugins</code>里包含并设置为<code>true</code>，这里只使用了<code>gitee</code>插件</strong></p><h4 id="参考配置博客"><a href="#参考配置博客" class="headerlink" title="参考配置博客"></a>参考配置博客</h4><p><a href="https://blog.csdn.net/to_free/article/details/114981807">typora+gitee</a><br><a href="https://blog.csdn.net/to_free/article/details/108784006">Typora+gitee+notejs+坚果云构建私有云笔记</a><br><a href="https://blog.csdn.net/qq_39714832/article/details/111257518">Typora+图床详解（小白都能学得会）</a></p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV通识1：验证任务_目标、验证周期</title>
    <link href="/202110042004/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%E3%80%81%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F/"/>
    <url>/202110042004/IC/sv%E5%AD%A6%E4%B9%A0/%E9%80%9A%E8%AF%86essay/ic/sv%E5%AD%A6%E4%B9%A0/SV%E5%AD%A6%E4%B9%A01-1%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%E3%80%81%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、验证的目标"><a href="#一、验证的目标" class="headerlink" title="一、验证的目标"></a>一、验证的目标</h1><h2 id="1-验证工程师面临的任务"><a href="#1-验证工程师面临的任务" class="headerlink" title="1.验证工程师面临的任务"></a>1.验证工程师面临的任务</h2><ul><li>模块级 module level</li><li>子系统级 subsytem level</li><li>系统级 chip level</li></ul><h2 id="2-验证的目标：按时、保质、低耗"><a href="#2-验证的目标：按时、保质、低耗" class="headerlink" title="2.验证的目标：按时、保质、低耗"></a>2.验证的目标：按时、保质、低耗</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201036.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201201.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201325.png"/></p><h1 id="二、验证周期"><a href="#二、验证周期" class="headerlink" title="二、验证周期"></a>二、验证周期</h1><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201426.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201712.png"/></p><p><strong>回归测试简单来讲把已有的测试都做一遍</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004201806.png"/></p><h2 id="上述细致解释"><a href="#上述细致解释" class="headerlink" title="上述细致解释"></a>上述细致解释</h2><h3 id="（1）功能描述文档"><a href="#（1）功能描述文档" class="headerlink" title="（1）功能描述文档"></a>（1）功能描述文档</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202117.png"/></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202700.png"/></p><h3 id="（2）验证计划"><a href="#（2）验证计划" class="headerlink" title="（2）验证计划"></a>（2）验证计划</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004202842.png"/> </p><h3 id="（3）验证环境"><a href="#（3）验证环境" class="headerlink" title="（3）验证环境"></a>（3）验证环境</h3><p><strong>工具主流quasta，方法主流动态仿真</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203302.png"/></p><h3 id="（4）uvm帮助调试-debug"><a href="#（4）uvm帮助调试-debug" class="headerlink" title="（4）uvm帮助调试(debug)"></a>（4）uvm帮助调试(debug)</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203826.png"/></p><h3 id="（5）-回归测试"><a href="#（5）-回归测试" class="headerlink" title="（5） 回归测试"></a>（5） 回归测试</h3><p><strong>修复bug后再跑一边全部测试用例</strong></p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004203944.png"/></p><h3 id="（6）硅后与流片"><a href="#（6）硅后与流片" class="headerlink" title="（6）硅后与流片"></a>（6）硅后与流片</h3><p>即便流片还需要功能验证，不断提高覆盖率</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204112.png"/></p><h3 id="（7）硅后系统测试"><a href="#（7）硅后系统测试" class="headerlink" title="（7）硅后系统测试"></a>（7）硅后系统测试</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204327.png"/></p><h3 id="（8）逃逸分析"><a href="#（8）逃逸分析" class="headerlink" title="（8）逃逸分析"></a>（8）逃逸分析</h3><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20211004204442.png"/></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>sv学习</category>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sv学习</tag>
      
      <tag>通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随便记一点：初识aurora接口</title>
    <link href="/202110042004/IC/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/auroraessay/ic/%E6%8E%A5%E5%8F%A3/aurora/%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%AD%A5/"/>
    <url>/202110042004/IC/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/auroraessay/ic/%E6%8E%A5%E5%8F%A3/aurora/%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190509145732524.png" alt=""></p><p><em>sof_n：数据传输开始标志，低电平有效；</em>eof_n：数据传输结束标志，低电平有效；<br>*rdy_n：传输数据有效标志，低电平有效；</p><h2 id="Status-and-Control-Ports"><a href="#Status-and-Control-Ports" class="headerlink" title="Status and Control Ports"></a>Status and Control Ports</h2><ul><li><p>reset/tx_ststem_reset/rx_system_reset</p></li><li><p>gt_reset：r. The gt_reset port should be asserted when the module is first powered up in hardware.</p></li><li><p>init_clk_in:The init_clk_in port is required because user_clk stops when </p><p>gt_reset is asserted. It is recommended that the frequency chosen for init_clk_in be lower than the GT Reference Clock input frequency.</p></li><li><p>tx_aligned,tx_bonded,tx_verify,rx_reset:与rx的对应接口相连</p><p>Only available in TX-only simplex dataflow mode and sideband as back channel core configuration.</p></li></ul><p>Only available in RX-only simplex dataflow mode and sideband as back channel core configuration.</p><h2 id="Status-and-Control-Ports-Cont’d"><a href="#Status-and-Control-Ports-Cont’d" class="headerlink" title="Status and Control Ports  (Cont’d)"></a>Status and Control Ports  <strong>(Cont’d)</strong></h2><p>暂空，和上节表对应</p><h2 id="Full-Duplex-Status-and-Control-Ports"><a href="#Full-Duplex-Status-and-Control-Ports" class="headerlink" title="Full-Duplex Status and Control Ports"></a><strong>Full-Duplex Status and Control Ports</strong></h2><p>Cont’d是续的意思，这里是续表</p><p>lane_up总线指示通道中的哪些车道已完成车道初始化过程。该信号可用于帮助调试多通道信道中的设备问题</p><p>channel_up只有在核心完成整个初始化过程后才会断言</p><p>在断言channel_up之前无法接收数据。只能使用用户界面上的m_axi_rx_tvalid信号来限定传入的数据。</p><p>channel_up可以倒置，用于重置驱动全双工通道TX侧的模块，因为直到channel_up之后才能发生传输</p><p>如果在数据接收前需要重置用户应用程序模块，则可以倒置并使用其中一个lane_up信号。在断言所有lane_up信号后才能接收数据</p><h2 id="Simplex-Cores"><a href="#Simplex-Cores" class="headerlink" title="Simplex Cores"></a><strong>Simplex Cores</strong></h2><h2 id="This-interface-includes-the-serial-I-O-ports-of-the-transceivers-and-the-control-and-status"><a href="#This-interface-includes-the-serial-I-O-ports-of-the-transceivers-and-the-control-and-status" class="headerlink" title="This interface includes the serial I/O ports of the transceivers, and the control and status"></a>This interface includes the serial I/O ports of the transceivers, and the control and status</h2>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>接口与协议</category>
      
      <category>aurora</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>fpga</tag>
      
      <tag>aurora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo的fluid主题的背景固定</title>
    <link href="/202110011100/%E9%80%9A%E7%9F%A5notify/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A/"/>
    <url>/202110011100/%E9%80%9A%E7%9F%A5notify/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="基于hexo的fluid主题的背景固定"><a href="#基于hexo的fluid主题的背景固定" class="headerlink" title="基于hexo的fluid主题的背景固定"></a>基于hexo的fluid主题的背景固定</h1><p>背景固定效果需要使用注入器，因此需要将hexo升至5.0版本以上</p><p>效果如本页所示，这种效果贯穿着整个博客。具体做法如下：使用<code>注入器</code>(如果没有<code>injector.js</code>文件，则在<code>scripts</code>文件夹下新建<code>injector.js</code>)，在<code>injector.js</code>中写下这些代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 全屏背景的需要导入这些js</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/&quot;</span> &#125; = hexo.config;<br>hexo.extend.injector.register(<span class="hljs-string">&quot;body_begin&quot;</span>, <span class="hljs-string">`&lt;div id=&quot;web_bg&quot;&gt;&lt;/div&gt;`</span>);<br>hexo.extend.injector.register(<br>  <span class="hljs-string">&quot;body_end&quot;</span>,<br>  <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/backgroundize.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;link defer rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>css/backgroundize.css&quot; /&gt;</span><br><span class="hljs-string">  `</span><br>);<br></code></pre></div></td></tr></table></figure><p>在<code>js</code>文件夹中新建<code>backgroundize.js</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bannerContainer = $(<span class="hljs-string">&quot;#banner&quot;</span>);<br><span class="hljs-keyword">const</span> viewBg = $(<span class="hljs-string">&quot;#web_bg&quot;</span>);<br><span class="hljs-keyword">const</span> bannerMask = $(<span class="hljs-string">&quot;#banner .mask&quot;</span>);<br><span class="hljs-keyword">const</span> bg = $(bannerContainer).css(<span class="hljs-string">&quot;background-image&quot;</span>);<br>$(viewBg).css(<span class="hljs-string">&quot;background-image&quot;</span>, bg);<br>$(bannerContainer).css(<span class="hljs-string">&quot;background-image&quot;</span>, <span class="hljs-string">&quot;url()&quot;</span>);<br><span class="hljs-keyword">const</span> color = $(bannerMask).css(<span class="hljs-string">&quot;background-color&quot;</span>);<br>$(bannerMask).css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">`rgba(0,0,0,0)`</span>);<br>$(viewBg).css(<span class="hljs-string">&quot;background-color&quot;</span>, color);<br></code></pre></div></td></tr></table></figure><p>在<code>css</code>文件夹中新增<code>backgroundize.css</code>文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">#web_bg &#123;<br>  <span class="hljs-attr">position</span>: fixed;<br>  z-index: -<span class="hljs-number">999</span>;<br>  width: <span class="hljs-number">100</span>%;<br>  height: <span class="hljs-number">100</span>%;<br>  background-attachment: local;<br>  background-position: center;<br>  -webkit-background-size: cover;<br>  -moz-background-size: cover;<br>  background-size: cover;<br>  background-repeat: repeat;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意确认保存css的文件夹名称是css或是style，如果是style则需更改injector.js的导入文件地址</strong></p>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog可综合的语法</title>
    <link href="/202109272059/IC/%E7%9F%A5%E8%AF%86essay/ic/verilog%E5%AD%A6%E4%B9%A0/01Verilog%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <url>/202109272059/IC/%E7%9F%A5%E8%AF%86essay/ic/verilog%E5%AD%A6%E4%B9%A0/01Verilog%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="可综合的含义是"><a href="#可综合的含义是" class="headerlink" title="可综合的含义是"></a>可综合的含义是</h3><p>把语言描述变成电路网表，综合软件采用器件库提供的标准单元将RTL级描述转换成门级网表，具体综合过程如下：<br> <span id="more"></span></p><ol><li><p>综合软件读取RTL级代码（可综合的代码），将其转换成门级网表，确保门级的网表的输入输出关系与RTL代码描述的输入输出关系保持一致</p></li><li><p>对门级网表进行优化（局部优化）</p></li><li><p>采用器件库内标准的原件或者FPGA内部的逻辑单元实现优化后的门级网表</p></li></ol><p><a href="https://www.eefocus.com/initial_wei/blog/12-10/287444_c623b.html">而乐鑫2022数字IC实习类笔试最后一个多选题也考了关于Verilog可综合的语法，查阅了一下相关资料，这篇文章总结的很全</a></p><p>所有综合工具都支持的结构：<br>always，assign，begin，end，case，wire，tri，aupply0，supply1，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，buf，not，bufif0，bufif1，notif0，notif1，if，inout，input，instantitation，module，negedge，posedge，operators，output，parameter</p><h3 id="所有综合工具都不支持的结构："><a href="#所有综合工具都不支持的结构：" class="headerlink" title="所有综合工具都不支持的结构："></a>所有综合工具都不支持的结构：</h3><p>time，defparam，$finish，fork，join，initial，delays，UDP，wait</p><h3 id="有些工具支持有些工具不支持的结构："><a href="#有些工具支持有些工具不支持的结构：" class="headerlink" title="有些工具支持有些工具不支持的结构："></a>有些工具支持有些工具不支持的结构：</h3><p>casex，casez，wand，triand，wor，trior，real，disable，forever，arrays，memories，repeat，task，while</p><p>Verilog中提供了四种循环语句，可用于控制语句的执行次数，分别是for、while、repeat、forever</p><h3 id="关于while、repeat、forever："><a href="#关于while、repeat、forever：" class="headerlink" title="关于while、repeat、forever："></a>关于while、repeat、forever：</h3><p>while和repeat可以综合，但是循环次数需要在编译之前就确定，动态改变循环次数是不可综合的，forever是不可综合的，它主要用来产生各种激励</p><p>部分参考： <a href="http://xilinx.eetrend.com/content/2019/100045400.html">http://xilinx.eetrend.com/content/2019/100045400.html</a></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>microblaze运行linux方案探索</title>
    <link href="/202109131145/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1essay/projects/1/"/>
    <url>/202109131145/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1essay/projects/1/</url>
    
    <content type="html"><![CDATA[<h2 id="方案背景"><a href="#方案背景" class="headerlink" title="方案背景"></a>方案背景</h2><p>microblaze上跑linux的方案，包括如何启动和固化<br> <span id="more"></span></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案(1)"></a>解决方案(1)</h2><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912195221.png"/></p><h3 id="1-相关技术"><a href="#1-相关技术" class="headerlink" title="1 相关技术"></a>1 相关技术</h3><h4 id="1-1-microblaze运行linux可行性"><a href="#1-1-microblaze运行linux可行性" class="headerlink" title="1.1 microblaze运行linux可行性"></a>1.1 microblaze运行linux可行性</h4><ol><li>主要开发文档<br><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">ug1144</a></li></ol><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912221635.png"/></p><ol><li>microblaze官方wiki</li></ol><p>介绍mmu,处理器结构,microblaze with linux</p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913101354.png"/></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842560/MicroBlaze">原文链接</a></p><ol><li>4种启动方案与一种实现案例(博客)</li></ol><p><span id="MicroBlaze处理器的PetaLinux操作系统移植"></p><p><a href="http://www.eepw.com.cn/article/191233.htm">MicroBlaze处理器的PetaLinux操作系统移植：</a>PetaLinux有4种启动方案：XMD下载启动、TFTP网络下载启动、Flash启动和SysACE CF卡启动。其中，XMD和TFTP网络下载启动方案，在每次系统上电后都必须重新下载，适用于系统调试；Flash启动方案在系统上电后自动从Flash中读取配置文件，但Flash烧写速度较慢，更改系统配置较为不便。因此，本系统选用SysACECF卡启动方案..</p><ol><li>mircoblaze的vivado搭建官方指南</li></ol><p><a href="https://www.xilinx.com/support/documentation-navigation/design-hubs/dh0020-microblaze-hub.html">相关文档大全</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913101955.png"/></p><p>《ug940》</p><h4 id="1-2固化bitstream文件"><a href="#1-2固化bitstream文件" class="headerlink" title="1.2固化bitstream文件?"></a>1.2固化bitstream文件?</h4><p>1.传统方法对Bitstream进行flash固化</p><p>需要说明的是，下载完比特流后，如果开发板断电，程序会丢失。如果想要程序断电不丢失的话，需要将程序固化至开发板中，这个需要在嵌入式 SDK 软件中完成， ZYNQ 芯片无法单独固化比特流文件(PL的配置文件)。这是由于 ZYNQ 非易失性存储器的引脚(如 SD 卡、QSPI Flash)是 ZYNQ PS 部分的专用引脚， 这些非易失性存储器由 PS 的 ARM 处理器进行驱动，需要将bit流文件和elf文件（软件程序的下载文件） 合成一个 BOOT.BIN，才能进行固化， 因此需要学习 ZYNQ 嵌入式 SDK 的开发流程。</p><ol><li><strong>尚不明确micrblaze软核是先进行固化后在完成镜像移植启动，还是在镜像移植</strong></li></ol><!--2.如果要实现Linux系统，是需要进行petalinux移植时固化？--><!--[参考文章：](#MicroBlaze处理器的PetaLinux操作系统移植)--><!--PetaLinux有4种启动方案：XMD下载启动、TFTP网络下载启动、Flash启动和SysACE CF卡启动。其中，XMD和TFTP网络下载启动方案，在每次系统上电后都必须重新下载，适用于系统调试；Flash启动方案在系统上电后自动从Flash中读取配置文件，但Flash烧写速度较慢，更改系统配置较为不便。因此，本系统选用SysACECF卡启动方案。--><!--在petalinux创建ps端linux系统时的hdf中包括microblaze软核及其周边外设--><h3 id="2-相关设计参考"><a href="#2-相关设计参考" class="headerlink" title="2 相关设计参考"></a>2 相关设计参考</h3><h4 id="2-1-启动-使用flash完成操作系统启动"><a href="#2-1-启动-使用flash完成操作系统启动" class="headerlink" title="2.1 启动(使用flash完成操作系统启动)"></a>2.1 启动(使用flash完成操作系统启动)</h4><p><a href="https://blog.csdn.net/weiaipan1314/article/details/110679080">参考启动流程：</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913105356.png"/></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842560/MicroBlaze">参考文章MicroBlaze 上的嵌入式软件堆栈概述：</a><br>MicroBlaze 的软件堆栈不像Xilinx的其他嵌入式设备那样从加固的BootROM开始。相反，初始引导代码必须包含在FPGA比特流中，通常通过初始化映射到MicroBlaze引导向量的一小块 BlockRAM来实现。对于某些系统，整个应用程序可能会驻留在这个BlockRAM 中。对于更复杂的系统（例如Linux），可以在BlockRAM中初始化第一阶段引导加载程序。Xilinx 提供了一个称为 FS-Boot的第一阶段引导加载程序，它在启动时执行并负责将第二阶段引导加载程序（通常是U-Boot，但可能是最终应用程序）从非易失性存储器复制到 MicroBlaze可以从中执行的存储器中，通常为DDR。FS-Boot 至少需要 8KB 的 BlockRAM。 </p><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913105918.png"/></p><p>有关创建 FS-Boot 并将其合并到比特流中的更多信息，请参阅PetaLinux 工具指南。 </p><p><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">microblaze启动手册说明—《ug11440》:</a><br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913112526.png"/></p><p><a href="https://china.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_1/c_ug1144-petalinux-tools-reference-guide.pdf">flash做uboot—《ug1144》:</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913110611.png"/></h2><p><a href="https://www.xilinx.com/support/answers/50991.html">zynq支持的flash容量</a></p><h4 id="2-2-BD设计结构参考"><a href="#2-2-BD设计结构参考" class="headerlink" title="2.2 BD设计结构参考"></a>2.2 BD设计结构参考</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210912221254.png"/></p><h4 id="2-3-设计方案猜想"><a href="#2-3-设计方案猜想" class="headerlink" title="2.3 设计方案猜想"></a>2.3 设计方案猜想</h4><p>通过petalinux配置位于flash启动镜像并封装，使用jtag完成镜像启动？</p><h3 id="3-其他注意点"><a href="#3-其他注意点" class="headerlink" title="3 其他注意点"></a>3 其他注意点</h3><h4 id="3-1-ug1144-P17"><a href="#3-1-ug1144-P17" class="headerlink" title="3.1 ug1144,P17"></a>3.1 ug1144,P17</h4><p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20210913111726.png"/></p><!--正点原子zynq5pynq开发指南P99--><h2 id="解决方案-2-—还未研究"><a href="#解决方案-2-—还未研究" class="headerlink" title="解决方案(2)—还未研究"></a>解决方案(2)—还未研究</h2><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><h4 id="1-uclinux"><a href="#1-uclinux" class="headerlink" title="1 uclinux"></a>1 uclinux</h4><p>运行uclinux嵌入式系统uclinux表示micro-control linux</p><p><a href="http://www.doc88.com/p-1505465960626.html">在Microblaze处理器上进行uclinux移植</a><br><a href="https://www.zhihu.com/question/66072428">除了uclinux，在单片机上可以移植哪些版本的linux</a></p><p>无名无名 (提问者)2017-10-09<br>也就是说，在目前的嵌入式市场里面，不带mmu的系统已经占比特别少了，对吗？</p><p>jiangtao9999<br>jiangtao9999 (作者) 回复无名 (提问者)2017-10-12<br>所以我说放弃单片机这个概念。因为你用的东西也不一定就真的是通用 CPU 但也不一定就真的是几千个晶体管的只能当作 DPS 看待的玩意。现在技术提升了，很多功能溢出的 CPU 也不贵。很多人就会倾向于选择通用设备而方便开发。而且现在这种产品的需求量也是很大的，功能残缺的东西，也大有人用。这些东西，有的时候不是再跑个 uclinux 去浪费资源，而是直接写成运行功能的代码，不用操作系统直接运行的了。</p><p>怎么说呢。现在定义上，只要能实现一个芯片搞定，就叫单片机。但是随着技术发展，很多东西都能封装到一个芯片上，但是实际上内部设计，还是不同功能独立区分的。所以相对来说 ARM 更多的类似于多个芯片集成封装。更何况 ARM 内部集成的电路还有更多的功能。而不是传统的那种真的只有一个芯片设计的 CPU 了。你可以理解单片机就是为了一件任务做设计的，没有高级系统。而 ARM 跑 Linux ，属于通用 CPU 运行通用型操作系统。</p><p>印象里当初 uclinux 其实主要用在没有 mmu 的 arm 上，但是现在硬件基本都有 mmu ，甚至 arm 的 vfp/neon 都成标配了（当然也可以选择没有的，但是没有浮点运算现在这种什么都要求计算性能的地方用整数计算机很慢的）。</p><p>综上，现在最好放弃单片机这种概念了。比较容易乱。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p><strong>和普通单片机一样完成系统移植？</strong></p><!--## 解决方案(3)--还未研究--><!--#### 1 MicroBlaze V7 新添内存管理单元（MMU）--><!--[MicroBlaze V7 新添内存管理单元（MMU）part1(转)](http://blog.sina.com.cn/s/blog_538eef960100h7dc.html)--><!--[利用Vivado进行MicroBlaze处理器应用教程](https://blog.csdn.net/weiaipan1314/article/details/110674762)--><!--#### 2 全功能操作系统是Lynuxworks BlueCat Linux-->]]></content>
    
    
    <categories>
      
      <category>项目与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/202109071200/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/common_command/"/>
    <url>/202109071200/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/common_command/</url>
    
    <content type="html"><![CDATA[<p>…<br> <span id="more"></span></p><h2 id="1-hexo-目录分层"><a href="#1-hexo-目录分层" class="headerlink" title="1 hexo 目录分层"></a>1 hexo 目录分层</h2><ul><li>source :管理文件</li><li>about页面修改: \myblog\source\about\index.md<br>相关提示：<code>以下仅为页面顶部的基本信息，更多内容请在 ./pages/about.md 中编辑，支持 markdown 和 HTML</code></li></ul><h2 id="2-配置文件修改"><a href="#2-配置文件修改" class="headerlink" title="2 配置文件修改"></a>2 配置文件修改</h2><h3 id="有主题的情况下优先在主题的config文件里修改"><a href="#有主题的情况下优先在主题的config文件里修改" class="headerlink" title="有主题的情况下优先在主题的config文件里修改"></a>有主题的情况下优先在主题的config文件里修改</h3><p>本博客应用xx主题，修改目录为<br><strong>.\myblog\themes\fluid_config.yml</strong></p><p>修改完要clean才能正确渲染</p><h3 id="header-category-setting"><a href="#header-category-setting" class="headerlink" title="header category setting"></a>header category setting</h3><p><strong>.\myblog\themes\fluid_config.yml</strong></p><h2 id="3-hexo常用命令"><a href="#3-hexo常用命令" class="headerlink" title="3 hexo常用命令"></a>3 hexo常用命令</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>创建 hexo new “title”</li><li>某个目录下创建的基础命令为：<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">hexo <span class="hljs-keyword">new</span> --path ./essay/IC/<span class="hljs-number">02</span> <span class="hljs-string">&quot;02&quot;</span> <br><span class="hljs-meta"># 在\myblog\source\_posts\essay\IC下创建了一篇博客</span><br><span class="hljs-meta"># 同时会自动创建同名文件夹) </span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="4-header-与-category-的关系"><a href="#4-header-与-category-的关系" class="headerlink" title="4 header 与 category 的关系"></a>4 header 与 category 的关系</h2><p>.md文件下的，例如：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">title: 第一篇文章<br>date: 2020<span class="hljs-string">-03</span><span class="hljs-string">-07</span> 01:43:47<br><span class="hljs-keyword">tags:</span> 实用手册<br>categories: [实用手册]<br></code></pre></div></td></tr></table></figure><p>中的<code>categories: [实用手册]</code>对应生成于网站的/categories/下，在文章页用<code>categories: [A,B,C]</code>会<strong>生成</strong>并对应到该目录层级下</p><p>要想显示在页头，对应修改（已应用主题，有的主题会有页头索引，有的没有，所以此次修改的是个目录）</p><p>myblog\themes\fluid_config.yml</p><p>下的menu与header，例如</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">navbar:</span><br><span class="hljs-symbol">  blog_title:</span>  <span class="hljs-meta"># 导航栏左侧的标题，为空则按 hexo config.title 显示</span><br><span class="hljs-symbol">  menu:</span>  <span class="hljs-meta"># 可自行增减，若想减去某个入口，可以将值留空，显示文本关联 languages</span><br><span class="hljs-symbol">    home:</span> /<br><span class="hljs-symbol">    archive:</span> <span class="hljs-meta-keyword">/archives/</span><br><span class="hljs-symbol">    category:</span> <span class="hljs-meta-keyword">/categories/</span><br><span class="hljs-symbol">    tag:</span> <span class="hljs-meta-keyword">/tags/</span><br>    实用手册: <span class="hljs-meta-keyword">/categories/</span>实用手册<br>    项目与设计: <span class="hljs-meta-keyword">/categories/</span>program/<br><span class="hljs-symbol">    CS:</span> <span class="hljs-meta-keyword">/categories/</span>CS/<br><span class="hljs-symbol">    IC:</span> <span class="hljs-meta-keyword">/categories/</span>IC/<br><span class="hljs-symbol">    about:</span> <span class="hljs-meta-keyword">/about/</span><br>    <span class="hljs-meta">#links: /links/  # 友链页，把前面#去掉即可展示</span><br></code></pre></div></td></tr></table></figure><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h2><ul><li>[TOC]目录用不了，注意</li></ul>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开放评论、live2d与音乐盒!</title>
    <link href="/202011291125/%E9%80%9A%E7%9F%A5notify/notifyOpenMusicCommitLive2d/"/>
    <url>/202011291125/%E9%80%9A%E7%9F%A5notify/notifyOpenMusicCommitLive2d/</url>
    
    <content type="html"><![CDATA[<h1 id="开放评论、live2d与音乐盒！"><a href="#开放评论、live2d与音乐盒！" class="headerlink" title="开放评论、live2d与音乐盒！"></a>开放评论、live2d与音乐盒！</h1><h2 id="音乐盒基础设置"><a href="#音乐盒基础设置" class="headerlink" title="音乐盒基础设置"></a>音乐盒基础设置</h2><p><strong>‘.\source_data\fluid_config.yml’</strong></p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">aplayer:  # 音乐播放器<br>  enable: true<br>  order: <span class="hljs-string">&#x27;random&#x27;</span>  # 播放顺序，可选值: <span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-string">&#x27;random&#x27;</span><br>  song<span class="hljs-variable">s:</span>  # 歌曲列表，必须传入下列各参数，其中 url 与 cover 在本地需存于 <span class="hljs-keyword">source</span> 目录，更多参数见文档：http<span class="hljs-variable">s:</span>//aplayer.js.org/#/zh-Hans/?id=%E5%<span class="hljs-number">8</span>F%<span class="hljs-number">82</span>%E6%<span class="hljs-number">95</span>%B0<br>    - &#123; name: <span class="hljs-string">&#x27;The Sound of a Lost Generation&#x27;</span>, artis<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;Blitz Kids&#x27;</span>, ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;/music/Blitz Kids - The Sound of a Lost Generation.mp3&#x27;</span>, cover: <span class="hljs-string">&#x27;/music/The Sound of a Lost Generation.jpg&#x27;</span> &#125;<br>    - &#123; name: <span class="hljs-string">&#x27;シャナ&#x27;</span>, artis<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;Guiano,IA&#x27;</span>, ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;/music/Guiano,IA - シャナ.mp3&#x27;</span>, cover: <span class="hljs-string">&#x27;/music/シャナ.jpg&#x27;</span> &#125;<br></code></pre></div></td></tr></table></figure><h2 id="音乐盒自动播放"><a href="#音乐盒自动播放" class="headerlink" title="音乐盒自动播放"></a>音乐盒自动播放</h2><p><strong>.\themes\fluid\layout_partial\plugins\aplayer.ejs</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">&lt;<span class="hljs-meta">%-</span> js_ex(theme.static_prefix.aplayer, <span class="hljs-string">&#x27;APlayer.min.js&#x27;</span>) %&gt;<br>&lt;<span class="hljs-meta">%-</span> css_ex(theme.static_prefix.aplayer, <span class="hljs-string">&#x27;APlayer.min.css&#x27;</span>) %&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">const</span> ap = <span class="hljs-keyword">new</span> APlayer(</span></span><span class="xquery">&#123;</span><br><span class="xquery">    container:<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;aplayer&#x27;</span>),</span><br><span class="xquery">    fixed:<span class="hljs-built_in"> true</span>,</span><br><span class="xquery">    autoplay:<span class="hljs-built_in"> true</span>,</span><br><span class="xquery">    loop: <span class="hljs-string">&#x27;all&#x27;</span>,</span><br><span class="xquery">    order: <span class="hljs-string">&#x27;&lt;%= theme.aplayer.order %&gt;&#x27;</span>,</span><br><span class="xquery">    preload: <span class="hljs-string">&#x27;auto&#x27;</span>,</span><br><span class="xquery">    audio: &lt;<span class="hljs-meta">%-</span> JSON.stringify(theme.aplayer.songs || []) %&gt;</span><br><span class="xquery">  &#125;</span><span class="xml">);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通知</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GablrielGraph拓扑控制图的python图像实现</title>
    <link href="/202005081806/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C/WSNessay/projects/GablrielGraph%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%9A%84python%E5%9B%BE%E5%83%8F%E5%AE%9E%E7%8E%B0/"/>
    <url>/202005081806/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C/WSNessay/projects/GablrielGraph%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%9A%84python%E5%9B%BE%E5%83%8F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p><strong>拓扑控制（topology control）</strong><br>&emsp;是一种协调节点间各自传输范围的技术，用以构建具有某些期望的全局特性（如连通性）的网络拓扑结构，同时减少节点的能耗或增加网络的传输能力。<br>&emsp;选取一种拓扑控制算法(如 RNG、GG、DG、YG、MST、DRNG、 DLMST、DLSS，TopDisc 等)，编程实现该算法并用图形显示效果。要求有执行算法前后拓扑对比图、链路数量统计对比。节点数目最少 50 个，随机分布，其他如通信半径、部署区域大小等自行选取。考虑到连通性问题，要求应用拓扑控制的初始网络为全连通网络（即每个节点与其他任意节点至少存 在一条链路，随机生成节点位置时可多试几次或增加节点密度）。</p><p><img src="https://note.youdao.com/yws/api/personal/file/22D1B9E5C9FD401C9A9C05CC1596597D?method=download&amp;shareKey=d24dc172db07ec9b71163e6928e7bf71" alt="插入图片"></p><h2 id="拓扑算法的选择与原理"><a href="#拓扑算法的选择与原理" class="headerlink" title="拓扑算法的选择与原理"></a>拓扑算法的选择与原理</h2><p><strong>1.    UDG(Unit Disk Graph)</strong></p><p><strong>定义：</strong>假定网络中N个节点构成了二维平面中的节点V所有节点都以最大功率工作时所产生的拓扑成为UDG<br><strong>思路：</strong>每个节点遍历其余结点坐标，计算彼此距离(功率)，属于范围内的节点连接成边缘，将边缘加入列表</p><script type="math/tex; mode=display">u,v\in V dis(u,v)\leq D_{max}(u)</script><p><strong>2.    GG(Gabriel Graph)</strong></p><p><strong>定义：</strong>任意两个节点u和v，以边u、v为直径的圆内没有其他节点<br><strong>思路：</strong>每个节点遍历其余结点坐标，计算彼此距离(功率)，判断是否属于范围内，且彼此连接圆内只有目标节点一个，成功便将边缘加入列表</p><script type="math/tex; mode=display">w,u,v\in V dis(u,v)\leq D_{max}(u) \quad \forall w\ \neq u,v: d^2(u,v)<[d^2(u,w)+d^2(v,w)]</script><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><p><strong>config.py：</strong>定义了随机初始化节点函数<br><strong>util.py：</strong>定义了针对单个节点，利用udg或gg思想，遍历其余所有节点返回生成的边缘列表有关方法<br><strong>gg.py：</strong>gg图演示程序</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="gg-py"><a href="#gg-py" class="headerlink" title="gg.py"></a>gg.py</h3><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix"><span class="hljs-comment">#初始化节点</span><br><span class="hljs-attr">nodes</span> = node_init(<span class="hljs-attr">_num=50,_rad_max=300)</span><br><span class="hljs-comment"># edge1=edge_init(0,nodes[0],nodes[1])#初始化一条边</span><br><span class="hljs-comment">#计算所有边（gg）</span><br><span class="hljs-attr">edges=[]</span><br>for i <span class="hljs-keyword">in</span> range(len(nodes)):<br>    edges.append(trav2gg(nodes[i],nodes))<br><span class="hljs-comment">#将边缘对象转化为画图所需的边</span><br>for i <span class="hljs-keyword">in</span> edges:<br>    for j <span class="hljs-keyword">in</span> i:<br>        edgelist.append((j.node1_id,j.node2_id))<br><span class="hljs-comment">#画点</span><br><span class="hljs-attr">g_gg</span> = nx.Graph()<br>g_gg.add_nodes_from([i for i <span class="hljs-keyword">in</span> range(len(nodes))])<br><span class="hljs-attr">pos</span> = &#123;i:(nodes[i].x,nodes[i].y) for i <span class="hljs-keyword">in</span> range(len(nodes))&#125;<br>nx.draw_networkx_nodes(g_gg,<span class="hljs-attr">pos=pos,</span><br>    <span class="hljs-attr">node_color</span> = &#x27;black&#x27;,<span class="hljs-attr">node_size</span> = <span class="hljs-number">20</span>)<br>nx.draw_networkx_edges(g_gg,<span class="hljs-attr">pos</span> = pos,<span class="hljs-attr">edgelist=edgelist,</span><br>    <span class="hljs-attr">edge_color=&#x27;r&#x27;,width</span> =<span class="hljs-number">0.8</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><h3 id="config-py"><a href="#config-py" class="headerlink" title="config.py"></a>config.py</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#生成随机位置<br>def position<span class="hljs-constructor">_random(<span class="hljs-params">_wid</span>, <span class="hljs-params">_hei</span>)</span>:<br>    x = random.randint(<span class="hljs-number">0</span>, _wid)<br>    y = random.randint(<span class="hljs-number">0</span>, _hei)<br>    return <span class="hljs-literal">[<span class="hljs-identifier">x</span>, <span class="hljs-identifier">y</span>]</span><br>#生成指定数量节点<br>def node<span class="hljs-constructor">_init(<span class="hljs-params">_a</span>=[<span class="hljs-params">wid</span>, <span class="hljs-params">hei</span>], <span class="hljs-params">_rad_max</span>=<span class="hljs-params">rad_max</span>, <span class="hljs-params">_num</span>=<span class="hljs-params">node_num</span>)</span>:<br>    nodes = <span class="hljs-literal">[]</span><br>    positions = <span class="hljs-literal">[]</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(_num):<br>        pos = position<span class="hljs-constructor">_random(<span class="hljs-params">_a</span>[0], <span class="hljs-params">_a</span>[1])</span><br>        <span class="hljs-keyword">if</span> pos not <span class="hljs-keyword">in</span> positions:<br>            positions.append(pos)<br>            nodes.append(e.<span class="hljs-constructor">Node(<span class="hljs-params">i</span>, <span class="hljs-params">pos</span>[0], <span class="hljs-params">pos</span>[1], <span class="hljs-params">_rad_max</span>)</span>)<br>    return nodes<br></code></pre></div></td></tr></table></figure><h3 id="util-py"><a href="#util-py" class="headerlink" title="util.py"></a>util.py</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">def trav2gg(_node, _node_list):<br>    edge_list = <span class="hljs-literal">[]</span>#存放遍历后该节点的边界<br>    node_list=<span class="hljs-literal">[]</span>#存放遍历后的该节点的邻居节点<br>    #UDG算法计算该节点的全部邻居节点以及边缘<br>    <span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> enumerate(_node_list):<br>        _edge = edge<span class="hljs-constructor">_init(&#x27;<span class="hljs-params">edge</span>&#x27;, <span class="hljs-params">_node</span>, <span class="hljs-params">value</span>)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_edge</span>.</span></span>length &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_node</span>.</span></span>r <span class="hljs-keyword">and</span> value.id != <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_node</span>.</span></span>id:<br>            edge_list.append(_edge)<br>            node_list.append(value)<br>    # GG算法计算该在UDG子集中的边界<br>    edge_list_out=<span class="hljs-literal">[]</span>#存放gg算法该节点的边界<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> edge_list:<br>        # 判断是否只有目标节点一个，在其与源节点两点所成的圆上<br>        <span class="hljs-keyword">if</span> is<span class="hljs-constructor">_onemin(<span class="hljs-params">_node</span>,<span class="hljs-params">_node_list</span>[<span class="hljs-params">i</span>.<span class="hljs-params">node2_id</span>],<span class="hljs-params">node_list</span>)</span>:<br>            edge_list_out.append(i)<br>    return edge_list_out<br></code></pre></div></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="目标范围：1000-1000，节点数量：50，最大通信功率-距离-：250"><a href="#目标范围：1000-1000，节点数量：50，最大通信功率-距离-：250" class="headerlink" title="目标范围：1000*1000，节点数量：50，最大通信功率(距离)：250"></a>目标范围：1000*1000，节点数量：50，最大通信功率(距离)：250</h3><style>.box{width:300px; text-align:center; font-szie:18px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/CF1C9980F43A41C59752BDB836F8A7CE?method=download&shareKey=b8dba991e1fb41b51c2d76eaed103074" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/5046419210C34BF491DC651301DC0780?method=download&shareKey=fd1e6dead5d79855ca0f427514c4f179">      UDG      </div>    </td>  </tr></table><h3 id="目标范围：1000-1000，节点数量：100，最大通信功率-距离-：200"><a href="#目标范围：1000-1000，节点数量：100，最大通信功率-距离-：200" class="headerlink" title="目标范围：1000*1000，节点数量：100，最大通信功率(距离)：200"></a>目标范围：1000*1000，节点数量：100，最大通信功率(距离)：200</h3><style>.box{width:300px; text-align:center; font-szie:26px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/53849627B88A4BDFB889FB3390847843?method=download&shareKey=447dd4faf1ed0d9b835b23c12b19599b" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/139F559E69134EC49B5D9078A933CB51?method=download&shareKey=5cd3d9230e587555291d1aa1e1d1564e">      UDG      </div>    </td>  </tr></table><h3 id="目标范围：1000-1000，节点数量：20，最大通信功率-距离-：900"><a href="#目标范围：1000-1000，节点数量：20，最大通信功率-距离-：900" class="headerlink" title="目标范围：1000*1000，节点数量：20，最大通信功率(距离)：900"></a>目标范围：1000*1000，节点数量：20，最大通信功率(距离)：900</h3><style>.box{width:300px; text-align:center; font-szie:18px;}.box img {width:100%;}</style><table class="box">  <tr>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/765C8073EA0E49DDBE692B100D041226?method=download&shareKey=4105687de2fad2f9301d84483150f0e9" >      GG      </div>    </td>    <td>      <div class="box">      <img src="https://note.youdao.com/yws/api/personal/file/EAE685E724904D8A92C6439E4E03F474?method=download&shareKey=73f041cf1dde57283bfba26879d50c35">      UDG      </div>    </td>  </tr></table><p><a href="https://hexo.io/docs/one-command-deployment.html">Markdown数学公式语法1</a></p><p><a href="https://hexo.io/docs/one-command-deployment.html">Markdown数学公式语法2</a></p><p><a href="https://www.zybuluo.com/codeep/note/163962">Markdown数学公式语法3</a></p><p><a href="https://blog.csdn.net/qq_43401552/article/details/104805466">Hexo+markdown之引用图片方法汇集</a></p><p><a href="https://blog.csdn.net/weixin_41010198/article/details/86639739">Markdwon中多张图片的并排显示（Mardown的灵动使用技巧）</a></p>]]></content>
    
    
    <categories>
      
      <category>项目与设计</category>
      
      <category>实验</category>
      
      <category>WSN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/1/"/>
    <url>/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/1/</url>
    
    <content type="html"><![CDATA[<p> 段落没有限制文字，那就直接上文字？<br> <span id="more"></span><br> 下面是相关不出现在首页的内容<br>预览草稿shell命令<br>hexo s —draft</p><h2 id="以下是引用块"><a href="#以下是引用块" class="headerlink" title="以下是引用块"></a>以下是引用块</h2><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><h2 id="以下是代码块"><a href="#以下是代码块" class="headerlink" title="以下是代码块"></a>以下是代码块</h2><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);</span><br></code></pre></div></td></tr></table></figure><h2 id="这里插入图片"><a href="#这里插入图片" class="headerlink" title="这里插入图片"></a>这里插入图片</h2><p><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&amp;shareKey=b7cf3fddbacf87de023fb7230df6a0e4" alt="插入图片"></p><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&shareKey=b7cf3fddbacf87de023fb7230df6a0e4" class="[123]" title="title text" alt="alt text"><img src="https://note.youdao.com/yws/api/personal/file/25510E80090540C4A26AF222E9579473?method=download&shareKey=b7cf3fddbacf87de023fb7230df6a0e4" alt="" width="100px" height="100px"><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://hexo.io/docs/one-command-deployment.html">链接</a></p><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h2><div style="position: relative; width:100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?aid=62606177&cid=108789598&page=1&&high_quality=1" scrolling="no" border="0" framespacing="0" allowfullscreen="true" framespacing="0" style="position: absolute; width: 100%;height: 100%; left: 0; top: 0;"></iframe></div><h2 id="页面内容跳转"><a href="#页面内容跳转" class="headerlink" title="页面内容跳转"></a>页面内容跳转</h2><p>要利用markdown语法实现页内跳转，首先在跳转目的地创建一个html标签<span id="jump">跳转到的地方</span>，其后在点击跳转处创建markdown超链接<a href="#jump">点击跳转</a>。注意：id值需前后保持一致，区分大小写。最后，在需要跳转时按住Ctrl键，再点击超链接文字即可实现页内跳转。</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p><script type="math/tex">1u,v\in V dis(u,v)\leq D_{max}(u)</script> [comment]:行间公式<br>$ 2u,v\in V dis(u,v)\leq D_{max}(u) $ [comment]:行内公式</p><h2 id="隐藏页面链接"><a href="#隐藏页面链接" class="headerlink" title="隐藏页面链接"></a>隐藏页面链接</h2><p><a href="../../../page/">隐藏链接</a></p>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/hello-world/"/>
    <url>/202003070143/%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8Cstart/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>实用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
