

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="12 模式匹配​        前一章提到过，Scala的内建控制结构里有一个match表达式，用于模式匹配或偏函数。 ​    模式匹配是Scala中一个强大的高级功能，模式匹配在Chisel中被用于硬件的参数化配置，可以快速地裁剪、配置不同规模的硬件电路。所以，尽管模式匹配不是很容易就能掌握并熟练运用，但是学会它将会对软、硬件编程都大有帮助。 ​        本章介绍了功能强大的模式匹配，尽">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala（二）：进阶篇">
<meta property="og:url" content="http://yoursite.com/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="12 模式匹配​        前一章提到过，Scala的内建控制结构里有一个match表达式，用于模式匹配或偏函数。 ​    模式匹配是Scala中一个强大的高级功能，模式匹配在Chisel中被用于硬件的参数化配置，可以快速地裁剪、配置不同规模的硬件电路。所以，尽管模式匹配不是很容易就能掌握并熟练运用，但是学会它将会对软、硬件编程都大有帮助。 ​        本章介绍了功能强大的模式匹配，尽">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/2022-3-4-scala/96717167_p0-16468039212541.jpg">
<meta property="article:published_time" content="2022-03-04T09:17:00.000Z">
<meta property="article:modified_time" content="2022-03-09T11:14:23.770Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/202203041717/CS/Scalaessay/cs/scala/2022-3-4-scala/2022-3-4-scala/96717167_p0-16468039212541.jpg">
  
  <title>Scala（二）：进阶篇 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96717167_p0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Scala（二）：进阶篇">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-04 17:17" pubdate>
        2022年3月4日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      41k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      129 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Scala（二）：进阶篇</h1>
            
            <div class="markdown-body">
              <h1 id="12-模式匹配"><a href="#12-模式匹配" class="headerlink" title="12 模式匹配"></a>12 模式匹配</h1><p>​        前一章提到过，Scala的内建控制结构里有一个<strong>match表达式，用于模式匹配或偏函数。</strong></p>
<p>​    模式匹配是Scala中一个强大的高级功能，<strong>模式匹配在Chisel中被用于硬件的参数化配置，可以快速地裁剪、配置不同规模的硬件电路。</strong>所以，尽管模式匹配不是很容易就能掌握并熟练运用，但是学会它将会对软、硬件编程都大有帮助。</p>
<p>​        本章介绍了功能强大的模式匹配，尽管概念比较容易理解，但是要熟练运用则比较难。</p>
<p>​        <del>偏函数，在Chisel里也会用到。</del></p>
<p>​        <del>在实际编写硬件时，模式匹配是用不上的。</del></p>
<h2 id="12-1-样例类与样例对象"><a href="#12-1-样例类与样例对象" class="headerlink" title="12.1 样例类与样例对象"></a>12.1 样例类与样例对象</h2><p><strong>（1）样例类：</strong></p>
<p>​        定义类时，若在最前面加上关键字“case”，那么这个类就被称为样例类。基本形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> 类名<br></code></pre></div></td></tr></table></figure>
<p>Scala的编译器会自动对样例类添加一些语法便利：</p>
<ul>
<li><p><strong>添加与类同名的工厂方法</strong>，使得可<strong>以通过<code>类名(参数)</code>来构造对象，而不需要<code>new 类名(参数)</code></strong>，<font color=gray>使得代码看起来更加自然</font></p>
</li>
<li><p><strong>参数列表的每个参数都隐式地获得了一个val前缀</strong>。也就是说，类内部会自动添加与参数同名的公有字段。</p>
</li>
<li><p><strong>自动实现toString、hashCode和equals方法</strong>，<font color=gray>会自动以“自然”的方式实现toString、hashCode和equals方法</font></p>
</li>
<li><p><strong>添加一个好用的copy方法，用于构造与旧对象只有某些字段不同的新对象</strong>，只需通过传入具名参数和缺省参数实现。比如objectA.copy(arg0 = 10)会创建一个只有arg0为10、其余成员与objectA完全一样的新对象。</p>
</li>
</ul>
<p><strong>（2）样例类定义示例：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义了一个样例类</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span></span>) </span><br><span class="hljs-comment">//defined class Students</span><br><br><span class="hljs-comment">//便利1，很方便的实例化</span><br>scala&gt; <span class="hljs-keyword">val</span> stu1 = <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">//stu1: Students = Students(Alice,100)</span><br><br><span class="hljs-comment">//便利2，形参获得val成为内部成员</span><br>scala&gt; stu1.name<br><span class="hljs-comment">//res0: String = Alice</span><br><br><span class="hljs-comment">//便利2</span><br>scala&gt; stu1.score<br><span class="hljs-comment">//res1: Int = 100</span><br><br><span class="hljs-comment">//便利4，很好用的copy</span><br>scala&gt; <span class="hljs-keyword">val</span> stu2 = stu1.copy()<br><span class="hljs-comment">//stu2: Students = Students(Alice,100)</span><br><span class="hljs-comment">//完全一样</span><br>scala&gt; stu2 == stu1<br><span class="hljs-comment">//res2: Boolean = true</span><br><br><span class="hljs-comment">//便利4</span><br>scala&gt; <span class="hljs-keyword">val</span> stu3 = stu1.copy(name = <span class="hljs-string">&quot;Bob&quot;</span>)<br><span class="hljs-comment">//stu3: Students = Students(Bob,100)</span><br><span class="hljs-comment">//完全一样</span><br>scala&gt; stu3 == stu1<br><span class="hljs-comment">//res3: Boolean = false</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）样例类的好处</strong></p>
<p>​        样例类最大的好处是支持模式匹配。相关内容会在本章接下来的内容中介绍。</p>
<p><strong>（4）样例类与样例对象的其他特性</strong></p>
<p>​        <strong>样例对象与样例类很像，</strong>也是定义单例对象时在最前面加上关键字<code>case</code>。</p>
<p>​        <strong>样例对象和普通的单例对象一样，没有参数和构造方法，也是一个具体的实例，但是样例对象的实际形式更接近样例类</strong></p>
<p>​        <strong>前面说的样例类的特性，样例对象也具备</strong>，例如可用于模式匹配。从编译后的结果来比较，样例对象与一个无参、无构造方法的样例类是一样的。</p>
<h2 id="12-2-模式匹配"><a href="#12-2-模式匹配" class="headerlink" title="12.2 模式匹配"></a>12.2 模式匹配</h2><p><strong>形式：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">选择器 <span class="hljs-keyword">match</span> &#123; 可选分支 &#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>选择器</strong>是待匹配的对象，</li>
<li><strong>花括号里是一系列以关键字<code>case</code>开头的“可选分支”</strong><ul>
<li><strong>每个可选分支</strong>都包括一个模式以及一个或多个表达式<ul>
<li>如果模式匹配成功，就执行相应的表达式，最后返回结果。可选分支定义如下： </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> 模式 =&gt; 表达式<br></code></pre></div></td></tr></table></figure>
<p><strong>match表达式/匹配模式与Java的switch语法的区别</strong>：</p>
<ul>
<li><strong>match是一个表达式，它可以返回一个值</strong></li>
<li>可选分支<strong>存在优先级</strong>，其<strong>匹配顺序也就是代码编写时的顺序</strong>，<font color=grey>并且只有第一个匹配成功的模式会被选中，然后对它的表达式求值并返回。如果表达式有多个，则按顺序执行直到下个case语句为止，并不会贯穿执行到末尾的case语句，所以多个表达式也可以不用花括号包起来</font></li>
<li><strong>要确保至少有一个模式匹配成功，否则会抛出MatchError异常</strong> </li>
</ul>
<h2 id="12-3-模式种类"><a href="#12-3-模式种类" class="headerlink" title="12.3 模式种类"></a>12.3 模式种类</h2><p>​        多样的模式种类，是模式匹配强大的原因</p>
<p><strong>主要种类有以下七种：</strong></p>
<ul>
<li>通配模式</li>
<li>常量模式</li>
<li>变量模式</li>
<li>构造方法模式</li>
<li>序列模式</li>
<li>元组模式</li>
<li>带类型的模式</li>
<li>变量绑定</li>
</ul>
<h3 id="（1）通配模式"><a href="#（1）通配模式" class="headerlink" title="（1）通配模式"></a>（1）通配模式</h3><p><strong>定义</strong>：</p>
<ul>
<li>用下划线<code>_</code>表示，匹配任何对象</li>
</ul>
<p><strong>使用位置</strong>：</p>
<ul>
<li>末尾<strong>用于缺省、捕获所有可选路径</strong>，相当于switch的default。</li>
<li>如果某个模式需要<strong>忽略局部特性</strong>，也可以用下划线代替。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//忽略局部特性的一个例子</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, _) =&gt; <span class="hljs-literal">true</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>         |  &#125;<br>test: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">Boolean</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment">//res0: Boolean = true</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment">//res1: Boolean = true</span><br><br>scala&gt; test(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment">//res2: Boolean = false</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>上述例子中，第一个case就是用下划线忽略了模式的局部特性：表明只有含有三个元素，且前两个为1和2、第三个元素任意的列表才能匹配该模式。不符合第一个case的对象，都会被通配模式捕获。</p>
</blockquote>
<hr>
<p><strong>特别注意：</strong></p>
<p>​        越具体的模式，可匹配的范围就越小；反之，越模糊的模式，覆盖的范围越大。<strong>具体的模式，应该定义在模糊的模式前面，</strong>否则如果具体模式的作用范围是模糊模式的子集，那写在后面的具体模式就<strong>永远不会被执行</strong>。像通配模式这种全覆盖的模式，一定要写在最后。</p>
<h3 id="（2）常量模式"><a href="#（2）常量模式" class="headerlink" title="（2）常量模式"></a>（2）常量模式</h3><p><strong>定义：</strong></p>
<ul>
<li>用一个常量、字面量作为模式，使得只能匹配自身</li>
</ul>
<p>​        任何<strong>字面量</strong>、任何<strong>val类型的变量或单例对象（样例对象也是一样的）</strong>可以作为常量模式，<strong>（<code>Nil</code>这个单例对象能且仅能匹配空列表）</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span> =&gt; <span class="hljs-string">&quot;five&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span> =&gt; <span class="hljs-string">&quot;truth&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> =&gt; <span class="hljs-string">&quot;hi!&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-string">&quot;the empty list&quot;</span>  <span class="hljs-comment">//用Nil这个单例对象匹配空列表</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;something else&quot;</span>     <br>         |  &#125;<br><span class="hljs-comment">//test2: (x: Any)String</span><br><br>scala&gt; test2(<span class="hljs-type">List</span>())<br><span class="hljs-comment">//res0: String = the empty list</span><br><br>scala&gt; test2(<span class="hljs-number">5</span>)<br><span class="hljs-comment">//res1: String = five</span><br><br>scala&gt; test2(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//res2: String = truth</span><br><br>scala&gt; test2(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">//res3: String = hi!</span><br><br>scala&gt; test2(<span class="hljs-number">233</span>)<br><span class="hljs-comment">//res4: String = something else</span><br></code></pre></div></td></tr></table></figure>
<h3 id="（3）变量模式"><a href="#（3）变量模式" class="headerlink" title="（3）变量模式"></a>（3）变量模式</h3><p><strong>定义：</strong></p>
<ul>
<li>变量模式一方面与通配模式一样，<strong>一个变量名，它可以匹配任何对象</strong></li>
<li>变量模式还会<strong>把该变量名与匹配成功的输入对象绑定</strong>，在表达式中可以通过这个变量名来进一步操作输入对象。变量模式还可以放在最后面代替通配模式。<strong>（可以理解为能当变量调用的通配符）</strong>例如： </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |     <span class="hljs-keyword">case</span> somethingElse =&gt; <span class="hljs-string">&quot;Not Zero: &quot;</span> + somethingElse<br>         |  &#125;<br><span class="hljs-comment">//test3: (x: Any)String</span><br><br>scala&gt; test3(<span class="hljs-number">0</span>) <span class="hljs-comment">//匹配了常量0</span><br><span class="hljs-comment">//res0: String = Zero!</span><br><br>scala&gt; test3(<span class="hljs-type">List</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">//变量匹配了List(0)</span><br><span class="hljs-comment">//res1: String = Not Zero: List(0)</span><br></code></pre></div></td></tr></table></figure>
<p>​        <strong>与通配模式一样，变量模式的后面不能添加别的模式，否则编译器会警告无法到达变量模式后面的代码。</strong>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> somethingElse =&gt; <span class="hljs-string">&quot;Not Zero: &quot;</span> + somethingElse<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//&lt;console&gt;:12: warning: patterns after a variable pattern cannot match (SLS 8.1.1)</span><br><span class="hljs-comment">//         case somethingElse =&gt; &quot;Not Zero: &quot; + somethingElse</span><br><span class="hljs-comment">//              ^</span><br><span class="hljs-comment">//&lt;console&gt;:13: warning: unreachable code due to variable pattern &#x27;somethingElse&#x27; on line //12</span><br><span class="hljs-comment">//         case 0 =&gt; &quot;Zero!&quot;</span><br><span class="hljs-comment">//                   ^</span><br><span class="hljs-comment">//&lt;console&gt;:13: warning: unreachable code</span><br><span class="hljs-comment">//         case 0 =&gt; &quot;Zero!&quot;</span><br><span class="hljs-comment">//                   ^</span><br><br>test3: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">String</span><br></code></pre></div></td></tr></table></figure>
<p><strong>区分常量和变量的规则</strong>：        </p>
<p>​        <strong>常量模式有时候看上去也是一个变量名</strong>，比如“Nil”就是引用空列表这个常量模式。</p>
<p>​        Scala有一个简单的词法区分规则：</p>
<ul>
<li><p><strong>小写字母开头的简单名称会被当做变量模式</strong>，其他引用都是常量模式。<strong>即使以小写字母开头的简单名称是某个常量的别名，也会被当成变量模式。</strong></p>
<p>如果想绕开这个规则，有两种方法：</p>
</li>
<li><p>如果常量是某个对象的字段，可以加上限定词如this.a或object.a等来表示这是一个常量。</p>
</li>
<li><p>用反引号把名称包起来，编译器就会把它解读成常量，这也是绕开关键字与自定义标识符冲突的方法。例如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> somethingElse = <span class="hljs-number">1</span><br>somethingElse: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> `somethingElse` =&gt; <span class="hljs-string">&quot;A constant!&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;Zero!&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something else!&quot;</span><br>         |  &#125;<br>test4: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">String</span><br><br>scala&gt; test4(somethingElse)<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">A</span> constant!<br></code></pre></div></td></tr></table></figure>
<h3 id="（4）构造方法模式-样例类"><a href="#（4）构造方法模式-样例类" class="headerlink" title="（4）构造方法模式(样例类)"></a>（4）构造方法模式(样例类)</h3><p><strong>定义：</strong></p>
<ul>
<li>把<strong>样例类的构造方法作为模式</strong>，其形式为<code>名称(模式)</code>，即需要小括号</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>（假设这里的“名称”指定的是<strong>一个样例类的名字</strong>）那么该模式将<strong>首先检查待匹配的对象是不是以这个名称命名的样例类的实例</strong>，然后<strong>再检查待匹配的对象的构造方法参数是不是匹配括号里的“模式”</strong></li>
<li><strong>Scala的模式支持深度匹配，</strong>也就是说，<strong>括号里的模式可以是任何一种模式</strong>，包括构造方法模式。嵌套的构造方法模式会进一步展开匹配。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义样例类A</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-comment">//defined class A</span><br><br><span class="hljs-comment">//定义样例类B</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">x: <span class="hljs-type">String</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">A</span></span>)</span><br><span class="hljs-comment">//defined class B</span><br><br><span class="hljs-comment">//构造方法模式匹配B构造参数，同时深度匹配A</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test5</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, e, <span class="hljs-type">A</span>(<span class="hljs-number">10</span>)) =&gt; e + <span class="hljs-number">1</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt;<br>         |  &#125;<br><span class="hljs-comment">//test5: (x: Any)AnyVal</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>“abc”是常量模式，只能匹配字符串“abc”</p>
<p>e是变量模式，绑定B的第二个构造参数，然后在表达式里加1并返回</p>
<p>A(10)是构造方法模式，B的第三个参数必须是以10为参数构造的A的对象</p>
</blockquote>
<p>上述构造方法模式的实际匹配：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-type">A</span>(<span class="hljs-number">10</span>))<br><span class="hljs-comment">//a: B = B(abc,1,A(10))</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-type">B</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-type">A</span>(<span class="hljs-number">1</span>))<br><span class="hljs-comment">//b: B = B(abc,1,A(1))</span><br><br>scala&gt; test5(a)<br><span class="hljs-comment">//res0: AnyVal = 2</span><br><br>scala&gt; test5(b)<br><span class="hljs-comment">//res1: AnyVal = ()</span><br></code></pre></div></td></tr></table></figure>
<h3 id="（5）-序列模式-List或Array"><a href="#（5）-序列模式-List或Array" class="headerlink" title="（5） 序列模式(List或Array)"></a>（5） 序列模式(List或Array)</h3><p><strong>定义：</strong></p>
<ul>
<li>序列类型也可以用于模式匹配，比如List或Array。<ul>
<li>下划线<code>_</code>或变量模式可以<strong>指出不关心的元素</strong></li>
<li>把<code>_*</code>放在最后可以<strong>匹配任意元素个数</strong>。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test6</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, _*) =&gt; <span class="hljs-string">&quot;OK!&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Oops!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//test6: (x: Any)String</span><br><br>scala&gt; test6(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment">//res0: String = OK!</span><br><br>scala&gt; test6(<span class="hljs-number">1</span>)<br><span class="hljs-comment">//res1: String = Oops!</span><br></code></pre></div></td></tr></table></figure>
<h3 id="（6）元组模式-a-b-c-…"><a href="#（6）元组模式-a-b-c-…" class="headerlink" title="（6）元组模式(a,b,c,…)"></a>（6）元组模式(a,b,c,…)</h3><p><strong>定义：</strong></p>
<ul>
<li>元组也可以用于模式匹配</li>
<li>在圆括号里可以包含任意模式，<strong>即通过元组匹配多个其他模式</strong><ul>
<li>形如(a, b, c)的模式可以匹配任意的三元组，注意<strong>里面是三个变量模式，不是三个字母常量。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test7</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> (<span class="hljs-number">1</span>, e, <span class="hljs-string">&quot;OK&quot;</span>) =&gt; <span class="hljs-string">&quot;OK, e = &quot;</span> + e<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Oops!&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//test7: (x: Any)String</span><br><br>scala&gt; test7(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br><span class="hljs-comment">//res0: String = OK, e = 10</span><br></code></pre></div></td></tr></table></figure>
<h3 id="（7）带类型的模式"><a href="#（7）带类型的模式" class="headerlink" title="（7）带类型的模式"></a>（7）带类型的模式</h3><p><strong>定义：</strong>模式定义时，也可以<strong>声明具体的数据类型</strong>。</p>
<p><strong>用途：</strong>用带类型的模式可以<strong>代替类型测试和类型转换</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test8</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; s.length<br>         |     <span class="hljs-keyword">case</span> m: <span class="hljs-type">Map</span>[_, _] =&gt; m.size<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">-1</span><br>         |  &#125;<br><span class="hljs-comment">//test8: (x: Any)Int</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>带类型的变量模式<code>s: String</code><strong>将匹配每个非空的String实例</strong></p>
</li>
<li><p><code>m: Map[_, _]</code><strong>将匹配任意映射实例</strong>。</p>
</li>
</ul>
<p><strong>调用变量时候：</strong>入参x的类型是Any，而s的类型是String，所以表达式里可以写s.length而不能写x.length，因为Any类没有叫length的成员。m.size同理。</p>
<p><strong>无法进行深度指明：</strong></p>
<p>​        在带类型的模式中，虽然可以像上个例子那样指明对象类型为笼统的映射“Map[<em>, </em>]”，但是无法更进一步指明映射的键-值分别是什么类型。前面曾说过，这是因为Scala采用了擦除式的泛型，即运行时并不会保留类型参数的信息，所以程序在运行时无法判断某个映射的键-值具体是哪两种类型。唯一例外的是数组，因为数组的元素类型跟数组保存在一起。</p>
<h3 id="（8）变量绑定-除变量模式外的添加变量手段"><a href="#（8）变量绑定-除变量模式外的添加变量手段" class="headerlink" title="（8）变量绑定(除变量模式外的添加变量手段)"></a>（8）变量绑定(除变量模式外的添加变量手段)</h3><p><strong>用途：</strong>除了变量模式可以使用变量外，还可以对任何其他模式添加变量，构成变量绑定模式。</p>
<p><strong>定义：</strong></p>
<ul>
<li>其形式为<code>变量名 @ 模式</code>。</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>变量绑定模式执行模式匹配的规则与原本模式一样，但是<strong>在匹配成功后会把输入对象的相应部分与添加的变量进行绑定</strong>，通过该变量就能<strong>在表达式中进行额外的操作</strong>。例如下面为一个常量模式绑定了变量e：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test9</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, e @ <span class="hljs-number">3</span>) =&gt; e<br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span><br>         |  &#125;<br><span class="hljs-comment">//test9: (x: Any)Int</span><br><br>scala&gt; test9(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">//res0: Int = 3</span><br></code></pre></div></td></tr></table></figure>
<h2 id="12-4-守卫模式"><a href="#12-4-守卫模式" class="headerlink" title="12.4 守卫模式"></a>12.4 守卫模式</h2><blockquote>
<p>​        模式守卫出现在模式之后，是一条用if开头的语句。模式守卫可以是任意的布尔表达式，通常会引用到模式中的变量。如果存在模式守卫，那么必须模式守卫返回true，模式匹配才算成功。</p>
<p>​        Scala要求模式都是线性的，即一个模式内的两个变量不能同名。如果想指定模式的两个部分要相同，不是定义两个同名的变量，而是通过模式守卫来解决。</p>
</blockquote>
<p><strong>形式：</strong></p>
<ul>
<li>case后面加个If</li>
<li>通常引用到模式中的变量</li>
<li>返回true才算成功</li>
</ul>
<p><strong>通俗解释：</strong></p>
<p>​        用于匹配成功后的进一步限定</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 只匹配正整数</span><br><span class="hljs-keyword">case</span> i: <span class="hljs-type">Int</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> =&gt; ???  <br><span class="hljs-comment">// 只匹配以字母&#x27;a&#x27;开头的字符串</span><br><span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> <span class="hljs-keyword">if</span> s(<span class="hljs-number">0</span>) == &#x27;a&#x27; =&gt; ???  <br><span class="hljs-comment">// 只匹配两个元素相等的二元组</span><br><span class="hljs-keyword">case</span> (x, y) <span class="hljs-keyword">if</span> x == y =&gt; ??? <br></code></pre></div></td></tr></table></figure>
<h2 id="12-5-密封类Sealed"><a href="#12-5-密封类Sealed" class="headerlink" title="12.5 密封类Sealed"></a>12.5 密封类Sealed</h2><p><strong>形式：</strong></p>
<ul>
<li><code>sealed class</code></li>
<li>如果在“class”前面加上关键字“sealed”，那么这个类就称为密封类。</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li><strong>作用区域：</strong>密封类只能在同一个文件中定义子类，不能在文件之外被别的类继承</li>
</ul>
<blockquote>
<ul>
<li><ul>
<li>这有助于编译器检查模式匹配的完整性，因为这样确保了不会有新的模式随意出现，而只需要关心本文件内已有的样例类。所以，要使用模式匹配，最好把最顶层的基类做成密封类。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>继承自密封类的样例类做匹配：</strong>对继承自密封类的样例类做<strong>匹配</strong>，<strong>编译器会用警告信息</strong>标示出缺失的组合。<font color=grey>如果确实不需要覆盖所有组合，又不想用通配模式来避免编译器发出警告</font>，<strong>可以在选择器后面添加<code>@unchecked</code>注解</strong>，这样编译器对后续模式分支的覆盖完整性检查就会被压制。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//定义一个密封类</span><br>scala&gt; <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Var</span>(<span class="hljs-params">name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为Double</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span>(<span class="hljs-params">num: <span class="hljs-type">Double</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String, Expr</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnOp</span>(<span class="hljs-params">operator: <span class="hljs-type">String</span>, arg: <span class="hljs-type">Expr</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//定义一个继承自密封类的样例类，入参为String, Expr， Expr</span><br>scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinOp</span>(<span class="hljs-params">operator: <span class="hljs-type">String</span>, left: <span class="hljs-type">Expr</span>, right: <span class="hljs-type">Expr</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Expr</span></span><br><br><span class="hljs-comment">//匹配一个继承自密封类的样例类，结果报错</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = e <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//&lt;console&gt;:16: warning: match may not be exhaustive.</span><br><span class="hljs-comment">//It would fail on the following inputs: BinOp(_, _, _), UnOp(_, _)</span><br><span class="hljs-comment">//       def describe(e: Expr): String = e match &#123;undefined</span><br><span class="hljs-comment">//                                       ^</span><br><span class="hljs-comment">//describe: (e: Expr)String</span><br><br><span class="hljs-comment">//通过通配符匹配继承自密封类的样例类</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = e <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |     <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>  <span class="hljs-comment">// Should not happen</span><br>         |  &#125;<br><span class="hljs-comment">//describe: (e: Expr)String</span><br><br><span class="hljs-comment">//使用@unchecked，完成继承自密封类的样例类的匹配</span><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(e: <span class="hljs-type">Expr</span>): <span class="hljs-type">String</span> = (e: <span class="hljs-meta">@unchecked</span>) <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Number</span>(_) =&gt; <span class="hljs-string">&quot;a number&quot;</span><br>         |     <span class="hljs-keyword">case</span> <span class="hljs-type">Var</span>(_) =&gt; <span class="hljs-string">&quot;a variable&quot;</span><br>         |  &#125;<br><span class="hljs-comment">//describe: (e: Expr)String</span><br></code></pre></div></td></tr></table></figure>
<p>​        <strong>有关注解的内容，本教程不会讲解。需要深入了解的读者，请自行查阅资料。Chisel源码使用了注解。</strong></p>
<h2 id="12-6-可选值Option-T"><a href="#12-6-可选值Option-T" class="headerlink" title="12.6 可选值Option[T]"></a>12.6 可选值Option[T]</h2><p><strong>（1）解决的问题：</strong></p>
<p>从上面很多例子中，我们发现两个问题：</p>
<ul>
<li>一是<strong>每条case分支可能返回不同类型的值</strong>，导致函数的返回值或变量的类型不好确定，该如何把它们统一起来？</li>
<li>二是<strong>通配模式下，常常不需要返回一个值，但什么都不写又不太好</strong></li>
</ul>
<p>要解决这两个问题，Scala提供了一个新的语法——<strong>可选值Option[T]</strong></p>
<p><strong>（2）定义</strong></p>
<p><strong>定义：可选值就是类型为Option[T]的一个值</strong></p>
<ul>
<li><strong>Option</strong>：是标准库里的一个密封抽象类</li>
<li><strong>T</strong>：可以是任意的类型，例如标准类型或自定义的类（并且T是协变的，简单来说，就是如果类型T是类型U的超类，那么Option[T]也是Option[U]的超类）</li>
</ul>
<p><strong>（3）Some类和None对象</strong></p>
<ul>
<li><p>Option类有一个子类：<strong>Some类</strong></p>
<ul>
<li><p><code>Some(x)</code>可以构造一个Some的对象</p>
</li>
<li><p><strong>参数x</strong>：是一个具体的值，根据x的类型，可选值的类型会发生改变。例如，Some(10)的类型是Option[Int]，Some(“10”)的类型是Option[String]</p>
</li>
<li><p><strong>作用：</strong>由于Some对象需要一个具体的参数值，所以这部分可选值用于表示“有值”。<strong>Some(x)常作为case语句的返回值。</strong></p>
</li>
</ul>
</li>
<li><p>Option类还有一个子对象：<strong>None</strong></p>
<ul>
<li>它的类型是<code>Option[Nothing]</code>，是所有Option[T]类型的子类，代表“无值”。<strong>None常作为通配模式的返回值。</strong></li>
</ul>
</li>
</ul>
<p>​        也就是说，<strong>Option类型代表要么是一个具体的值，要么无值</strong>。Some(x)常作为case语句的返回值，而None常作为通配模式的返回值。<strong>需要注意的是，Option[T]和T是两个完全没有关系的类型，赋值时不要混淆。</strong></p>
<p>​        <strong>None对象的意义：</strong>如果没有可选值语法，要表示“无值”可能会选用null，这就必须对变量进行判空操作。在Java里，判空是一个运行时的动作，如果忘记判空，编译时并不会报错，但是<strong>在运行时可能会抛出空指针异常</strong>，进而引发严重的错误。有了可选值之后，首先从字面上提醒读者这是一个可选值，存在无值和有值两种情况；其次，最重要的是，由于Option[T]类型与T类型不一样，赋值时就可能需要先做相应的类型转换。类型转换最常见的方式就是模式匹配，<strong>在这期间可以把无值None过滤掉。如果不进行类型转换，编译器就会抛出类型错误，这样在编译期就进行判空处理进而防止运行时出现更严重的问题。</strong> </p>
<p><strong>（4）判断Some和None的方法</strong></p>
<ul>
<li><p>Option可选值提供了一个方法<strong>isDefined</strong></p>
<ul>
<li><p>如果调用对象是None，则返回false</p>
</li>
<li><p>Some对象都会返回true</p>
</li>
</ul>
</li>
<li><p>还有一个方法<strong>get</strong>，</p>
<ul>
<li>用于把Some(x)中的x返回</li>
<li>如果调用对象是None则报错</li>
</ul>
</li>
</ul>
<h2 id="12-7-另类用法——定义变量时的模式匹配"><a href="#12-7-另类用法——定义变量时的模式匹配" class="headerlink" title="12.7 另类用法——定义变量时的模式匹配"></a>12.7 另类用法——定义变量时的模式匹配</h2><blockquote>
<p>原文：对于提取器(这里不用关心提取器是什么)，可以通过“val/var 对象名(模式) = 值”的方式来使用模式匹配，常常用于定义变量。这里的“对象名”是指提取器，即某个单例对象，列表、数组、映射、元组等常用集合的伴生对象都是提取器。</p>
</blockquote>
<p>定义：提取器通过val/var来进行模式匹配，形式如下，<strong>常用于定义变量</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> 对象名(模式) = 值<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>“对象名”是指提取器</strong>，某个单例对象，列表、数组、映射、元组<strong>等常用集合的伴生对象都是提取器</strong></li>
</ul>
<p>实例代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//实现变量x,y的定义和初始化</span><br>scala&gt; <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(x, y, _*) = <span class="hljs-type">Array</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">233</span>)<br><span class="hljs-comment">//x: Int = -1</span><br><span class="hljs-comment">//y: Int = 1</span><br><br><span class="hljs-comment">//实现变量的定义和初始化</span><br>scala&gt; <span class="hljs-keyword">val</span> a :: <span class="hljs-number">10</span> :: _ = <span class="hljs-type">List</span>(<span class="hljs-number">999</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">//a: Int = 999</span><br><br>scala&gt; <span class="hljs-keyword">val</span> capitals = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;China&quot;</span> -&gt; <span class="hljs-string">&quot;Beijing&quot;</span>, <span class="hljs-string">&quot;America&quot;</span> -&gt; <span class="hljs-string">&quot;Washington&quot;</span>, <span class="hljs-string">&quot;Britain&quot;</span> -&gt; <span class="hljs-string">&quot;London&quot;</span>)<br><span class="hljs-comment">//capitals: scala.collection.immutable.Map[String,String] = Map(China -&gt; Beijing, America -&gt; Washington, Britain -&gt; London)</span><br><br>scala&gt; <span class="hljs-keyword">for</span>((country, city) &lt;- capitals)<br>         |    println(<span class="hljs-string">&quot;The capital of &quot;</span> + country + <span class="hljs-string">&quot; is &quot;</span> + city)<br><span class="hljs-comment">//The capital of China is Beijing</span><br><span class="hljs-comment">//The capital of America is Washington</span><br><span class="hljs-comment">//The capital of Britain is London</span><br><br></code></pre></div></td></tr></table></figure>
<h2 id="12-8-偏函数"><a href="#12-8-偏函数" class="headerlink" title="12.8 偏函数"></a>12.8 偏函数</h2><blockquote>
<p>​        前面说过，在Scala里，万物皆对象。函数是一等值，与整数、浮点数、字符串等等相同，所以函数也是一种对象。既然函数也是一个对象，那么必然属于某一种类型。为了标记函数的类型，Scala提供了一系列特质：Function0、Function1、Function2……Function22来表示参数为0、1、2……22个的函数。与元组很像，因此函数的参数最多只能有22个。当然也可以自定义含有更多参数的FunctionX，但是Scala标准库没有提供，也没有必要。</p>
</blockquote>
<p>还有一个特殊的函数特质：<strong>偏函数PartialFunction</strong></p>
<p><strong>偏函数的作用</strong>：划分一个输入参数的可行域，在可行域内对入参执行一种操作，在可行域之外对入参执行其他操作</p>
<p>偏函数要实现的两个抽象方法——<strong>apply和isDefinedAt</strong>：</p>
<ul>
<li><strong>isDefinedAt</strong>用于判断入参是否在可行域内，是的话就返回true，否则返回false</li>
<li><strong>apply</strong>是偏函数的函数体（<strong>隐式调用</strong>），用于对入参执行操作。使用偏函数之前，应该先用isDefinedAt判断入参是否合法，否则可能会出现异常。</li>
</ul>
<p><strong>定义偏函数</strong>：一种简便方法就是<strong>使用case语句组</strong>。广义上讲，case语句就是一个偏函数，所以才可以用于模式匹配。一个case语句就是函数的一个入口，多个case语句就有多个入口，每个case语句又可以有自己的参数列表和函数体。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> isInt1: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">String</span>] = &#123;<br>  <span class="hljs-keyword">case</span> x: <span class="hljs-type">Int</span> =&gt; x + <span class="hljs-string">&quot; is a Int.&quot;</span><br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">val</span> isInt2 = <span class="hljs-keyword">new</span> <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">String</span>] &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">Any</span>) = x.asInstanceOf[<span class="hljs-type">Int</span>] + <span class="hljs-string">&quot; is a Int.&quot;</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isDefinedAt</span></span>(x: <span class="hljs-type">Any</span>) = x.isInstanceOf[<span class="hljs-type">Int</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><p><strong>apply方法可以隐式调用</strong></p>
</li>
<li><p><strong>x.isInstanceOf[T]</strong>：判断x是不是T类型(及其超类)的对象，是的话就返回true</p>
</li>
<li><strong>x.asInstanceOf[T]</strong>：则把x转换成T类型的对象，如果不能转换则会报错</li>
<li><strong>偏函数PartialFunction[Any, Any]</strong>：是Function1[Any, Any]的子特质，因为case语句只有一个参数。[Any, Any]中的第一个Any是输入参数的类型，第二个Any是返回结果的类型。如果确实需要输入多个参数，则可以用元组、列表或数组等把多个参数变成一个集合。</li>
<li><p><strong>在用case语句定义偏函数时，前述的各种模式类型、模式守卫都可以使用。最后的通配模式可有可无，但是没有时，要保证运行不会出错</strong></p>
<p><strong>上述代码运行如下：</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; isInt1(<span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">String</span> = <span class="hljs-number">1</span> is a <span class="hljs-type">Int</span>.<br><br>scala&gt; isInt2(<span class="hljs-number">1</span>)<br>res1: <span class="hljs-type">String</span> = <span class="hljs-number">1</span> is a <span class="hljs-type">Int</span>.<br><br>scala&gt; isInt1.isDefinedAt(&#x27;<span class="hljs-number">1</span>&#x27;)<br>res2: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; isInt2.isDefinedAt(&#x27;<span class="hljs-number">1</span>&#x27;)<br>res3: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; isInt1(&#x27;<span class="hljs-number">1</span>&#x27;)<br>scala.<span class="hljs-type">MatchError</span>: <span class="hljs-number">1</span> (of <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Character</span>)</span><br>  at scala.<span class="hljs-type">PartialFunction</span>$ $anon$<span class="hljs-number">1.</span>apply(<span class="hljs-type">PartialFunction</span>.scala:<span class="hljs-number">255</span>)<br>  at scala.<span class="hljs-type">PartialFunction</span>$ $anon$<span class="hljs-number">1.</span>apply(<span class="hljs-type">PartialFunction</span>.scala:<span class="hljs-number">253</span>)<br>  at $anonfun$<span class="hljs-number">1.</span>applyOrElse(&lt;console&gt;:<span class="hljs-number">12</span>)<br>  at scala.runtime.<span class="hljs-type">AbstractPartialFunction</span>.apply(<span class="hljs-type">AbstractPartialFunction</span>.scala:<span class="hljs-number">34</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; isInt2(&#x27;<span class="hljs-number">1</span>&#x27;)<br>java.lang.<span class="hljs-type">ClassCastException</span>: java.lang.<span class="hljs-type">Character</span> cannot be cast to java.lang.<span class="hljs-type">Integer</span><br>  at scala.runtime.<span class="hljs-type">BoxesRunTime</span>.unboxToInt(<span class="hljs-type">BoxesRunTime</span>.java:<span class="hljs-number">101</span>)<br>  at $anon$<span class="hljs-number">1.</span>apply(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at $anon$<span class="hljs-number">1.</span>apply(&lt;console&gt;:<span class="hljs-number">12</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br></code></pre></div></td></tr></table></figure>
<h1 id="13-类型参数化（泛型）"><a href="#13-类型参数化（泛型）" class="headerlink" title="13 类型参数化（泛型）"></a>13 类型参数化（泛型）</h1><blockquote>
<p>​        在面向对象的编程里，提高代码复用率的一个重要方法就是泛型。泛型是一种重要的多态，称为“全类型多态”或“参数多态”。在某些容器类里，通常需要存储其它类型的对象，但是具体是什么类型，事先并不知道。倘若对每种可能包含的类型都编写一个新类，那么这完全不现实。一是工作量巨大，二是自定义类型是什么完全无法预知。例如，列表的元素可以是基本类型，也可以是自定义的类型，不可能在编写列表类时把自定义类型也考虑进去。更重要的是，这些容器类仅仅需要知道一个具体的类型，其它成员完全是一样的。既然这样，那完全可以编写一个泛型的类，它独立于成员的类型存在，然后把类型也作为一个参数，实例化生成不同的类对象。</p>
<p>​        既然与定义类型相关，那么可以泛型的自然是类和特质。</p>
</blockquote>
<p>​        在前面讲解集合时，就已经初步了解了这样的类和特质。例如，Array[T]、List[T]、Map[T, U]等等。<strong>本章将深入讲解Scala有关类型参数化的内容。</strong></p>
<p>​        本章的内容也是比较抽象、难理解。<strong>其应用在于阅读Chisel的源码，理解语言的工作机制，读懂API</strong>。如果是实<strong>际编写硬件电路用不到这些语法</strong></p>
<h2 id="13-1-深入解析，类内部的变量"><a href="#13-1-深入解析，类内部的变量" class="headerlink" title="13.1 深入解析，类内部的变量"></a>13.1 深入解析，类内部的变量</h2><blockquote>
<p>​        对于可重新赋值的字段，可执行两个基本操作：获取字段值或者设置为一个新值。在JavaBeans库里，这两个操作分别由名为“getter”和“setter”的方法来完成。Scala遵循了Java的惯例，只不过实现两个基本操作的方法的名字不一样：</p>
</blockquote>
<p>​    Scala如果在类中定义了一个var类型的字段：</p>
<ul>
<li>编译器会隐式地把这个变量限制成private[this]的访问权限</li>
<li>隐式地定义一个名为<strong>“变量名”的getter方法</strong>，默认返回变量的值</li>
<li>隐式地定义一个名为<strong>“变量名_=”的setter方法</strong>，默认接收外部传入的参数来直接赋给变量。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> = _<br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-comment">// 这个变量名“a”是随意取的，只要不与两个方法名冲突即可</span><br>  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = _<br>  <span class="hljs-comment">// getter，方法名与原来的变量名相同</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aInt</span></span>: <span class="hljs-type">Int</span> = a<br>  <span class="hljs-comment">// setter，注意名字里的“_=”</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aInt_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>字段必须被初始化<ul>
<li>这里的“=  _”，它将字段初始化为零值(具体零值是什么取决于字段的类型，数值类型的零值是0，布尔类型是false，引用类型是null)</li>
<li>也可以初始化为某个具体值。如果不初始化，就是一个抽象字段。</li>
</ul>
</li>
<li>private[this]，表明该成员只能用“this.a”或“a”来访问，句点前面不能是其它任何对象（下面一堆废话）<ul>
<li><font color=grey>实际上定义的var类型字段并不是用**private[this]**修饰的，只不过被编译器隐式转换了，所以外部仍然可以读取和修改该字段，但编译器会自动转换成对getter和setter方法的调用</font></li>
<li><font color=grey>也就是说，“对象.变量”会调用getter方法，而“对象.变量 = 新值”会调用setter方法。而且，这两个方法的权限与原本定义的var字段的权限相同，如果原本的var字段是公有的，那么这两个方法就是公有的；如果原本的var字段是受保护的，那么这两个方法也是受保护的；依此类推。当然，也可以逆向操作，自定义getter和setter方法，以及一个private[this]修饰的var类型字段，只要注意方法与字段的名字不冲突</font>

</li>
</ul>
</li>
</ul>
<p><strong>字段与方法没有必然联系：</strong></p>
<p>​        如果<strong>定义了“var a”这样的语句</strong>，那么必然有隐式的“a”和“a_=”方法，并且无法显式修改这两个方法(名字冲突)；</p>
<p>​        如果<strong>自定义了“b”和“b_=”这样的方法</strong>，却不一定要相应的var字段与之对应，这两个方法也可以操作类内的其他成员，而且仍然可以通过“object.b”和“object.b = value”来调用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = _<br>  <span class="hljs-comment">// 默认的getter和setter</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">originalValue</span></span>: <span class="hljs-type">Int</span> = a<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">originalValue_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x<br>  <span class="hljs-comment">// 自定义的getter和setter，且没有对应的var字段</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tenfoldValue</span></span>: <span class="hljs-type">Int</span> = a * <span class="hljs-number">10</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tenfoldValue_=</span></span>(x: <span class="hljs-type">Int</span>) = a = x / <span class="hljs-number">10</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br><span class="hljs-comment">//a: A = A@19dac2d6</span><br><br>scala&gt; a.originalValue = <span class="hljs-number">1</span><br><span class="hljs-comment">//a.originalValue: Int = 1</span><br><br>scala&gt; a.originalValue<br><span class="hljs-comment">//res0: Int = 1</span><br><br>scala&gt; a.tenfoldValue<br><span class="hljs-comment">//res1: Int = 10</span><br><br>scala&gt; a.tenfoldValue = <span class="hljs-number">1000</span><br><span class="hljs-comment">//a.tenfoldValue: Int = 1000</span><br><br>scala&gt; a.originalValue<br><span class="hljs-comment">//res2: Int = 100</span><br></code></pre></div></td></tr></table></figure>
<h2 id="13-2-泛型初步：类型构造器"><a href="#13-2-泛型初步：类型构造器" class="headerlink" title="13.2 泛型初步：类型构造器"></a>13.2 泛型初步：类型构造器</h2><p><strong>定义：</strong>使用方括号进行限定</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> a: <span class="hljs-type">T</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>A类型构造器、一个泛型的类</li>
</ul>
<blockquote>
<p>​        “A”是一个类，但它不是一个类型，因为它接收一个类型参数。A也被称为“类型构造器”，因为它可以接收一个类型参数来构造一个类型，就像普通类的构造方法接收值参数构造实例对象一样。</p>
<p>​        A[Int]是一种类型，A[String]是另一种类型，等等。也可以说A是一个泛型的类。在指明类型时，不能像普通类那样只写一个类名，而必须在方括号里给出具体的类型参数。例如：</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesNotCompile</span></span>(x: <span class="hljs-type">A</span>) = &#123;&#125;<br><span class="hljs-comment">//&lt;console&gt;:12: error: class A takes type parameters</span><br><span class="hljs-comment">//       def doesNotCompile(x: A) = &#123;&#125;</span><br><span class="hljs-comment">//                             ^</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesCompile</span></span>(x: <span class="hljs-type">A</span>[<span class="hljs-type">AnyRef</span>]) = &#123;&#125;<br><span class="hljs-comment">//doesCompile: (x: A[AnyRef])Unit</span><br></code></pre></div></td></tr></table></figure>
<p><strong>方括号和参数类型添加位置：</strong></p>
<ul>
<li><p><strong>泛型的类和特质</strong>需要在名字后面加上方括号和类型参数，</p>
</li>
<li><p><strong>成员方法的具有泛型参数</strong>需要在方法名后面也必须加上方括号和类型参数</p>
</li>
<li><strong>字段则不需要</strong>，只要直接用类型参数指明类型即可</li>
</ul>
<h2 id="13-3-型变注解"><a href="#13-3-型变注解" class="headerlink" title="13.3 型变注解"></a>13.3 型变注解</h2><p><strong>定义：</strong></p>
<p>​        像A[T]这样的类型构造器，它们的类型参数T可以是<strong>协变的、逆变的或者不变的</strong>，这被称为<strong>类型参数的“型变”</strong></p>
<p>​        类型参数的前缀“+”和“-”被称为<strong>型变注解</strong></p>
<ul>
<li><strong>“A[+T]”</strong>表示类A在类型参数T上是协变的</li>
<li>“<strong>A[-T]”</strong>表示类A在类型参数T上是逆变的</li>
<li>没有型变参数就是不变的。</li>
</ul>
<p>如果类型S是类型T的子类型：</p>
<ul>
<li>那么协变表示A[S]也是A[T]的子类型</li>
<li>而逆变表示A[T]反而是A[S]的子类型</li>
<li>不变则表示A[S]和A[T]是两种没有任何关系的不同类型。</li>
</ul>
<h2 id="13-4-检查型变注解"><a href="#13-4-检查型变注解" class="headerlink" title="13.4 检查型变注解"></a>13.4 检查型变注解</h2><p>​        标注了型变注解的类型参数不能随意使用，类型系统设计要满足“里氏替换原则”：在任何需要类型为T的对象的地方，都能用类型为T的子类型的对象替换。里氏替换原则的依据是子类型多态。类型为超类的变量是可以指向类型为子类的对象，因为子类继承了超类所有非私有成员，能在超类中使用的成员，一般在子类中均可用。有关里氏替换原则的详细解释，这里不再展开。</p>
<p>​        假设类型T是类型S的超类，如果类型参数是协变的，导致A[T]也是A[S]的超类，那么“val a: A[T] = new A[S]”就合法。此时，如果类A内部的某个方法funcA的入参的类型也是这个协变类型参数，那么方法调用“a.funcA(b: T)”就会出错，因为a实际指向的是一个子类对象，子类对象的方法funcA接收的入参的类型是S，而子类S不能指向超类T，所以传入的b不能被接收。但是a的类型是A[T]又隐式地告诉使用者，可以传入类型是T的参数，这就产生了矛盾。相反，funcA的返回类型是协变类型参数就没有问题，因为子类对象的funcA的返回值的类型虽然是S，但是能被T类型的变量接收，即“val c: T = a.funcA()”合法。a的类型A[T]隐式地告诉使用者应该用T类型的变量接收返回值，虽然实际返回的值是S类型，但是子类型多态允许这样做。也就是说，要保证不出错，生产者产生的值的类型应该是子类，消费者接收的值的类型应该是超类(接收者本来只希望使用超类的成员，但是实际给出的子类统统都具备，接收者也不会去使用多出来的成员，所以子类型多态才正确)。基于此，方法的入参的类型应该是逆变类型参数，逆变使得“val a: A[S] = new A[T]”合法，也就是实际引用的对象的方法想要一个T类型的参数，但传入了子类型S的值，符合里氏替换原则。同理，方法的返回类型应该是协变的。</p>
<p>​        既然类型参数的使用有限制，那么就应该有一个规则来判断该使用什么类型参数。Scala的编译器把类或特质中任何出现类型参数的地方都当作一个“点”，点有协变点、逆变点和不变点之分，以声明类型参数的类和特质作为顶层开始，逐步往内层深入，对这些点进行归类。在顶层的点都是协变点，例如顶层的方法的返回类型就在协变点。默认情况下，在更深一层的嵌套的点与在包含嵌套的外一层的点被归为一类。该规则有一些例外：①方法的值参数所在的点会根据方法外的点进行一次翻转，也就是把协变点翻转成逆变点、逆变点翻转成协变点、不变点仍然保持不变。②方法的类型参数(即方法名后面的方括号)也会根据方法外的点进行一次翻转。③如果类型也是一个类型构造器，比如以C[T]为类型，那么，当T有“-”注解时就根据外层进行翻转，有“+”注解时就保持与外层一致，否则就变成不变点。</p>
<p>​        协变点只能用“+”注解的类型参数，逆变点只能用“-”注解的类型参数。没有型变注解的类型参数可以用在任何点，也是唯一一种能用在不变点的类型参数。所以对于类型Q[+U, -T, V]而言，U处在协变点，T处在逆变点，而V处在不变点。</p>
<p>以如下例子为例进行解释：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>[-<span class="hljs-type">T</span>, +<span class="hljs-type">U</span>] </span>&#123;undefined<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">meow</span></span>[<span class="hljs-type">W</span>ˉ](volume: <span class="hljs-type">T</span>ˉ, listener: <span class="hljs-type">Cat</span>[<span class="hljs-type">U</span>+, <span class="hljs-type">T</span>ˉ]ˉ): <span class="hljs-type">Cat</span>[<span class="hljs-type">Cat</span>[<span class="hljs-type">U</span>+, <span class="hljs-type">T</span>ˉ]ˉ, <span class="hljs-type">U</span>+]+<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        右上角的正号表示协变点，负号表示逆变点。首先，Cat类声明了类型参数，所以它是顶层。方法meow的返回值属于顶层的点，所以返回类型的最右边是正号，表示协变点。因为方法的返回类型也是类型构造器Cat，并且第一个类型参数是逆变的，所以这里相对协变翻转成了逆变，而第二个类型参数是协变的，所以保持协变属性不变。继续往里归类，返回类型嵌套的Cat处在逆变点，所以第一个类型参数的位置相对逆变翻转成协变，第二个类型参数的位置保持逆变属性不变。两个值参数volume和listener都相对协变翻转成了逆变点，并且listener的类型是Cat，所以和返回类型嵌套的Cat一样。方法的类型参数W，也相对协变翻转成了逆变点。</p>
<p>​        虽然型变注解的检查很麻烦，但这些工作都被编译器自动完成了。编译器的检查方法也很直接，就是查看顶层声明的类型参数是否出现在正确的位置。比如，上例中，T都出现在逆变点，U都出现在协变点，所以可以通过检查。至于W是什么，则不关心。</p>
<h3 id="13-5-类型构造器的继承关系"><a href="#13-5-类型构造器的继承关系" class="headerlink" title="13.5 类型构造器的继承关系"></a>13.5 类型构造器的继承关系</h3><p>​        因为类型构造器需要根据类型参数来确定最终的类型，所以在判断多个类型构造器之间的继承关系时，也必须依赖类型参数。对于只含单个类型参数的类型构造器而言，继承关系很好判断，只需要看型变注解是协变、逆变还是不变。当类型参数不止一个时，该如何判断呢？尤其是函数的参数是一个函数时，更需要确定一个函数的子类型是什么样的函数。</p>
<p>​        以常用的单参数函数为例，其特质Function1的部分定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Function1</span>[-<span class="hljs-type">S</span>, +<span class="hljs-type">T</span>] </span>&#123;undefined<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">S</span>): <span class="hljs-type">T</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        类型参数S代表函数的入参的类型，很显然应该是逆变的。类型参数T代表函数返回值的类型，所以是协变的。</p>
<p>​        假设类A是类a的超类，类B是类b的超类，并且定义了一个函数的类型为Function1[a, B]。那么，这个函数的子类型应该是Function1[A, b]。解释如下：假设在需要类型为Function1[a, B]的函数的地方，实际用类型为Function1[A, b]的函数代替了。那么，本来会给函数传入a类型的参数，但实际函数需要A类型的参数，由于类A是类a的超类，这符合里氏替换原则；本来会用类型为B的变量接收函数的返回值，但实际函数返回了b类型的值，由于类B是类b的超类，这也符合里氏替换原则。综上所述，用Function1[A, b]代替Function1[a, B]符合里氏替换原则，所以Function1[A, b]是Function1[a, B]的子类型。</p>
<p>​        因此，对于含有多个类型参数的类型构造器，要构造子类型，就是把逆变类型参数由子类替换成超类、把协变类型参数由超类替换成子类</p>
<h2 id="13-6-上界和下界"><a href="#13-6-上界和下界" class="headerlink" title="13.6 上界和下界"></a>13.6 上界和下界</h2><p>​        对于类型构造器A[+T]，倘若没有别的手段，很显然它的方法的参数不能泛化，因为协变的类型参数不能用作函数的入参类型。如果要泛化参数，必须借助额外的类型参数，那么这个类型参数该怎么定义呢？因为可能存在“val x: A[超类] = new A[子类]”这样的定义，导致方法的入参类型会是T的超类，所以，额外的类型参数必须是T的超类。Scala提供了一个语法——下界，其形式为“U &gt;: T”，表示U必须是T的超类，或者是T本身(一个类型既是它自身的超类，也是它自身的子类)。</p>
<p>​        通过使用下界标定一个新的类型参数，就可以在A[+T]这样的类型构造器里泛化方法的入参类型。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>): <span class="hljs-type">U</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        现在，编译器不会报错，因为下界的存在，导致编译器预期参数x的类型是T的超类。实际运行时，会根据传入的实际入参确定U是什么。返回类型定义成了U，当然也可以是T，但是动态地根据U来调整类型显得更自然。</p>
<p>​        与下界对应的是上界，其形式为“U &lt;: T”，表示U必须是T的子类或本身。通过上界，就能在A[-T]这样的类型构造器里泛化方法的返回类型。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>): <span class="hljs-type">U</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        注意，编写上、下界时，不能写错类型的位置和开口符号</p>
<h2 id="13-7-方法的类型参数"><a href="#13-7-方法的类型参数" class="headerlink" title="13.7 方法的类型参数"></a>13.7 方法的类型参数</h2><p>​        除了类和特质能一开始声明类型参数外，方法也可以带有类型参数。如果方法仅仅使用了包含它的类或特质已声明的类型参数，那么方法自己就没必要写出类型参数。如果出现了包含它的类或特质未声明的类型参数，则必须写在方法的类型参数里。注意，方法的类型参数不能有型变注解。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: not found: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">U</span></span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>(x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>                            ^<br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">U</span>](x: <span class="hljs-type">T</span>, y: <span class="hljs-type">U</span>): <span class="hljs-type">Unit</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        方法的类型参数不能与包含它的类和特质已声明的类型参数一样，否则会把它们覆盖掉。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"> scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funcA</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>) = x.getClass<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>[<span class="hljs-type">Int</span>]<br>a: <span class="hljs-type">A</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">A</span>@<span class="hljs-number">3217</span>aada<br><br>scala&gt; a.funcA(<span class="hljs-string">&quot;Hello&quot;</span>)<br>res0: <span class="hljs-type">Class</span>[_ &lt;: <span class="hljs-type">String</span>] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br></code></pre></div></td></tr></table></figure>
<h2 id="13-8-对象私有化"><a href="#13-8-对象私有化" class="headerlink" title="13.8 对象私有化"></a>13.8 对象私有化</h2><p>​        var类型的字段，其类型参数不能是协变的，因为隐式的setter方法需要一个入参，这就把协变类型参数用作入参。其类型参数也不能是逆变的，因为隐式的getter方法的返回类型就是字段的类型。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: contravariant <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> <span class="hljs-title">occurs</span> <span class="hljs-title">in</span> <span class="hljs-title">covariant</span> <span class="hljs-title">position</span> <span class="hljs-title">in</span> <span class="hljs-title">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">T</span> <span class="hljs-title">of</span> <span class="hljs-title">variable</span> <span class="hljs-title">a</span></span><br>         <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>             ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: covariant <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> <span class="hljs-title">occurs</span> <span class="hljs-title">in</span> <span class="hljs-title">contravariant</span> <span class="hljs-title">position</span> <span class="hljs-title">in</span> <span class="hljs-title">type</span> <span class="hljs-title">T</span> <span class="hljs-title">of</span> <span class="hljs-title">value</span> <span class="hljs-title">a_=</span></span><br>         <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>             ^<br></code></pre></div></td></tr></table></figure>
<p>​        但是也有例外，如果var字段是对象私有的，即用private[this]修饰，那么它只能在定义该类或特质时被访问。由于外部无法直接访问，也就不可能在运行时违背里氏替换原则。因此隐式的getter和setter方法可以忽略对型变注解的检查。如果想在内部自定义getter或setter方法来产生一个错误，假设当前类型参数T是协变的，尽管可以通过下界来避免setter方法的型变注解错误，但是赋值操作又会发生类型匹配错误。连类型检查都无法通过，更不可能在运行时发生错误。同样，逆变类型参数也是如此。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[+<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>) = a = x<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found    : x.<span class="hljs-keyword">type</span> (<span class="hljs-keyword">with</span> underlying <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">U</span>)</span><br> required: <span class="hljs-type">T</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>[<span class="hljs-type">U</span> &gt;: <span class="hljs-type">T</span>](x: <span class="hljs-type">U</span>) = a = x<br>                                      ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |  &#125; <br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>[-<span class="hljs-type">T</span>] </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">var</span> a: <span class="hljs-type">T</span> = _<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](): <span class="hljs-type">U</span> = a<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found    : <span class="hljs-type">T</span><br> required: <span class="hljs-type">U</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">U</span> &lt;: <span class="hljs-type">T</span>](): <span class="hljs-type">U</span> = a<br>                                ^<br></code></pre></div></td></tr></table></figure>
<p>​        所以，Scala的编译器会忽略对private[this] var类型的字段的检查。</p>
<h2 id="14-抽象成员"><a href="#14-抽象成员" class="headerlink" title="14 抽象成员"></a>14 抽象成员</h2><p>​        对于本章内容不感兴趣或理解不深的读者，<strong>完全可以跳过</strong></p>
<p>​        因为这些内容也仅仅是<strong>帮助理解Chisel标准库的工作机制</strong>。实际的电路不可能会有这样的抽象成员。</p>
<h2 id="14-1-抽象成员"><a href="#14-1-抽象成员" class="headerlink" title="14.1 抽象成员"></a>14.1 抽象成员</h2><p>​        类可以用“<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=abstract&amp;spm=1001.2101.3001.7020">abstract</a>”修饰变成抽象的，特质天生就是抽象的，所以抽象类和特质里可以包含抽象成员，也就是没有完整定义的成员。Scala有四种抽象成员：抽象val字段、抽象var字段、抽象方法和抽象类型，它们的声明形式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Abstract</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span>                          <span class="hljs-comment">// 抽象类型</span></span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">T</span>  <span class="hljs-comment">// 抽象方法</span><br>  <span class="hljs-keyword">val</span> initial: <span class="hljs-type">T</span>                  <span class="hljs-comment">// 抽象val字段</span><br>  <span class="hljs-keyword">var</span> current: <span class="hljs-type">T</span>              <span class="hljs-comment">// 抽象var字段</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        因为定义不充分，存在不可初始化的字段和类型，或者没有函数体的方法，所以抽象类和特质不能直接用new构造实例。抽象成员的本意，就是让更具体的子类或子对象来实现它们。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Concrete</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Abstract</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T</span> </span>= <span class="hljs-type">String</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span></span>(x: <span class="hljs-type">String</span>) = x + x<br>  <span class="hljs-keyword">val</span> initial = <span class="hljs-string">&quot;hi&quot;</span><br>  <span class="hljs-keyword">var</span> current = initial<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        抽象类型指的是用type关键字声明的一种类型——它是某个类或特质的成员但并未给出定义。虽然类和特质都定义了一种类型，并且它们可以是抽象的，但这不意味着抽象类或特质就叫抽象类型，抽象类型永远都是类和特质的成员。在使用抽象类型进行定义的地方，最后都要被解读成抽象类型的具体定义。而使用抽象类型的原因，一是给名字冗长或含义不明的类型起一个别名，二是声明子类必须实现的抽象类型。</p>
<p>​        在不知道某个字段正确的值，但是明确地知道在当前类的每个实例中，该字段都会有一个不可变更的值时，就可以使用抽象val字段。抽象val字段与抽象无参方法类似，而且访问方式完全一样。但是，抽象val字段保证每次使用时都返回一个相同的值，而抽象方法的具体实现可能每次都返回不同的值。另外，抽象val字段只能实现成具体的val字段，不能改成var字段或无参方法；而抽象无参方法可以实现成具体的无参方法，也可以是val字段。</p>
<p>​        抽象var字段与抽象val字段类似，但是是一个可被重新赋值的字段。与前一章讲解的具体var字段类似，抽象var字段会被编译器隐式地展开成抽象setter和抽象getter方法，但是不会在当前抽象类或特质中生成一个“private[this] var”字段。这个字段会在定义了其具体实现的子类或子对象当中生成。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AbstractTime</span> </span>&#123;undefined<br>  <span class="hljs-keyword">var</span> hour: <span class="hljs-type">Int</span><br>  <span class="hljs-keyword">var</span> minute: <span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-comment">// 相当于</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AbstractTime</span> </span>&#123;undefined<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hour</span></span>: <span class="hljs-type">Int</span>             <span class="hljs-comment">// hour的getter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hour_=</span></span>(x: <span class="hljs-type">Int</span>)    <span class="hljs-comment">// hour的setter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minute</span></span>: <span class="hljs-type">Int</span>         <span class="hljs-comment">// minute的getter方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minute_=</span></span>(x: <span class="hljs-type">Int</span>) <span class="hljs-comment">// minute的setter方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="14-2-初始化抽象val字段"><a href="#14-2-初始化抽象val字段" class="headerlink" title="14.2 初始化抽象val字段"></a>14.2 初始化抽象val字段</h2><p>​        抽象val字段有时会承担超类参数的职能：它们允许程序员在子类中提供那些在超类中缺失的细节。这对特质尤其重要，因为特质没有构造方法，参数化通常都是通过子类实现抽象val字段来完成。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>  <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>  <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        要在具体的类中混入这个特质，就必须实现它的两个抽象val字段。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">RationalTrait</span> &#123;undefined<br>    <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        注意，前面说过，这不是直接实例化特质，而是隐式地用一个匿名类混入了该特质，并且花括号里的内容属于隐式的匿名类。</p>
<p>​        构造子类的实例对象时，首先构造超类/超特质的组件，然后才轮到子类的剩余组件。因为花括号里的内容不属于超类/超特质，所以在构造超类/超特质的组件时，花括号里的内容其实是无用的。并且在这个过程中，如果需要访问超类/超特质的抽象val字段，会交出相应类型的默认值(比如Int类型的默认值是0)，而不是花括号里的定义。只有轮到构造子类的剩余组件时，花括号里的子类定义才会派上用场。所以，在构造超类/超特质的组件时，尤其是特质还不能接收子类的参数，如果默认值不满足某些要求，构造就会出错。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>         |    require(denomArg != <span class="hljs-number">0</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">RationalTrait</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalTrait</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>         |  &#125;<br>java.lang.<span class="hljs-type">IllegalArgumentException</span>: requirement failed<br>  at scala.<span class="hljs-type">Predef</span>$.require(<span class="hljs-type">Predef</span>.scala:<span class="hljs-number">264</span>)<br>  at <span class="hljs-type">RationalTrait</span>.$init$(&lt;console&gt;:<span class="hljs-number">14</span>)<br>  ... <span class="hljs-number">32</span> elided<br></code></pre></div></td></tr></table></figure>
<p>​        在这个例子中，require函数会在参数为false时报错。该特质是用默认值0去初始化两个抽象字段的，花括号里的定义只有等超特质构造完成才有用，所以require函数无法通过。为此，Scala提供了两种方法解决这种问题。</p>
<p> <strong>（1）预初始化字段</strong><br>        如果能让花括号里的代码在最开始执行，那么就能避免该问题，这个方法被称作“预初始化字段”。其形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> &#123; 定义 &#125; <span class="hljs-keyword">with</span> 超类/超特质 <br></code></pre></div></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">new</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span><br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>res0: <span class="hljs-type">RationalTrait</span> = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">1</span>a01ffff <br></code></pre></div></td></tr></table></figure>
<p>​        除了匿名类可以这样使用，单例对象或具名子类也可以，其形式是把花括号里的代码与单例对象名或类名用extends隔开，最后用with连接想要继承的类或混入的特质。例如： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, d: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">RationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg = n<br>         |    <span class="hljs-keyword">val</span> denomArg = d<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>java.lang.<span class="hljs-type">IllegalArgumentException</span>: requirement failed<br>  at scala.<span class="hljs-type">Predef</span>$.require(<span class="hljs-type">Predef</span>.scala:<span class="hljs-number">264</span>)<br>  at <span class="hljs-type">RationalTrait</span>.$init$(&lt;console&gt;:<span class="hljs-number">14</span>)<br>  ... <span class="hljs-number">29</span> elided<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, d: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg = n<br>         |    <span class="hljs-keyword">val</span> denomArg = d<br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RationalClass</span></span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">RationalClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">RationalClass</span> = <span class="hljs-type">RationalClass</span>@<span class="hljs-number">6</span>f26e775<br></code></pre></div></td></tr></table></figure>
<p>​        这个语法有一个瑕疵，就是由于预初始化字段发生得比构造超类/超特质更早，导致预初始化字段时实例对象其实还未被构造，所以花括号里的代码不能通过“this”来引用正在构造的对象本身。如果代码里出现了this，那么这个引用将指向包含当前被构造的类或对象的对象，而不是被构造的对象本身。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">new</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span><br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-keyword">this</span>.numerArg * <span class="hljs-number">2</span><br>         |  &#125; <span class="hljs-keyword">with</span> <span class="hljs-type">RationalTrait</span><br>&lt;console&gt;:<span class="hljs-number">15</span>: error: value numerArg is not a member of <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">$iw</span></span><br>         <span class="hljs-keyword">val</span> denomArg = <span class="hljs-keyword">this</span>.numerArg * <span class="hljs-number">2</span><br>                             ^ <br></code></pre></div></td></tr></table></figure>
<p>​        这个代码无法通过编译，因为this指向了包含用new构造的对象的那个对象，在本例中是名为“$iw”的合成对象，该合成对象是Scala的编译器用于存放用户输入的代码的地方。由于$iw没有叫numerArg的成员，所以编译器产生了错误。</p>
<p><strong>（2）惰性的val字段</strong><br>        预初始化字段是人为地调整初始化顺序，而把val字段定义成惰性的，则可以让程序自己确定初始化顺序。如果在val字段前面加上关键字“lazy”，那么该字段只有首次被使用时才会进行初始化。如果是用表达式进行初始化，那就对表达式求值并保存，后续使用字段时都是复用保存的结果而不是每次都求值表达式。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LazyRationalTrait</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> numerArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">val</span> denomArg: <span class="hljs-type">Int</span><br>         |    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> numer = numerArg / g<br>         |    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> denom = denomArg / g<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= numer + <span class="hljs-string">&quot;/&quot;</span> + denom<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> g = &#123;undefined<br>         |       require(denomArg != <span class="hljs-number">0</span>)<br>         |       gcd(numerArg, denomArg)<br>         |    &#125;<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> =<br>         |       <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) a <span class="hljs-keyword">else</span> gcd(b, a % b)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LazyRationalTrait</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-number">2</span><br>x: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">LazyRationalTrait</span> &#123;undefined<br>         |      <span class="hljs-keyword">val</span> numerArg = <span class="hljs-number">1</span> * x<br>         |      <span class="hljs-keyword">val</span> denomArg = <span class="hljs-number">2</span> * x<br>         |  &#125;<br>res0: <span class="hljs-type">LazyRationalTrait</span> = <span class="hljs-number">1</span>/<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>
<p>​        首先仍然是先构造超特质的组件，但是需要初始化的非抽象字段都被lazy修饰，所以没有执行任何操作。并且由于require函数在字段g内部，而g没有初始化，所以不会出错。然后开始构造子类的组件，先对1 <em> x和2 </em> x两个表达式进行求值，得到2和4后把两个抽象字段初始化了。最后，解释器需要调用toString方法进行信息输出，该方法要访问numer，此时才对numer右侧的初始化表达式进行求值，且numerArg已经初始化为2；在numer初始化时要访问g，所以才对g进行初始化，但denomArg已满足require的要求，求得g为2并保存；等到toString方法要访问denom时，才初始化denom，并且g不用再次求值。至此，对象构造完成。 </p>
<h2 id="14-3-抽象类型"><a href="#14-3-抽象类型" class="headerlink" title="14.3 抽象类型"></a>14.3 抽象类型</h2><p>​        假设要编写一个Food类，用各种子类来表示各种食物。要编写一个抽象的Animal类，有一个eat方法，接收Food类型的参数。那么可能会写成如下形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Food</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        如果用不同的Animal子类来代表不同的动物，并且食物类型也会根据动物的习性发生改变。比如定义一头吃草的牛，那么可能定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125; <br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-title">needs</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">abstract</span>, <span class="hljs-title">since</span> <span class="hljs-title">method</span> <span class="hljs-title">eat</span> <span class="hljs-title">in</span> <span class="hljs-title">class</span> <span class="hljs-title">Animal</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> (<span class="hljs-params">food: <span class="hljs-type">Food</span></span>)<span class="hljs-title">Unit</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span></span><br>(<span class="hljs-type">Note</span> that <span class="hljs-type">Food</span> does not <span class="hljs-keyword">match</span> <span class="hljs-type">Grass</span>: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">subclass</span> <span class="hljs-title">of</span> <span class="hljs-title">class</span> <span class="hljs-title">Food</span>, <span class="hljs-title">but</span> <span class="hljs-title">method</span> <span class="hljs-title">parameter</span> <span class="hljs-title">types</span> <span class="hljs-title">must</span> <span class="hljs-title">match</span> <span class="hljs-title">exactly</span>.)</span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>             ^<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: method eat overrides nothing.<br><span class="hljs-type">Note</span>: the <span class="hljs-keyword">super</span> classes of <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-title">contain</span> <span class="hljs-title">the</span> <span class="hljs-title">following</span>, <span class="hljs-title">non</span> <span class="hljs-title">final</span> <span class="hljs-title">members</span> <span class="hljs-title">named</span> <span class="hljs-title">eat</span></span>:<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Food</span>): <span class="hljs-type">Unit</span><br>       <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125;<br>                    ^<br></code></pre></div></td></tr></table></figure>
<p>​        奇怪的是，编译器并不允许这么做。问题出在“override def eat(food: Grass) = {}”这句代码并不会被编译。实现超类的抽象方法其实相当于重写，但是重写要保证参数列表完全一致，否则就是函数重载。在这里，超类的方法eat的参数类型是Food，但是子类的版本改成了Grass。Scala的编译器执行严格的类型检查，尽管Grass是Food的子类，但是出现在函数的参数类型上，并不能简单地套用子类型多态，就认为Grass等效于Food。所以，错误信息显示Cow类一是没有实现Animal类的抽象eat方法，二是Cow类的eat方法并未重写任何东西。</p>
<p>​        如果有读者认为这种规则过于严厉，应该放松，那么就会出现如下不符合常识的情况：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br><br><span class="hljs-keyword">val</span> bessy: <span class="hljs-type">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br><br>bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br></code></pre></div></td></tr></table></figure>
<p>​        假设编译器放开对eat方法的参数类型的限制，使得任何Food类型都能通过编译，那么Fish类作为Food的子类，也就能被Cow类的eat方法所接受。但是，给一头牛喂鱼，而不是吃草，显然与事实不符。</p>
<p>​        要达到上述目的，就需要更精确的编程模型。一种办法就是借助抽象类型及上界，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br><br>scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |     <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> <span class="hljs-title">&lt;</span></span>: <span class="hljs-type">Food</span><br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">SuitableFood</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span><br></code></pre></div></td></tr></table></figure>
<p>​        在这里，引入了一个抽象类型。由于方法eat的参数设定为抽象类型，在编译时会被解读成具体的SuitableFood实现，所以不同的Animal子类可以通过更改具体的SuitableFood来达到改变食物类型的目的，并且这符合严格的规则检查。其次，上界保证了在子类实现SuitableFood时，必须是Food的某个子类，即不会喂给动物吃非食物类的东西。此时的Cow类如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grass</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span><br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">Grass</span>) = &#123;&#125;<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        如果现在给吃草的牛喂一条鱼，那么就会发生类型错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> bessy: <span class="hljs-type">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br>bessy: <span class="hljs-type">Animal</span> = <span class="hljs-type">Cow</span>@<span class="hljs-number">2442</span>f36d<br><br>scala&gt; bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Fish</span><br> required: bessy.<span class="hljs-type">SuitableFood</span><br>       bessy eat (<span class="hljs-keyword">new</span> <span class="hljs-type">Fish</span>)<br>                  ^ <br></code></pre></div></td></tr></table></figure>
<h2 id="14-4-路径依赖类型"><a href="#14-4-路径依赖类型" class="headerlink" title="14.4 路径依赖类型"></a>14.4 路径依赖类型</h2><p>​        在前面给牛喂鱼的例子中，可以发现错误信息里有一个有趣的现象：方法eat要求的参数类型是bessy.SuitableFood。关于类型“bessy.SuitableFood”，比普通的类型描述多了一个对象。这说明类型可以是对象的成员，bessy.SuitableFood表示SuitableFood是由bessy引用的对象的成员，或者说bessy引用对象的专属食物。像这样的类型称为路径依赖类型，尽管最后的类型是相同的，但若是前面的路径不同，那就是不同的类型。“路径”就是指对象的引用，它可以是单名，也可以是更长的路径。</p>
<p>​        比如，狗吃狗粮，一条狗能吃另一条狗的狗粮，但牛怎么都不能吃狗粮：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogFood</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogFood</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;undefined<br>         |    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">DogFood</span><br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(food: <span class="hljs-type">DogFood</span>) = &#123;&#125;<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> lassie = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span><br>lassie: <span class="hljs-type">Dog</span> = <span class="hljs-type">Dog</span>@<span class="hljs-number">2655</span>ad3b<br><br>scala&gt; <span class="hljs-keyword">val</span> bessy = <span class="hljs-keyword">new</span> <span class="hljs-type">Cow</span><br>bessy: <span class="hljs-type">Cow</span> = <span class="hljs-type">Cow</span>@<span class="hljs-number">663e2</span>cfd<br><br>scala&gt; lassie eat (<span class="hljs-keyword">new</span> bessy.<span class="hljs-type">SuitableFood</span>)<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Grass</span><br> required: <span class="hljs-type">DogFood</span><br>       lassie eat (<span class="hljs-keyword">new</span> bessy.<span class="hljs-type">SuitableFood</span>)<br>                   ^<br><br>scala&gt; <span class="hljs-keyword">val</span> bootsie = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span><br>bootsie: <span class="hljs-type">Dog</span> = <span class="hljs-type">Dog</span>@<span class="hljs-number">456454e0</span><br><br>scala&gt; lassie eat (<span class="hljs-keyword">new</span> bootsie.<span class="hljs-type">SuitableFood</span>)<br><br>scala&gt;<br></code></pre></div></td></tr></table></figure>
<p>​        因为bessy.SuitableFood和lassie.SuitableFood的路径不同，所以它们是不同的类型。而lassie.SuitableFood和bootsie.SuitableFood尽管有不同的路径，似乎是不同的类型，但其实这两个都是实际类型DogFood的别名，所以实质上是同一个类型。</p>
<p>​        Scala的“路径依赖类型”很像Java的“内部类类型”，但是两者有重要区别：路径依赖类型的路径表明了外部类的对象，而内部类类型仅表明了外部类。</p>
<p>​        Scala也可以表示Java的内部类，但是语法稍有不同。Scala定义一个内部类只需这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;undefined<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        内部类Inner可以通过“Outer#Inner”来寻址，而不是Java的“Outer.Inner”，因为Scala把句点符号作为对象访问成员的专属符号，而类访问成员则是通过井号。比如有如下两个对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span><br><span class="hljs-keyword">val</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span><br></code></pre></div></td></tr></table></figure>
<p>​        那么，o1.Inner和o2.Inner就是两个路径依赖类型，并且是两个不同的类型。这两个路径依赖类型都是Outer#Inner的子类型，因为Outer#Inner其实是用任意的Outer对象来表示Inner类型。相比之下，o1.Inner是通过一个被o1引用的具体对象来表示的类型。o2.Inner也是如此。</p>
<p>​        与Java一样，Scala的内部类的实例持有包含它的外部类的实例的引用，这使得内部类可以访问包含它的外部类的成员。也正因此，在没有给出某个外部类的具体实例时，不能直接实例化内部类，因为光有内部类实例，没有相应的外部类实例，就无法访问外部类实例的成员。有两种途径实例化内部类：一是在外部类的花括号内部通过“this.Inner”来实例化，让this引用正在构造的外部类实例；二是给出具体的外部类实例，比如o1.Inner，就可以通过“new o1.Inner”来实例化。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i1 = <span class="hljs-keyword">new</span> o1.<span class="hljs-type">Inner</span><br>i1: o1.<span class="hljs-type">Inner</span> = <span class="hljs-type">Outer</span>$<span class="hljs-type">Inner</span>@<span class="hljs-number">5464</span>a18<br><br> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span>是不能直接实例化的，因为没有具体的外部类实例：<br><br>scala&gt; <span class="hljs-keyword">val</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: <span class="hljs-type">Outer</span> is not a legal prefix <span class="hljs-keyword">for</span> a constructor<br>       <span class="hljs-keyword">val</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Outer</span>#<span class="hljs-type">Inner</span><br>                          ^<br></code></pre></div></td></tr></table></figure>
<h2 id="14-5-细化类型"><a href="#14-5-细化类型" class="headerlink" title="14.5 细化类型"></a>14.5 细化类型</h2><p>​        当一个类继承自另一个类时，就称前者是后者的名义子类型。Scala还有一个结构子类型，表示两个类型只是有某些兼容的成员，而不是常规的那样继承来的关系。结构子类型通过细化类型来表示。</p>
<p>​        比如，要做一个食草动物的集合。一种方法是定义一个食草的特质，让所有的食草动物类都混入该特质。但是这样会让食草动物与最基本的动物的关系不那么紧密。如果按前面定义食草牛那样继承自Animal类，那么食草动物集合的元素类型就可以表示为Animal类型，但这样又可能把食肉动物或杂食动物也包含进集合。此时，就可以使用结构子类型，其形式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">Animal</span> &#123; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span> &#125; <br></code></pre></div></td></tr></table></figure>
<p>​        最前面是基类Animal的声明，花括号里是想要兼容的成员。这个成员声明得比基类Animal更具体、更精细，表示食物类型必须是草。当然，并不一定要更加具体。那么，用这样一个类型指明集合元素得类型，就可以只包含食草动物了：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> animals: <span class="hljs-type">List</span>[<span class="hljs-type">Animal</span> &#123; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SuitableFood</span> </span>= <span class="hljs-type">Grass</span> &#125;] = ??? <br></code></pre></div></td></tr></table></figure>
<h2 id="14-6-Scala的枚举"><a href="#14-6-Scala的枚举" class="headerlink" title="14.6 Scala的枚举"></a>14.6 Scala的枚举</h2><p>​        Scala没有特定的语法表示枚举，而是在标准类库中提供一个枚举类——scala.Enumeration。通过创建一个继承自这个类的子对象可以创建枚举。例如： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">Red</span>, <span class="hljs-type">Green</span>, <span class="hljs-type">Blue</span> = <span class="hljs-type">Value</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Color</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        对象Color和普通的单例对象一样，可以通过“Color.Red”这样的方式来访问成员，或者先用“import Color._”导入。</p>
<p>​        Enumeration类定义了一个名为Value的内部类，以及同名的无参方法。该方法每次都返回内部类Value的全新实例，也就是说，枚举对象Color的三个枚举值都分别引用了一个Value类型的实例对象。并且，因为Value是内部类，所以它的对象的具体类型还与外部类的实例对象有关。在这里，外部类的对象就是自定义的Color，所以三个枚举值引用的对象的真正类型应该是Color.Value。</p>
<p>​        假如还有别的枚举对象，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">North</span>, <span class="hljs-type">East</span>, <span class="hljs-type">South</span>, <span class="hljs-type">West</span> = <span class="hljs-type">Value</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span></span><br></code></pre></div></td></tr></table></figure>
<p>​        根据路径依赖类型的规则，Color.Value和Direction.Value是两个不同类型，所以两个枚举对象分别创造了两种不同类型的枚举值。</p>
<p>​        方法Value有一个重载的版本，可以接收一个字符串参数来给枚举值关联特定的名称。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;undefined<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">North</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;N&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">East</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;E&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">South</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;S&quot;</span>)<br>         |     <span class="hljs-keyword">val</span> <span class="hljs-type">West</span> = <span class="hljs-type">Value</span>(<span class="hljs-string">&quot;W&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Direction</span> </span><br></code></pre></div></td></tr></table></figure>
<p>​        方法values返回枚举值的名称的集合。优先给出特定名称，否则就给字段名称。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Color</span>.values<br>res0: <span class="hljs-type">Color</span>.<span class="hljs-type">ValueSet</span> = <span class="hljs-type">Color</span>.<span class="hljs-type">ValueSet</span>(<span class="hljs-type">Red</span>, <span class="hljs-type">Green</span>, <span class="hljs-type">Blue</span>)<br><br>scala&gt; <span class="hljs-type">Direction</span>.values<br>res1: <span class="hljs-type">Direction</span>.<span class="hljs-type">ValueSet</span> = <span class="hljs-type">Direction</span>.<span class="hljs-type">ValueSet</span>(<span class="hljs-type">N</span>, <span class="hljs-type">E</span>, <span class="hljs-type">S</span>, <span class="hljs-type">W</span>)<br></code></pre></div></td></tr></table></figure>
<p>​        枚举值从0开始编号。内部类Value有一个方法id返回相应的编号，也可以通过“对象名(编号)”来返回相应的枚举值的名称。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Color</span>.<span class="hljs-type">Red</span>.id<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Color</span>(<span class="hljs-number">2</span>)<br>res3: <span class="hljs-type">Color</span>.<span class="hljs-type">Value</span> = <span class="hljs-type">Blue</span><br><br>scala&gt; <span class="hljs-type">Color</span>(<span class="hljs-number">3</span>)<br>java.util.<span class="hljs-type">NoSuchElementException</span>: key not found: <span class="hljs-number">3</span><br>  at scala.collection.<span class="hljs-type">MapLike</span>.<span class="hljs-keyword">default</span>(<span class="hljs-type">MapLike</span>.scala:<span class="hljs-number">231</span>)<br>  at scala.collection.<span class="hljs-type">MapLike</span>.<span class="hljs-keyword">default</span>$(<span class="hljs-type">MapLike</span>.scala:<span class="hljs-number">230</span>)<br>  at scala.collection.<span class="hljs-type">AbstractMap</span>.<span class="hljs-keyword">default</span>(<span class="hljs-type">Map</span>.scala:<span class="hljs-number">59</span>)<br>  at scala.collection.mutable.<span class="hljs-type">HashMap</span>.apply(<span class="hljs-type">HashMap</span>.scala:<span class="hljs-number">65</span>)<br>  at scala.<span class="hljs-type">Enumeration</span>.apply(<span class="hljs-type">Enumeration</span>.scala:<span class="hljs-number">142</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; <span class="hljs-type">Direction</span>.<span class="hljs-type">North</span>.id<br>res4: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Direction</span>(<span class="hljs-number">0</span>)<br>res5: <span class="hljs-type">Direction</span>.<span class="hljs-type">Value</span> = <span class="hljs-type">N</span><br></code></pre></div></td></tr></table></figure>
<h1 id="15-隐式转换与隐式参数"><a href="#15-隐式转换与隐式参数" class="headerlink" title="15 隐式转换与隐式参数"></a>15 隐式转换与隐式参数</h1><p>​        隐式定义是一个很常用的Scala高级语法</p>
<p>​        尤其是在阅读、理解Chisel这样的DSL语言时，就不得不彻底搞明白自定义的隐式定义是如何工作的。</p>
<p>​        <strong>编写实际的硬件电路，像RocketChip的快速裁剪、配置功能，就是通过模式匹配加上隐式参数实现的</strong>（配置机制会在后续章节讲解。<strong>对于想掌握Chisel高级功能的读者，本章是学习的重点</strong>）</p>
<h2 id="15-1-隐式定义的规则"><a href="#15-1-隐式定义的规则" class="headerlink" title="15.1 隐式定义的规则"></a>15.1 隐式定义的规则</h2><p>Scala对隐式定义有如下约束规则：</p>
<p>①标记规则。只有用关键字“implicit”标记的定义才能被编译器隐式使用，任何函数、变量或单例对象都可以被标记。其中，标记为隐式的变量和单例对象常用作隐式参数，隐式的函数常用于隐式转换。比如，代码“x + y”因为调用对象x的类型错误而不能通过编译，那么编译器会尝试把代码改成“convert(x) + y”，其中convert是某种可用的隐式转换。如果convert能将x改成某种支持“+”方法的对象，那么这段代码就可能通过类型检查。</p>
<p>②作用域规则。Scala编译器只会考虑在当前作用域内的隐式定义，否则，所有隐式定义都是全局可见的将会使得程序异常复杂甚至出错。隐式定义在当前作用域必须是“单个标识符”，即编译器不会展开成“A.convert(x) + y”的形式。如果想用A.convert，那么必须先用“import A.convert”导入才行，然后被展开成“convert(x) + y”的形式。单个标识符规则有一个例外，就是编译器会在与隐式转换相关的源类型和目标类型的伴生对象里查找隐式定义。因此，常在伴生对象中定义隐式转换，而不用在需要时显式导入。</p>
<p>③每次一个规则。编译器只会插入一个隐式定义，不会出现“convert1(convert2(x)) + y”这种嵌套的形式，但是可以让隐式定义包含隐式参数来绕开这个限制。</p>
<p>④显式优先原则。如果显式定义能通过类型检查，就不必进行隐式转换。因此，总是可以把隐式定义变成显式的，这样代码变长但是歧义变少。用显式还是隐式，需要取舍。</p>
<p>此外，隐式转换可以用任意合法的标识符来命名。有了名字后，一是可以显式地把隐式转换函数写出来，二是明确地导入具体的隐式转换而不是导入所有的隐式定义。</p>
<p>Scala只会在三个地方使用隐式定义：转换到一个预期的类型，转换某个选择接收端(即调用方法或字段的对象)，隐式参数。</p>
<h2 id="15-2-隐式地转换到期望类型"><a href="#15-2-隐式地转换到期望类型" class="headerlink" title="15.2 隐式地转换到期望类型"></a>15.2 隐式地转换到期望类型</h2><p>​        Scala的编译器对于类型检查比较严格，比如把一个浮点数赋值给整数变量，通常情况下人们可能希望通过截断小数部分来完成赋值，但是Scala在默认情况下是不允许这种丢失精度的转换的，这会造成类型匹配错误。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Double</span>(<span class="hljs-number">1.5</span>)<br> required: <span class="hljs-type">Int</span><br>       <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>                    ^<br></code></pre></div></td></tr></table></figure>
<p>​        但是用户可能并不关心精度问题，确实需要这样一种赋值操作，那么就可以通过定义一个隐式转换来完成。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> scala.language.implicitConversions<br><span class="hljs-keyword">import</span> scala.language.implicitConversions<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleToInt</span></span>(x: <span class="hljs-type">Double</span>) = x.toInt<br>doubleToInt: (x: <span class="hljs-type">Double</span>)<span class="hljs-type">Int</span><br><br>scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.5</span><br>i: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span> <br></code></pre></div></td></tr></table></figure>
<p>​        此时再进行之前的赋值，就会正确地截断小数部分。当然，隐式转换也可以显式地调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = doubleToInt(<span class="hljs-number">2.33</span>)<br>i: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span> <br></code></pre></div></td></tr></table></figure>
<p>​        第七章讲解类继承时，最后提到了Scala的全局类层次，其中就有七种基本值类的转换，比如Int可以赋值给Double。这其实也是隐式转换在起作用，只是这个隐式转换定义在scala包里的单例对象Predef里。因为所有的Scala文件都会被编译器隐式地在开头按顺序插入“import java.lang.<em>”、“import scala.</em>”、“import Predef._”三条语句，所以标准库里的隐式转换会以不被察觉的方式工作。</p>
<h2 id="15-3-隐式地转换接收端"><a href="#15-3-隐式地转换接收端" class="headerlink" title="15.3 隐式地转换接收端"></a>15.3 隐式地转换接收端</h2><p>接收端就是指调用方法或字段的那个对象，也就是调用对象在非法的情</p>
<p>况下，被隐式转换变成了合法的对象，这是隐式转换最常用的地方。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span>(<span class="hljs-params">val i: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span></span><br><br>scala&gt; <span class="hljs-number">1.</span>i<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: value i is not a member of <span class="hljs-type">Int</span><br>       <span class="hljs-number">1.</span>i<br>         ^<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToMy</span></span>(x: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt</span>(x)<br>intToMy: (x: <span class="hljs-type">Int</span>)<span class="hljs-type">MyInt</span><br><br>scala&gt; <span class="hljs-number">1.</span>i<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<p>​        在上个例子中，标准值类Int是没有叫“i”的字段的，在定义隐式转换前，“1.i”是非法的。有了隐式转换后，把一个Int对象作为参数构造了一个新的MyInt对象，而MyInt对象就有字段i。所以“1.i”被编译器隐式地展开成了“intToMy(1).i”。这就使得已有类型可以通过“自然”的方式与新类型进行互动。</p>
<p>​        此外，隐式转换的这个作用还经常被用于模拟新的语法，尤其是在构建DSL语言时用到。因为DSL语言含有大量的自定义类型，这些自定义类型可能要频繁地与已有类型交互，有了隐式转换之后就能让代码的语法更加自然。比如Chisel就是这样的DSL语言，如果读者仔细研究Chisel的源码，就会发现大量的隐式定义。</p>
<p>​        前面说过，映射的键-值对语法“键 -&gt; 值”其实是一个对偶“(键, 值)”。这并不是什么高深的技巧，就是隐式转换在起作用。Scala仍然是在Predef这个单例对象里定义了一个箭头关联类ArrowAssoc，该类有一个方法“-&gt;”，接收一个任意类型的参数，把调用对象和参数构成一个二元组来返回。同时，单例对象里还有一个隐式转换any2ArrowAssoc，该转换也接收一个任意类型的参数，用这个参数构造一个ArrowAssoc类的实例对象。所以，“键 -&gt; 值”会被编译器隐式地展开成“any2ArrowAssoc(键).-&gt;(值)”。因此，严格来讲没有“键 -&gt; 值”这个语法，只不过是用隐式转换模拟出来的罢了。</p>
<h2 id="14-4-隐式类"><a href="#14-4-隐式类" class="headerlink" title="14.4 隐式类"></a>14.4 隐式类</h2><p>​        隐式类是一个以关键字“implicit”开头的类，用于简化富包装类的编写。它不能是样例类，并且主构造方法有且仅有一个参数。此外，隐式类只能位于某个单例对象、类或特质里，不能单独出现在顶层。隐式类的特点就是让编译器在相同层次下自动生成一个与类名相同的隐式转换，该转换接收一个与隐式类的主构造方法相同的参数，并用这个参数构造一个隐式类的实例对象来返回。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">width: <span class="hljs-type">Int</span>, height: <span class="hljs-type">Int</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Rec</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectangleMaker</span>(<span class="hljs-params">width: <span class="hljs-type">Int</span></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>(height: <span class="hljs-type">Int</span>) = <span class="hljs-type">Rectangle</span>(width, height)<br>  &#125;<br>  <span class="hljs-comment">// 自动生成的</span><br>  <span class="hljs-comment">// implicit def RectangleMaker(width: Int) = new RectangleMaker(width)</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​        将该文件编译后，就可以在解释器里用“import Rec._”或“import Rec.RectangleMaker”来引入这个隐式转换，然后用“1 x 10”这样的语句来构造一个长方形。实际上，Int类并不存在方法“x”，但是隐式转换把Int对象转换成一个RectangleMaker类的对象，转换后的对象有一个构造Rectangle的方法“x”。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: value x is not a member of <span class="hljs-type">Int</span><br>       <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>         ^<br><br>scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">Rec</span>.<span class="hljs-type">RectangleMaker</span><br><span class="hljs-keyword">import</span> <span class="hljs-type">Rec</span>.<span class="hljs-type">RectangleMaker</span><br><br>scala&gt; <span class="hljs-number">1</span> x <span class="hljs-number">10</span><br>res0: <span class="hljs-type">Rectangle</span> = <span class="hljs-type">Rectangle</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br></code></pre></div></td></tr></table></figure>
<p>​        隐式类需要单参数主构造方法的原因很简单，因为用于转换的调用对象只有一个，并且自动生成的隐式转换不会去调用辅助构造方法。隐式类不能出现在顶层是因为自动生成的隐式转换与隐式类在同一级，如果不用导入就能直接使用，那么顶层大量的隐式类就会使得代码变得复杂且容易出错。</p>
<h2 id="15-5-隐式参数"><a href="#15-5-隐式参数" class="headerlink" title="15.5 隐式参数"></a>15.5 隐式参数</h2><p>​        函数最后一个参数列表可以用关键字“implicit”声明为隐式的，这样整个参数列表的参数都是隐式参数。注意，是整个参数列表，即使括号里有多个参数，也只需要开头写一个“implicit”。而且每个参数都是隐式的，不存在部分隐式部分显式。</p>
<p>​        当调用函数时，若缺省了隐式参数列表，则编译器会尝试插入相应的隐式定义。当然，也可以显式给出参数，但是要么全部缺省，要么全部显式给出，不能只写一部分。</p>
<p>​        要让编译器隐式插入参数，就必须事先定义好符合预期类型的隐式变量(val和var可以混用，关键在于类型)、隐式单例对象或隐式函数(别忘了函数也能作为函数的参数进行传递)，这些隐式定义也必须用“implicit”修饰。隐式变量、单例对象、函数在当前作用域的引用也必须满足“单标识符”原则，即不同层次之间需要用“import”来解决。</p>
<p>​        隐式参数的类型应该是“稀有”或“特定”的，类型名称最好能表明该参数的作用。如果直接使用Int、Boolean、String等常用类型，容易引发混乱。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreferredPrompt</span>(<span class="hljs-params">val preference: <span class="hljs-type">String</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreferredDrink</span>(<span class="hljs-params">val preference: <span class="hljs-type">String</span></span>)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span></span>(name: <span class="hljs-type">String</span>)(<span class="hljs-keyword">implicit</span> prompt: <span class="hljs-type">PreferredPrompt</span>,<br>      drink: <span class="hljs-type">PreferredDrink</span>) = &#123;<br>    println(<span class="hljs-string">&quot;Welcome, &quot;</span> + name + <span class="hljs-string">&quot;. The system is ready.&quot;</span>)<br>    print(<span class="hljs-string">&quot;But while you work, &quot;</span>)<br>    println(<span class="hljs-string">&quot;why not enjoy a cup of &quot;</span> + drink.preference + <span class="hljs-string">&quot;?&quot;</span>)<br>    println(prompt.preference)<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">JoesPrefs</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> prompt = <span class="hljs-keyword">new</span> <span class="hljs-type">PreferredPrompt</span>(<span class="hljs-string">&quot;Yes, master&gt; &quot;</span>)<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> drink = <span class="hljs-keyword">new</span> <span class="hljs-type">PreferredDrink</span>(<span class="hljs-string">&quot;tea&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: could not find <span class="hljs-keyword">implicit</span> value <span class="hljs-keyword">for</span> parameter prompt: <span class="hljs-type">PreferredPrompt</span><br>       <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br>                    ^<br><br>scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">JoesPrefs</span>._<br><span class="hljs-keyword">import</span> <span class="hljs-type">JoesPrefs</span>._<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)<br><span class="hljs-type">Welcome</span>, <span class="hljs-type">Joe</span>. <span class="hljs-type">The</span> system is ready.<br><span class="hljs-type">But</span> <span class="hljs-keyword">while</span> you work, why not enjoy a cup of tea?<br><span class="hljs-type">Yes</span>, master&gt;<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt, drink)<br><span class="hljs-type">Welcome</span>, <span class="hljs-type">Joe</span>. <span class="hljs-type">The</span> system is ready.<br><span class="hljs-type">But</span> <span class="hljs-keyword">while</span> you work, why not enjoy a cup of tea?<br><span class="hljs-type">Yes</span>, master&gt;<br><br>scala&gt; <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt)<br>&lt;console&gt;:<span class="hljs-number">15</span>: error: not enough arguments <span class="hljs-keyword">for</span> method greet: (<span class="hljs-keyword">implicit</span> prompt: <span class="hljs-type">PreferredPrompt</span>, <span class="hljs-keyword">implicit</span> drink: <span class="hljs-type">PreferredDrink</span>)<span class="hljs-type">Unit</span>.<br><span class="hljs-type">Unspecified</span> value parameter drink.<br>       <span class="hljs-type">Greeter</span>.greet(<span class="hljs-string">&quot;Joe&quot;</span>)(prompt)<br></code></pre></div></td></tr></table></figure>
<h2 id="15-6-含有隐式参数的主构造方法"><a href="#15-6-含有隐式参数的主构造方法" class="headerlink" title="15.6 含有隐式参数的主构造方法"></a>15.6 含有隐式参数的主构造方法</h2><p>​        不仅是普通的函数可以有隐式参数，类的主构造方法也可以包含隐式参数，辅助构造方法是不允许出现隐式参数的。但有一个问题需要注意，假设类A仅有一个参数列表，并且该列表是隐式的，那么A的实际定义形式是“A()(implicit 参数)”，也就是比字面上的代码多了一个空括号。不管是用new实例化类A，还是被其它类继承，若调用主构造方法时显式给出隐式参数，就必须写出这个空括号。若隐式参数由编译器自动插入，则空括号可有可无。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-number">1</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: no arguments allowed <span class="hljs-keyword">for</span> nullary constructor <span class="hljs-type">A</span>: ()(<span class="hljs-keyword">implicit</span> x: <span class="hljs-type">Int</span>)<span class="hljs-type">A</span><br>       <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-number">1</span>)<br>                     ^<br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()(<span class="hljs-number">1</span>)<br>a: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7</span>cf8f45a<br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">ORZ</span> = <span class="hljs-number">233</span><br><span class="hljs-type">ORZ</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>b: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7</span>d977a20<br><br>scala&gt; b.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>c: <span class="hljs-type">A</span> = <span class="hljs-type">A</span><span class="hljs-meta">@de</span>0c402<br><br>scala&gt; c.x<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> &#123; <span class="hljs-keyword">val</span> y = x &#125;<br>d: <span class="hljs-type">A</span>&#123;<span class="hljs-keyword">val</span> y: <span class="hljs-type">Int</span>&#125; = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">5</span>c5c7cc4<br><br>scala&gt; d.x<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br><br>scala&gt; <span class="hljs-keyword">import</span> scala.language.reflectiveCalls<br><span class="hljs-keyword">import</span> scala.language.reflectiveCalls<br><br>scala&gt; d.y<br>res3: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br></code></pre></div></td></tr></table></figure>
<p>​        如果类A有多个参数列表，且最后一个是隐式的参数列表，则主构造方法没有额外的空括号。</p>
<h2 id="15-7-上下文界定"><a href="#15-7-上下文界定" class="headerlink" title="15.7 上下文界定"></a>15.7 上下文界定</h2><p>​        排序是一个常用的操作，Scala提供了一个特质Ordering[T]，方便用户定义特定的排序行为。该特质有一个抽象方法compare，接收两个T类型的参数，然后返回一个Int类型的结果。如果第一个参数“大于”第二个参数，则应该返回正数，反之应该返回负数，相等则返回0。这里的“大于”、“小于”和“等于”是可以自定义的，完全取决于compare的具体定义，并不一定就是常规的逻辑，比如可以和正常逻辑相反。此外，该特质还有方法gt、gteq、lt和lteq，用于表示大于、大于等于、小于和小于等于，分别根据compare的结果来返回相应的布尔值。换句话说，如果一个对象里混入了Ordering[T]特质，并实现了自己需要的compare方法，就能省略定义很多其它相关的方法。</p>
<p>​        假设现在需要编写一个方法寻找“最大”的列表元素，并且具体行为会根据某个隐式Ordering[T]对象发生改变，那么可能定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>])(<span class="hljs-keyword">implicit</span> ordering: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)(ordering)  <span class="hljs-comment">// 参数ordering被显式传递</span><br>           <span class="hljs-keyword">if</span> (ordering.gt(x, maxRest)) x   <span class="hljs-comment">// 参数ordering被显式使用 </span><br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>​        在这里，读者只需关心两行带注释的代码。注意，函数maxList的第二个参数列表是隐式的，这就会让编译器在缺省给出时，自动在当前作用域下寻找一个Ordering[T]类型的对象。在第一行注释处，函数内部进行了自我调用，并且第二个参数仅仅只是传递了ordering，此时就可以利用隐式参数的特性，不必显式给出第二个参数的传递。</p>
<p>隐式导入的Predef对象里定义了下面这样一个函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">implicitly</span></span>[<span class="hljs-type">T</span>](<span class="hljs-keyword">implicit</span> t: <span class="hljs-type">T</span>) = t <br></code></pre></div></td></tr></table></figure>
<p>​        想要使用这个函数，可以只写成“implicitly[T]”的形式。只需要指明T是什么具体类型，在缺省参数的情况下，编译器会在当前作用域下自动寻找一个T类型的隐式对象传递给参数t，然后把这个对象返回。例如，implicitly[ORZ]就会把当前作用域下的隐式ORZ对象返回。既然函数maxList的第二个参数是编译器隐式插入的，那么第二行注释处也就没必要显式写出ordering，而可以改成“implicitly[Ordering[T]]”。</p>
<p>所以，一个更精简的maxList如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>])(<span class="hljs-keyword">implicit</span> ordering: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)  <br>           <span class="hljs-keyword">if</span> (implicitly[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]].gt(x, maxRest)) x <br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code>     现在，函数maxList的定义里已经完全不需要显式写出隐式参数的名字了，所以隐式参数可以改成任意名字，而函数体仍然保持不变。由于这个模式很常用，所以Scala允许省掉这个参数列表并改用上下文界定。形如“[T : Ordering]”的函数的类型参数就是一个上下文界定，它有两层含义：①和正常情况一样，先在函数中引入一个类型参数T。②为函数添加一个类型为Ordering[T]的隐式参数。例如：
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxList</span></span>[<span class="hljs-type">T</span> : <span class="hljs-type">Ordering</span>](elements: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =<br>    elements <span class="hljs-keyword">match</span> &#123;undefined<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;empty list!&quot;</span>)<br>       <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x) =&gt; x<br>       <span class="hljs-keyword">case</span> x :: rest =&gt;<br>           <span class="hljs-keyword">val</span> maxRest = maxList(rest)  <br>           <span class="hljs-keyword">if</span> (implicitly[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]].gt(x, maxRest)) x <br>           <span class="hljs-keyword">else</span> maxRest <br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>​        上下文界定与前面讲的上界和下界很像，但[T &lt;: Ordering[T]]表明T是Ordering[T]的子类型并且不会引入隐式参数，[T : Ordering]则并没有标定类型T的范围，而是说类型T与某种形式的排序相关，并且会引入隐式参数。</p>
<p>​        上下文界定是一种很灵活的语法，配合像Ordering[T]这样的特质以及隐式参数，可以实现各种功能而不需要改变定义的T类型。</p>
<h2 id="15-8-多个匹配的隐式定义"><a href="#15-8-多个匹配的隐式定义" class="headerlink" title="15.8 多个匹配的隐式定义"></a>15.8 多个匹配的隐式定义</h2><p>​        当多个隐式定义都符合条件时，编译器会发出定义模棱两可错误。但是如果其中一个比别的更加具体，那么编译器会自动选择定义更具体的隐式定义，且不会发出错误。所谓“具体”，只要满足两个条件之一便可：①更具体的定义，其类型是更模糊的定义的子类型。如果是隐式转换，比较的是参数类型，不是返回结果的类型。②子类中的隐式定义比超类中的隐式定义更具体。</p>
<p>定义模棱两可：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>z: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz = <span class="hljs-number">100</span><br>zz: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>&lt;console&gt;:<span class="hljs-number">14</span>: error: ambiguous <span class="hljs-keyword">implicit</span> values:<br> both value z of <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">Int</span></span><br> and value zz of <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">=&gt;</span> <span class="hljs-title">Int</span></span><br> <span class="hljs-keyword">match</span> expected <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Int</span></span><br>       <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>               ^<br></code></pre></div></td></tr></table></figure>
<p> 条件①：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>z: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz: <span class="hljs-type">Any</span> = <span class="hljs-number">100</span><br>zz: <span class="hljs-type">Any</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>a: <span class="hljs-type">A</span> = <span class="hljs-type">A</span><span class="hljs-meta">@fee</span>881<br><br>scala&gt; a.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
<p>条件②：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">implicit val x: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sup</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> z = <span class="hljs-number">10</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sup</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sup</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> zz = <span class="hljs-number">100</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Sup</span><br>a: <span class="hljs-type">Sup</span> = <span class="hljs-type">Sup</span>@<span class="hljs-number">789</span>dd6bf<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">Sub</span><br>b: <span class="hljs-type">Sub</span> = <span class="hljs-type">Sub</span>@<span class="hljs-number">772</span>cf46b<br><br>scala&gt; <span class="hljs-keyword">import</span> a._<br><span class="hljs-keyword">import</span> a._<br><br>scala&gt; <span class="hljs-keyword">import</span> b._<br><span class="hljs-keyword">import</span> b._<br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()<br>c: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">352</span>bea0e<br><br>scala&gt; c.x<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure>
<p>九、总结<br>隐式定义是一个很常用的Scala高级语法，尤其是在阅读、理解Chisel这样的DSL语言时，就不得不彻底搞明白自定义的隐式定义是如何工作的。即使是编写实际的硬件电路，像RocketChip的快速裁剪、配置功能，就是通过模式匹配加上隐式参数实现的。配置机制会在后续章节讲解。对于想掌握Chisel高级功能的读者，本章是学习的重点。</p>
<hr>
<p><img src="2022-3-4-scala/96717167_p0-16468039212541.jpg" srcset="/img/loading.gif" lazyload alt="背景图pixivid：96717167"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                      <a class="hover-with-bg" href="/categories/CS/Scala/">Scala</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                      <a class="hover-with-bg" href="/tags/CS/">CS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202203091915/IC/Chieslessay/cs/scala/2022-3-9-chisel/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Chisel（一）：初步</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202202281650/CS/Scalaessay/cs/scala/Scala2/">
                        <span class="hidden-mobile">Scala学习材料</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"right","width":250,"height":500,"vOffset":-100},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
