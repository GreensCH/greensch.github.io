

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="1 概论1.1 导论Scala来源于scalable（可扩展的）这个单词，它的可扩展性非常强   Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性  Scala比Java更加面向对象 Scala是一门函数式编程语言(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala) 同样运行在JVM上，可以与现存程序同时运行 可直">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala学习笔记">
<meta property="og:url" content="http://yoursite.com/202202260117/CS/Scalaessay/cs/scala/2022-02-10-scala/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="1 概论1.1 导论Scala来源于scalable（可扩展的）这个单词，它的可扩展性非常强   Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性  Scala比Java更加面向对象 Scala是一门函数式编程语言(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala) 同样运行在JVM上，可以与现存程序同时运行 可直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103912684.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301104056461.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110611005.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110658494.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301113507259.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301120214795.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301121507718.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
<meta property="article:published_time" content="2022-02-25T17:17:00.000Z">
<meta property="article:modified_time" content="2022-03-03T03:39:01.235Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png">
  
  <title>Scala学习笔记 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://note.youdao.com/yws/api/personal/file/FDCD397DDBAF4A06B8925394CCE654F7?method=download&shareKey=466c9494a628c54696edbf7f0f62e6f1') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Scala学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-26 01:17" pubdate>
        2022年2月26日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      31k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Scala学习笔记</h1>
            
            <div class="markdown-body">
              <h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><h2 id="1-1-导论"><a href="#1-1-导论" class="headerlink" title="1.1 导论"></a>1.1 导论</h2><p>Scala来源于scalable（可扩展的）这个单词，它的<strong>可扩展性非常强</strong> </p>
<ul>
<li><p>Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性</p>
<ul>
<li>Scala比Java更加<strong>面向对象</strong></li>
<li>Scala是一门<strong>函数式编程语言</strong>(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala)</li>
<li>同样运行在<strong>JVM</strong>上，可以与现存程序同时运行</li>
<li>可直接使用<strong>Java类库</strong></li>
<li>同Java一样<strong>静态类型</strong></li>
<li>语法和Java类似，比Java<strong>更加简洁</strong>（简洁而并不是简单），<strong>表达性更强</strong>。</li>
</ul>
</li>
<li><p>关注点</p>
<ul>
<li>类型推断、不变量、函数式编程、高级程序构造</li>
<li>并发：actor模型</li>
<li>和现有Java代码交互、相比Java异同和优缺</li>
</ul>
</li>
<li><p><del>Scala更适合大数据的处理</del></p>
<ul>
<li><del>Scala对<strong>集合</strong>类型数据处理有非常好的支持</del></li>
<li><del>Spark的底层用Scala编写</del></li>
</ul>
</li>
<li><p>和Java关系：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">        javac               java<br><span class="hljs-string">.java</span> <span class="hljs-params">--------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br><span class="hljs-string">.scala</span> <span class="hljs-params">-------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br>        scalac              scala<br></code></pre></div></td></tr></table></figure>
<ul>
<li>Java很多语法源自Cpp</li>
<li>Java面向对象不是很彻底，有八大基本数据类型，同时又有包装类型（继承自Object）</li>
<li>对更加复杂的高端应用</li>
<li><strong>函数式编程语言</strong>可以解决上述问题</li>
<li>Scala最重要的是引入了类型推断和lamuda表达式</li>
</ul>
</li>
</ul>
<h2 id="1-2-总结特点"><a href="#1-2-总结特点" class="headerlink" title="1.2 总结特点"></a>1.2 总结特点</h2><p>Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的<strong>静态类型编程语言</strong>（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）</p>
<ul>
<li>Scala是一门多范式的编程语言，Scla支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程、面向对像、泛型、函数式四种程序设计方法）</li>
<li>Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM文上，并可以调用现有的Java类库，实现两种语言的无缝对接。</li>
<li>Scala单作为一门语言来看，非常的简洁高效。</li>
<li>Scaa在设计时，马丁奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁奥德斯基也加入了自己的思想，将<strong>函数式编程语言的特点融合到JAVA</strong>中，因此，对于学习Java的同学，只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的拿握Scaa这门语言</li>
</ul>
<h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2 环境"></a>2 环境</h1><h2 id="2-1-交互式命令行"><a href="#2-1-交互式命令行" class="headerlink" title="2.1 交互式命令行"></a>2.1 交互式命令行</h2><ul>
<li>交互式执行环境（cmd直接输入scala）：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png" srcset="/img/loading.gif" lazyload alt="image-20220301103816193"></p>
<ul>
<li>定义常量</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103912684.png" srcset="/img/loading.gif" lazyload alt="image-20220301103912684"></p>
<ul>
<li>print</li>
</ul>
<p>对比Java的<code>system.out.println(&quot;&quot;);</code>确实简洁不少</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301104056461.png" srcset="/img/loading.gif" lazyload alt="image-20220301104056461"></p>
<ul>
<li>推出交互式执行环境</li>
</ul>
<figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">scala&gt; :<span class="hljs-keyword">quit</span><br></code></pre></div></td></tr></table></figure>
<h2 id="2-2-完整编译流程"><a href="#2-2-完整编译流程" class="headerlink" title="2.2 完整编译流程"></a>2.2 完整编译流程</h2><p>和Java差不多</p>
<p><strong>源程序</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//HelloScala.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloScala</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):<span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;hello scala&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>object</code>关键字：定义单例对象(直接定义对象而不是类)</li>
<li><code>def</code>关键字：声明函数或方法</li>
<li><code>args</code>：在类型前面，表明我们更关心参数而不是类型</li>
<li><code>:Array[String]</code>：Array集合类型，[String]一个泛型，表明内部是String的集合</li>
<li><code>:Unit</code>：返回值为void</li>
<li><code>=&#123;&#125;</code>：函数体</li>
<li>没有分号</li>
</ul>
<p><strong>编译生成字节码文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scalac HelloScala.scala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110611005.png" srcset="/img/loading.gif" lazyload alt="image-20220301110611005"></p>
<p>为什么有HelloScala$.class和HelloScala.class两个文件？</p>
<blockquote>
<p> 底层机制：</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av204775475">尚硅谷007Scala环境搭建（三）</a></p>
<p>HelloScala.class：要执行程序的入口类</p>
<p>HelloScala$.class：上面类所属类，被调用</p>
<p>进一步补充：</p>
<p>如果编译的话会生成2个<code>.class</code>字节码文件，<code>HelloScala.class</code>和<code>HelloScala$.class</code>。都是字节码但是不能通过<code>java</code>直接运行。但对于HelloWorld这个例子来说，java源代码编译而成的字节码是可以通过<code>scala</code>命令运行的。</p>
<p>原因是没有引入Scala的库，添加<code>classpath</code>就可以通过java执行scala编译成的字节码了：</p>
<figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">java -cp %SCALA_HOME%<span class="hljs-regexp">/lib/</span>scala-library.jar; HelloScala<br></code></pre></div></td></tr></table></figure>
<p>使用<a target="_blank" rel="noopener" href="http://java-decompiler.github.io/">Java Decompiler</a>反编译字节码到java源文件可以看到引入Scala库的逻辑。并且：</p>
<ul>
<li>scala源文件中的<code>HelloScala</code>对象编译后成为了一个类，但对象本身编译后就是生成的另一个类<code>HelloScala$</code>类的单例对象<code>HelloScala$.MODULE$</code>，称之为伴生对象。</li>
<li><code>HelloScala$</code>有一个<code>main</code>实例方法，<code>HelloScala</code>类的静态方法通过这个单例对象转调这个实例方法。完成打印。</li>
<li>Scala比Java更面向对象。</li>
</ul>
</blockquote>
<p><strong>运行</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scala HelloScala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110658494.png" srcset="/img/loading.gif" lazyload alt="image-20220301110658494"></p>
<p><strong>反编译</strong></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301113507259.png" srcset="/img/loading.gif" lazyload alt="image-20220301113507259"></p>
<hr>
<p><del>暂时不管项目配置，还是单文件编译执行为主，项目开发肯定要以包的形式组织可以使用IntelliJ IDEA开发，使用maven或者sbt进行项目配置</del></p>
<p>使用VSCode编辑器，安装插件Scala Syntax (official)和Scala (Mentals)</p>
<ul>
<li>新建文件<code>HelloScala.scala</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">object HelloScala &#123; <span class="hljs-comment">// HelloScala is a object, not a class, will create a </span><br>    <span class="hljs-function">def <span class="hljs-title">main</span><span class="hljs-params">(args : Array[<span class="hljs-keyword">String</span>])</span> : Unit =</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello,world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>可以使用插件CodeRunner直接快捷键运行。也可以在命令行编译为字节码后再运行：</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>HelloScala.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>helloScala<br></code></pre></div></td></tr></table></figure>
<ul>
<li>或者直接运行scala源文件：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">scala <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloScala</span>.</span></span>scala<br></code></pre></div></td></tr></table></figure>
<h1 id="3-变量与数据类型"><a href="#3-变量与数据类型" class="headerlink" title="3 变量与数据类型"></a>3 变量与数据类型</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><ul>
<li>和java一样</li>
<li><code>//</code> 单行</li>
<li><code>/* */</code> 多行</li>
<li><code>/** */</code> 文档，方法或者类前面，便于<code>scaladoc</code>生成文档。</li>
</ul>
<h2 id="3-2-变量与常量"><a href="#3-2-变量与常量" class="headerlink" title="3.2 变量与常量"></a>3.2 变量与常量</h2><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> [:VariableType] = value <span class="hljs-comment">// variable</span><br>val <span class="hljs-keyword">name</span> [:ConstantType] = value <span class="hljs-comment">// constant</span><br></code></pre></div></td></tr></table></figure>
<p>因为Scala的<strong>函数式编程</strong>要素，所以一个指导意见就是<strong>能用常量就不要用变量</strong></p>
<ul>
<li><strong>推断类型：</strong>声明变量时，类型可以省略，编译器会自动推导</li>
<li><strong>静态类型：</strong>类型<strong>经过给定或推导确定</strong>后就不能修改**</li>
<li><strong>初始化：</strong>变量和常量声明时，必须有初始值</li>
<li><strong>变量与常量：</strong>变量可变，常量不可变</li>
<li><strong>引用类型常量：</strong>不能改变常量指向的对象，可以改变对象的字段</li>
<li><strong>结尾：</strong>不以<code>;</code>作为语句结尾，scala编译器自动识别语句结尾</li>
</ul>
<h2 id="3-3-Scala的基本类型"><a href="#3-3-Scala的基本类型" class="headerlink" title="3.3 Scala的基本类型"></a>3.3 Scala的基本类型</h2><p><strong>静态语言</strong></p>
<p>​    Scala是<strong>静态语言</strong>，在编译期间会检查每个对象的类型。对于类型不匹配的非法操作，在编译时就能被发现。对于动态语言而言，这种非法操作需要等到运行时才能被发现，此时可能造成严重错误</p>
<p>​    静态语言相比诸如Python这样的动态语言在某些方面是有优势的。对于Chisel而言，我们就需要这种优势。因为Chisel需要编译成Verilog，我们不能产生非法的Verilog语句并且等到模块运行时才去发现它</p>
<hr>
<p><strong>基本类型</strong></p>
<p>​    Scala标准库定义了一些基本类型，如下表所示。除了“<strong>String”</strong>类型是属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=java&amp;spm=1001.2101.3001.7020">java</a>.lang包之外，其余都在Scala的包里。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301120214795.png" srcset="/img/loading.gif" lazyload alt="image-20220301120214795"></h2><p><strong>定义变量</strong></p>
<p>​    事实上，在定义变量时，应该指明变量的类型，只不过Scala的编译器具有自动推断类型的功能，可以根据赋给变量的对象的类型，来自动推断出变量的类型。</p>
<p>​    如果要显式声明变量的类型，或者无法推断时，则只需在变量名后面加上一个冒号“ : ”，然后在等号与冒号之间写出类型名即可。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br>x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> y: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;123&quot;</span><br>y: <span class="hljs-type">String</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br>z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>字面量</strong></p>
<p>​    <strong>整数</strong>有四种类型，<strong>默认情况下推断为Int</strong>类型。如果字面量的结尾有<strong>“l”</strong>或者<strong>“L”</strong>，则推断为<strong>Long</strong>类型。此外，<strong>Byte</strong>和<strong>Short</strong>则<strong>需要定义变量时显式声明</strong>。注意，赋给的字面值不能超过类型的表示范围。</p>
<p>​    整数字面量默认是十进制的，但如果以“0x”或者“0X”开头，则字面量被认为是十六进制。十六进制的字母不区分大小写。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">100</span><br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">0X123Abc</span><br>b: <span class="hljs-type">Int</span> = <span class="hljs-number">1194684</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Int</span>(<span class="hljs-number">200</span>)<br> required: <span class="hljs-type">Byte</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>                     ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-number">200</span>L<br>d: <span class="hljs-type">Long</span> = <span class="hljs-number">200</span><br><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>浮点数</strong>的字面量<strong>都是十进制</strong>的，类型<strong>默认是Double</strong>类型。可以增加一个字母<strong>“e”</strong>或<strong>“E”</strong>，再添加一个整数作为指数，这样就构成10的n次幂。最末尾可以写一个<strong>“f”</strong>或者<strong>“F”</strong>，表示Float类型；也可以写一个<strong>“d</strong>”或者<strong>“D”</strong>，表示Double类型。</p>
<blockquote>
<p>注意，Double类型的字面量不能赋给Float类型的变量。虽然Float允许扩展成Double类型，但是会发生精度损失</p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301121507718.png" srcset="/img/loading.gif" lazyload alt="image-20220301121507718"></p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">1.2E3</span><br>a: <span class="hljs-type">Double</span> = <span class="hljs-number">1200.0</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">-3.2</span>f<br>b: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Double</span>(<span class="hljs-number">-3.2</span>)<br> required: <span class="hljs-type">Float</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.2</span>F<br>d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.200000047683716</span><br></code></pre></div></td></tr></table></figure>
<p><strong>字符字面量</strong></p>
<div class="hljs code-wrapper"><pre><code> **字符**字面量是以**单引号&#39; &#39;**包起来的一个字符，Scala中字符采用Unicode编码，可以用**&#39;\u&#39;编码号&#39;**的方式来**转义**一个Unicode字符，而且**Unicode编码**可以出现在代码的任何地方，甚至是名称命名。此外，还支持转义字符。例如
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = &#x27;<span class="hljs-type">A</span>&#x27;<br>a: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = &#x27;\u0041&#x27; <span class="hljs-comment">// \u0041对应Unicode的A</span><br>b: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = &#x27;\u0042&#x27;<br>c: <span class="hljs-type">Char</span> = <span class="hljs-type">B</span><br><br>scala&gt; <span class="hljs-keyword">val</span> \u0041\u0042 = <span class="hljs-number">1</span> <span class="hljs-comment">// 使用\u构造的Unicode字符作为变量名称</span><br><span class="hljs-type">AB</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; <span class="hljs-keyword">val</span> d = &#x27;\\&#x27; <span class="hljs-comment">//转义字符字符</span><br>d: <span class="hljs-type">Char</span> = \<br></code></pre></div></td></tr></table></figure>
<p><strong>字符串字面量</strong></p>
<p>​    <strong>字符串</strong>就是用<strong>双引号” “</strong>包起来的字符序列，长度任意，允许掺杂转义字符。此外，也可以用前后各<strong>三个双引号””” “””</strong>包起来，这样字符串里也能出现双引号，而且转义字符不会被解读</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;\\\\\\&quot;</span><br>a: <span class="hljs-type">String</span> = \\\<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;&quot;&quot;So long \u0041 String \\\&#x27;\&quot;!&quot;&quot;&quot;</span><br>b: <span class="hljs-type">String</span> = <span class="hljs-type">So</span> long <span class="hljs-type">A</span> <span class="hljs-type">String</span> \\\&#x27;\<span class="hljs-string">&quot;!</span><br></code></pre></div></td></tr></table></figure>
<p><strong>字符串插值</strong></p>
<p>​    Scala包括了一个灵活的机制来支持字符串插值，这使得<strong>表达式可以被嵌入在字符串字面量中并被求值</strong>。</p>
<ul>
<li>第一种形式是<strong>s插值器</strong>，即在字符串的双引号前加一个s，形如<strong>s“…${表达式}…”</strong>，s插值器会对内嵌的每个表达式求值，对<strong>求值结果</strong>调用内置的<strong>toString</strong>方法，替换掉字面量中的表达式。从<u>美元符号开始到首个非标识符字符</u>（字母、数字、下划线和操作符的组合，以及反引号对包起来的字符串，称为<strong>标识符</strong>）的部分会被当作表达式，如果有非标识符字符，就必须放在花括号里，且左花括号要紧跟美元符号</li>
<li>第二种形式是<strong>raw插值器</strong>，它与s插值器类似，只不过不识别转义字符</li>
<li>第三种形式是<strong>f插值器</strong>，允许给内嵌的表达式加上printf风格的指令，<strong>指令</strong>放在表达式之后并<strong>以百分号开始</strong>。指令语法来自java.util.Formatter</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;ABC&quot;</span><br>name: <span class="hljs-type">String</span> = <span class="hljs-type">ABC</span><br><br>scala&gt; println(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span> DEFG&quot;</span>)<br><span class="hljs-type">ABC</span> <span class="hljs-type">DEFG</span><br><br>scala&gt; <span class="hljs-string">s&quot;Sum = <span class="hljs-subst">$&#123;1 + 10&#125;</span>&quot;</span> <span class="hljs-comment">//</span><br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Sum</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-string">s&quot;\\\\&quot;</span><br>res1: <span class="hljs-type">String</span> = \\<br><br>scala&gt; <span class="hljs-string">raw&quot;\\\\&quot;</span>    <span class="hljs-comment">// raw插值器</span><br>res2: <span class="hljs-type">String</span> = \\\\<br><br>scala&gt; printf(<span class="hljs-string">f&quot;<span class="hljs-subst">$&#123;math.Pi&#125;</span>%.5f&quot;</span>)    <span class="hljs-comment">// f插值器  %.5f是printf风格，保留小数点后5位</span><br><span class="hljs-number">3.14159</span><br></code></pre></div></td></tr></table></figure>
<h1 id="4-函数及其几种形式"><a href="#4-函数及其几种形式" class="headerlink" title="4 函数及其几种形式"></a>4 函数及其几种形式</h1><h2 id="4-1-定义一个函数"><a href="#4-1-定义一个函数" class="headerlink" title="4.1 定义一个函数"></a>4.1 定义一个函数</h2><p><strong>(1) 定义一个函数</strong></p>
<p>​    Scala的函数定义以<strong>“def”</strong>开头，然后是一个自定义的函数名(推荐驼峰命名法)，接着是用圆括号“( )”包起来的参数列表。在参数列表里，多个参数用逗号隔开，并且每个参数名后面<strong>要紧跟一个冒号以及显式声明的参数类型</strong>，因为编译器在编译期间无法推断出入参类型。写完参数列表后，应该紧跟一个冒号，再添加函数返回结果的类型。最后，再写一个等号“=”，等号后面是用花括号“{ }”包起来的函数体。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">用“<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">”开始函数定义</span></span><br>       | 函数名<br>       |   |  参数及参数类型<br>       |   |        |   函数返回结果的类型<br>       |   |        |          |  等号<br>       |   |        |          |   |<br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        <span class="hljs-keyword">if</span>(x &gt; y)<br>          x<br>        <span class="hljs-keyword">else</span>  |<br>          y   | <br>      &#125;       |<br>              |<br>       花括号里定义函数体<br></code></pre></div></td></tr></table></figure>
<p><strong>(2) 分号推断</strong></p>
<p>​    在Scala的代码里，<strong>语句末尾的分号是可选的</strong>，因为编译器会自动推断分号。如果一行只有一条完整的语句，那么分号可写可不写；如果<strong>一行有多条语句，则必须用分号隔开</strong>，有三种情况句末<strong>不会推断出分号</strong>：</p>
<ul>
<li><strong>句末</strong>是以非法结尾字符结尾，例如以句点符号“.”或中缀操作符结尾</li>
<li><strong>下一行的句首</strong>是以非法起始字符开始，例如以句点符号“.”开头</li>
<li><strong>跨行</strong>出现的圆括号对“( )”或者方括号对“[ ]”，因为它们里面不能进行分号的自动推断，要么只包含一条完整语句，要么包含用分号显式隔开的多条语句。另外，花括号对“{ }”的里面可以进行分号的自动推断</li>
</ul>
<p>​    为了简洁起见，同时不产生无意的错误和歧义，<strong>建议一行只写一条完整的语句</strong>，句末分号省略，让编译器自动推断。而且内层的语句最好比外一层语句向内缩进两个空格，使得代码层次分明。</p>
<p><strong>(3) 函数返回结果</strong></p>
<p>​    在Scala里，<strong>“return”关键字也是可选的</strong>。默认情况下，编译器会自动为函数体里的最后一个表达式加上“return”，将其作为返回结果。<strong>建议不要显式声明“return”</strong>，这会引发warning，而且使得代码风格看上去像指令式风格。</p>
<p>​    <strong>返回结果的类型</strong>也是可以根据参数类型和返回的表达式来<strong>自动推断</strong>的，也就是说，上例中的“: Int”通常是可以省略的。</p>
<p>​    返回结果<strong>Unit</strong>，表示没有值返回。也就是说，这是一个有副作用的函数，并不能提供任何可引用的返回结果。Unit类型同样可以被推断出来，但如果显式声明为Unit类型的函数，则即使函数体最后有一个可以返回具体值的表达式，也不会把表达式的结果返回。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123; x + y &#125;<br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123; x + y &#125;<br>nothing: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; nothing(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>(4) 函数体与等号</strong></p>
<p>​    Scala的<strong>函数体是用花括号</strong>包起来的，这与C、C++、Java等语言类似。函数体里可以有多条语句，并自动推断分号、返回最后一个表达式。如果<strong>只有一条语句，那么花括号也可以省略</strong>。</p>
<p>​    Scala的<strong>函数定义还有一个等号</strong>，这使得它看起来类似数学里的函数“f(x) = …”。当函数的返回类型没有显式声明时，那么这个<strong>等号可以省略，但是返回类型一定会被推断成Unit类型</strong>，不管有没有值返回，而且<strong>函数体必须有花括号</strong>。当函数的返回类型显式声明时，则无论如何<strong>都不能省略等号</strong>。<strong>建议写代码时不要省略等号</strong>，避免产生不必要的错误，返回类型最好也显式声明。</p>
<p>总结：</p>
<ul>
<li>花括号：<ul>
<li>可以省略：只有一条语句</li>
<li>不可以省略：省略”=”时</li>
</ul>
</li>
<li>“=”：<ul>
<li>可以省略：返回值没有显式声明，此时返回值一定是Unit类型</li>
<li>不可以省略：返回值显式声明</li>
</ul>
</li>
</ul>
<p><strong>(5) 无参函数</strong></p>
<p>​    <strong>无参函数</strong>可以<strong>写一个空括号作参数列表</strong>，或者<strong>不写</strong>。如果有空括号，那么调用时可以写也可以不写空括号；如果没有空括号，那么调用时就一定不能写空括号。原则上，<strong>无副作用</strong>的无参函数<strong>省略括号</strong>，<strong>有副作用</strong>的无参函数<strong>添加括号</strong>，这提醒使用者需要额外小心</p>
<p>无参函数总结：</p>
<ul>
<li>写括号<ul>
<li>建议有副作用函数</li>
<li>调用时可以不写括号，也可以写括号</li>
</ul>
</li>
<li>不写括号<ul>
<li>建议无副作用函数</li>
<li>调用时只可以不写括号</li>
</ul>
</li>
</ul>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>​    方法其实就是定义在class、object、trait里面的函数，这种函数叫做“成员函数”或者“方法”，与多数oop(object-oriented programming)语言一样</p>
<h2 id="4-3-嵌套函数"><a href="#4-3-嵌套函数" class="headerlink" title="4.3 嵌套函数"></a>4.3 嵌套函数</h2><p>​    函数体内部还可以定义函数，这种函数的<strong>作用域是局部的</strong>，<strong>只能被定义它的外层函数调用</strong>，<strong>外部无法</strong>访问。局部函数可以直接使用外层函数的参数，也可以直接使用外层函数的内部变量。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addSub</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span></span>(z: <span class="hljs-type">Int</span>) = z - <span class="hljs-number">10</span><br>         |     <span class="hljs-keyword">if</span>(x &gt; y) sub(x - y) <span class="hljs-keyword">else</span> sub(y - x)<br>         | &#125;<br>addSub: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addSub(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">70</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-4-函数字面量"><a href="#4-4-函数字面量" class="headerlink" title="4.4 函数字面量"></a>4.4 函数字面量</h2><p>​    <strong>函数式编程</strong>有两个主要思想，其中之一就是：<strong>函数是一等(first-class)的值</strong>。换句话说，一个函数的地位与一个Int值、一个String值等等，是一样的（既然一个Int值可以成为函数的参数、函数的返回值、定义在函数体里、存储在变量里，那么，作为地位相同的函数，也可以这样）。</p>
<p>​    你可以把<strong>一个函数当参数</strong>传递给另一个函数，也可以让一个函数<strong>返回一个函数</strong>，亦可以把<strong>函数赋给一个变量</strong>，又或者像定义一个值那样<strong>在函数里定义别的函数</strong>(即前述的嵌套函数)。就像写一个整数字面量“1”那样，Scala也可以<strong>定义函数的字面量</strong>。<strong>函数字面量是一种匿名函数的形式</strong>，它可以存储在变量里、成为函数参数或者当作函数返回值，其定义形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(参数<span class="hljs-number">1</span>: 参数<span class="hljs-number">1</span>类型, 参数<span class="hljs-number">2</span>: 参数<span class="hljs-number">2</span>类型, ...) =&gt; &#123; 函数体 &#125;<br></code></pre></div></td></tr></table></figure>
<p>​    <strong>通常，函数字面量会赋给一个变量</strong>，这样就能通过“变量名(参数)”的形式来使用函数字面量。在参数类型可以被推断的情况下，可以省略类型，并且参数只有一个时，圆括号也可以省略。</p>
<ul>
<li>圆括号省略：参数只有一个时</li>
<li>类型省略：类型可以被推断时</li>
</ul>
<p>​    <strong>只保留函数体时</strong>，<strong>用下划线“_”作为占位符来代替参数</strong>。在<strong>参数类型不明确时</strong>，需要在下划线后面显式声明其类型。<strong>多个占位符代表多个参数(占位符也可以在大括号函数体内)</strong>，即第一个占位符是第一个参数，第二个占位符是第二个参数……因此不能重复使用某个参数。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> f = (_: <span class="hljs-type">Int</span>) + (_: <span class="hljs-type">Int</span>)<br>f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1072</span>/<span class="hljs-number">1534177037</span><span class="hljs-meta">@fb</span>42c1c<br><br>scala&gt; f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>函数字面量作为返回值：</strong>无论是用“def”定义的函数，还是函数字面量，它们的函数体都可以把一个函数字面量作为一个返回结果，这样就成为了返回函数的函数；它们的参数变量的类型也可以是一个函数，这样调用时给的入参就可以是一个函数字面量。类型为函数的变量，其冒号后面的类型写法是“(参数1类型, 参数2类型,…) =&gt; 返回结果的类型”。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> add = (x: <span class="hljs-type">Int</span>) =&gt; &#123; (y: <span class="hljs-type">Int</span>) =&gt; x + y &#125;<br>add: <span class="hljs-type">Int</span> =&gt; (<span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1192</span>/<span class="hljs-number">1767705308</span>@<span class="hljs-number">55456711</span><br><br>scala&gt; add(<span class="hljs-number">1</span>)(<span class="hljs-number">10</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aFunc</span></span>(f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>aFunc: (f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; aFunc(x =&gt; x + <span class="hljs-number">1</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>​    在第一个例子中，变量add被赋予了一个返回函数的函数字面量。在调用时，第一个括号里的“1”是传递给参数x，第二个括号里的“10”是传递给参数y。如果没有第二个括号，得到的就不是11，而是“(y: Int) =&gt; 1 + y”这个函数字面量。</p>
<p>​    在第二个例子中，函数aFunc的参数f是一个函数，并且该函数要求是一个入参为Int类型、返回结果也是Int类型的函数。在调用时，给出了函数字面量“x =&gt; x + 1”。这里没有显式声明x的类型，因为可以通过f的类型来推断出x必须是一个Int类型。在执行时，首先求值f(1)，结合参数“1”和函数字面量，可以算出结果是2。那么，“f(1) + 1”就等于3了。</p>
<h2 id="4-5-部分应用函数"><a href="#4-5-部分应用函数" class="headerlink" title="4.5 部分应用函数"></a>4.5 部分应用函数</h2><p>​    部分应用函数（使得def函数实现函数一等值效果）：给出一部分参数的情况下，赋值给一个变量</p>
<p>​    上面介绍的函数字面量实现了函数作为一等值的功能，而用“def”定义的函数也具有同样的功能，只不过需要借助部分应用函数的形式来实现。例如，有一个函数定义为“def max(…) …”，若想要把这个函数存储在某个变量里，不能直接写成“val x = max”的形式，而<strong>必须像函数调用那样，给出一部分参数</strong>，故而称作<strong>部分应用函数</strong>(如果参数全给了，就成了函数调用)。<strong>部分应用函数的作用</strong>，就是把def函数打包到一个函数值里，使它可以赋给变量，或当作函数参数进行传递。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//定义了一个函数</span><br>sum: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = sum(<span class="hljs-number">1</span>, _: <span class="hljs-type">Int</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">//提供了一个参数</span><br>b: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1204</span>/<span class="hljs-number">1037479646</span>@<span class="hljs-number">5</span>b0bfe86<br><br>scala&gt; b(<span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = sum _   <span class="hljs-comment">//一个参数都没有给出，像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</span><br>c: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1208</span>/<span class="hljs-number">1853277442</span>@<span class="hljs-number">5e4</span>c26a1<br><br>scala&gt; c(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<p>​    变量a其实是获得了函数sum调用的返回结果，变量b则是获得了部分应用函数打包的sum函数，因为只给出了参数x和z的值，参数y没有给出。注意，<strong>没给出的参数用下划线代替，而且必须显式声明参数类型</strong>。变量c也是部分应用函数，只不过一个参数都没有明确给出。<strong>像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</strong>，注意函数名和下划线之间必须有空格。</p>
<p>​    如果部分应用函数一个参数都没有给出，比如例子中的c，那么在需要该函数作入参的地方，下划线也可以省略（注：不要和前面给变量赋值的部分应用函数混淆，前者需要有下划线）。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">needSum</span></span>(f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>needSum: (f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br><span class="hljs-comment">//在需要c函数作入参的地方</span><br><br>scala&gt; needSum(sum _) <span class="hljs-comment">//下划线</span><br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; needSum(sum) <span class="hljs-comment">//省略下划线</span><br>res3: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-6-闭包"><a href="#4-6-闭包" class="headerlink" title="4.6 闭包"></a>4.6 闭包</h2><p>​    一个函数除了可以使用它的参数外，还能<strong>使用定义在函数以外的其他变量</strong>。</p>
<ul>
<li><p>函数的参数称为<strong>绑定变量</strong>，因为完全可以根据函数的定义得知参数的信息</p>
</li>
<li><p>函数以外的变量称为<strong>自由变量</strong>，因为函数自身无法给出这些变量的定义</p>
</li>
</ul>
<p>​    这样的函数称为<strong>闭包</strong>，因为它要在运行期间捕获自由变量，让函数闭合，定义明确。自由变量必<strong>须在函数前面定义</strong>，否则编译器就找不到，会报错。</p>
<p>​    闭包捕获的自由变量是闭包创建时活跃的那个自由变量，后续若<strong>新建同名的自由变量来覆盖前面的定义</strong>，由于闭包已经闭合完成，所以新自由变量与已创建的闭包无关。如果闭包捕获的自由变量本身是一个可变对象(例如var类型变量)，那么闭包会随之改变。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> more = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">val</span> addMore = (x: <span class="hljs-type">Int</span>) =&gt; x + more  <span class="hljs-comment">// addMore = x + 1</span><br><br>more = <span class="hljs-number">2</span>                                           <span class="hljs-comment">// addMore = x + 2</span><br><br><span class="hljs-keyword">var</span> more = <span class="hljs-number">10</span>                                   <span class="hljs-comment">// addMore = x + 2</span><br><br>more = <span class="hljs-number">-100</span>                                      <span class="hljs-comment">// addMore = x + 2</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-7-函数的体术调用形式"><a href="#4-7-函数的体术调用形式" class="headerlink" title="4.7 函数的体术调用形式"></a>4.7 函数的体术调用形式</h2><p><strong>（1）具名参数</strong>（就是普通用法）</p>
<p>​    <strong>普通函数</strong>调用形式是<strong>按参数的先后顺序逐个传递的</strong>，但如果调用时显式声明参数名并给其赋值，则可以无视参数顺序。按位置传递的参数和按名字传递的参数可以混用，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(<span class="hljs-number">1</span>, z = <span class="hljs-number">10</span>, y = <span class="hljs-number">100</span>)<br>y is maximum <br></code></pre></div></td></tr></table></figure>
<p><strong>（2）默认参数值（和以前学的一样）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(y = <span class="hljs-number">3</span>, z = <span class="hljs-number">5</span>)<br>x is maximum<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）重复参数（类似C中的arg*）</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">Scala允许把函数的最后一个参数标记为重复参数，其形式为在最后一个参数的类型后面加上星号“*”。重复参数的意思是可以在运行时传入任意个相同类型的元素，包括零个。类型为“<span class="hljs-built_in">T</span>*”的参数的实际类型是“Array[<span class="hljs-built_in">T</span>]”，即若干个<span class="hljs-built_in">T</span>类型对象构成的数组。尽管是<span class="hljs-built_in">T</span>类型的数组，但要求传入参数的类型仍然是<span class="hljs-built_in">T</span>。如果传入的实参是<span class="hljs-built_in">T</span>类型对象构成的数组，则会报错，除非用“变量名<span class="hljs-symbol">:</span> <br></code></pre></div></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addMany</span></span>(msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*) = &#123;undefined<br>         |     <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>         |     <span class="hljs-keyword">for</span>(x &lt;- num) sum += x<br>         |     println(msg + sum)<br>         |  &#125;<br>addMany: (msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*)<span class="hljs-type">Unit</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>sum = <span class="hljs-number">6</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>)<br>sum = <span class="hljs-number">0</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]<br> required: <span class="hljs-type">Int</span><br>       addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>                              ^<br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): _*)<br>sum = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-8-柯里化"><a href="#4-8-柯里化" class="headerlink" title="4.8 柯里化"></a>4.8 柯里化</h2><p>​    对大多数编程语言来说，<strong>函数只能有一个参数列表</strong>，但是列表里可以有若干个用逗号间隔的参数。</p>
<p>​    Scala有一个独特的语法——<strong>柯里化</strong>，也就是一个函数可以<strong>有任意个参数列表</strong>。</p>
<p>​    柯里化往往与另一个语法结合使用：当参数列表里只有一个参数时，在调用该函数时允许单个参数不用圆括号包起来，改用花括号也是可行的。</p>
<p>​    这样做的<strong>好处是</strong>：在自定义类库时，自定义方法就好像“if(…) {…}”、“while(…) {…}”、“for(…) {…}”等内建控制结构一样，让人看上去<strong>以为是内建控制</strong>，丝毫看不出是自定义语法。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//普通相加函数</span><br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addCurry</span></span>(x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//柯里化，addCurry拥有三个参数列表</span><br>addCurry: (x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) &#123;<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//用&#123;&#125;代替()的参数列表，从而表现得if,while,for等内建结构一样</span><br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-9-传名参数（把函数作为形参情况下的简洁用法）"><a href="#4-9-传名参数（把函数作为形参情况下的简洁用法）" class="headerlink" title="4.9 传名参数（把函数作为形参情况下的简洁用法）"></a>4.9 传名参数（把函数作为形参情况下的简洁用法）</h2><p>​    4.4介绍了<strong>函数字面量</strong>如何作为函数的参数进行传递，以及如何表示类型为函数时参数的类型。如果某个函数的入参类型是一个无参函数，那么通常的类型表示法是“() =&gt; 函数的返回类型”。在调用这个函数时，给出的参数就必须写成形如<strong>“() =&gt; 函数体”</strong>这样的函数字面量</p>
<p><strong>（1）传名参数是什么</strong></p>
<p>​    <strong>为了让代码看起来更舒服</strong>，也为了让自定义控制结构<strong>更像内建结构</strong>，Scala又提供了一个特殊语法——<strong>传名参数</strong>。</p>
<p>​    <strong>传名参数</strong>是类型是一个无参函数的<strong>函数入参</strong>。传名参数的类型表示法是<strong>“=&gt; 函数的返回类型”</strong>，即<strong>相对常规表示法去掉了前面的空括号</strong>。在调用该函数时，传递进去的函数字面量则可以只写“函数体”，去掉了“() =&gt;”。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> assertionEnabled = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// predicate是类型为无参函数的函数入参</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAssert</span></span>(predicate: () =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 常规版本的调用</span><br>myAssert(() =&gt; <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br><br> <span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// 传名参数的用法，注意因为去掉了空括号，所以调用predicate时不能有括号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byNameAssert</span></span>(predicate: =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 传名参数版本的调用，看上去更自然</span><br>byNameAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p> <strong>（2）调用函数与传名参数的一致性写法</strong></p>
<p>​    可以看到，传名参数使得代码更加简洁、自然，而常规写法则很别扭。事实上，predicate的类型可以改成Boolean的<strong>一个变量</strong>，而不必是一个<strong>返回Boolean的函数</strong>，这样<strong>调用函数时与传名参数是一致的</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 使用布尔型参数的版本</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boolAssert</span></span>(predicate: <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><span class="hljs-comment">// 布尔型参数版本的调用</span><br>boolAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）调用机制说明</strong></p>
<p>​    尽管byNameAssert和boolAssert在调用形式上是一样的，但是两者的运行机制却不完全一样。如果给函数的实参是一个表达式，比如“5 &gt; 3”这样的表达式，那么boolAssert在运行之前会先对表达式求值，然后把求得的值传递给函数去运行。而myAssert和byNameAssert则不会一开始就对表达式求值，它们是直接运行函数，直到函数调用入参时才会对表达式求值，也就是例子中的代码运行到“!predicate”时才会求“5 &gt; 3”的值。</p>
<p>​    为了说明这一点，可以传入一个产生异常的表达式，例如除数为零的异常。例子中，逻辑与“&amp;&amp;”具有短路机制：如果&amp;&amp;的左侧是false，那么直接跳过右侧语句的运行(事实上，这种短路机制也是通过传名参数实现的)。所以，布尔型参数版本会抛出除零异常，常规版本和传名参数版本则不会发生任何事。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code> 如果把变量assertionEnabled设置为true，让&amp;&amp;右侧的代码执行，那么三个函数都会抛出除零异常：
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; assertionEnabled = <span class="hljs-literal">true</span><br>assertionEnabled: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res30$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .myAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res31$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .byNameAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure>
<h2 id="4-10-总结"><a href="#4-10-总结" class="headerlink" title="4.10 总结"></a>4.10 总结</h2><p>​    本章内容是对Scala的函数的讲解，重点在于理解函数作为一等值的概念，函数字面量的作用以及部分应用函数的作用。在阅读复杂的代码时，常常遇见诸如<strong>“def xxx(f: T =&gt; U, …) …”或 “def xxx(…): T =&gt; U”</strong>的代码，要理解前者表示需要传入一个函数作为参数，后者表示函数返回的对象是一个函数。在学习初期，理解函数是一等值的概念可能有些费力，通过大量阅读和编写代码才能熟能生巧。同时不要忘记前一章说过，<strong>函数的参数都是val类型的，在函数体内不能修改传入的参数。</strong></p>
<h1 id="5-类和对象"><a href="#5-类和对象" class="headerlink" title="5 类和对象"></a>5 类和对象</h1><h2 id="5-1-类"><a href="#5-1-类" class="headerlink" title="5.1 类"></a>5.1 类</h2><p>说了一堆废话，和Java差不多就是</p>
<blockquote>
<p>​        在Scala里，类是用关键字<strong>“class”</strong>开头的代码定义。它是对象的<strong>蓝图</strong>，一旦定义完成，就可以通过<strong>“new 类名”</strong>的方式来<strong>构造一个对象</strong>。而这个对象的类型，就是这个类。换句话说，一个类就是一个类型，不同的类就是不同的类型。在后续的章节中，会讲到类的继承关系，以及超类、子类和子类型多态的概念。</p>
<p>​    在类里可以定义val或var类型的变量，它们被称为“<strong>字段</strong>”；还可以定义“def”函数，它们被称为<strong>“方法”</strong>；字段和方法统称<strong>“成员”</strong>。字段通常用于保存对象的状态或数据，而方法则用于承担对象的计算任务。<strong>字段也叫“实例变量”</strong></p>
</blockquote>
<p>​    <strong>介绍对象在操作系统中的情况：</strong></p>
<blockquote>
<p>因为每个被构造出来的对象都有其自己的字段。在运行时，操作系统会为每个对象分配一定的内存空间，用于保存对象的字段。方法则不同，对所有对象来说，方法都是一样的程序段，因此不需要为某个对象单独保存其方法。而且，方法的代码只有在被调用时才会被执行，如果一个对象在生命周期内都没有调用某些方法，那么完全没必要浪费内存为某个对象去保存这些无用的代码</p>
</blockquote>
<p>​    <strong>访问对象：</strong></p>
<p>​    <strong>需要注意的是</strong>，val类型的变量只能与初始化时的对象绑定，<strong>不能再被赋予新的对象（相同类也不行）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">1</span>a2e563e<br><br>scala&gt; stu.name<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">None</span><br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>res2: <span class="hljs-type">String</span> = <span class="hljs-type">Bob</span><br><br>scala&gt; stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>  <span class="hljs-comment">//无法重新赋值给一个变量</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: reassignment to <span class="hljs-keyword">val</span><br>       stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>           ^<br></code></pre></div></td></tr></table></figure>
<p>​    Scala的<strong>类成员默认都是公有的</strong>，<strong>没有“public”这个关键字</strong>，有private作为私有成员，示例代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(name)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">75063</span>bd0<br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: variable name in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">cannot</span> <span class="hljs-title">be</span> <span class="hljs-title">accessed</span> <span class="hljs-title">in</span> <span class="hljs-title">Students</span></span><br>       stu.name<br>           ^<br><br>scala&gt; stu.display<br><span class="hljs-type">Bob</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-2-类的构造方法"><a href="#5-2-类的构造方法" class="headerlink" title="5.2 类的构造方法"></a>5.2 类的构造方法</h2><p><strong>（1）主构造方法</strong></p>
<ul>
<li><p>Scala不需要显式定义构造方法 ，而是把<strong>类内部非字段、非方法的代码都</strong>当作<strong>“主构造方法”</strong></p>
<ul>
<li><strong>大白话</strong>：没有用函数框框起来的都是主构造方法</li>
</ul>
</li>
<li><p>类名后面可以定义<strong>若干个参数列表</strong>，用于接收参数，这些参数将在构造对象时用于初始化字段并传递给主构造方法使用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-type">A</span> student named <span class="hljs-type">Tom</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">5464</span>eb28<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>（了解）在这个例子中，Students类接收一个String参数n，并用n来初始化字段name。这样做，就无需像之前那样把name定义成var类型，而是使用函数式风格的val类型，而且不再需要一个register方法在构造对象时来更新name的数据</p>
<p>函数println既不是字段，也不是方法定义，所以被当成是主构造函数的一部分。在构造对象时，主构造函数被执行，因此在解释器里打印了相关信息</p>
</blockquote>
<p><strong>（2）辅助构造方法</strong></p>
<p>​    除了主构造方法，<strong>还可以定义若干个辅助构造方法</strong>。辅助构造方法都是以<strong>“def this(……)”</strong>来开头的，而且<strong>第一步行为必须是调用该类的另一个构造方法</strong>，即第一条语句必须是“this(……)”——要么是主构造方法，要么是之前的另一个辅助构造方法。这种规则的结果就是任何构造方法<strong>最终都会调用该类的主构造方法</strong>，使得主构造方法成为类的<strong>单一入口</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;None&quot;</span>) <span class="hljs-comment">//辅助构造方法</span><br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br><span class="hljs-type">A</span> student named <span class="hljs-type">None</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">74309</span>cd5<br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在这个例子中，定义了一个辅助构造方法，该方法是无参的，其行为也仅是给主构造方法传递一个字符串“None”。在后面创建对象时，缺省了参数，这样与主构造方法的参数列表是不匹配的，但是与辅助构造方法匹配，所以stu指向的对象是用辅助构造方法构造的。</p>
<p>在Java里，辅助构造方法可以调用超类的构造方法，而Scala加强了限制，只允许主构造方法调用超类的构造方法(详情见后续章节)。这种限制源于Scala为了代码简洁性与简单性做出的折衷处理。</p>
</blockquote>
<p><strong>（3）析构函数</strong>（也就是没有）</p>
<p>​    因为Scala没有指针，同时使用了Java的垃圾回收器，所以不需要像C++那样定义析构函数</p>
<p><strong>（4）私有主构造方法</strong></p>
<p>​    在<strong>类名与类的参数列表之间</strong>加上关键字<strong>“private”</strong>，那么<strong>主构造方法</strong>就是<strong>私有的</strong>，<strong>只能被内部定义访问</strong>，外部代码构造对象时就<strong>不能通过主构造方法进行</strong>，而<strong>必须使用其他公有的辅助构造方法或工厂方法</strong>(专门用于构造对象的方法)。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">private</span> (<span class="hljs-params">n: <span class="hljs-type">String</span>, m: <span class="hljs-type">Int</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">val</span> score = m<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(n: <span class="hljs-type">String</span>) = <span class="hljs-keyword">this</span>(n, <span class="hljs-number">100</span>)<br>         |    println(n + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + m)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: too many arguments (<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> constructor <span class="hljs-type">Students</span>: (n: <span class="hljs-type">String</span>)<span class="hljs-type">Students</span><br>       <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>                                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>)<br><span class="hljs-type">Bill</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">7509</span>b8e7<br></code></pre></div></td></tr></table></figure>
<h2 id="5-3-重写toString方法"><a href="#5-3-重写toString方法" class="headerlink" title="5.3 重写toString方法"></a>5.3 重写toString方法</h2><p>toString构造完一个对象时自动被调用的那个方法</p>
<blockquote>
<p>​    细心的读者会发现，在前面构造一个Students类的对象时，Scala解释器打印了一串晦涩的信息“Students@7509b8e7”。这其实来自于Students类的toString方法，这个方法返回一个字符串，并在<strong>构造完一个对象时被自动调用</strong>，返回结果交给解释器打印。该方法是所有Scala类<strong>隐式继承</strong>来的，如果不重写这个方法，就会用默认继承的版本。</p>
</blockquote>
<p>​    默认的toString方法来自于<strong>java.lang.Object类</strong>，其行为只是简单地打印类名、一个“@”符号和一个十六进制数。如果想让解释器输出更多有用的信息，则可以自定义toString方法。不过，这个方法是继承来的，要重写它必须在前面加上<strong>关键字“override”</strong>(后续章节会讲到override的作用)。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Nancy&quot;</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">A</span> student named <span class="hljs-type">Nancy</span>.<br></code></pre></div></td></tr></table></figure>
<h2 id="5-4-方法重载"><a href="#5-4-方法重载" class="headerlink" title="5.4 方法重载"></a>5.4 方法重载</h2><p>​    在类里定义了<strong>多个同名的方法</strong>，但是每个方法的<strong>参数(主要是参数类型)不一样</strong>，那么就称这个方法有多个不同的版本。这就叫方法重载，它是面向对象里多态属性的一种表现。这些方法虽然同名，但是它们是不同的，因为函数真正的特征标是它的参数，而不是函数名或返回类型。</p>
<p>​    注意重载与前面的重写的区别，重载是一个类里有多个不同版本的同名方法，重写是子类覆盖定义了超类的某个方法。</p>
<h2 id="5-5-类的参数"><a href="#5-5-类的参数" class="headerlink" title="5.5 类的参数"></a>5.5 类的参数</h2><ul>
<li><strong>前面的例子：</strong>从前面的例子可以发现，<strong>很多时候类的参数仅仅是直接赋给某些字段</strong>。</li>
<li><strong>参数自动复制到内部成员：</strong>Scala为了进一步简化代码，允许在类参数前加上<strong>val或var来修饰</strong>，这样就会在类的内部会生成<strong>一个与参数同名的公有字段</strong>。构造对象时，<strong>这些参数会直接复制给同名字段</strong>。</li>
<li><strong>参数限定权限：</strong>除此之外，还可以加上<strong>关键字private、protected或override来表明字段的权限</strong>(关于权限修饰见后续章节)。如果<strong>参数没有任何关键字，那它就仅仅是“参数”，不是类的成员</strong>，只能用来初始化字段或给方法使用。外部不能访问这样的参数，内部也不能修改它。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;undefined <span class="hljs-comment">//此处用val和var分别修饰了name和score</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">90</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">90.</span><br><br>scala&gt; stu.exam(<span class="hljs-number">100</span>)<br><br>scala&gt; stu.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-6-单例对象与伴生对象（静态变量）"><a href="#5-6-单例对象与伴生对象（静态变量）" class="headerlink" title="5.6 单例对象与伴生对象（静态变量）"></a>5.6 单例对象与伴生对象（静态变量）</h2><blockquote>
<div class="hljs code-wrapper"><pre><code> 在Scala里，除了用new可以构造一个对象，也可以用“object”开头定义一个对象。它类似于类的定义，只不过不能像类那样有参数，也没有构造方法。因此，不能用new来实例化一个object的定义，因为它已经是一个对象了。
</code></pre></div><p>​    <strong>单例对象定义</strong>：用“object”开头定义一个对象对象和用new实例化出来的对象没有什么区别，只不过new实例的对象是以类为蓝本构建的，并且数量没限制，而<strong>object定义的对象只能有这一个</strong>，故而得名<strong>“单例对象”</strong>。</p>
<p>​    </p>
</blockquote>
<ul>
<li><p>class：定义一个类</p>
</li>
<li><p>object：定义一个单例对象</p>
</li>
<li><p>new：实例化一个对象</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>伴生对象定义</strong>：如果某个单例对象和某个类同名，那么<strong>单例对象称为</strong>这个类的<strong>“伴生对象”</strong>，同样，<strong>类称</strong>为这个<strong>单例对象的“伴生类”</strong>。<strong>伴生类和伴生对象必须在同一个文件</strong>里，而且两者可以<strong>互访对方所有</strong>成员。</p>
</blockquote>
<ul>
<li>同名的某个类：<strong>伴生类</strong></li>
<li>同名的单例对象：<strong>伴生对象</strong></li>
<li>伴生类和伴生对象必须在同一文件中</li>
</ul>
<hr>
<blockquote>
<p>​    在C++、Java等oop语言里，类内部可以定义静态变量。这些静态变量不属于任何一个用new实例化的对象，而是它们的公有部分。Scala追求纯粹的面向对象属性，即所有的事物都是类或对象，但是静态变量这种不属于类也不属于对象的事物显然违背了Scala的理念。所以，Scala的做法是<strong>把类内所有的静态变量从类里移除</strong>，转而<strong>集中定义在伴生对象里</strong>，让静态变量属于伴生对象这个独一无二的对象。</p>
<p>​    既然单例对象和new实例的对象一样，那么类内可以定义的代码，单例对象同样可以拥有。例如，单例对象里面可以定义字段和方法。Scala允许在类里定义别的类和单例对象，所以单例对象也可以包含别的类和单例对象的定义。</p>
</blockquote>
<p>单例对象的<strong>作用</strong>：</p>
<ul>
<li><strong>用作伴生对象</strong></li>
<li>打包某方面功能的函数系列成为一个<strong>工具集</strong></li>
<li>包含<strong>主函数</strong>成为程序的入口</li>
</ul>
<hr>
<blockquote>
<p>“object”后面定义的<strong>单例对象名</strong>可以认为是这个单例对象的<strong>名称标签</strong>，因此可以通过句点符号访问单例对象的成员——“单例对象名.成员”，<strong>也可以赋给一个变量</strong>——“val 变量 = 单例对象名”，<strong>就像用new实例的对象那样</strong>。</p>
</blockquote>
<ul>
<li><p>名称标签：“object”后面定义的单例对象名</p>
</li>
<li><p>定义方式：object可以赋值给一个变量，就和new实例化一样</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7e5831</span>c4<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; (<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>).a<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span> </span>&#123; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;a singleton object&quot;</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-type">B</span>.b<br>res2: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-type">B</span><br>y: <span class="hljs-type">B</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">B</span>$@<span class="hljs-number">4489</span>b853<br><br>scala&gt; y.b<br>res3: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>object.type：</strong></p>
<p>​    前面说过，<strong>定义一个类，就是定义了一种类型</strong>。从抽象层面讲，<strong>定义单例对象却并没有定义一种类型</strong>。实际上<strong>每个单例对象有自己独特的类型</strong>，即<strong>object.type</strong>（可以认为新类型出现了，只不过这个类型并不能用来归类某个对象集合，等同于没有定义新类型）</p>
<p>​    即使是<strong>伴生对象也没有定义类型</strong>，而是<strong>由伴生类定义了同名的类型</strong>。后续章节将讲到，单例对象可以<strong>继承自超类</strong>或<strong>混入特质</strong>，这样它就能<strong>出现在需要超类对象的地方</strong>。例如下面的例子中，可以明确看到X.type和Y.type两种新类型出现，并且是不一样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br><br>scala&gt; <span class="hljs-keyword">var</span> x = <span class="hljs-type">X</span><br>x: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">X</span>$@<span class="hljs-number">630</span>bb67<br><br>scala&gt; x = <span class="hljs-type">Y</span><br>&lt;console&gt;:<span class="hljs-number">17</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Y</span>.<span class="hljs-keyword">type</span><br> required: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span><br>       x = <span class="hljs-type">Y</span><br>           ^<br></code></pre></div></td></tr></table></figure>
<h2 id="5-7-工厂对象与工厂方法"><a href="#5-7-工厂对象与工厂方法" class="headerlink" title="5.7 工厂对象与工厂方法"></a>5.7 工厂对象与工厂方法</h2><p>​    如果定义<strong>一个方法专门用来构造某一个类的对象</strong>，那么<strong>这种方法</strong>就称为<strong>“工厂方法”。</strong>包含这些工厂方法集合的单例对象，也就叫<strong>“工厂对象”</strong> 。</p>
<p>工厂对象的使用场景和好处：</p>
<div class="hljs code-wrapper"><pre><code>+ 通常，**工厂方法会定义在伴生对象里**。
+ 当一系列类存在继承关系时，可以在基类的伴生对象里定义一系列对应的工厂方法。
+ **使用工厂方法的好处**是可以不用直接使用new来实例化对象，改用方法调用，而且方法名可以是任意的，这样**对外隐藏了类的实现细节**。例如：
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">registerStu</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    将文件students.scala编译后，并在解释器里用<strong>“import Students._</strong>”导入单例对象后，就能这样使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = registerStu(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment">//利用工厂方法生成对象</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-8-一个特殊的方法：apply方法"><a href="#5-8-一个特殊的方法：apply方法" class="headerlink" title="5.8 一个特殊的方法：apply方法"></a>5.8 一个特殊的方法：apply方法</h2><blockquote>
<p>如果定义了这个方法，那么既可以显式调用——“对象.apply(参数)” ，也可以隐式调用——“对象(参数)”。隐式调用时，编译器会自动插入缺失的“.apply”。如果apply是无参方法，应该写出空括号，否则无法隐式调用。无论是类还是单例对象，都能定义这样的apply方法。</p>
</blockquote>
<p><strong>apply方法特殊点：</strong>这个方法可以进行隐式调用，如果是无参方法应有空括号，无论是类还是单例对象都可以定义apply方法</p>
<p><strong>apply方法的调用：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">对象(参数)  		<span class="hljs-comment">//隐式，省略了.apply</span><br>对象.apply(参数)	<span class="hljs-comment">//显式，和正常调用方法一样</span><br></code></pre></div></td></tr></table></figure>
<p><strong>apply方法使用场景：</strong></p>
<ul>
<li><strong>在伴生对象里定义名为apply的工厂方法，就能通过“伴生对象名(参数)”来构造一个对象。</strong></li>
<li>也常常在类里定义一个与类相关的、具有特定行为的apply方法，<strong>让使用者可以隐式调用，进而隐藏相应的实现细节</strong>。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="5-9-主函数"><a href="#5-9-主函数" class="headerlink" title="5.9 主函数"></a>5.9 主函数</h2><p>​    <strong>主函数是Scala程序唯一的入口</strong>，即程序是从主函数开始运行的。要提供这样的入口，则必须<strong>在某个单例对象里定义一个名为“main”的函数</strong>，而且<strong>该函数只有一个参数</strong>，<strong>类型为字符串数组Array[String]</strong>，函数的<strong>返回类型是Unit</strong>。<strong>任何符合条件的单例对象都能成为程序的入口</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br> <br><span class="hljs-comment">// main.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> score = args(<span class="hljs-number">1</span>).toInt<br>      <span class="hljs-keyword">val</span> s = <span class="hljs-type">Students2</span>(args(<span class="hljs-number">0</span>), score)<br>      println(s.toString)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">ArrayIndexOutOfBoundsException</span> =&gt; println(<span class="hljs-string">&quot;Arguments are deficient!&quot;</span>)<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Second argument must be a Int!&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>使用命令<code>scalac students2.scala main.scala</code>将两个文件编译后</p>
</li>
<li><p>用命令<code>scala Start 参数1 参数2</code>来运行程序。（命令里的“Start”就是包含主函数的单例对象的名字，后面可以输入若干个用空格间隔的参数。这些参数被打包成字符串数组供主函数使用，也就是代码里的args(0)、args(1)。）</p>
</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom<br>Arguments are deficient!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom aaa<br>Second argument must be a Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom <span class="hljs-number">100</span><br>Tom<span class="hljs-string">&#x27;s score is 100.</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p>​    <strong>主函数的一种简化写法是让单例对象混入“App”特质</strong>(特质在后续章节讲解)，这样就<strong>只要在单例对象里编写主函数的函数体</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// main2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(arg &lt;- args) &#123;<br>      sum += arg.toInt<br>    &#125;<br>    println(<span class="hljs-string">&quot;sum = &quot;</span> + sum)<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Arguments must be Int!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将文件编译后，就可以如下使用：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> AAA<br>Arguments must be Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> <span class="hljs-number">8</span><br>sum = <span class="hljs-number">30</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-10-总结"><a href="#5-10-总结" class="headerlink" title="5.10 总结"></a>5.10 总结</h2><p>​    本章讲解了Scala的类和对象，从中可以初窥Scala在语法精简和便捷上的努力。<strong>难点是</strong>理解单例对象的概念、类与类型的关系和工厂方法的作用。如果读者有其他oop语言基础，在这里也并不是能一下就接受Scala的语法。最后一个重点就是学会灵活使用apply方法。</p>
<h1 id="6-操作符即方法"><a href="#6-操作符即方法" class="headerlink" title="6 操作符即方法"></a>6 操作符即方法</h1><h2 id="6-1-操作符在Scala里的解释"><a href="#6-1-操作符在Scala里的解释" class="headerlink" title="6.1 操作符在Scala里的解释"></a>6.1 操作符在Scala里的解释</h2><blockquote>
<p>​    在诸如C++、Java等oop语言里，定义了像byte、short、int、char、float之类的基本类型，但是<strong>这些基本类型不属于面向对象的范畴</strong>。就好比C语言也有这些类型，但是C语言根本没有面向对象的概念。 比如只能说“1”是一个int类型的常量，却不能说它是一个int类型的对象。与之对应的，这些语言还定义了与基本类型相关的操作符。例如，有算术操作符加法“+”，它可以连接左、右两个操作数，然后算出相应的总和。</p>
</blockquote>
<p>​    前面提到，Scala追求纯粹的面向对象，像这种不属于面向对象范畴的基本类型及其操作符都是有违宗旨的。那么，Scala如何实现这些基本类型呢？实际<strong>在Scala标准库里定义了“class Byte”、“class  Short”、“class  Char”、“class Int”、“class  Long”、“class  Float”、“class  Double”、“class  Boolean”和“class Unit”九种值类，</strong>只不过<strong>这些类是抽象的、不可继承的，因此不能通过“new Int”这种语句来构造一个Int对象，也不能编写它们的子类，它们的对象都是由字面量来表示</strong>。例如，整数字面量“1”就是一个Int的对象。在运行时，前八种值类会被转换成对应的Java基本类型。第九个Unit类对应Java的“void”类型，即表示空值，这样就能理解返回值类型为Unit的、有副作用的函数其实是空函数。<strong>Unit类的对象由一个空括号作为字面量来表示。</strong></p>
<p>​    <strong>简而言之，Scala做到了真正的“万物皆对象”。</strong></p>
<p>​    还有，与基本类型相关的操作符该如何处理呢？严格来讲，<strong>Scala并不存在操作符的概念</strong>，这些所谓的操作符，例如算术运算的加减乘除，逻辑运算的与或非，比较运算的大于小于等等，其实都是定义在“class Int”、“class Double”等类里的成员方法。也就是说，<strong>在Scala里，操作符即方法。</strong>例如，Int类定义了一个名为“+”的方法，那么表达式“1 + 2”的真正形式应该是“1.+(2)”。它的释义是：Int对象“1”调用了它的成员方法“+”，并把Int对象“2”当作参数传递给了该方法，最后这个方法会返回一个新的Int对象“3”。</p>
<p>​    <strong><u>//////重要使用方法：类似操作符的方法调用（省略句号）///////</u></strong></p>
<p>​    推而广之，<u>“操作符即方法”的概念不仅仅限于九种值类的操作符，<strong>Scala里任何类定义的成员方法都是操作符，而且方法调用都能写成操作符的形式：去掉句点符号，并且方法参数只有一个时可以省略圆括号。</strong></u>示例代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friends</span></span>(n: <span class="hljs-type">String</span>, s: <span class="hljs-type">Int</span>) = println(<span class="hljs-string">&quot;My friend &quot;</span> + n + <span class="hljs-string">&quot; gets &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>)<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Students3</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>)<br>stu3: <span class="hljs-type">Students3</span> = <span class="hljs-type">Alice</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">80.</span><br><br>scala&gt; stu3 exam <span class="hljs-number">100</span><br><br>scala&gt; stu3.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; stu3 friends (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">70</span>)<br><span class="hljs-type">My</span> friend <span class="hljs-type">Bob</span> gets <span class="hljs-number">70.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-2-三种操作符"><a href="#6-2-三种操作符" class="headerlink" title="6.2 三种操作符"></a>6.2 三种操作符</h2><p><strong>（1）前缀操作符（+-!~）</strong></p>
<p>​    写在<strong>操作数前面的操作符</strong>称为<strong>前缀操作符</strong>，并且<strong>操作数只有一个</strong>。</p>
<p>​    前缀操作符<strong>对应一个无参方法</strong>，<strong>操作数是调用该方法的对象</strong>。<strong>前缀操作符只有“+”、“-”、“!”和“~”四个</strong>，相对应的方法名分别是“unary_+”，“unary_-”、“unary_!”和“unary_~”</p>
<blockquote>
<p>​    <strong>如果自定义的方法名是 “unary_”</strong>加上这四个操作符之外的操作符，那么就不能写成前缀操作符的形式。假设定义了方法“unary_*”（意思是unary_与乘号结合），那么写成“<em>p”的形式让人误以为这是一个指针，实际Scala并不存在指针，因此只能写成“p.unary_\</em>”或后缀操作符“p unary_*”的形式。例如：</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_!</span> </span>= -x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_*</span> </span>= x * <span class="hljs-number">2</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt</span>(<span class="hljs-number">10</span>)<br>mi: <span class="hljs-type">MyInt</span> = <span class="hljs-type">MyInt</span>@<span class="hljs-number">2</span>aac87ab<br><br>scala&gt; !mi<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">-10</span><br><br>scala&gt; *mi<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: not found: value *<br>       *mi<br>       ^<br>&lt;console&gt;:<span class="hljs-number">12</span>: warning: postfix operator mi should be enabled<br>by making the <span class="hljs-keyword">implicit</span> value scala.language.postfixOps visible.<br><span class="hljs-type">This</span> can be achieved by adding the <span class="hljs-keyword">import</span> clause <span class="hljs-symbol">&#x27;import</span> scala.language.postfixOps&#x27;<br>or by setting the compiler option -language:postfixOps.<br><span class="hljs-type">See</span> the <span class="hljs-type">Scaladoc</span> <span class="hljs-keyword">for</span> value scala.language.postfixOps <span class="hljs-keyword">for</span> a discussion<br>why the feature should be explicitly enabled.<br>       *mi<br>        ^<br><br>scala&gt; mi.unary_*<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）中缀操作符(可以带很多操作数)</strong></p>
<p>​    <strong>中缀操作符</strong>的<strong>左右两边都接收操作数</strong>，它<strong>对应普通的有参方法</strong>。两个操作数中的一个是调用该方法的对象，一个是传入该方法的参数，<strong>参数那一边没有数量限制</strong>，只是多个参数需要放在圆括号里。</p>
<p>​    <strong>Scala规定，以冒号“ : ”结尾的操作符，其<u>右操作数</u>是调用该方法的对象，<u>其余操作符</u>都是把左操作数当调用该方法的对象。</strong> 例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+*</span></span>(y: <span class="hljs-type">Int</span>) = (x + y) * y<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>:(y: <span class="hljs-type">Int</span>) = x + y<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi2 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt2</span>(<span class="hljs-number">10</span>)<br>mi2: <span class="hljs-type">MyInt2</span> = <span class="hljs-type">MyInt2</span>@<span class="hljs-number">216</span>c6825<br><br>scala&gt; mi2 +* <span class="hljs-number">10</span> <span class="hljs-comment">//两个操作符，先+10后乘10</span><br>res7: <span class="hljs-type">Int</span> = <span class="hljs-number">200</span><br><br>scala&gt; mi2 +: <span class="hljs-number">10</span> <span class="hljs-comment">//右侧才是</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: value +: is not a member of <span class="hljs-type">Int</span><br>       mi2 +: <span class="hljs-number">10</span><br>           ^<br><br>scala&gt; <span class="hljs-number">10</span> +: mi2 <span class="hljs-comment">//右侧mi2是调用该方法的对象，其余操作符为+,其余操作符的操作数为左侧的10</span><br>res9: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<p>​    对于系统打印函数<strong>“print”、“printf”和“println”，其实也是中缀操作符</strong>，不过<strong>左侧的操作数是调用对象——控制台Console</strong>，<strong>右侧是要打印的内容</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Console</span> println <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-type">Hello</span>, world! <br></code></pre></div></td></tr></table></figure>
<p><strong>（3）后缀操作符(类似方法调用)</strong></p>
<p>​    写在<strong>操作数后面的操作符</strong>称为<strong>后缀操作符</strong>，并且<strong>操作数只有一个</strong>，即调用该方法的对象。</p>
<p>​    后缀操作符也对应一个无参方法，但是要注意方法名<strong>如果构成前缀操作符的条件，那么既可以写成前缀操作符</strong>，也可以把完整的方法名写成后缀操作符。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;The value is &quot;</span> + x + <span class="hljs-string">&quot;.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi3 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt3</span>(<span class="hljs-number">10</span>)<br>mi3: <span class="hljs-type">MyInt3</span> = <span class="hljs-type">MyInt3</span>@<span class="hljs-number">2670435</span><br><br>scala&gt; <span class="hljs-keyword">import</span> scala.language.postfixOps<br><span class="hljs-keyword">import</span> scala.language.postfixOps<br><br>scala&gt; mi3 display <span class="hljs-comment">//操作数mi3  操作符display</span><br><span class="hljs-type">The</span> value is <span class="hljs-number">10.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-3-操作符的优先级和结核性"><a href="#6-3-操作符的优先级和结核性" class="headerlink" title="6.3 操作符的优先级和结核性"></a>6.3 操作符的优先级和结核性</h2><p><strong>（1）优先级</strong></p>
<p>​    在数学运算中，乘、除法的优先级要高于加、减法，这是算术操作符的优先级。Scala也保留了这种特性，并有一套判断操作符优先级的规则：通过操作符的首个字符来判断。因为操作符都是方法，所以也就是通过方法名的首个字符来比较优先级，注意前缀操作符的方法名要去掉关键字。当然，圆括号内的优先级是最高的，圆括号可以改变操作符的结合顺序。<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​    上图给出了各种字符的优先级顺序。例如，常规算术运算法则在计算表达式“1 + 2 <em> 3”时，会先算乘法，后算加法。类似地，如果有一个表达式“1 +++ 2 **</em> 3”，那么结合顺序就是“1 +++ (2 <em>*</em> 3)”。</p>
<blockquote>
<p>​    这个规则有一个例外（就是比较，+=一系列的，不用看）：如果操作符以等号结尾，并且不是“&gt;=”、“&lt;=”、“==”或“!=”四个比较操作符之一，那么就认为是赋值操作符，优先级最低。例如，表达式“sum *= 1 + 2”会先算“1 + 2”，再把得出的3和sum相乘并赋给sum。也就是说，“*=”的优先级并不会因为以乘号开头就比加号高，而是被当作了一种赋值操作。</p>
</blockquote>
<p><strong>（2）结合性（注意冒号这玩意就行）</strong></p>
<p>​    一般情况下，同级的操作符都是<strong>从左往右结合的</strong>。但是，前面说了，<strong>以冒号结尾的中缀操作符的调用对象在右侧</strong>，所以这些操作符是从右往左结合的。例如，“a + b + c + d”的结合顺序是“((a + b) + c) + d”，而“a ::: b ::: c ::: d”的结合顺序则是“a ::: (b ::: (c ::: d))”。</p>
<blockquote>
<p>​    一个好的编程习惯是让代码简洁易懂，不造成歧义。所以，在操作符的结合顺序不能一眼就看明白时，最好加上圆括号来表示前后顺序，即使不加圆括号也能得到预期的结果。例如，想要得到“x + y &lt;&lt; z”的默认结果，最好写成“(x + y) &lt;&lt; z”，以便阅读。</p>
</blockquote>
<p><strong>（3）预设操作符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">+</th>
<th style="text-align:center">算术加法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">算术减法</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">算术乘法</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">算术除法</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">算术取余</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;、&amp;</td>
<td style="text-align:center">逻辑与，前者短路，后者不短路</td>
</tr>
<tr>
<td style="text-align:center">&#124;&#124;、&#124;</td>
<td style="text-align:center">逻辑或，前者短路，后者不短路</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td style="text-align:center">位或</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">位取反</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">算术右移</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">逻辑右移</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-5-对象的相等性"><a href="#6-5-对象的相等性" class="headerlink" title="6.5 对象的相等性"></a>6.5 对象的相等性</h2><p>​    在编程时，常常需要比较两个对象的相等性。其实相等性有两种：</p>
<ul>
<li><strong>自然相等性</strong>，也就是常见的相等性。<strong>只要字面上的值相等，就认为两个对象相等</strong></li>
<li><strong>引用相等性</strong>。构造的对象常常会赋给一个变量，即让变量引用该对象。引用相等性用于比较两个变量是否引用了同一个对象，<strong>即是否指向JVM的堆里的同一个内存空间</strong>。如果两个变量引用了两个完全一样的对象，那么它们的自然相等性为true，但是引用相等性为false</li>
</ul>
<blockquote>
<p>在Java里，这两种相等性都是由操作符“==”和“!=”比较的。</p>
<p>Scala为了区分得更细致，也为了符合常规思维，<strong>只让“==”和“!=”比较自然相等性</strong>。<strong>这两个方法是所有类隐式继承来的，但是它们不能被子类重写。</strong>自定义类可能需要不同行为的相等性比较，因此<strong>可以重写隐式继承来的“equals”方法。</strong>为了比较引用相等性，Scala提供了“eq”和“ne”方法，它们也是被所有类隐式继承的，且不可被子类重写。例如：</p>
</blockquote>
<p><strong>Scala比较自然相等性：</strong></p>
<ul>
<li>只让<strong>“==”和“!=”</strong>方法比较，被所有类隐式继承的，且不可被子类重写</li>
</ul>
<p><strong>Scala比较引用相等性：</strong></p>
<ul>
<li>提供了“<strong>eq”和“ne”方法</strong>，它们也是被所有类隐式继承的，且不可被子类重写</li>
</ul>
<p><strong>自定义相等性行为：</strong></p>
<ul>
<li>可以重写隐式继承来的“equals”方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>a: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>b: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>c: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> d = a<br>d: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; a == c<br>res0: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a == b<br>res1: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a equals b<br>res2: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a eq b<br>res3: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a eq d<br>res4: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><p>​    本章又进一步阐释了Scala追求的纯粹的面向对象，介绍了“操作符即方法”这个重要概念。这一概念对构建良好的DSL语言很重要，因为它使得不仅内建类型可以写成表达式，也让自定义的类在计算时可以写出自然的表达式风格。</p>
<p>​    关于对象相等性，这是一个较为复杂的概念。在自定义类里，如果要比较对象相等性，则不仅是简单地重写equals方法，还需要其他手段。这里不再赘述，如有必要，后续会继续讨论。</p>
<h1 id="7-类继承"><a href="#7-类继承" class="headerlink" title="7 类继承"></a>7 类继承</h1><h2 id="7-1-Scala的类集成"><a href="#7-1-Scala的类集成" class="headerlink" title="7.1 Scala的类集成"></a>7.1 Scala的类集成</h2><p>​    在面向对象编程里，为了节省代码量，也为了反映实际各种类之间的联系，通常采取两种策略：包含和继承。包含代表了一种has-a的关系，也就是一个类包括了另一个类的实例。例如，午餐的菜单含有水果，那么就可以先编写一个水果类，然后再编写一个午餐类，并在午餐类里包含水果类的对象，但这两者没有必然联系。继承代表了一种is-a的关系，也就是从一个宽泛的类可以派生出更加具体的类。例如，编写的水果类包含了一些常见水果的公有属性，然后要编写一个更具体的苹果类。考虑到现实世界中，苹果就是(is-a，更准确来说应该是is-a-kind-of)一种特殊的水果，那么苹果类完全可以把水果类里定义的属性都继承过来，而且这两者有必然联系。</p>
<p>​    本章介绍的内容就是关于类继承的Scala语法，以及一些特性。</p>
<p>​    通过在类的参数列表后面加上关键字“extends”和被继承类的类名，就完成了一个继承的过程。被继承的类称为“超类”或者“父类”，而派生出来的类称为“子类”。如果继承层次较深，最顶层的类通常也叫“基类”。继承关系只有“超类”和“子类”的概念，即超类的超类也叫超类，子类的子类还叫子类。例如：</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                      <a class="hover-with-bg" href="/categories/CS/Scala/">Scala</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                      <a class="hover-with-bg" href="/tags/CS/">CS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202202281650/CS/Scalaessay/cs/scala/Scala2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Scala学习材料</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202202110126/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B69%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88_%E9%9B%86%E6%88%90/">
                        <span class="hidden-mobile">UVM入门进阶9：寄存器模型概览_集成.md</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"right","width":250,"height":500,"vOffset":-100},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
