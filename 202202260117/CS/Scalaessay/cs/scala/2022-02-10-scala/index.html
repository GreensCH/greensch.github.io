

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="1 概论1.1 导论Scala来源于scalable（可扩展的）这个单词，它的可扩展性非常强   Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性  Scala比Java更加面向对象 Scala是一门函数式编程语言(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala) 同样运行在JVM上，可以与现存程序同时运行 可直">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala（一）：基础篇">
<meta property="og:url" content="http://yoursite.com/202202260117/CS/Scalaessay/cs/scala/2022-02-10-scala/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="1 概论1.1 导论Scala来源于scalable（可扩展的）这个单词，它的可扩展性非常强   Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性  Scala比Java更加面向对象 Scala是一门函数式编程语言(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala) 同样运行在JVM上，可以与现存程序同时运行 可直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103912684.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301104056461.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110611005.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110658494.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301113507259.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301120214795.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301121507718.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20190208201013172.png">
<meta property="og:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96247202_p0.jpg">
<meta property="article:published_time" content="2022-02-25T17:17:00.000Z">
<meta property="article:modified_time" content="2022-03-09T05:31:14.715Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png">
  
  <title>Scala（一）：基础篇 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96247202_p0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Scala（一）：基础篇">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-26 01:17" pubdate>
        2022年2月26日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      62k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      194 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Scala（一）：基础篇</h1>
            
            <div class="markdown-body">
              <h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><h2 id="1-1-导论"><a href="#1-1-导论" class="headerlink" title="1.1 导论"></a>1.1 导论</h2><p>Scala来源于scalable（可扩展的）这个单词，它的<strong>可扩展性非常强</strong> </p>
<ul>
<li><p>Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性</p>
<ul>
<li>Scala比Java更加<strong>面向对象</strong></li>
<li>Scala是一门<strong>函数式编程语言</strong>(java1.8引入的中的lamuda表达式就是函数编程的重要概念，实际上就是借鉴Scala)</li>
<li>同样运行在<strong>JVM</strong>上，可以与现存程序同时运行</li>
<li>可直接使用<strong>Java类库</strong></li>
<li>同Java一样<strong>静态类型</strong></li>
<li>语法和Java类似，比Java<strong>更加简洁</strong>（简洁而并不是简单），<strong>表达性更强</strong>。</li>
</ul>
</li>
<li><p>关注点</p>
<ul>
<li>类型推断、不变量、函数式编程、高级程序构造</li>
<li>并发：actor模型</li>
<li>和现有Java代码交互、相比Java异同和优缺</li>
</ul>
</li>
<li><p><del>Scala更适合大数据的处理</del></p>
<ul>
<li><del>Scala对<strong>集合</strong>类型数据处理有非常好的支持</del></li>
<li><del>Spark的底层用Scala编写</del></li>
</ul>
</li>
<li><p>和Java关系：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">        javac               java<br><span class="hljs-string">.java</span> <span class="hljs-params">--------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br><span class="hljs-string">.scala</span> <span class="hljs-params">-------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br>        scalac              scala<br></code></pre></div></td></tr></table></figure>
<ul>
<li>Java很多语法源自Cpp</li>
<li>Java面向对象不是很彻底，有八大基本数据类型，同时又有包装类型（继承自Object）</li>
<li>对更加复杂的高端应用</li>
<li><strong>函数式编程语言</strong>可以解决上述问题</li>
<li>Scala最重要的是引入了类型推断和lamuda表达式</li>
</ul>
</li>
</ul>
<h2 id="1-2-总结特点"><a href="#1-2-总结特点" class="headerlink" title="1.2 总结特点"></a>1.2 总结特点</h2><p>Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的<strong>静态类型编程语言</strong>（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）</p>
<ul>
<li>Scala是一门多范式的编程语言，Scla支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程、面向对像、泛型、函数式四种程序设计方法）</li>
<li>Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM文上，并可以调用现有的Java类库，实现两种语言的无缝对接。</li>
<li>Scala单作为一门语言来看，非常的简洁高效。</li>
<li>Scaa在设计时，马丁奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁奥德斯基也加入了自己的思想，将<strong>函数式编程语言的特点融合到JAVA</strong>中，因此，对于学习Java的同学，只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的拿握Scaa这门语言</li>
</ul>
<h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2 环境"></a>2 环境</h1><h2 id="2-1-交互式命令行"><a href="#2-1-交互式命令行" class="headerlink" title="2.1 交互式命令行"></a>2.1 交互式命令行</h2><ul>
<li>交互式执行环境（cmd直接输入scala）：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103816193.png" srcset="/img/loading.gif" lazyload alt="image-20220301103816193"></p>
<ul>
<li>定义常量</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301103912684.png" srcset="/img/loading.gif" lazyload alt="image-20220301103912684"></p>
<ul>
<li>print</li>
</ul>
<p>对比Java的<code>system.out.println(&quot;&quot;);</code>确实简洁不少</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301104056461.png" srcset="/img/loading.gif" lazyload alt="image-20220301104056461"></p>
<ul>
<li>推出交互式执行环境</li>
</ul>
<figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">scala&gt; :<span class="hljs-keyword">quit</span><br></code></pre></div></td></tr></table></figure>
<h2 id="2-2-完整编译流程"><a href="#2-2-完整编译流程" class="headerlink" title="2.2 完整编译流程"></a>2.2 完整编译流程</h2><p>和Java差不多</p>
<p><strong>源程序</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//HelloScala.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloScala</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):<span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;hello scala&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>object</code>关键字：定义单例对象(直接定义对象而不是类)</li>
<li><code>def</code>关键字：声明函数或方法</li>
<li><code>args</code>：在类型前面，表明我们更关心参数而不是类型</li>
<li><code>:Array[String]</code>：Array集合类型，[String]一个泛型，表明内部是String的集合</li>
<li><code>:Unit</code>：返回值为void</li>
<li><code>=&#123;&#125;</code>：函数体</li>
<li>没有分号</li>
</ul>
<p><strong>编译生成字节码文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scalac HelloScala.scala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110611005.png" srcset="/img/loading.gif" lazyload alt="image-20220301110611005"></p>
<p>为什么有HelloScala$.class和HelloScala.class两个文件？</p>
<blockquote>
<p> 底层机制：</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av204775475">尚硅谷007Scala环境搭建（三）</a></p>
<p>HelloScala.class：要执行程序的入口类</p>
<p>HelloScala$.class：上面类所属类，被调用</p>
<p>进一步补充：</p>
<p>如果编译的话会生成2个<code>.class</code>字节码文件，<code>HelloScala.class</code>和<code>HelloScala$.class</code>。都是字节码但是不能通过<code>java</code>直接运行。但对于HelloWorld这个例子来说，java源代码编译而成的字节码是可以通过<code>scala</code>命令运行的。</p>
<p>原因是没有引入Scala的库，添加<code>classpath</code>就可以通过java执行scala编译成的字节码了：</p>
<figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">java -cp %SCALA_HOME%<span class="hljs-regexp">/lib/</span>scala-library.jar; HelloScala<br></code></pre></div></td></tr></table></figure>
<p>使用<a target="_blank" rel="noopener" href="http://java-decompiler.github.io/">Java Decompiler</a>反编译字节码到java源文件可以看到引入Scala库的逻辑。并且：</p>
<ul>
<li>scala源文件中的<code>HelloScala</code>对象编译后成为了一个类，但对象本身编译后就是生成的另一个类<code>HelloScala$</code>类的单例对象<code>HelloScala$.MODULE$</code>，称之为伴生对象。</li>
<li><code>HelloScala$</code>有一个<code>main</code>实例方法，<code>HelloScala</code>类的静态方法通过这个单例对象转调这个实例方法。完成打印。</li>
<li>Scala比Java更面向对象。</li>
</ul>
</blockquote>
<p><strong>运行</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; scala HelloScala<br></code></pre></div></td></tr></table></figure>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301110658494.png" srcset="/img/loading.gif" lazyload alt="image-20220301110658494"></p>
<p><strong>反编译</strong></p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301113507259.png" srcset="/img/loading.gif" lazyload alt="image-20220301113507259"></p>
<hr>
<p><del>暂时不管项目配置，还是单文件编译执行为主，项目开发肯定要以包的形式组织可以使用IntelliJ IDEA开发，使用maven或者sbt进行项目配置</del></p>
<p>使用VSCode编辑器，安装插件Scala Syntax (official)和Scala (Mentals)</p>
<ul>
<li>新建文件<code>HelloScala.scala</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">object HelloScala &#123; <span class="hljs-comment">// HelloScala is a object, not a class, will create a </span><br>    <span class="hljs-function">def <span class="hljs-title">main</span><span class="hljs-params">(args : Array[<span class="hljs-keyword">String</span>])</span> : Unit =</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello,world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>可以使用插件CodeRunner直接快捷键运行。也可以在命令行编译为字节码后再运行：</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>HelloScala.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>helloScala<br></code></pre></div></td></tr></table></figure>
<ul>
<li>或者直接运行scala源文件：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">scala <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloScala</span>.</span></span>scala<br></code></pre></div></td></tr></table></figure>
<h1 id="3-变量与数据类型"><a href="#3-变量与数据类型" class="headerlink" title="3 变量与数据类型"></a>3 变量与数据类型</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><ul>
<li>和java一样</li>
<li><code>//</code> 单行</li>
<li><code>/* */</code> 多行</li>
<li><code>/** */</code> 文档，方法或者类前面，便于<code>scaladoc</code>生成文档。</li>
</ul>
<h2 id="3-2-变量与常量"><a href="#3-2-变量与常量" class="headerlink" title="3.2 变量与常量"></a>3.2 变量与常量</h2><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> [:VariableType] = value <span class="hljs-comment">// variable</span><br>val <span class="hljs-keyword">name</span> [:ConstantType] = value <span class="hljs-comment">// constant</span><br></code></pre></div></td></tr></table></figure>
<p>因为Scala的<strong>函数式编程</strong>要素，所以一个指导意见就是<strong>能用常量就不要用变量</strong></p>
<ul>
<li><strong>推断类型：</strong>声明变量时，类型可以省略，编译器会自动推导</li>
<li><strong>静态类型：</strong>类型<strong>经过给定或推导确定</strong>后就不能修改**</li>
<li><strong>初始化：</strong>变量和常量声明时，必须有初始值</li>
<li><strong>变量与常量：</strong>变量可变，常量不可变</li>
<li><strong>引用类型常量：</strong>不能改变常量指向的对象，可以改变对象的字段</li>
<li><strong>结尾：</strong>不以<code>;</code>作为语句结尾，scala编译器自动识别语句结尾</li>
</ul>
<h2 id="3-3-Scala的基本类型"><a href="#3-3-Scala的基本类型" class="headerlink" title="3.3 Scala的基本类型"></a>3.3 Scala的基本类型</h2><p><strong>静态语言</strong></p>
<p>​    Scala是<strong>静态语言</strong>，在编译期间会检查每个对象的类型。对于类型不匹配的非法操作，在编译时就能被发现。对于动态语言而言，这种非法操作需要等到运行时才能被发现，此时可能造成严重错误</p>
<p>​    静态语言相比诸如Python这样的动态语言在某些方面是有优势的。对于Chisel而言，我们就需要这种优势。因为Chisel需要编译成Verilog，我们不能产生非法的Verilog语句并且等到模块运行时才去发现它</p>
<hr>
<p><strong>基本类型</strong></p>
<p>​    Scala标准库定义了一些基本类型，如下表所示。除了“<strong>String”</strong>类型是属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=java&amp;spm=1001.2101.3001.7020">java</a>.lang包之外，其余都在Scala的包里。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301120214795.png" srcset="/img/loading.gif" lazyload alt="image-20220301120214795"></h2><p><strong>定义变量</strong></p>
<p>​    事实上，在定义变量时，应该指明变量的类型，只不过Scala的编译器具有自动推断类型的功能，可以根据赋给变量的对象的类型，来自动推断出变量的类型。</p>
<p>​    如果要显式声明变量的类型，或者无法推断时，则只需在变量名后面加上一个冒号“ : ”，然后在等号与冒号之间写出类型名即可。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br>x: <span class="hljs-type">Int</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> y: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;123&quot;</span><br>y: <span class="hljs-type">String</span> = <span class="hljs-number">123</span><br><br>scala&gt; <span class="hljs-keyword">val</span> z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br>z: <span class="hljs-type">Double</span> = <span class="hljs-number">1.2</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>字面量</strong></p>
<p>​    <strong>整数</strong>有四种类型，<strong>默认情况下推断为Int</strong>类型。如果字面量的结尾有<strong>“l”</strong>或者<strong>“L”</strong>，则推断为<strong>Long</strong>类型。此外，<strong>Byte</strong>和<strong>Short</strong>则<strong>需要定义变量时显式声明</strong>。注意，赋给的字面值不能超过类型的表示范围。</p>
<p>​    整数字面量默认是十进制的，但如果以“0x”或者“0X”开头，则字面量被认为是十六进制。十六进制的字母不区分大小写。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">100</span><br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">0X123Abc</span><br>b: <span class="hljs-type">Int</span> = <span class="hljs-number">1194684</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Int</span>(<span class="hljs-number">200</span>)<br> required: <span class="hljs-type">Byte</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Byte</span> = <span class="hljs-number">200</span><br>                     ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-number">200</span>L<br>d: <span class="hljs-type">Long</span> = <span class="hljs-number">200</span><br><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>浮点数</strong>的字面量<strong>都是十进制</strong>的，类型<strong>默认是Double</strong>类型。可以增加一个字母<strong>“e”</strong>或<strong>“E”</strong>，再添加一个整数作为指数，这样就构成10的n次幂。最末尾可以写一个<strong>“f”</strong>或者<strong>“F”</strong>，表示Float类型；也可以写一个<strong>“d</strong>”或者<strong>“D”</strong>，表示Double类型。</p>
<blockquote>
<p>注意，Double类型的字面量不能赋给Float类型的变量。虽然Float允许扩展成Double类型，但是会发生精度损失</p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/image-20220301121507718.png" srcset="/img/loading.gif" lazyload alt="image-20220301121507718"></p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-number">1.2E3</span><br>a: <span class="hljs-type">Double</span> = <span class="hljs-number">1200.0</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-number">-3.2</span>f<br>b: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>&lt;console&gt;:<span class="hljs-number">11</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Double</span>(<span class="hljs-number">-3.2</span>)<br> required: <span class="hljs-type">Float</span><br>       <span class="hljs-keyword">val</span> c: <span class="hljs-type">Float</span> = <span class="hljs-number">-3.2</span><br>                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.2</span>F<br>d: <span class="hljs-type">Double</span> = <span class="hljs-number">-3.200000047683716</span><br></code></pre></div></td></tr></table></figure>
<p><strong>字符字面量</strong></p>
<div class="hljs code-wrapper"><pre><code> **字符**字面量是以**单引号&#39; &#39;**包起来的一个字符，Scala中字符采用Unicode编码，可以用**&#39;\u&#39;编码号&#39;**的方式来**转义**一个Unicode字符，而且**Unicode编码**可以出现在代码的任何地方，甚至是名称命名。此外，还支持转义字符。例如
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = &#x27;<span class="hljs-type">A</span>&#x27;<br>a: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = &#x27;\u0041&#x27; <span class="hljs-comment">// \u0041对应Unicode的A</span><br>b: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = &#x27;\u0042&#x27;<br>c: <span class="hljs-type">Char</span> = <span class="hljs-type">B</span><br><br>scala&gt; <span class="hljs-keyword">val</span> \u0041\u0042 = <span class="hljs-number">1</span> <span class="hljs-comment">// 使用\u构造的Unicode字符作为变量名称</span><br><span class="hljs-type">AB</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; <span class="hljs-keyword">val</span> d = &#x27;\\&#x27; <span class="hljs-comment">//转义字符字符</span><br>d: <span class="hljs-type">Char</span> = \<br></code></pre></div></td></tr></table></figure>
<p><strong>字符串字面量</strong></p>
<p>​    <strong>字符串</strong>就是用<strong>双引号” “</strong>包起来的字符序列，长度任意，允许掺杂转义字符。此外，也可以用前后各<strong>三个双引号””” “””</strong>包起来，这样字符串里也能出现双引号，而且转义字符不会被解读</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;\\\\\\&quot;</span><br>a: <span class="hljs-type">String</span> = \\\<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;&quot;&quot;So long \u0041 String \\\&#x27;\&quot;!&quot;&quot;&quot;</span><br>b: <span class="hljs-type">String</span> = <span class="hljs-type">So</span> long <span class="hljs-type">A</span> <span class="hljs-type">String</span> \\\&#x27;\<span class="hljs-string">&quot;!</span><br></code></pre></div></td></tr></table></figure>
<p><strong>字符串插值</strong></p>
<p>​    Scala包括了一个灵活的机制来支持字符串插值，这使得<strong>表达式可以被嵌入在字符串字面量中并被求值</strong>。</p>
<ul>
<li>第一种形式是<strong>s插值器</strong>，即在字符串的双引号前加一个s，形如<strong>s“…${表达式}…”</strong>，s插值器会对内嵌的每个表达式求值，对<strong>求值结果</strong>调用内置的<strong>toString</strong>方法，替换掉字面量中的表达式。从<u>美元符号开始到首个非标识符字符</u>（字母、数字、下划线和操作符的组合，以及反引号对包起来的字符串，称为<strong>标识符</strong>）的部分会被当作表达式，如果有非标识符字符，就必须放在花括号里，且左花括号要紧跟美元符号</li>
<li>第二种形式是<strong>raw插值器</strong>，它与s插值器类似，只不过不识别转义字符</li>
<li>第三种形式是<strong>f插值器</strong>，允许给内嵌的表达式加上printf风格的指令，<strong>指令</strong>放在表达式之后并<strong>以百分号开始</strong>。指令语法来自java.util.Formatter</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;ABC&quot;</span><br>name: <span class="hljs-type">String</span> = <span class="hljs-type">ABC</span><br><br>scala&gt; println(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span> DEFG&quot;</span>)<br><span class="hljs-type">ABC</span> <span class="hljs-type">DEFG</span><br><br>scala&gt; <span class="hljs-string">s&quot;Sum = <span class="hljs-subst">$&#123;1 + 10&#125;</span>&quot;</span> <span class="hljs-comment">//</span><br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Sum</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-string">s&quot;\\\\&quot;</span><br>res1: <span class="hljs-type">String</span> = \\<br><br>scala&gt; <span class="hljs-string">raw&quot;\\\\&quot;</span>    <span class="hljs-comment">// raw插值器</span><br>res2: <span class="hljs-type">String</span> = \\\\<br><br>scala&gt; printf(<span class="hljs-string">f&quot;<span class="hljs-subst">$&#123;math.Pi&#125;</span>%.5f&quot;</span>)    <span class="hljs-comment">// f插值器  %.5f是printf风格，保留小数点后5位</span><br><span class="hljs-number">3.14159</span><br></code></pre></div></td></tr></table></figure>
<h1 id="4-函数及其几种形式"><a href="#4-函数及其几种形式" class="headerlink" title="4 函数及其几种形式"></a>4 函数及其几种形式</h1><h2 id="4-1-定义一个函数"><a href="#4-1-定义一个函数" class="headerlink" title="4.1 定义一个函数"></a>4.1 定义一个函数</h2><p><strong>(1) 定义一个函数</strong></p>
<p>​    Scala的函数定义以<strong>“def”</strong>开头，然后是一个自定义的函数名(推荐驼峰命名法)，接着是用圆括号“( )”包起来的参数列表。在参数列表里，多个参数用逗号隔开，并且每个参数名后面<strong>要紧跟一个冒号以及显式声明的参数类型</strong>，因为编译器在编译期间无法推断出入参类型。写完参数列表后，应该紧跟一个冒号，再添加函数返回结果的类型。最后，再写一个等号“=”，等号后面是用花括号“{ }”包起来的函数体。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">用<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">开始函数定义</span></span><br>       | 函数名<br>       |   |  参数及参数类型<br>       |   |        |   函数返回结果的类型<br>       |   |        |          |  等号<br>       |   |        |          |   |<br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        <span class="hljs-keyword">if</span>(x &gt; y)<br>          x<br>        <span class="hljs-keyword">else</span>  |<br>          y   | <br>      &#125;       |<br>              |<br>       花括号里定义函数体<br></code></pre></div></td></tr></table></figure>
<p><strong>(2) 分号推断</strong></p>
<p>​    在Scala的代码里，<strong>语句末尾的分号是可选的</strong>，因为编译器会自动推断分号。如果一行只有一条完整的语句，那么分号可写可不写；如果<strong>一行有多条语句，则必须用分号隔开</strong>，有三种情况句末<strong>不会推断出分号</strong>：</p>
<ul>
<li><strong>句末</strong>是以非法结尾字符结尾，例如以句点符号“.”或中缀操作符结尾</li>
<li><strong>下一行的句首</strong>是以非法起始字符开始，例如以句点符号“.”开头</li>
<li><strong>跨行</strong>出现的圆括号对“( )”或者方括号对“[ ]”，因为它们里面不能进行分号的自动推断，要么只包含一条完整语句，要么包含用分号显式隔开的多条语句。另外，花括号对“{ }”的里面可以进行分号的自动推断</li>
</ul>
<p>​    为了简洁起见，同时不产生无意的错误和歧义，<strong>建议一行只写一条完整的语句</strong>，句末分号省略，让编译器自动推断。而且内层的语句最好比外一层语句向内缩进两个空格，使得代码层次分明。</p>
<p><strong>(3) 函数返回结果</strong></p>
<p>​    在Scala里，<strong>“return”关键字也是可选的</strong>。默认情况下，编译器会自动为函数体里的最后一个表达式加上“return”，将其作为返回结果。<strong>建议不要显式声明“return”</strong>，这会引发warning，而且使得代码风格看上去像指令式风格。</p>
<p>​    <strong>返回结果的类型</strong>也是可以根据参数类型和返回的表达式来<strong>自动推断</strong>的，也就是说，上例中的“: Int”通常是可以省略的。</p>
<p>​    返回结果<strong>Unit</strong>，表示没有值返回。也就是说，这是一个有副作用的函数，并不能提供任何可引用的返回结果。Unit类型同样可以被推断出来，但如果显式声明为Unit类型的函数，则即使函数体最后有一个可以返回具体值的表达式，也不会把表达式的结果返回。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123; x + y &#125;<br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123; x + y &#125;<br>nothing: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; nothing(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>(4) 函数体与等号</strong></p>
<p>​    Scala的<strong>函数体是用花括号</strong>包起来的，这与C、C++、Java等语言类似。函数体里可以有多条语句，并自动推断分号、返回最后一个表达式。如果<strong>只有一条语句，那么花括号也可以省略</strong>。</p>
<p>​    Scala的<strong>函数定义还有一个等号</strong>，这使得它看起来类似数学里的函数“f(x) = …”。当函数的返回类型没有显式声明时，那么这个<strong>等号可以省略，但是返回类型一定会被推断成Unit类型</strong>，不管有没有值返回，而且<strong>函数体必须有花括号</strong>。当函数的返回类型显式声明时，则无论如何<strong>都不能省略等号</strong>。<strong>建议写代码时不要省略等号</strong>，避免产生不必要的错误，返回类型最好也显式声明。</p>
<p>总结：</p>
<ul>
<li>花括号：<ul>
<li>可以省略：只有一条语句</li>
<li>不可以省略：省略”=”时</li>
</ul>
</li>
<li>“=”：<ul>
<li>可以省略：返回值没有显式声明，此时返回值一定是Unit类型</li>
<li>不可以省略：返回值显式声明</li>
</ul>
</li>
</ul>
<p><strong>(5) 无参函数</strong></p>
<p>​    <strong>无参函数</strong>可以<strong>写一个空括号作参数列表</strong>，或者<strong>不写</strong>。如果有空括号，那么调用时可以写也可以不写空括号；如果没有空括号，那么调用时就一定不能写空括号。原则上，<strong>无副作用</strong>的无参函数<strong>省略括号</strong>，<strong>有副作用</strong>的无参函数<strong>添加括号</strong>，这提醒使用者需要额外小心</p>
<p>无参函数总结：</p>
<ul>
<li>写括号<ul>
<li>建议有副作用函数</li>
<li>调用时可以不写括号，也可以写括号</li>
</ul>
</li>
<li>不写括号<ul>
<li>建议无副作用函数</li>
<li>调用时只可以不写括号</li>
</ul>
</li>
</ul>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>​    方法其实就是定义在class、object、trait里面的函数，这种函数叫做“成员函数”或者“方法”，与多数oop(object-oriented programming)语言一样</p>
<h2 id="4-3-嵌套函数"><a href="#4-3-嵌套函数" class="headerlink" title="4.3 嵌套函数"></a>4.3 嵌套函数</h2><p>​    函数体内部还可以定义函数，这种函数的<strong>作用域是局部的</strong>，<strong>只能被定义它的外层函数调用</strong>，<strong>外部无法</strong>访问。局部函数可以直接使用外层函数的参数，也可以直接使用外层函数的内部变量。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addSub</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span></span>(z: <span class="hljs-type">Int</span>) = z - <span class="hljs-number">10</span><br>         |     <span class="hljs-keyword">if</span>(x &gt; y) sub(x - y) <span class="hljs-keyword">else</span> sub(y - x)<br>         | &#125;<br>addSub: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addSub(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">70</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-4-函数字面量"><a href="#4-4-函数字面量" class="headerlink" title="4.4 函数字面量"></a>4.4 函数字面量</h2><p>​    <strong>函数式编程</strong>有两个主要思想，其中之一就是：<strong>函数是一等(first-class)的值</strong>。换句话说，一个函数的地位与一个Int值、一个String值等等，是一样的（既然一个Int值可以成为函数的参数、函数的返回值、定义在函数体里、存储在变量里，那么，作为地位相同的函数，也可以这样）。</p>
<p>​    你可以把<strong>一个函数当参数</strong>传递给另一个函数，也可以让一个函数<strong>返回一个函数</strong>，亦可以把<strong>函数赋给一个变量</strong>，又或者像定义一个值那样<strong>在函数里定义别的函数</strong>(即前述的嵌套函数)。就像写一个整数字面量“1”那样，Scala也可以<strong>定义函数的字面量</strong>。<strong>函数字面量是一种匿名函数的形式</strong>，它可以存储在变量里、成为函数参数或者当作函数返回值，其定义形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">(参数<span class="hljs-number">1</span>: 参数<span class="hljs-number">1</span>类型, 参数<span class="hljs-number">2</span>: 参数<span class="hljs-number">2</span>类型, ...) =&gt; &#123; 函数体 &#125;<br></code></pre></div></td></tr></table></figure>
<p>​    <strong>通常，函数字面量会赋给一个变量</strong>，这样就能通过“变量名(参数)”的形式来使用函数字面量。在参数类型可以被推断的情况下，可以省略类型，并且参数只有一个时，圆括号也可以省略。</p>
<ul>
<li>圆括号省略：参数只有一个时</li>
<li>类型省略：类型可以被推断时</li>
</ul>
<p>​    <strong>只保留函数体时</strong>，<strong>用下划线“_”作为占位符来代替参数</strong>。在<strong>参数类型不明确时</strong>，需要在下划线后面显式声明其类型。<strong>多个占位符代表多个参数(占位符也可以在大括号函数体内)</strong>，即第一个占位符是第一个参数，第二个占位符是第二个参数……因此不能重复使用某个参数。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> f = (_: <span class="hljs-type">Int</span>) + (_: <span class="hljs-type">Int</span>)<br>f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1072</span>/<span class="hljs-number">1534177037</span><span class="hljs-meta">@fb</span>42c1c<br><br>scala&gt; f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>函数字面量作为返回值：</strong>无论是用“def”定义的函数，还是函数字面量，它们的函数体都可以把一个函数字面量作为一个返回结果，这样就成为了返回函数的函数；它们的参数变量的类型也可以是一个函数，这样调用时给的入参就可以是一个函数字面量。类型为函数的变量，其冒号后面的类型写法是“(参数1类型, 参数2类型,…) =&gt; 返回结果的类型”。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> add = (x: <span class="hljs-type">Int</span>) =&gt; &#123; (y: <span class="hljs-type">Int</span>) =&gt; x + y &#125;<br>add: <span class="hljs-type">Int</span> =&gt; (<span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1192</span>/<span class="hljs-number">1767705308</span>@<span class="hljs-number">55456711</span><br><br>scala&gt; add(<span class="hljs-number">1</span>)(<span class="hljs-number">10</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">11</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aFunc</span></span>(f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>aFunc: (f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; aFunc(x =&gt; x + <span class="hljs-number">1</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>​    在第一个例子中，变量add被赋予了一个返回函数的函数字面量。在调用时，第一个括号里的“1”是传递给参数x，第二个括号里的“10”是传递给参数y。如果没有第二个括号，得到的就不是11，而是“(y: Int) =&gt; 1 + y”这个函数字面量。</p>
<p>​    在第二个例子中，函数aFunc的参数f是一个函数，并且该函数要求是一个入参为Int类型、返回结果也是Int类型的函数。在调用时，给出了函数字面量“x =&gt; x + 1”。这里没有显式声明x的类型，因为可以通过f的类型来推断出x必须是一个Int类型。在执行时，首先求值f(1)，结合参数“1”和函数字面量，可以算出结果是2。那么，“f(1) + 1”就等于3了。</p>
<h2 id="4-5-部分应用函数"><a href="#4-5-部分应用函数" class="headerlink" title="4.5 部分应用函数"></a>4.5 部分应用函数</h2><p>​    部分应用函数（使得def函数实现函数一等值效果）：给出一部分参数的情况下，赋值给一个变量</p>
<p>​    上面介绍的函数字面量实现了函数作为一等值的功能，而用“def”定义的函数也具有同样的功能，只不过需要借助部分应用函数的形式来实现。例如，有一个函数定义为“def max(…) …”，若想要把这个函数存储在某个变量里，不能直接写成“val x = max”的形式，而<strong>必须像函数调用那样，给出一部分参数</strong>，故而称作<strong>部分应用函数</strong>(如果参数全给了，就成了函数调用)。<strong>部分应用函数的作用</strong>，就是把def函数打包到一个函数值里，使它可以赋给变量，或当作函数参数进行传递。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//定义了一个函数</span><br>sum: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> b = sum(<span class="hljs-number">1</span>, _: <span class="hljs-type">Int</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">//提供了一个参数</span><br>b: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1204</span>/<span class="hljs-number">1037479646</span>@<span class="hljs-number">5</span>b0bfe86<br><br>scala&gt; b(<span class="hljs-number">2</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-keyword">val</span> c = sum _   <span class="hljs-comment">//一个参数都没有给出，像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</span><br>c: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = $$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1208</span>/<span class="hljs-number">1853277442</span>@<span class="hljs-number">5e4</span>c26a1<br><br>scala&gt; c(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<p>​    变量a其实是获得了函数sum调用的返回结果，变量b则是获得了部分应用函数打包的sum函数，因为只给出了参数x和z的值，参数y没有给出。注意，<strong>没给出的参数用下划线代替，而且必须显式声明参数类型</strong>。变量c也是部分应用函数，只不过一个参数都没有明确给出。<strong>像这样一个参数都不给的部分应用函数，只需要在函数名后面给一个下划线即可</strong>，注意函数名和下划线之间必须有空格。</p>
<p>​    如果部分应用函数一个参数都没有给出，比如例子中的c，那么在需要该函数作入参的地方，下划线也可以省略（注：不要和前面给变量赋值的部分应用函数混淆，前者需要有下划线）。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">needSum</span></span>(f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>) = f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>needSum: (f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br><span class="hljs-comment">//在需要c函数作入参的地方</span><br><br>scala&gt; needSum(sum _) <span class="hljs-comment">//下划线</span><br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; needSum(sum) <span class="hljs-comment">//省略下划线</span><br>res3: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-6-闭包"><a href="#4-6-闭包" class="headerlink" title="4.6 闭包"></a>4.6 闭包</h2><p>​    一个函数除了可以使用它的参数外，还能<strong>使用定义在函数以外的其他变量</strong>。</p>
<ul>
<li><p>函数的参数称为<strong>绑定变量</strong>，因为完全可以根据函数的定义得知参数的信息</p>
</li>
<li><p>函数以外的变量称为<strong>自由变量</strong>，因为函数自身无法给出这些变量的定义</p>
</li>
</ul>
<p>​    这样的函数称为<strong>闭包</strong>，因为它要在运行期间捕获自由变量，让函数闭合，定义明确。自由变量必<strong>须在函数前面定义</strong>，否则编译器就找不到，会报错。</p>
<p>​    闭包捕获的自由变量是闭包创建时活跃的那个自由变量，后续若<strong>新建同名的自由变量来覆盖前面的定义</strong>，由于闭包已经闭合完成，所以新自由变量与已创建的闭包无关。如果闭包捕获的自由变量本身是一个可变对象(例如var类型变量)，那么闭包会随之改变。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> more = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">val</span> addMore = (x: <span class="hljs-type">Int</span>) =&gt; x + more  <span class="hljs-comment">// addMore = x + 1</span><br><br>more = <span class="hljs-number">2</span>                                           <span class="hljs-comment">// addMore = x + 2</span><br><br><span class="hljs-keyword">var</span> more = <span class="hljs-number">10</span>                                   <span class="hljs-comment">// addMore = x + 2</span><br><br>more = <span class="hljs-number">-100</span>                                      <span class="hljs-comment">// addMore = x + 2</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-7-函数的体术调用形式"><a href="#4-7-函数的体术调用形式" class="headerlink" title="4.7 函数的体术调用形式"></a>4.7 函数的体术调用形式</h2><p><strong>（1）具名参数</strong>（就是普通用法）</p>
<p>​    <strong>普通函数</strong>调用形式是<strong>按参数的先后顺序逐个传递的</strong>，但如果调用时显式声明参数名并给其赋值，则可以无视参数顺序。按位置传递的参数和按名字传递的参数可以混用，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(<span class="hljs-number">1</span>, z = <span class="hljs-number">10</span>, y = <span class="hljs-number">100</span>)<br>y is maximum <br></code></pre></div></td></tr></table></figure>
<p><strong>（2）默认参数值（和以前学的一样）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">if</span>(x &gt; y &amp;&amp; x &gt; z) println(<span class="hljs-string">&quot;x is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; x &amp;&amp; y &gt; z) println(<span class="hljs-string">&quot;y is maximum&quot;</span>)<br>         |     <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;z is maximum&quot;</span>)<br>         |  &#125;<br>max: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; max(y = <span class="hljs-number">3</span>, z = <span class="hljs-number">5</span>)<br>x is maximum<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）重复参数（类似C中的arg*）</strong></p>
<p>​    Scala允许把<strong>函数的最后一个参数标记为重复参数</strong></p>
<p>​    形式为在最后一个参数的类型后面加上星号<strong>“*</strong>”。重复参数的意思是可以在运行时传入任意个相同类型的元素，包括零个。<strong>类型为“T*”的参数的实际类型是“Array[T]”</strong>，即若干个T类型对象构成的数组（尽管是T类型的数组，但<strong>要求传入参数的类型仍然是T</strong>，如果传入的<strong>实参是T类型对象构成的数组，则会报错</strong>，除非用<strong>“变量名: _*</strong>”的形式告诉编译器把数组元素一个一个地传入）</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addMany</span></span>(msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*) = &#123;undefined<br>         |     <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>         |     <span class="hljs-keyword">for</span>(x &lt;- num) sum += x<br>         |     println(msg + sum)<br>         |  &#125;<br>addMany: (msg: <span class="hljs-type">String</span>, num: <span class="hljs-type">Int</span>*)<span class="hljs-type">Unit</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>sum = <span class="hljs-number">6</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>)<br>sum = <span class="hljs-number">0</span><br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]<br> required: <span class="hljs-type">Int</span><br>       addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>                              ^<br><br>scala&gt; addMany(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): _*)<br>sum = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-8-柯里化"><a href="#4-8-柯里化" class="headerlink" title="4.8 柯里化"></a>4.8 柯里化</h2><p>​    对大多数编程语言来说，<strong>函数只能有一个参数列表</strong>，但是列表里可以有若干个用逗号间隔的参数。</p>
<p>​    Scala有一个独特的语法——<strong>柯里化</strong>，也就是一个函数可以<strong>有任意个参数列表</strong>。</p>
<p>​    柯里化往往与另一个语法结合使用：当参数列表里只有一个参数时，在调用该函数时允许单个参数不用圆括号包起来，改用花括号也是可行的。</p>
<p>​    这样做的<strong>好处是</strong>：在自定义类库时，自定义方法就好像“if(…) {…}”、“while(…) {…}”、“for(…) {…}”等内建控制结构一样，让人看上去<strong>以为是内建控制</strong>，丝毫看不出是自定义语法。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//普通相加函数</span><br>add: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>, z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addCurry</span></span>(x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>) = x + y + z <span class="hljs-comment">//柯里化，addCurry拥有三个参数列表</span><br>addCurry: (x: <span class="hljs-type">Int</span>)(y: <span class="hljs-type">Int</span>)(z: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span><br><br>scala&gt; addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) &#123;<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//用&#123;&#125;代替()的参数列表，从而表现得if,while,for等内建结构一样</span><br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<h2 id="4-9-传名参数（把函数作为形参情况下的简洁用法）"><a href="#4-9-传名参数（把函数作为形参情况下的简洁用法）" class="headerlink" title="4.9 传名参数（把函数作为形参情况下的简洁用法）"></a>4.9 传名参数（把函数作为形参情况下的简洁用法）</h2><p>​    4.4介绍了<strong>函数字面量</strong>如何作为函数的参数进行传递，以及如何表示类型为函数时参数的类型。如果某个函数的入参类型是一个无参函数，那么通常的类型表示法是“() =&gt; 函数的返回类型”。在调用这个函数时，给出的参数就必须写成形如<strong>“() =&gt; 函数体”</strong>这样的函数字面量</p>
<p><strong>（1）传名参数是什么</strong></p>
<p>​    <strong>为了让代码看起来更舒服</strong>，也为了让自定义控制结构<strong>更像内建结构</strong>，Scala又提供了一个特殊语法——<strong>传名参数</strong>。</p>
<p>​    <strong>传名参数</strong>是类型是一个无参函数的<strong>函数入参</strong>。传名参数的类型表示法是<strong>“=&gt; 函数的返回类型”</strong>，即<strong>相对常规表示法去掉了前面的空括号</strong>。在调用该函数时，传递进去的函数字面量则可以只写“函数体”，去掉了“() =&gt;”。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> assertionEnabled = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// predicate是类型为无参函数的函数入参</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAssert</span></span>(predicate: () =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 常规版本的调用</span><br>myAssert(() =&gt; <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br><br> <span class="hljs-comment">//////////////////////////////////////////////</span><br><span class="hljs-comment">// 传名参数的用法，注意因为去掉了空括号，所以调用predicate时不能有括号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byNameAssert</span></span>(predicate: =&gt; <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><br><span class="hljs-comment">// 传名参数版本的调用，看上去更自然</span><br>byNameAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p> <strong>（2）调用函数与传名参数的一致性写法</strong></p>
<p>​    可以看到，传名参数使得代码更加简洁、自然，而常规写法则很别扭。事实上，predicate的类型可以改成Boolean的<strong>一个变量</strong>，而不必是一个<strong>返回Boolean的函数</strong>，这样<strong>调用函数时与传名参数是一致的</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 使用布尔型参数的版本</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boolAssert</span></span>(predicate: <span class="hljs-type">Boolean</span>) =<br>  <span class="hljs-keyword">if</span>(assertionEnabled &amp;&amp; !predicate)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AssertionError</span><br><span class="hljs-comment">// 布尔型参数版本的调用</span><br>boolAssert(<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）调用机制说明</strong></p>
<p>​    尽管byNameAssert和boolAssert在调用形式上是一样的，但是两者的运行机制却不完全一样。如果给函数的实参是一个表达式，比如“5 &gt; 3”这样的表达式，那么boolAssert在运行之前会先对表达式求值，然后把求得的值传递给函数去运行。而myAssert和byNameAssert则不会一开始就对表达式求值，它们是直接运行函数，直到函数调用入参时才会对表达式求值，也就是例子中的代码运行到“!predicate”时才会求“5 &gt; 3”的值。</p>
<p>​    为了说明这一点，可以传入一个产生异常的表达式，例如除数为零的异常。例子中，逻辑与“&amp;&amp;”具有短路机制：如果&amp;&amp;的左侧是false，那么直接跳过右侧语句的运行(事实上，这种短路机制也是通过传名参数实现的)。所以，布尔型参数版本会抛出除零异常，常规版本和传名参数版本则不会发生任何事。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code> 如果把变量assertionEnabled设置为true，让&amp;&amp;右侧的代码执行，那么三个函数都会抛出除零异常：
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; assertionEnabled = <span class="hljs-literal">true</span><br>assertionEnabled: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; myAssert(() =&gt; <span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res30$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .myAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; byNameAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  at .$anonfun$res31$<span class="hljs-number">1</span>(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  at .byNameAssert(&lt;console&gt;:<span class="hljs-number">13</span>)<br>  ... <span class="hljs-number">28</span> elided<br><br>scala&gt; boolAssert(<span class="hljs-number">5</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>)<br>java.lang.<span class="hljs-type">ArithmeticException</span>: / by zero<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure>
<h2 id="4-10-章节总结"><a href="#4-10-章节总结" class="headerlink" title="4.10 章节总结"></a>4.10 章节总结</h2><p>​    本章内容是对Scala的函数的讲解，重点在于理解函数作为一等值的概念，函数字面量的作用以及部分应用函数的作用。在阅读复杂的代码时，常常遇见诸如<strong>“def xxx(f: T =&gt; U, …) …”或 “def xxx(…): T =&gt; U”</strong>的代码，要理解前者表示需要传入一个函数作为参数，后者表示函数返回的对象是一个函数。在学习初期，理解函数是一等值的概念可能有些费力，通过大量阅读和编写代码才能熟能生巧。同时不要忘记前一章说过，<strong>函数的参数都是val类型的，在函数体内不能修改传入的参数。</strong></p>
<h1 id="5-类和对象"><a href="#5-类和对象" class="headerlink" title="5 类和对象"></a>5 类和对象</h1><h2 id="5-1-类"><a href="#5-1-类" class="headerlink" title="5.1 类"></a>5.1 类</h2><p>说了一堆废话，和Java差不多就是</p>
<blockquote>
<p>​        在Scala里，类是用关键字<strong>“class”</strong>开头的代码定义。它是对象的<strong>蓝图</strong>，一旦定义完成，就可以通过<strong>“new 类名”</strong>的方式来<strong>构造一个对象</strong>。而这个对象的类型，就是这个类。换句话说，一个类就是一个类型，不同的类就是不同的类型。在后续的章节中，会讲到类的继承关系，以及超类、子类和子类型多态的概念。</p>
<p>​    在类里可以定义val或var类型的变量，它们被称为“<strong>字段</strong>”；还可以定义“def”函数，它们被称为<strong>“方法”</strong>；字段和方法统称<strong>“成员”</strong>。字段通常用于保存对象的状态或数据，而方法则用于承担对象的计算任务。<strong>字段也叫“实例变量”</strong></p>
</blockquote>
<p>​    <strong>介绍对象在操作系统中的情况：</strong></p>
<blockquote>
<p>因为每个被构造出来的对象都有其自己的字段。在运行时，操作系统会为每个对象分配一定的内存空间，用于保存对象的字段。方法则不同，对所有对象来说，方法都是一样的程序段，因此不需要为某个对象单独保存其方法。而且，方法的代码只有在被调用时才会被执行，如果一个对象在生命周期内都没有调用某些方法，那么完全没必要浪费内存为某个对象去保存这些无用的代码</p>
</blockquote>
<p>​    <strong>访问对象：</strong></p>
<p>​    <strong>需要注意的是</strong>，val类型的变量只能与初始化时的对象绑定，<strong>不能再被赋予新的对象（相同类也不行）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">1</span>a2e563e<br><br>scala&gt; stu.name<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">None</span><br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>res2: <span class="hljs-type">String</span> = <span class="hljs-type">Bob</span><br><br>scala&gt; stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>  <span class="hljs-comment">//无法重新赋值给一个变量</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: reassignment to <span class="hljs-keyword">val</span><br>       stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>           ^<br></code></pre></div></td></tr></table></figure>
<p>​    Scala的<strong>类成员默认都是公有的</strong>，<strong>没有“public”这个关键字</strong>，有private作为私有成员，示例代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;None&quot;</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span></span>(n: <span class="hljs-type">String</span>) = name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(name)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">75063</span>bd0<br><br>scala&gt; stu.register(<span class="hljs-string">&quot;Bob&quot;</span>)<br><br>scala&gt; stu.name<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: variable name in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">cannot</span> <span class="hljs-title">be</span> <span class="hljs-title">accessed</span> <span class="hljs-title">in</span> <span class="hljs-title">Students</span></span><br>       stu.name<br>           ^<br><br>scala&gt; stu.display<br><span class="hljs-type">Bob</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-2-类的构造方法"><a href="#5-2-类的构造方法" class="headerlink" title="5.2 类的构造方法"></a>5.2 类的构造方法</h2><p><strong>（1）主构造方法</strong></p>
<ul>
<li><p>Scala不需要显式定义构造方法 ，而是把<strong>类内部非字段、非方法的代码都</strong>当作<strong>“主构造方法”</strong></p>
<ul>
<li><strong>大白话</strong>：没有用函数框框起来的都是主构造方法</li>
</ul>
</li>
<li><p>类名后面可以定义<strong>若干个参数列表</strong>，用于接收参数，这些参数将在构造对象时用于初始化字段并传递给主构造方法使用。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-type">A</span> student named <span class="hljs-type">Tom</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">5464</span>eb28<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>（了解）在这个例子中，Students类接收一个String参数n，并用n来初始化字段name。这样做，就无需像之前那样把name定义成var类型，而是使用函数式风格的val类型，而且不再需要一个register方法在构造对象时来更新name的数据</p>
<p>函数println既不是字段，也不是方法定义，所以被当成是主构造函数的一部分。在构造对象时，主构造函数被执行，因此在解释器里打印了相关信息</p>
</blockquote>
<p><strong>（2）辅助构造方法</strong></p>
<p>​    除了主构造方法，<strong>还可以定义若干个辅助构造方法</strong>。辅助构造方法都是以<strong>“def this(……)”</strong>来开头的，而且<strong>第一步行为必须是调用该类的另一个构造方法</strong>，即第一条语句必须是“this(……)”——要么是主构造方法，要么是之前的另一个辅助构造方法。这种规则的结果就是任何构造方法<strong>最终都会调用该类的主构造方法</strong>，使得主构造方法成为类的<strong>单一入口</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;None&quot;</span>) <span class="hljs-comment">//辅助构造方法</span><br>         |    println(<span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot; has been registered.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span><br><span class="hljs-type">A</span> student named <span class="hljs-type">None</span> has been registered.<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">74309</span>cd5<br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在这个例子中，定义了一个辅助构造方法，该方法是无参的，其行为也仅是给主构造方法传递一个字符串“None”。在后面创建对象时，缺省了参数，这样与主构造方法的参数列表是不匹配的，但是与辅助构造方法匹配，所以stu指向的对象是用辅助构造方法构造的。</p>
<p>在Java里，辅助构造方法可以调用超类的构造方法，而Scala加强了限制，只允许主构造方法调用超类的构造方法(详情见后续章节)。这种限制源于Scala为了代码简洁性与简单性做出的折衷处理。</p>
</blockquote>
<p><strong>（3）析构函数</strong>（也就是没有）</p>
<p>​    因为Scala没有指针，同时使用了Java的垃圾回收器，所以不需要像C++那样定义析构函数</p>
<p><strong>（4）私有主构造方法</strong></p>
<p>​    在<strong>类名与类的参数列表之间</strong>加上关键字<strong>“private”</strong>，那么<strong>主构造方法</strong>就是<strong>私有的</strong>，<strong>只能被内部定义访问</strong>，外部代码构造对象时就<strong>不能通过主构造方法进行</strong>，而<strong>必须使用其他公有的辅助构造方法或工厂方法</strong>(专门用于构造对象的方法)。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span> <span class="hljs-title">private</span> (<span class="hljs-params">n: <span class="hljs-type">String</span>, m: <span class="hljs-type">Int</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">val</span> score = m<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(n: <span class="hljs-type">String</span>) = <span class="hljs-keyword">this</span>(n, <span class="hljs-number">100</span>)<br>         |    println(n + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + m)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: too many arguments (<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> constructor <span class="hljs-type">Students</span>: (n: <span class="hljs-type">String</span>)<span class="hljs-type">Students</span><br>       <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">90</span>)<br>                                      ^<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Bill&quot;</span>)<br><span class="hljs-type">Bill</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Students</span>@<span class="hljs-number">7509</span>b8e7<br></code></pre></div></td></tr></table></figure>
<h2 id="5-3-重写toString方法"><a href="#5-3-重写toString方法" class="headerlink" title="5.3 重写toString方法"></a>5.3 重写toString方法</h2><p>toString构造完一个对象时自动被调用的那个方法</p>
<blockquote>
<p>​    细心的读者会发现，在前面构造一个Students类的对象时，Scala解释器打印了一串晦涩的信息“Students@7509b8e7”。这其实来自于Students类的toString方法，这个方法返回一个字符串，并在<strong>构造完一个对象时被自动调用</strong>，返回结果交给解释器打印。该方法是所有Scala类<strong>隐式继承</strong>来的，如果不重写这个方法，就会用默认继承的版本。</p>
</blockquote>
<p>​    默认的toString方法来自于<strong>java.lang.Object类</strong>，其行为只是简单地打印类名、一个“@”符号和一个十六进制数。如果想让解释器输出更多有用的信息，则可以自定义toString方法。不过，这个方法是继承来的，要重写它必须在前面加上<strong>关键字“override”</strong>(后续章节会讲到override的作用)。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">n: <span class="hljs-type">String</span></span>) </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> name = n<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">&quot;A student named &quot;</span> + n + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Nancy&quot;</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">A</span> student named <span class="hljs-type">Nancy</span>.<br></code></pre></div></td></tr></table></figure>
<h2 id="5-4-方法重载"><a href="#5-4-方法重载" class="headerlink" title="5.4 方法重载"></a>5.4 方法重载</h2><p>​    在类里定义了<strong>多个同名的方法</strong>，但是每个方法的<strong>参数(主要是参数类型)不一样</strong>，那么就称这个方法有多个不同的版本。这就叫方法重载，它是面向对象里多态属性的一种表现。这些方法虽然同名，但是它们是不同的，因为函数真正的特征标是它的参数，而不是函数名或返回类型。</p>
<p>​    注意重载与前面的重写的区别，重载是一个类里有多个不同版本的同名方法，重写是子类覆盖定义了超类的某个方法。</p>
<h2 id="5-5-类的参数"><a href="#5-5-类的参数" class="headerlink" title="5.5 类的参数"></a>5.5 类的参数</h2><ul>
<li><strong>前面的例子：</strong>从前面的例子可以发现，<strong>很多时候类的参数仅仅是直接赋给某些字段</strong>。</li>
<li><strong>参数自动复制到内部成员：</strong>Scala为了进一步简化代码，允许在类参数前加上<strong>val或var来修饰</strong>，这样就会在类的内部会生成<strong>一个与参数同名的公有字段</strong>。构造对象时，<strong>这些参数会直接复制给同名字段</strong>。</li>
<li><strong>参数限定权限：</strong>除此之外，还可以加上<strong>关键字private、protected或override来表明字段的权限</strong>(<a href="#限定词与自限定"><strong>关于权限修饰见后续章节</strong></a>)。如果<strong>参数没有任何关键字，那它就仅仅是“参数”，不是类的成员</strong>，只能用来初始化字段或给方法使用。外部不能访问这样的参数，内部也不能修改它。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;undefined <span class="hljs-comment">//此处用val和var分别修饰了name和score</span><br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">90</span>)<br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">90.</span><br><br>scala&gt; stu.exam(<span class="hljs-number">100</span>)<br><br>scala&gt; stu.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-6-单例对象与伴生对象（静态变量）"><a href="#5-6-单例对象与伴生对象（静态变量）" class="headerlink" title="5.6 单例对象与伴生对象（静态变量）"></a>5.6 单例对象与伴生对象（静态变量）</h2><blockquote>
<div class="hljs code-wrapper"><pre><code> 在Scala里，除了用new可以构造一个对象，也可以用“object”开头定义一个对象。它类似于类的定义，只不过不能像类那样有参数，也没有构造方法。因此，不能用new来实例化一个object的定义，因为它已经是一个对象了。
</code></pre></div><p>​    <strong>单例对象定义</strong>：用“object”开头定义一个对象对象和用new实例化出来的对象没有什么区别，只不过new实例的对象是以类为蓝本构建的，并且数量没限制，而<strong>object定义的对象只能有这一个</strong>，故而得名<strong>“单例对象”</strong>。</p>
<p>​    </p>
</blockquote>
<ul>
<li><p>class：定义一个类</p>
</li>
<li><p>object：定义一个单例对象</p>
</li>
<li><p>new：实例化一个对象</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>伴生对象定义</strong>：如果某个单例对象和某个类同名，那么<strong>单例对象称为</strong>这个类的<strong>“伴生对象”</strong>，同样，<strong>类称</strong>为这个<strong>单例对象的“伴生类”</strong>。<strong>伴生类和伴生对象必须在同一个文件</strong>里，而且两者可以<strong>互访对方所有</strong>成员。</p>
</blockquote>
<ul>
<li>同名的某个类：<strong>伴生类</strong></li>
<li>同名的单例对象：<strong>伴生对象</strong></li>
<li>伴生类和伴生对象必须在同一文件中</li>
</ul>
<hr>
<blockquote>
<p>​    在C++、Java等oop语言里，类内部可以定义静态变量。这些静态变量不属于任何一个用new实例化的对象，而是它们的公有部分。Scala追求纯粹的面向对象属性，即所有的事物都是类或对象，但是静态变量这种不属于类也不属于对象的事物显然违背了Scala的理念。所以，Scala的做法是<strong>把类内所有的静态变量从类里移除</strong>，转而<strong>集中定义在伴生对象里</strong>，让静态变量属于伴生对象这个独一无二的对象。</p>
<p>​    既然单例对象和new实例的对象一样，那么类内可以定义的代码，单例对象同样可以拥有。例如，单例对象里面可以定义字段和方法。Scala允许在类里定义别的类和单例对象，所以单例对象也可以包含别的类和单例对象的定义。</p>
</blockquote>
<p>单例对象的<strong>作用</strong>：</p>
<ul>
<li><strong>用作伴生对象</strong></li>
<li>打包某方面功能的函数系列成为一个<strong>工具集</strong></li>
<li>包含<strong>主函数</strong>成为程序的入口</li>
</ul>
<hr>
<blockquote>
<p>“object”后面定义的<strong>单例对象名</strong>可以认为是这个单例对象的<strong>名称标签</strong>，因此可以通过句点符号访问单例对象的成员——“单例对象名.成员”，<strong>也可以赋给一个变量</strong>——“val 变量 = 单例对象名”，<strong>就像用new实例的对象那样</strong>。</p>
</blockquote>
<ul>
<li><p>名称标签：“object”后面定义的单例对象名</p>
</li>
<li><p>定义方式：object可以赋值给一个变量，就和new实例化一样</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">A</span>@<span class="hljs-number">7e5831</span>c4<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; (<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>).a<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span> </span>&#123; <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;a singleton object&quot;</span> &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-type">B</span>.b<br>res2: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-type">B</span><br>y: <span class="hljs-type">B</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">B</span>$@<span class="hljs-number">4489</span>b853<br><br>scala&gt; y.b<br>res3: <span class="hljs-type">String</span> = a singleton <span class="hljs-class"><span class="hljs-keyword">object</span></span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>object.type：</strong></p>
<p>​    前面说过，<strong>定义一个类，就是定义了一种类型</strong>。从抽象层面讲，<strong>定义单例对象却并没有定义一种类型</strong>。实际上<strong>每个单例对象有自己独特的类型</strong>，即<strong>object.type</strong>（可以认为新类型出现了，只不过这个类型并不能用来归类某个对象集合，等同于没有定义新类型）</p>
<p>​    即使是<strong>伴生对象也没有定义类型</strong>，而是<strong>由伴生类定义了同名的类型</strong>。后续章节将讲到，单例对象可以<strong>继承自超类</strong>或<strong>混入特质</strong>，这样它就能<strong>出现在需要超类对象的地方</strong>。例如下面的例子中，可以明确看到X.type和Y.type两种新类型出现，并且是不一样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">X</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Y</span></span><br><br>scala&gt; <span class="hljs-keyword">var</span> x = <span class="hljs-type">X</span><br>x: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span> = <span class="hljs-type">X</span>$@<span class="hljs-number">630</span>bb67<br><br>scala&gt; x = <span class="hljs-type">Y</span><br>&lt;console&gt;:<span class="hljs-number">17</span>: error: <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">mismatch</span></span>;<br> found   : <span class="hljs-type">Y</span>.<span class="hljs-keyword">type</span><br> required: <span class="hljs-type">X</span>.<span class="hljs-keyword">type</span><br>       x = <span class="hljs-type">Y</span><br>           ^<br></code></pre></div></td></tr></table></figure>
<h2 id="5-7-工厂对象与工厂方法"><a href="#5-7-工厂对象与工厂方法" class="headerlink" title="5.7 工厂对象与工厂方法"></a>5.7 工厂对象与工厂方法</h2><p>​    如果定义<strong>一个方法专门用来构造某一个类的对象</strong>，那么<strong>这种方法</strong>就称为<strong>“工厂方法”。</strong>包含这些工厂方法集合的单例对象，也就叫<strong>“工厂对象”</strong> 。</p>
<p>工厂对象的使用场景和好处：</p>
<div class="hljs code-wrapper"><pre><code>+ 通常，**工厂方法会定义在伴生对象里**。
+ 当一系列类存在继承关系时，可以在基类的伴生对象里定义一系列对应的工厂方法。
+ **使用工厂方法的好处**是可以不用直接使用new来实例化对象，改用方法调用，而且方法名可以是任意的，这样**对外隐藏了类的实现细节**。例如：
</code></pre></div><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">registerStu</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    将文件students.scala编译后，并在解释器里用<strong>“import Students._</strong>”导入单例对象后，就能这样使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><span class="hljs-keyword">import</span> <span class="hljs-type">Students</span>._<br><br>scala&gt; <span class="hljs-keyword">val</span> stu = registerStu(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment">//利用工厂方法生成对象</span><br>stu: <span class="hljs-type">Students</span> = <span class="hljs-type">Tim</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">100.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-8-一个特殊的方法：apply方法"><a href="#5-8-一个特殊的方法：apply方法" class="headerlink" title="5.8 一个特殊的方法：apply方法"></a>5.8 一个特殊的方法：apply方法</h2><blockquote>
<p>如果定义了这个方法，那么既可以显式调用——“对象.apply(参数)” ，也可以隐式调用——“对象(参数)”。隐式调用时，编译器会自动插入缺失的“.apply”。如果apply是无参方法，应该写出空括号，否则无法隐式调用。无论是类还是单例对象，都能定义这样的apply方法。</p>
</blockquote>
<p><strong>apply方法特殊点：</strong>这个方法可以进行隐式调用，如果是无参方法应有空括号，无论是类还是单例对象都可以定义apply方法</p>
<p><strong>apply方法的调用：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">对象(参数)  		<span class="hljs-comment">//隐式，省略了.apply</span><br>对象.apply(参数)	<span class="hljs-comment">//显式，和正常调用方法一样</span><br></code></pre></div></td></tr></table></figure>
<p><strong>apply方法使用场景：</strong></p>
<ul>
<li><strong>在伴生对象里定义名为apply的工厂方法，就能通过“伴生对象名(参数)”来构造一个对象。</strong></li>
<li>也常常在类里定义一个与类相关的、具有特定行为的apply方法，<strong>让使用者可以隐式调用，进而隐藏相应的实现细节</strong>。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="5-9-主函数"><a href="#5-9-主函数" class="headerlink" title="5.9 主函数"></a>5.9 主函数</h2><p>​    <strong>主函数是Scala程序唯一的入口</strong>，即程序是从主函数开始运行的。要提供这样的入口，则必须<strong>在某个单例对象里定义一个名为“main”的函数</strong>，而且<strong>该函数只有一个参数</strong>，<strong>类型为字符串数组Array[String]</strong>，函数的<strong>返回类型是Unit</strong>。<strong>任何符合条件的单例对象都能成为程序的入口</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// students2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students2</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;Current score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Students2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, score: <span class="hljs-type">Int</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">Students2</span>(name, score)<br>&#125;<br> <br><span class="hljs-comment">// main.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> score = args(<span class="hljs-number">1</span>).toInt<br>      <span class="hljs-keyword">val</span> s = <span class="hljs-type">Students2</span>(args(<span class="hljs-number">0</span>), score)<br>      println(s.toString)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">ArrayIndexOutOfBoundsException</span> =&gt; println(<span class="hljs-string">&quot;Arguments are deficient!&quot;</span>)<br>      <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Second argument must be a Int!&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>使用命令<code>scalac students2.scala main.scala</code>将两个文件编译后</p>
</li>
<li><p>用命令<code>scala Start 参数1 参数2</code>来运行程序。（命令里的“Start”就是包含主函数的单例对象的名字，后面可以输入若干个用空格间隔的参数。这些参数被打包成字符串数组供主函数使用，也就是代码里的args(0)、args(1)。）</p>
</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom<br>Arguments are deficient!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom aaa<br>Second argument must be a Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala <span class="hljs-built_in">Start</span> Tom <span class="hljs-number">100</span><br>Tom<span class="hljs-string">&#x27;s score is 100.</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p>​    <strong>主函数的一种简化写法是让单例对象混入“App”特质</strong>(特质在后续章节讲解)，这样就<strong>只要在单例对象里编写主函数的函数体</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// main2.scala</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Start2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(arg &lt;- args) &#123;<br>      sum += arg.toInt<br>    &#125;<br>    println(<span class="hljs-string">&quot;sum = &quot;</span> + sum)<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> ex: <span class="hljs-type">NumberFormatException</span> =&gt; println(<span class="hljs-string">&quot;Arguments must be Int!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将文件编译后，就可以如下使用：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> AAA<br>Arguments must be Int!<br><span class="hljs-built_in">PS</span> E:\Microsoft VS\Scala&gt; scala Start2 <span class="hljs-number">10</span> <span class="hljs-literal">-8</span> <span class="hljs-number">20</span> <span class="hljs-number">8</span><br>sum = <span class="hljs-number">30</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-10-章节总结"><a href="#5-10-章节总结" class="headerlink" title="5.10 章节总结"></a>5.10 章节总结</h2><p>​    本章讲解了Scala的类和对象，从中可以初窥Scala在语法精简和便捷上的努力。<strong>难点是</strong>理解单例对象的概念、类与类型的关系和工厂方法的作用。如果读者有其他oop语言基础，在这里也并不是能一下就接受Scala的语法。最后一个重点就是学会灵活使用apply方法。</p>
<h1 id="6-操作符即方法"><a href="#6-操作符即方法" class="headerlink" title="6 操作符即方法"></a>6 操作符即方法</h1><h2 id="6-1-操作符在Scala里的解释"><a href="#6-1-操作符在Scala里的解释" class="headerlink" title="6.1 操作符在Scala里的解释"></a>6.1 操作符在Scala里的解释</h2><blockquote>
<p>​    在诸如C++、Java等oop语言里，定义了像byte、short、int、char、float之类的基本类型，但是<strong>这些基本类型不属于面向对象的范畴</strong>。就好比C语言也有这些类型，但是C语言根本没有面向对象的概念。 比如只能说“1”是一个int类型的常量，却不能说它是一个int类型的对象。与之对应的，这些语言还定义了与基本类型相关的操作符。例如，有算术操作符加法“+”，它可以连接左、右两个操作数，然后算出相应的总和。</p>
</blockquote>
<p>​    前面提到，Scala追求纯粹的面向对象，像这种不属于面向对象范畴的基本类型及其操作符都是有违宗旨的。那么，Scala如何实现这些基本类型呢？实际<strong>在Scala标准库里定义了“class Byte”、“class  Short”、“class  Char”、“class Int”、“class  Long”、“class  Float”、“class  Double”、“class  Boolean”和“class Unit”九种值类，</strong>只不过<strong>这些类是抽象的、不可继承的，因此不能通过“new Int”这种语句来构造一个Int对象，也不能编写它们的子类，它们的对象都是由字面量来表示</strong>。例如，整数字面量“1”就是一个Int的对象。在运行时，前八种值类会被转换成对应的Java基本类型。第九个Unit类对应Java的“void”类型，即表示空值，这样就能理解返回值类型为Unit的、有副作用的函数其实是空函数。<strong>Unit类的对象由一个空括号作为字面量来表示。</strong></p>
<p>​    <strong>简而言之，Scala做到了真正的“万物皆对象”。</strong></p>
<p>​    还有，与基本类型相关的操作符该如何处理呢？严格来讲，<strong>Scala并不存在操作符的概念</strong>，这些所谓的操作符，例如算术运算的加减乘除，逻辑运算的与或非，比较运算的大于小于等等，其实都是定义在“class Int”、“class Double”等类里的成员方法。也就是说，<strong>在Scala里，操作符即方法。</strong>例如，Int类定义了一个名为“+”的方法，那么表达式“1 + 2”的真正形式应该是“1.+(2)”。它的释义是：Int对象“1”调用了它的成员方法“+”，并把Int对象“2”当作参数传递给了该方法，最后这个方法会返回一个新的Int对象“3”。</p>
<p>​    <strong><u>//////重要使用方法：类似操作符的方法调用（省略句号）///////</u></strong></p>
<p>​    推而广之，<u>“操作符即方法”的概念不仅仅限于九种值类的操作符，<strong>Scala里任何类定义的成员方法都是操作符，而且方法调用都能写成操作符的形式：去掉句点符号，并且方法参数只有一个时可以省略圆括号。</strong></u>示例代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, var score: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exam</span></span>(s: <span class="hljs-type">Int</span>) = score = s<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friends</span></span>(n: <span class="hljs-type">String</span>, s: <span class="hljs-type">Int</span>) = println(<span class="hljs-string">&quot;My friend &quot;</span> + n + <span class="hljs-string">&quot; gets &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>)<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= name + <span class="hljs-string">&quot;&#x27;s score is &quot;</span> + score + <span class="hljs-string">&quot;.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> stu3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Students3</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>)<br>stu3: <span class="hljs-type">Students3</span> = <span class="hljs-type">Alice</span><span class="hljs-symbol">&#x27;s</span> score is <span class="hljs-number">80.</span><br><br>scala&gt; stu3 exam <span class="hljs-number">100</span><br><br>scala&gt; stu3.score<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br>scala&gt; stu3 friends (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">70</span>)<br><span class="hljs-type">My</span> friend <span class="hljs-type">Bob</span> gets <span class="hljs-number">70.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-2-三种操作符"><a href="#6-2-三种操作符" class="headerlink" title="6.2 三种操作符"></a>6.2 三种操作符</h2><p><strong>（1）前缀操作符（+-!~）</strong></p>
<p>​    写在<strong>操作数前面的操作符</strong>称为<strong>前缀操作符</strong>，并且<strong>操作数只有一个</strong>。</p>
<p>​    前缀操作符<strong>对应一个无参方法</strong>，<strong>操作数是调用该方法的对象</strong>。<strong>前缀操作符只有“+”、“-”、“!”和“~”四个</strong>，相对应的方法名分别是“unary_+”，“unary_-”、“unary_!”和“unary_~”</p>
<blockquote>
<p>​    <strong>如果自定义的方法名是 “unary_”</strong>加上这四个操作符之外的操作符，那么就不能写成前缀操作符的形式。假设定义了方法“unary_*”（意思是unary_与乘号结合），那么写成“<em>p”的形式让人误以为这是一个指针，实际Scala并不存在指针，因此只能写成“p.unary_\</em>”或后缀操作符“p unary_*”的形式。例如：</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_!</span> </span>= -x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary_*</span> </span>= x * <span class="hljs-number">2</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt</span>(<span class="hljs-number">10</span>)<br>mi: <span class="hljs-type">MyInt</span> = <span class="hljs-type">MyInt</span>@<span class="hljs-number">2</span>aac87ab<br><br>scala&gt; !mi<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">-10</span><br><br>scala&gt; *mi<br>&lt;console&gt;:<span class="hljs-number">12</span>: error: not found: value *<br>       *mi<br>       ^<br>&lt;console&gt;:<span class="hljs-number">12</span>: warning: postfix operator mi should be enabled<br>by making the <span class="hljs-keyword">implicit</span> value scala.language.postfixOps visible.<br><span class="hljs-type">This</span> can be achieved by adding the <span class="hljs-keyword">import</span> clause <span class="hljs-symbol">&#x27;import</span> scala.language.postfixOps&#x27;<br>or by setting the compiler option -language:postfixOps.<br><span class="hljs-type">See</span> the <span class="hljs-type">Scaladoc</span> <span class="hljs-keyword">for</span> value scala.language.postfixOps <span class="hljs-keyword">for</span> a discussion<br>why the feature should be explicitly enabled.<br>       *mi<br>        ^<br><br>scala&gt; mi.unary_*<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）中缀操作符(可以带很多操作数)</strong></p>
<p>​    <strong>中缀操作符</strong>的<strong>左右两边都接收操作数</strong>，它<strong>对应普通的有参方法</strong>。两个操作数中的一个是调用该方法的对象，一个是传入该方法的参数，<strong>参数那一边没有数量限制</strong>，只是多个参数需要放在圆括号里。</p>
<p>​    <strong>Scala规定，以冒号“ : ”结尾的操作符，其<u>右操作数</u>是调用该方法的对象，<u>其余操作符</u>都是把左操作数当调用该方法的对象。</strong> 例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+*</span></span>(y: <span class="hljs-type">Int</span>) = (x + y) * y<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>:(y: <span class="hljs-type">Int</span>) = x + y<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi2 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt2</span>(<span class="hljs-number">10</span>)<br>mi2: <span class="hljs-type">MyInt2</span> = <span class="hljs-type">MyInt2</span>@<span class="hljs-number">216</span>c6825<br><br>scala&gt; mi2 +* <span class="hljs-number">10</span> <span class="hljs-comment">//两个操作符，先+10后乘10</span><br>res7: <span class="hljs-type">Int</span> = <span class="hljs-number">200</span><br><br>scala&gt; mi2 +: <span class="hljs-number">10</span> <span class="hljs-comment">//右侧才是</span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: value +: is not a member of <span class="hljs-type">Int</span><br>       mi2 +: <span class="hljs-number">10</span><br>           ^<br><br>scala&gt; <span class="hljs-number">10</span> +: mi2 <span class="hljs-comment">//右侧mi2是调用该方法的对象，其余操作符为+,其余操作符的操作数为左侧的10</span><br>res9: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<p>​    对于系统打印函数<strong>“print”、“printf”和“println”，其实也是中缀操作符</strong>，不过<strong>左侧的操作数是调用对象——控制台Console</strong>，<strong>右侧是要打印的内容</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Console</span> println <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-type">Hello</span>, world! <br></code></pre></div></td></tr></table></figure>
<p><strong>（3）后缀操作符(类似方法调用)</strong></p>
<p>​    写在<strong>操作数后面的操作符</strong>称为<strong>后缀操作符</strong>，并且<strong>操作数只有一个</strong>，即调用该方法的对象。</p>
<p>​    后缀操作符也对应一个无参方法，但是要注意方法名<strong>如果构成前缀操作符的条件，那么既可以写成前缀操作符</strong>，也可以把完整的方法名写成后缀操作符。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span>(<span class="hljs-params">val x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = println(<span class="hljs-string">&quot;The value is &quot;</span> + x + <span class="hljs-string">&quot;.&quot;</span>)<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt3</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> mi3 = <span class="hljs-keyword">new</span> <span class="hljs-type">MyInt3</span>(<span class="hljs-number">10</span>)<br>mi3: <span class="hljs-type">MyInt3</span> = <span class="hljs-type">MyInt3</span>@<span class="hljs-number">2670435</span><br><br>scala&gt; <span class="hljs-keyword">import</span> scala.language.postfixOps<br><span class="hljs-keyword">import</span> scala.language.postfixOps<br><br>scala&gt; mi3 display <span class="hljs-comment">//操作数mi3  操作符display</span><br><span class="hljs-type">The</span> value is <span class="hljs-number">10.</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-3-操作符的优先级和结核性"><a href="#6-3-操作符的优先级和结核性" class="headerlink" title="6.3 操作符的优先级和结核性"></a>6.3 操作符的优先级和结核性</h2><p><strong>（1）优先级</strong></p>
<p>​    在数学运算中，乘、除法的优先级要高于加、减法，这是算术操作符的优先级。Scala也保留了这种特性，并有一套判断操作符优先级的规则：通过操作符的首个字符来判断。因为操作符都是方法，所以也就是通过方法名的首个字符来比较优先级，注意前缀操作符的方法名要去掉关键字。当然，圆括号内的优先级是最高的，圆括号可以改变操作符的结合顺序。<br><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​    上图给出了各种字符的优先级顺序。例如，常规算术运算法则在计算表达式“1 + 2 <em> 3”时，会先算乘法，后算加法。类似地，如果有一个表达式“1 +++ 2 **</em> 3”，那么结合顺序就是“1 +++ (2 <em>*</em> 3)”。</p>
<blockquote>
<p>​    这个规则有一个例外（就是比较，+=一系列的，不用看）：如果操作符以等号结尾，并且不是“&gt;=”、“&lt;=”、“==”或“!=”四个比较操作符之一，那么就认为是赋值操作符，优先级最低。例如，表达式“sum *= 1 + 2”会先算“1 + 2”，再把得出的3和sum相乘并赋给sum。也就是说，“*=”的优先级并不会因为以乘号开头就比加号高，而是被当作了一种赋值操作。</p>
</blockquote>
<p><strong>（2）结合性（注意冒号这玩意就行）</strong></p>
<p>​    一般情况下，同级的操作符都是<strong>从左往右结合的</strong>。但是，前面说了，<strong>以冒号结尾的中缀操作符的调用对象在右侧</strong>，所以这些操作符是从右往左结合的。例如，“a + b + c + d”的结合顺序是“((a + b) + c) + d”，而“a ::: b ::: c ::: d”的结合顺序则是“a ::: (b ::: (c ::: d))”。</p>
<blockquote>
<p>​    一个好的编程习惯是让代码简洁易懂，不造成歧义。所以，在操作符的结合顺序不能一眼就看明白时，最好加上圆括号来表示前后顺序，即使不加圆括号也能得到预期的结果。例如，想要得到“x + y &lt;&lt; z”的默认结果，最好写成“(x + y) &lt;&lt; z”，以便阅读。</p>
</blockquote>
<p><strong>（3）预设操作符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">+</th>
<th style="text-align:center">算术加法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">算术减法</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">算术乘法</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">算术除法</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">算术取余</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;、&amp;</td>
<td style="text-align:center">逻辑与，前者短路，后者不短路</td>
</tr>
<tr>
<td style="text-align:center">&#124;&#124;、&#124;</td>
<td style="text-align:center">逻辑或，前者短路，后者不短路</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td style="text-align:center">位或</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">位取反</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">算术右移</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">逻辑右移</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-5-对象的相等性"><a href="#6-5-对象的相等性" class="headerlink" title="6.5 对象的相等性"></a>6.5 对象的相等性</h2><p>​    在编程时，常常需要比较两个对象的相等性。其实相等性有两种：</p>
<ul>
<li><strong>自然相等性</strong>，也就是常见的相等性。<strong>只要字面上的值相等，就认为两个对象相等</strong></li>
<li><strong>引用相等性</strong>。构造的对象常常会赋给一个变量，即让变量引用该对象。引用相等性用于比较两个变量是否引用了同一个对象，<strong>即是否指向JVM的堆里的同一个内存空间</strong>。如果两个变量引用了两个完全一样的对象，那么它们的自然相等性为true，但是引用相等性为false</li>
</ul>
<blockquote>
<p>在Java里，这两种相等性都是由操作符“==”和“!=”比较的。</p>
<p>Scala为了区分得更细致，也为了符合常规思维，<strong>只让“==”和“!=”比较自然相等性</strong>。<strong>这两个方法是所有类隐式继承来的，但是它们不能被子类重写。</strong>自定义类可能需要不同行为的相等性比较，因此<strong>可以重写隐式继承来的“equals”方法。</strong>为了比较引用相等性，Scala提供了“eq”和“ne”方法，它们也是被所有类隐式继承的，且不可被子类重写。例如：</p>
</blockquote>
<p><strong>Scala比较自然相等性：</strong></p>
<ul>
<li>只让<strong>“==”和“!=”</strong>方法比较，被所有类隐式继承的，且不可被子类重写</li>
</ul>
<p><strong>Scala比较引用相等性：</strong></p>
<ul>
<li>提供了“<strong>eq”和“ne”方法</strong>，它们也是被所有类隐式继承的，且不可被子类重写</li>
</ul>
<p><strong>自定义相等性行为：</strong></p>
<ul>
<li>可以重写隐式继承来的“equals”方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>a: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> b = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>b: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> c = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>c: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> d = a<br>d: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br><br>scala&gt; a == c<br>res0: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a == b<br>res1: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a equals b<br>res2: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>scala&gt; a eq b<br>res3: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; a eq d<br>res4: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-6-章节总结"><a href="#6-6-章节总结" class="headerlink" title="6.6 章节总结"></a>6.6 章节总结</h2><p>​    本章又进一步阐释了Scala追求的纯粹的面向对象，介绍了“操作符即方法”这个重要概念。这一概念对构建良好的DSL语言很重要，因为它使得不仅内建类型可以写成表达式，也让自定义的类在计算时可以写出自然的表达式风格。</p>
<p>​    关于对象相等性，这是一个较为复杂的概念。在自定义类里，如果要比较对象相等性，则不仅是简单地重写equals方法，还需要其他手段。这里不再赘述，如有必要，后续会继续讨论。</p>
<h1 id="7-extends类继承"><a href="#7-extends类继承" class="headerlink" title="7 extends类继承"></a>7 extends类继承</h1><h2 id="7-1-Scala的类集成"><a href="#7-1-Scala的类集成" class="headerlink" title="7.1 Scala的类集成"></a>7.1 Scala的类集成</h2><p>​    在类的参数列表后面加上关键字<strong>“extends”</strong>和被继承类的类名，就完成了一个继承的过程。通常使用的三个名词：</p>
<ul>
<li>超类：基本的一种继承关系<ul>
<li>父类：只限定于一级继承时这么称呼</li>
</ul>
</li>
<li>子类</li>
</ul>
<blockquote>
<p>​    被继承的类称为“超类”或者“父类”，而派生出来的类称为“子类”。如果继承层次较深，最顶层的类通常也叫“基类”。继承关系只有“超类”和“子类”的概念，即超类的超类也叫超类，子类的子类还叫子类。例如：</p>
</blockquote>
<p>示例代码（纯粹演示Scala语法，没有实际意义）：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Class A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;Class B inherits from A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">5922</span>cff3<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">A</span><br><br>scala&gt; x.b<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">B</span> inherits from <span class="hljs-type">A</span><br></code></pre></div></td></tr></table></figure>
<h2 id="7-2-构造方法"><a href="#7-2-构造方法" class="headerlink" title="7.2 构造方法"></a>7.2 构造方法</h2><p>​    子类调用超类的构造方法的语法是：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span>(<span class="hljs-params">子类从外接收的参数</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">超类</span>(<span class="hljs-params">子类给超类的参数</span>)</span><br></code></pre></div></td></tr></table></figure>
<p>​    父类构造方法没有参数：6.1中的例子中，父类的构造方法<strong>没有参数，所以“extends A”也就不需要参数</strong></p>
<p>​    只有主构造方法才能调用超类的构造方法：Scala<strong>只允许主构造方法调用超类的构造方法</strong>，而这种写法就是子类的主构造方法在调用超类的构造方法。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val a: <span class="hljs-type">Int</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">giveA: <span class="hljs-type">Int</span>, val b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>(<span class="hljs-params">giveA</span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>x: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">5</span>f81507a<br><br>scala&gt; x.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br>scala&gt; x.b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<h2 id="7-3-一些特殊性质"><a href="#7-3-一些特殊性质" class="headerlink" title="7.3 一些特殊性质"></a>7.3 一些特殊性质</h2><p><strong>（1）覆盖：override</strong></p>
<p>​    覆盖超类的成员时，应该在定义的开头<strong>加上关键字“override”</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mercury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Metal</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> state = <span class="hljs-string">&quot;liquid&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mercury</span></span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>（2）不可覆盖的成员、不可被继承的类：final</strong></p>
<ul>
<li><p>如果超类成员在开头用<strong>关键字“final”</strong>修饰，那么<strong>子类就只能继承，而不能重写</strong>。</p>
</li>
<li><p><strong>“final”也可以用于修饰class</strong>，那么这个类就禁止被其他类继承。</p>
</li>
</ul>
<hr>
<p><strong>（3）无参方法与字段</strong></p>
<p>​    Scala的<strong>无参方法在调用时，可以省略空括号</strong>。</p>
<blockquote>
<p>鉴于此，对用户代码而言，如果看不到类库的具体实现，那么调用无参方法和调用同名的字段则没有什么不同，甚至无法区分其具体实现到底是方法还是字段。如果把类库里的无参方法改成字段，或是把字段改成无参方法，那么客户代码不用更改也能运行。</p>
</blockquote>
<p>​    为了方便在这两种定义之间进行切换，Scala允许<strong>超类的无参方法</strong>被子类<strong>重写为字段</strong>，<strong>但字段不能反过来被重写为无参方法</strong>，而且<strong>方法的返回类型必须和字段的类型一致</strong>。示例代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">justA</span></span>() = <span class="hljs-string">&quot;A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-string">&quot;B&quot;</span> <span class="hljs-comment">//超类的无参方法被子类重写为字段</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-number">1</span> <span class="hljs-comment">//方法的返回类型必须和字段的类型一致</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: overriding method justA in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> (<span class="hljs-params"></span>)<span class="hljs-title">String</span></span>;<br> value justA has incompatible <span class="hljs-class"><span class="hljs-keyword">type</span></span><br>         <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> justA = <span class="hljs-number">1</span><br>                      ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> d = <span class="hljs-number">10</span> <br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span></span>() = <span class="hljs-number">100</span>  <span class="hljs-comment">//超类的字段不能反过来被重写为无参方法</span><br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: overriding value d in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> <span class="hljs-title">Int</span></span>;<br> method d needs to be a stable, immutable value<br>         <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span></span>() = <span class="hljs-number">100</span><br>                      ^<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>​    <strong>字段与方法的区别</strong>在于：字段一旦被初始化之后，就会被保存在内存中，以后每次调用都只需直接读取内存即可；方法不会占用内存空间，但是每次调用都需要执行一遍程序段，速度比字段要慢。因此，到底定义成无参方法还是字段，就是在速度和内存之间折衷。</p>
<p>​    <strong>字段能重写无参方法的原理</strong>是<strong>Scala只有两种命名空间</strong>：</p>
<ul>
<li>值——字段、方法、包、单例对象</li>
<li>类型——类、特质。</li>
</ul>
<p>​    因为<strong>字段和方法同处一个命名空间</strong>，所以字段可以重写无参方法。这也告诉我们，同处一个命名空间的定义类型，在同一个作用域内不能以相同的名字同时出现。例如，同一个类里不能同时出现同名的字段、无参方法和单例对象：</p>
</blockquote>
<h2 id="7-4-多态与动态绑定"><a href="#7-4-多态与动态绑定" class="headerlink" title="7.4 多态与动态绑定"></a>7.4 多态与动态绑定</h2><p>​    类型为超类的变量可以指向子类的对象，这一现象被称为<strong>子类型多态</strong>，也是面向对象的多态之一。但是对于方法而言，尽管变量的类型是超类，<strong>方法的版本却是“动态绑定”的</strong>。也就是说，调用的方法要运行哪个版本，<strong>是由变量指向的对象来决定</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = <span class="hljs-string">&quot;I&#x27;m A.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() = <span class="hljs-string">&quot;I&#x27;m B.&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">A</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">B</span>@<span class="hljs-number">6</span>c5abd8f<br><br>scala&gt; x.display<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">I</span><span class="hljs-symbol">&#x27;m</span> <span class="hljs-type">B</span>.<br></code></pre></div></td></tr></table></figure>
<h2 id="7-5-抽象类（abstract）"><a href="#7-5-抽象类（abstract）" class="headerlink" title="7.5 抽象类（abstract）"></a>7.5 抽象类（abstract）</h2><p>抽象类：</p>
<ul>
<li>类里<strong>包含了没有具体定义的成员</strong>（没有初始化的字段或没有函数体的方法）</li>
<li>必须用关键字“abstract”修饰</li>
</ul>
<p>抽象成员：</p>
<ul>
<li>没有具体定义的成员</li>
<li>不需要“abstract”的修饰</li>
</ul>
<p>​    <strong>抽象类无法构造</strong>出具体的对象，不能通过”new”构造实例对象</p>
<blockquote>
<p>​    如果类里<strong>包含了没有具体定义的成员</strong>（没有初始化的字段或没有函数体的方法），那么这个类就是<strong>抽象类</strong>，<strong>必须用关键字“abstract”修饰</strong>。相应的成员称为<strong>抽象成员</strong>，<strong>不需要“abstract”的修饰</strong>。因为存在抽象成员，所以这个类不可能构造出具体的对象，因为有无法初始化抽象字段或者无法执行抽象方法，所以抽象类不能通过“new”来构造实例对象。</p>
</blockquote>
<p>​    <strong>抽象类的子类</strong>可以对父类抽象成员进行定义，此时<strong>关键字”override”可以不写</strong></p>
<p>​    <strong>抽象类常用于定义基类</strong>，因为基类会派生出很多不同的子类，这些子类往往具有行为不同的同名成员，所以基类只需要声明有哪些公共成员，让子类去实现它们各自期望的版本。 </p>
<blockquote>
<p>​    抽象类缺失的抽象成员的定义，可以由抽象类的子类来补充。也就是说，抽象类“声明”了抽象成员，却没有立即“定义”它。如果子类补齐了抽象成员的相关定义，就称子类“实现”了超类的抽象成员。相对的，我们称超类的成员是“抽象”的，而子类的成员是“具体”的。子类实现超类的抽象成员时，关键字“override”可写可不写。例如</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a: <span class="hljs-type">Int</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">is</span> <span class="hljs-title">abstract</span></span>; cannot be instantiated<br>       <span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span><br>               ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">val b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = b * <span class="hljs-number">2</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>(<span class="hljs-number">1</span>)<br>y: <span class="hljs-type">B</span> = <span class="hljs-type">B</span>@<span class="hljs-number">7</span>fe87c0e<br><br>scala&gt; y.a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; y.b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<h2 id="7-6-没有多重继承"><a href="#7-6-没有多重继承" class="headerlink" title="7.6 没有多重继承"></a>7.6 没有多重继承</h2><p>​    <strong>Scala没有多重继承</strong>，也就是说，在“extends”后面只能有一个类，这与大多数oop语言不同。多重继承其实是一个很让人头疼的问题，使用起来很复杂，也很容易出错。在笔者学习C++的时候，看到了C++为了使用多重继承而不得不做出的大量语法规则修改，和单个继承混在一起时常把人搞晕。<strong>Scala舍弃多重继承的做法，对于程序员而言是莫大的帮助</strong>，不用在编写代码时考虑冗长的代码设计。尤其是对超类方法的调用，当存在多个超类时，为了避免歧义而不得不仔细设计方法的行为。</p>
<p>​    虽然多重继承不好用，但是它实现的功能在某些时候又不可或缺。为此，Scala<strong>专门设计了“特质”来实现相同的功能</strong>，并且特质的规则更简单、更明了。特质将在后一章介绍。</p>
<h2 id="7-7-Scala类的层次结构"><a href="#7-7-Scala类的层次结构" class="headerlink" title="7.7 Scala类的层次结构"></a>7.7 Scala类的层次结构</h2><p>​    Scala所有的类——不管是标准库里已有的类还是自定义的类<strong>都存在层次关系</strong>。这种关系如下图所示，其中<strong>实线箭头</strong>表示属于指向的<strong>类的子类</strong>，<strong>虚线箭头</strong>表示可以<strong>隐式转换</strong>成指向的类：</p>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/20190208201013172.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>最顶部的类是抽象类Any</strong>，<strong>它是所有类的超类</strong>，Any类定义了几个成员方法，如下表所示：</p>
<center><b>Any类的成员方法</b></center>

<div class="table-container">
<table>
<thead>
<tr>
<th>方法定义</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>def getClass(): Class[_]</td>
<td style="text-align:center">抽象</td>
<td style="text-align:center">返回运行时对象所属的类的表示</td>
</tr>
<tr>
<td>final def !=(arg0: Any): Boolean</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">比较两个对象的自然相等性是否不相等</td>
</tr>
<tr>
<td>final def ==(arg0: Any): Boolean</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">比较两个对象的自然相等性是否相等</td>
</tr>
<tr>
<td>def equals(arg0: Any): Boolean</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">比较两个对象的自然相等性，被!=和==调用</td>
</tr>
<tr>
<td>final def ##(): Int</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">计算对象的哈希值，等同于hashCode，但是自然相等性相等的两个对象会得到相同的哈希值，并且不能计算null对象</td>
</tr>
<tr>
<td>def hashCode(): Int</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">计算对象的哈希值</td>
</tr>
<tr>
<td>final def asInstanceOf[T]: T</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">把对象强制转换为T类型</td>
</tr>
<tr>
<td>final def isInstanceOf[T]: Boolean</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">判断对象是否属于T类型，或T的子类</td>
</tr>
<tr>
<td>def toString(): String</td>
<td style="text-align:center">具体</td>
<td style="text-align:center">返回一个字符串来表示对象</td>
</tr>
</tbody>
</table>
</div>
<p>​    也就是说，<strong>任何类都有这几个方法</strong>。注意，不能出现同名的方法，若确实需要自定义版本，则记得带上“override”。</p>
<p>​    <strong>再往下一层</strong>，Any类有<strong>两个子类：AnyVal和AnyRef</strong>。也就是说，<strong>所有类被分成两大部分：值类和引用类</strong>。值类也就是前面讲过的对应Java的九种基本类型，并且其中七个存在一定的隐式转换，例如Byte可以扩展成Short等等。隐式转换是Scala的一个语法，用于对象在两个类之间进行类型转换，后面章节会讲到。除了标准库里已有的隐式转换，也可以自定义隐式转换。</p>
<p>​    <strong>除了这九个值类，也可以自定义值类</strong>，即定义时显式地继承自AnyVal类。如果没有显式地继承自AnyVal类，则都认为是AnyRef类的子类，也就是说一般自定义的类都属于引用类。大部分标准库里的类都是引用类，比如常见的字符串类String，还有后续会讲解的列表类、映射类、集合类等等。Java的类都属于引用类，因为Java的基本类型都在值类里面。</p>
<p>​    前面讲过引用相等性，很显然只有引用类才有引用相等性。事实上，比较引用相等性的两个方法——eq和ne，都定义在AnyRef类里。值类AnyVal是没有这两个方法的，也不需要。</p>
<p>​    在层次结构的底部有两个底类型——Null类和Nothing类。其中Null类是所有引用类的子类，表示空引用，即指向JVM里的空内存，这与Java的null概念是一样的。但是Null并不兼容值类，所以Scala还有一个类——Nothing，它是所有值类和引用类的子类，甚至还是Null类的子类。因此Nothing不仅表示空引用，还表示空值。Scala里有一个可选值语法，也就是把各种类型打包成一个特殊的可选值。为了表示“空”、“没有”这个特殊的概念，以及兼容各种自定义、非自定义的值和引用类，这个特殊的可选值其实就是把Nothing类进行打包。</p>
<p>​    除了自定义的普通类属于引用类，后一章讲解的特质，也是属于引用类的范畴。</p>
<h2 id="7-8-章节总结"><a href="#7-8-章节总结" class="headerlink" title="7.8 章节总结"></a>7.8 章节总结</h2><p>​    本章介绍了类继承的语法，其内容不多，也简单易懂。这一章真正的难点是阅读大型系统软件时，遇到的纷繁复杂的类层次，要梳理这些类的继承关系往往费时费力。还有自己编写代码时，<strong>如何设计类的结构，让系统稳定、简单、逻辑清晰</strong>，也不是一件容易事。</p>
<p>​    <strong>在编写Chisel时，类继承主要用于编写接口</strong>，因为接口可以扩展，但是实际的硬件电路并没有很强烈的继承关系。</p>
<h1 id="8-trait特质"><a href="#8-trait特质" class="headerlink" title="8 trait特质"></a>8 trait特质</h1><h2 id="8-1-什么是特质"><a href="#8-1-什么是特质" class="headerlink" title="8.1 什么是特质"></a>8.1 什么是特质</h2><p><strong>（1）特质trait</strong></p>
<p>​    Scala没有多重继承，为了提高代码复用率，故而创造了新的编程概念——<strong>特质</strong></p>
<p>​    特质是用<strong>关键字“trait”</strong>为开头来定义的</p>
<p>​    <strong>特质与单例对象很像</strong>，两者都不能有入参。<strong>类、单例对象、特质三者一样</strong>，内部可以包含字段和方法，甚至包含其他类、单例对象、特质的定义。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特质</th>
<th>单例对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>不能有入参</td>
<td>不能有入参</td>
</tr>
<tr>
<td>抽象的，但不需要用“abstract”来说明</td>
<td>具体的</td>
</tr>
<tr>
<td>可以包含抽象成员</td>
<td>不能包含抽象成员</td>
</tr>
<tr>
<td>不能用new来实例化</td>
<td>不能用new来实例化</td>
</tr>
</tbody>
</table>
</div>
<p><strong>（2）混入</strong>：</p>
<ul>
<li><strong>特质可以被其它类、单例对象和特质“混入”</strong>。这里使用术语“混入”而不是“继承”，是因为特质在<strong>超类方法调用上采用线性化机制</strong>，<strong>与多重继承有很大的区别</strong>。</li>
<li>其它方面，“混入”和“继承”其实是一样的。例如，某个类混入一个特质后，就包含了特质的所有公有成员，而且也可以用“override”来重写特质的成员</li>
<li>要混入一个特质，在当前类没有继承的情况下<strong>可以使用关键字“extends”</strong>，否则<strong>通过关键字“with”来混入其他特质</strong>。例如：</li>
</ul>
<p>​    Scala只允许继承自一个类，但是<strong>对特质的混入数量却没有限制</strong>，故而<strong>可用于替代多重继承语法</strong>，同时也拥有多态的特性</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Class A&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;Trait B&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span> </span>&#123;undefined<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span> </span>= <span class="hljs-string">&quot;Trait C&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> <span class="hljs-keyword">with</span> <span class="hljs-title">C</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-type">D</span>.a<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">Class</span> <span class="hljs-type">A</span><br><br>scala&gt; <span class="hljs-type">D</span>.b<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">Trait</span> <span class="hljs-type">B</span><br><br>scala&gt; <span class="hljs-type">D</span>.c<br>res2: <span class="hljs-type">String</span> = <span class="hljs-type">Trait</span> <span class="hljs-type">C1</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）特质拥有多态的特性</strong>：</p>
<blockquote>
<p>​    特质也定义了一个类型，而且类型为该特质的变量，可以指向混入该特质的对象。例如：</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> x: <span class="hljs-type">A</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span><br>x: <span class="hljs-type">A</span> = <span class="hljs-type">B</span>@<span class="hljs-number">7</span>cc1f72c <br></code></pre></div></td></tr></table></figure>
<h2 id="8-2-特质的继承和混入"><a href="#8-2-特质的继承和混入" class="headerlink" title="8.2 特质的继承和混入"></a>8.2 特质的继承和混入</h2><p>​    <strong>特质也可以继承自其他类</strong>，<strong>或混入任意个特质</strong>，这样该特质就是关键字“extends”引入的那个类/特质的子特质。如果没有继承和混入，那么这个特质就是AnyRef类的子特质。前面讲过AnyRef类是所有非值类和特质的超类。</p>
<p>​    <strong>当某个类、单例对象或特质用关键字“extends”混入一个特质时，会隐式继承自这个特质的超类。</strong>（也就是说，类/单例对象/特质的超类，都是由“extends”引入的类或特质决定的。）</p>
<p>​    <strong>特质对混入有一个限制条件</strong>：那就是要混入该特质的类/单例对象/特质，它的超类必须是待混入特质的超类，或者是待混入特质的超类的子类。因为特质是多重继承的替代品，那就有“继承”的意思。既然是继承，混入特质的类/单例对象/特质的层次，就必须比待混入特质的层次要低。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: illegal inheritance; superclass <span class="hljs-type">C</span><br> is not a subclass of the superclass <span class="hljs-type">A</span><br> of the mixin <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span></span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span></span><br>                                  ^<br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span></span><br>&lt;console&gt;:<span class="hljs-number">13</span>: error: illegal inheritance; superclass <span class="hljs-type">A</span><br> is not a subclass of the superclass <span class="hljs-type">B</span><br> of the mixin <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span></span><br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>​    上例中，类Test1直接混入特质D，这样隐式继承自D的超类——类A，所以合法。类Test2和Test3分别继承自类A和A的子类，所以也允许混入特质D。类Test4的超类是C，而C与A没有任何关系，所以非法。类Test5的超类是A，特质E的超类是B，尽管类A是类B的超类，这也仍然是非法的。从提示的错误信息也可以看出，混入特质的类/单例对象/特质，其超类必须是待混入特质的超类或超类的子类。</p>
</blockquote>
<h2 id="8-3-混入特质的简便方法"><a href="#8-3-混入特质的简便方法" class="headerlink" title="8.3 混入特质的简便方法"></a>8.3 混入特质的简便方法</h2><ul>
<li><strong>快速构造一个混入某些特质的实例：</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait2</span> ... &#123; definition &#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>​    上面代码其实是<strong>定义了一个匿名类</strong>，这个匿名类混入了这些特质，并且花括号内是该匿名类的定义。然后使用new构造了这个匿名类的一个对象，其等效的代码就是：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Trait2</span> ... </span>&#123; definition &#125;<br><br>&gt;<span class="hljs-keyword">new</span> <span class="hljs-type">AnonymousClass</span><br></code></pre></div></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">T</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> tt = <span class="hljs-string">&quot;T__T&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">T</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">X</span> </span>&#123;undefined<br>         |    <span class="hljs-keyword">val</span> xx = <span class="hljs-string">&quot;X__X&quot;</span><br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">X</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">T</span> <span class="hljs-keyword">with</span> <span class="hljs-type">X</span><br>a: <span class="hljs-type">T</span> <span class="hljs-keyword">with</span> <span class="hljs-type">X</span> = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">4</span>c1fed69<br><br>scala&gt; a.tt<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">T__T</span><br><br>scala&gt; a.xx<br>res1: <span class="hljs-type">String</span> = <span class="hljs-type">X__X</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>除此之外，还可以在最前面加上一个想要继承的超类</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">new</span> <span class="hljs-type">SuperClass</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait1</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Trait2</span> ... &#123; definition &#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="8-4-特质的线性化叠加的计算"><a href="#8-4-特质的线性化叠加的计算" class="headerlink" title="8.4 特质的线性化叠加的计算"></a>8.4 特质的线性化叠加的计算</h2><p>​    <strong>多重继承一个很明显的问题</strong>：多个超特质的方法调用</p>
<blockquote>
<p>当子类特质调用超类的方法时，若多个超类都有该方法的不同实现，那么需要附加额外的语法来确定具体调用哪个版本。</p>
</blockquote>
<p>​    <strong>Scala特质采取一种线性化的规则</strong>来调用特质中的方法，这与大多数语言不一样。在特质里，<strong>“super”调用是动态绑定的</strong>。也就是说，按特质本身的定义，无法确定super调用的具体行为；直到特质混入某个类或别的特质，有了具体的超类方法，才能确定super的行为。这是实现线性化的基础。</p>
<p>线性化叠加特点总结：</p>
<ul>
<li><p>① <strong>超特质</strong>的方法实现前用关键字组合<strong>“abstract override”</strong>进行声明</p>
<blockquote>
<p>注意这不是重写，而是告诉编译器该方法用于线性叠加。这个关键字组合只能用在特质里，不允许用在其他地方。</p>
</blockquote>
</li>
<li><p>② <strong>超特质</strong>对该方法的定义必须出现“super.方法名(参数)”</p>
</li>
<li><p>③ <strong>被混入的类</strong>应有同名同参的方法（内部定义、继承、重写都可以）</p>
<blockquote>
<p>这个关键字组合也意味着该特质必须被某个拥有该方法具体定义的类混入(这个类的方法可以是自己实现或者重写的，也可以是继承的，总之它拥有该方法)，也就是这个类定义了该方法的最终行为。如果被没有拥有该方法具体定义的类给混入了，那么就会报错。</p>
</blockquote>
</li>
<li><p>④ <strong>被混入的类不能立刻混入</strong>，应该把他再作为父类定义一个子类，用子类混入各种特质;同时也可以使用简便方法，定义新的匿名类如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span> <span class="hljs-keyword">with</span> <span class="hljs-type">D</span> <span class="hljs-keyword">with</span> <span class="hljs-type">E</span> <span class="hljs-keyword">with</span> <span class="hljs-type">F</span> <span class="hljs-keyword">with</span> <span class="hljs-type">B</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>需要混入特质进行线性化计算的类，在定义时不能立即混入特质。这样做会让编译器认为这个类是在重写末尾那个特质的方法，而且当类的上一层超类是抽象类时还会报错。应该先定义这个类的子类来混入特质，然后构造子类的对象。或者直接用第三点讲的“new SuperClass with Trait1 with Trait2 …”来快速构造一个子类对象。</p>
</blockquote>
<ul>
<li><p>⑤ <strong>方法的执行顺序遵循线性化计算公式</strong>：<strong>起点最右边特质</strong>，同时<strong>从起点处接收参数</strong>，结果返回作为参数传<strong>递给右边第二个参数</strong>，最后回到最左边的<strong>被混入的类本身</strong></p>
<blockquote>
<p>可以理解为特质是按一定顺序对入参进行各种变换，最后把变换后的入参交给类来计算。</p>
</blockquote>
</li>
</ul>
<p>⑥ <span id="jump">回到<strong>被混入的类</strong>本身，说明此类<strong>直接或间接override或实现了基类的方法</strong>，且直接实现时<strong>需使用override关键词</strong></span></p>
<ul>
<li>如果此类同名同参方法的实现使用了<strong>“super.方法名(参数)”</strong>，那么会调用它的上一层超类的实现版本</li>
<li><strong>此类没有override</strong>，那就一定要对该同名同参方法的实现，或也调用上一层超类的实现版本</li>
</ul>
<p><mark>线性化计算公式（定义被混入类的匿名子类的规则）：</mark></p>
<ul>
<li>① <strong>最左边</strong>是被混入类本身。</li>
<li>② <strong>左边第二个</strong>写最后混入的那个特质，<strong>往右按继承顺序写下该特质的所有超类和超特质</strong></li>
<li>③ 写完<strong>第二个带着的所有超类和特质后</strong>，往右写下<strong>倒数第二个混入的特质</strong>，以及其超类和超特质，直到写完所有特质。</li>
<li>④ <strong>所有重复项只保留最右边那个</strong>，并在最右边加上<code>AnyRef和Any</code>。</li>
</ul>
<p>为了具体说明，以如下代码为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><br><span class="hljs-comment">// test.scala</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;X -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;B -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;C -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;D -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;E -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">F</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;F -&gt; &quot;</span> + s)<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span> <span class="hljs-keyword">with</span> <span class="hljs-type">D</span> <span class="hljs-keyword">with</span> <span class="hljs-type">E</span> <span class="hljs-keyword">with</span> <span class="hljs-type">F</span> <span class="hljs-keyword">with</span> <span class="hljs-type">B</span><br>println(x.m(<span class="hljs-string">&quot;End&quot;</span>))<br></code></pre></div></td></tr></table></figure>
<p><strong>实例运行结果：</strong></p>
<blockquote>
<p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End</p>
<p>​    首先，需要混入特质进行线性化计算的类G在定义时没有立即混入特质，即只有“class G extends X”，而是通过“new G with D with E with F with B”来构造G的匿名子类的对象。其次，注意基类A是一个抽象类，类X实现了抽象方法m，类G重写了X的m，其余特质也用“abstract override”重写了m，这保证了m最终会回到类G。最后，基类A的m的返回类型“String”的声明是必须的，因为抽象方法无法推断返回类型，不声明就默认是Unit。</p>
</blockquote>
<p>根据线性化计算公式可得(蓝色表示起点，红色表示重复，类X不参与计算)：</p>
<blockquote>
<p>① G</p>
<p>② G→B(蓝色)→A</p>
<p>③ G→B→A→F→C→A</p>
<p>④ G→B→A→F→C→A→E→C→A</p>
<p>⑤ G→B→A→F→C→A→E→C→A→D→A</p>
<p>⑥ G→B→F→E→C→D→A</p>
<p>⑦ G→B→F→E→C→D→A→AnyRef→Any</p>
<p>​    起点是B，传入参数“End”会得到“B -&gt; End”；然后B的super.m调用F的m，并传入计算得到的“B -&gt; End”，那么F会得到“F -&gt; B -&gt; End”，再继续向右调用；最后A的m是抽象的，无操作可执行，转而回到G的m，所以最后传给G的参数实际是“D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End”，得到的结果也就是“G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End”。 </p>
</blockquote>
<h2 id="8-5-特殊情况的验证"><a href="#8-5-特殊情况的验证" class="headerlink" title="8.5 特殊情况的验证"></a>8.5 特殊情况的验证</h2><ul>
<li><strong>如果G的m也有super或没有重写</strong>，那么会调用X的m，最后的结果是最左边多个X<a href="#jump">（也就是第六点）： </a></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-keyword">super</span>.m(<span class="hljs-string">&quot;G -&gt; &quot;</span> + s)<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>X -&gt; G -&gt; D -&gt; C -&gt; E -&gt; F -&gt; B -&gt; End</p>
</blockquote>
<hr>
<ul>
<li>如果<strong>立即混入特质</strong>，则相当于普通的方法重写：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span> <span class="hljs-keyword">with</span> <span class="hljs-title">F</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span><br>...<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>G -&gt; End </p>
</blockquote>
<hr>
<ul>
<li>如果<strong>上一层超类是抽象类</strong>，立即混入会引发错误：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">D</span> <span class="hljs-keyword">with</span> <span class="hljs-title">E</span> <span class="hljs-keyword">with</span> <span class="hljs-title">F</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span></span>(s: <span class="hljs-type">String</span>) = <span class="hljs-string">&quot;G -&gt; &quot;</span> + s<br>&#125;<br><span class="hljs-keyword">val</span> x = <span class="hljs-keyword">new</span> <span class="hljs-type">G</span><br>...<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>E:\Microsoft VS\Scala\Chapter 12.\traittest.scala:23: error: overriding method m in trait B of type (s: String)String;<br> method m needs `abstract override’ modifiers<br>  override def m(s: String) = “G -&gt; “ + s<br>               ^<br>one error found </p>
</blockquote>
<h2 id="8-6-章节总结"><a href="#8-6-章节总结" class="headerlink" title="8.6 章节总结"></a>8.6 章节总结</h2><p>​    <strong>特质用于代码重用，这与抽象基类的作用相似</strong>。不过，特质<strong>常用于混入在不相关的类中</strong>，而抽象基类则用于构成有继承层次的一系列相关类。在Chisel中，特质常用于<strong>硬件电路模块的公有属性的提取</strong>，在需要这些属性的电路中混入相应的特质，在不需要的时候删去，就能快速地修改电路设计</p>
<h1 id="9-package包"><a href="#9-package包" class="headerlink" title="9 package包"></a>9 package包</h1><h2 id="9-1-包的定义、命名方式、内容、编译"><a href="#9-1-包的定义、命名方式、内容、编译" class="headerlink" title="9.1 包的定义、命名方式、内容、编译"></a>9.1 包的定义、命名方式、内容、编译</h2><blockquote>
<p>​    当代码过于庞大时，为了让整个系统层次分明，各个功能部分划分明显，常常需要把整体划分成若干独立的模块。与Java一样，Scala把代码以“包”的形式划分。</p>
</blockquote>
<p>​    <strong>包定义</strong>：<strong>以关键字“package”为开头来定义的</strong>，有两种风格的定义方式：</p>
<ul>
<li>可以用花括号把包的范围包起来（这种风格类似C++和C#的命名空间）<ul>
<li>好处：而且这种方法使得一个文件可以包含多个不同的包</li>
</ul>
</li>
<li>也可以不用花括号标注范围（这种风格类似Java）<ul>
<li>好处：但包的声明必须在文件最前面，这样使得整个文件的内容都属于这个包</li>
</ul>
</li>
</ul>
<p>​    <strong>包的命名方式</strong>：推荐使用Java的<strong>反转域名法，即“com.xxx.xxx”的形式</strong></p>
<p>​    <strong>包的内容</strong>：可以定义<strong>class、object和trait</strong>，也可以定义<strong>别的package</strong></p>
<p>​    <strong>包的编译：</strong>如果编译一个包文件，那么会在当前路径下<strong>生成一个与包名相同的文件夹</strong>，文件夹里是包内class、object和trait编译后生成的文件，或者是包内层的包生成的更深一层文件夹<strong>。如果多个文件的顶层包的包名相同</strong>，那么编译后的文件会放在同一个文件夹内。<strong>也就是说，一个包的定义可以由多个文件的源代码组成</strong></p>
<h2 id="9-2-包的访问、层次、精确代码访问"><a href="#9-2-包的访问、层次、精确代码访问" class="headerlink" title="9.2 包的访问、层次、精确代码访问"></a>9.2 包的访问、层次、精确代码访问</h2><blockquote>
<p>​    因为包里还可以定义包，所以包也有层次结构。包的层次不仅<strong>便于人们按模块阅读</strong>，同时<strong>也告诉编译器这些代码存在某些层次联系</strong>。</p>
</blockquote>
<p>​    <strong>（1）包的访问</strong>：</p>
<ul>
<li>方法一（注：如果包名中就出现了句点，那么编译器也会按层次编译）：<ul>
<li>如果一个包仅仅是包含了其他的包，没有额外的class、object和trait定义，推荐使用这种方式访问，这样内部代码省去了一次缩进。</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> one.two<br></code></pre></div></td></tr></table></figure>
<ul>
<li>方法二：<ul>
<li><span id="可用于声明不同的包，方法一不行">可用于声明不同的包，方法一不行</span></li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> one<br>    <span class="hljs-keyword">package</span> two<br></code></pre></div></td></tr></table></figure>
<p><strong>（2）编译的先后顺序</strong>：先编译出一个名为one的文件夹，然后在里面又编译出一个名为two的文件夹</p>
<p><strong>（3）Scala的包是嵌套的而不是分级的</strong>：而不像Java那样只是分级的。这体现在Java访问包内的内容必须从最顶层的包开始把全部路径写齐，而<strong>Scala则可以按照一定的规则书写更简短的形式</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-keyword">package</span> navigation &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navigator</span> </span>&#123;<br>      <span class="hljs-comment">// 不需要写成bobsrockets.navigation.StarMap</span><br>      <span class="hljs-keyword">val</span> map = <span class="hljs-keyword">new</span> <span class="hljs-type">StarMap</span><br>    &#125;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarMap</span></span><br>  &#125;<br> <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> </span>&#123;<br>    <span class="hljs-comment">// 不需要写成bobsrockets.navigation.Navigator</span><br>    <span class="hljs-keyword">val</span> nav = <span class="hljs-keyword">new</span> navigation.<span class="hljs-type">Navigator</span><br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> fleets &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>      <span class="hljs-comment">// 不需要写成bobsrockets.Ship</span><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>嵌套的几个特点：</strong>    </p>
<ul>
<li>访问<strong>同一个包内</strong>的class、object和trait不需要增加路径前缀</li>
</ul>
<blockquote>
<p>因为“new StarMap”和“class StarMap”都位于bobsrockets.navigation包内，所以这条代码能够通过编译。</p>
</blockquote>
<ul>
<li>访问<strong>同一个包内更深一层的包</strong>所含的class、object和trait，只需要写出那层更深的包。</li>
</ul>
<blockquote>
<p>因为“class Ship”和“package navigation”都位于bobsrockets包内，所以要访问navigation包内的class、object和trait只需要增加“navigation.”，而不是完整的路径。</p>
</blockquote>
<ul>
<li>当使用<strong>花括号显式表明包的作用范围</strong>时，包外所有可访问的class、object和trait在包内也可以直接访问</li>
</ul>
<blockquote>
<p>因为“package fleets”位于外层包bobsrockets，所以bobsrockets包内、fleets包外的所有class、object和trait可以直接访问，故而“new Ship”不需要完整路径也能通过编译。</p>
</blockquote>
<ul>
<li>以上规则只在<strong>同一个文件内显式嵌套时可以生效</strong></li>
<li><strong>通过包名带句点来访问嵌套（即使把这两个文件合并），无法编译</strong>。例如下面的代码就不能通过编译：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span></span><br>&#125;<br> <br><span class="hljs-comment">// fleets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets.fleets &#123; <span class="hljs-comment">//一起声明</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>    <span class="hljs-comment">// 无法编译，Ship不在作用域内</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>但是当第二个文件把<a href="#可用于声明不同的包，方法一不行"><strong>每个包分开声明时</strong></a>，上述规则又能生效。例如下面的代码是合法的：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span></span><br> <br><span class="hljs-comment">// fleets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets<br>  <span class="hljs-keyword">package</span> fleets <span class="hljs-comment">//分开声明</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span> </span>&#123;<br>      <span class="hljs-comment">// 可以编译</span><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addShip</span></span>() = &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">Ship</span> &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（4）访问最顶包的内容：root</strong></p>
<p>​    为了访问不同文件最顶层包的内容，Scala定义了一个<strong>隐式的顶层包“_root_”</strong>，<strong>所有自定义的包其实都包含在这个包里</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// launch.scala</span><br><span class="hljs-keyword">package</span> launch &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster3</span></span><br>&#125;<br> <br><span class="hljs-comment">// bobsrockets.scala</span><br><span class="hljs-keyword">package</span> bobsrockets &#123;<br>  <span class="hljs-keyword">package</span> navigation &#123;<br>    <span class="hljs-keyword">package</span> launch &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster1</span></span><br>    &#125;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MissionControl</span> </span>&#123;<br>      <span class="hljs-keyword">val</span> booster1 = <span class="hljs-keyword">new</span> launch.<span class="hljs-type">Booster1</span><br>      <span class="hljs-keyword">val</span> booster2 = <span class="hljs-keyword">new</span> bobsrockets.launch.<span class="hljs-type">Booster2</span><br>      <span class="hljs-keyword">val</span> booster3 = <span class="hljs-keyword">new</span> _root_.launch.<span class="hljs-type">Booster3</span><br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> launch &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Booster2</span></span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>Booster3必须通过“<em>root</em>”才能访问，否则就和Booster1混淆，造成歧义。</p>
</blockquote>
<h2 id="9-3-import导入"><a href="#9-3-import导入" class="headerlink" title="9.3 import导入"></a>9.3 import导入</h2><blockquote>
<p>和python类似，如果每次都按第二点的精确访问方式来编程，则显得过于繁琐和复杂。因此，可以通过关键字“import”来导入相应的内容。</p>
</blockquote>
<p><strong>（1）Scala的import的特点：</strong></p>
<ul>
<li>①可以<strong>出现在代码的任意位置</strong>，而不仅仅是开头</li>
<li>②除了导入包内所含的内容，<strong>还能导入对象</strong>(单例对象和new构造的对象都可以)和<strong>包自身</strong>，<strong>甚至函数的参数</strong>都能<strong>作为对象来导入</strong></li>
<li>③可以<strong>重命名或隐藏某些成员</strong>，（类似python import as）例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><br><span class="hljs-keyword">package</span> <span class="hljs-type">A</span> &#123;<br>  <span class="hljs-keyword">package</span> <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span></span><br>  &#125;<br> <br>  <span class="hljs-keyword">package</span> <span class="hljs-type">C</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">N</span></span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>​    通过语句“import A.B”就能把包B导入。当要访问M时，只需要写“B.M”而不需要完整的路径。通过“import A.B.M”和“import A.C.N”就分别导入了类M和对象N。此时访问它们只需要写M和N即可。</p>
</blockquote>
<p><strong>（2）import多个元素：</strong></p>
<p>​    <strong>路径最后的元素</strong>可以<strong>放在花括号里</strong>，这样就能导入一个或多个元素</p>
<p>​    例如通过<code>import A.&#123;B, C&#125;</code>就<strong>导入了两个包</strong>。花括号内的语句也叫<strong>“引入选择器子句”</strong>。</p>
<p><strong>（3）导入所有的元素</strong></p>
<p>​    <strong>使用下划线</strong>。例如<code>import A._或import A.&#123;_&#125;</code>就把包B和C都导入了，<strong>其中通配符“_”代指其余元素</strong></p>
<p><strong>（4）导入时对包重命名</strong>    </p>
<p>​    如果写成<code>import A.&#123;B =&gt; packageB&#125;</code>，就是在导入包B的同时重命名为“packageB”，此时可以<strong>用packageB指代包B</strong>，也<strong>仍能用“A.B”显式访问</strong></p>
<p><strong>（5）导入时对包隐藏</strong></p>
<p>​    如果写成<code>import A.&#123;B =&gt; _, _&#125;</code>，就是<strong>把包B进行隐藏，而导入A的其他元素</strong>。注意，指<strong>代其余元素的下划线通配符必须放在最后</strong>。</p>
<p><strong>（6）导入时注意相对路径问题</strong></p>
<p>​    <strong>包导入是相对路径</strong>，也就是<strong>代码里有<code>import A._</code>的文件要和包A编译后的文件夹要在同一级目录下</strong></p>
<h2 id="9-4-this自引用"><a href="#9-4-this自引用" class="headerlink" title="9.4 this自引用"></a>9.4 this自引用</h2><p>​    Scala有一个<strong>关键字“this”</strong>，用于指代对象自己。</p>
<p>​    <strong>简单的理解就是</strong>：</p>
<ul>
<li>如果this用在<strong>类的方法</strong>里，则指代<strong>正在调用方法的那个对象</strong>；</li>
<li>如果用在类的<strong>构造方法</strong>里，则指代<strong>当前正在构建的对象</strong>。</li>
</ul>
<h2 id="9-5-访问修饰符"><a href="#9-5-访问修饰符" class="headerlink" title="9.5 访问修饰符"></a>9.5 访问修饰符</h2><p>​    <strong>包、类、对象的成员</strong>都可以标上<strong>访问修饰符“private”和“protected”</strong>。</p>
<ul>
<li>用“private”修饰的成员是私有的，只能被包含它的包、类或对象的内部代码访问；</li>
<li>用“protected”修饰的成员是受保护的，除了能被包含它的包、类或对象的内部代码访问，<strong>还能被子类访问(只有类才有子类)</strong>。</li>
</ul>
<p><span id="限定词与自限定"></span></p>
<h2 id="9-6-限定词与自限定"><a href="#9-6-限定词与自限定" class="headerlink" title="9.6 限定词与自限定"></a>9.6 限定词与自限定</h2><p>​    <strong>限定词：</strong>除此之外，还可以加上限定词，<strong>使被修饰对象能被限定词访问</strong>，语法为：<code>[限定词]</code></p>
<blockquote>
<p>假设X指代某个包、类或对象，那么private[X]和protected[X]就是在不加限定词的基础上，<strong>把访问权限扩大到X的内部</strong>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-type">A</span> &#123;<br>  <span class="hljs-keyword">package</span> <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-keyword">private</span>[<span class="hljs-type">A</span>] <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustA</span></span><br>  &#125;<br> <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeA</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>.<span class="hljs-type">JustA</span>  <span class="hljs-comment">// OK</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">package</span> <span class="hljs-type">C</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>.<span class="hljs-type">B</span>.<span class="hljs-type">JustA</span>  <span class="hljs-comment">// error</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>​    <strong>限定词还能是自引用关键字“this”</strong></p>
<ul>
<li><p><strong>private[this]比private更严格</strong>，不仅只能由内部代码访问，还<strong>必须是调用方法的对象或构造方法正在构造的对象来访问</strong></p>
</li>
<li><p><strong>protected[this]则在private[this]的基础上扩展到定义时的子类</strong>，例如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt1</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mi1 = x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt1</span>) = mi1 + m.mi1<br>         |  &#125;<br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt1</span></span><br><br>scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInt2</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>) </span>&#123;<br>         |    <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">val</span> mi2 = x<br>         |    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt2</span>) = mi2 + m.mi2<br>         |  &#125;<br>&lt;console&gt;:<span class="hljs-number">13</span>: error: value mi2 is not a member of <span class="hljs-type">MyInt2</span><br>         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(m: <span class="hljs-type">MyInt2</span>) = mi2 + m.m<br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>MyInt1可以编译成功，但是MyInt2却不行，因为add传入的对象不是调用方法的对象，所以不能访问字段mi2，尽管这还是代码内部。换句话说，用private[this]和protected[this]修饰的成员x，只能通过“this.x”的方式来访问。</p>
</blockquote>
<p>​    <strong>对于类、对象和特质，不建议直接用private和protected修饰，容易造成作用域混乱，应该用带有限定词的访问修饰符来修饰，显式声明它们在包内的作用域。</strong></p>
<p>​    前面说过，伴生对象和伴生类共享访问权限，即两者可以互访对方的所有私有成员。<strong>在伴生对象里使用“protected”没有意义</strong>，因为伴生对象没有子类。<strong>特质使用“private”和“protected”修饰成员也没有意义。</strong></p>
<h2 id="9-7-package-object包对象"><a href="#9-7-package-object包对象" class="headerlink" title="9.7 package object包对象"></a>9.7 package object包对象</h2><blockquote>
<p>​    <strong>包里可直接包含的元素有类、特质和单例对象</strong>，但其实<strong>类内可定义的元素都能放在包里</strong>（只不过字段和方法不能直接定义在包里）</p>
<p>​    <strong>包对象可以理解为</strong>（我自己想的）：包中唯一的可定义字段和方法且直属该包的区域/对象）</p>
</blockquote>
<p>​    <strong>Scala把字段和方法放在一个“包对象”中，每个包都允许有一个包对象。</strong></p>
<p>​    <strong>包对象</strong>用<strong>关键字组合“package object”</strong>为开头来定义，其<strong>名称与关联的包名相同，有点类似伴生类与伴生对象的关系</strong>。</p>
<p>​    <mark>包对象不是包，也不是对象</mark>，它会被编译成名为“package.class”的文件，该文件位于与它关联的包的对应文件夹里。<strong>为了保持路径同步，建议定义包对象的文件命名为“package.scala”，并和定义关联包的文件放在同一个目录下。</strong></p>
<h2 id="9-8-章节总结"><a href="#9-8-章节总结" class="headerlink" title="9.8 章节总结"></a>9.8 章节总结</h2><p>​    本章讲解了包的概念，以及Scala独有的一些语法特点。<strong>这一章并不是重点</strong>，主要是方便读者在阅读别人的代码时能理解层次结构、模块划分，以及根据import的路径来快速寻找相应的定义</p>
<h1 id="10-集合"><a href="#10-集合" class="headerlink" title="10 集合"></a>10 集合</h1><p>​    不管是用Scala编写软件，还是用Chisel开发硬件电路，集合都是非常有用的数据结构。</p>
<p>​    Scala里常见的集合有：<strong>数组、列表、集、映射、序列、元组、数组缓冲、列表缓冲</strong>。</p>
<p>​    了解这些集合的概念并熟练掌握基本使用方法，对提高工作效率大有帮助。本章的内容便是逐一讲解这些集合类，所涉内容均为基础，对编写、阅读Chisel代码有用即可。<u>如果想深入了解集合的原理，请读者自行学习。</u></p>
<h2 id="10-1-Array数组（一个类）"><a href="#10-1-Array数组（一个类）" class="headerlink" title="10.1 Array数组（一个类）"></a>10.1 Array数组（一个类）</h2><p>​    <strong>数组是最基本的集合</strong>，实际是计算机内一片地址连续的内存空间，通过指针来访问每一个数组元素。因为数组是结构最简单的集合，所以<strong>它在访问速度上要比其它集合要更快</strong></p>
<p>​    <strong>关于数组你必须知道的事情：</strong>    </p>
<ul>
<li><strong>Scala的数组类名为Array</strong>，    <strong>Array是一个具体的类，通过new来构造一个数组对象。数组元素的类型任意的，所有元素的类型必须一致。且数组在运行时会保存类型参数信息。</strong></li>
</ul>
<blockquote>
<p>Scala编译器的泛型机制是擦除式的，在运行时并不会保留类型参数的信息。但是数组的特点使得它成为唯一的例外，因为数组的元素类型跟数组保存在一起</p>
</blockquote>
<ul>
<li><p><strong>数组的性质：</strong>数组对象必须是定长的，也就是在构造时可以选择任意长度的数组，构造完毕后就不能再更改长度了</p>
</li>
<li><p><strong>构造数组对象</strong>的语法如下：</p>
<ul>
<li><strong>T表示元素的类型</strong>，可以显式声明，也可以通过传入给构造方法的对象来自动推断（构造对象时，除了可以用值参数来“配置”对象，也可以用类型参数来“配置”。这其实是oop里一种重要的多态，称为全类型多态或参数多态，即通过已有的各种类型创建新的各种类型。）</li>
<li><strong>n代表元素个数</strong>，它必须是一个非负整数，如果n等于0则表示空数组</li>
</ul>
</li>
</ul>
<p><mark>常用的构造方法实例：</mark></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">//使用模板：</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>](n)<br><span class="hljs-comment">//使用实例：</span><br><span class="hljs-keyword">val</span> intArray = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p><mark>特殊的构造方法实例：</mark></p>
<ul>
<li><strong>特殊的构造方法</strong>：除此之外，Array的伴生对象里还定义了一个apply工厂方法，因此也可以按如下方式构造数组对象：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> charArray = <span class="hljs-type">Array</span>(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)<br>charArray: <span class="hljs-type">Array</span>[<span class="hljs-type">Char</span>] = <span class="hljs-type">Array</span>(a, b, c) <br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>数组的访问：</strong>数组可以用过<code>(下标)</code>来索引每个元素（用括号索引的原因是让编译器隐式插入apply方法的调用）</li>
</ul>
<blockquote>
<p>和大多数语言一样，Scala的数组下标也是从0开始的。不过，有一点不同的是，其他语言的数组下标都是写在方括号里，而Scala的数组下标却是写在圆括号里。还记得“操作符即方法吗”？Scala并没有什么下标索引操作符，而是在Array类里定义了一个apply方法，该方法接收一个Int类型的参数，返回对应下标的数组元素。所以，Scala的数组下标才要写在圆括号里，这其实是让编译器隐式插入apply方法的调用，当然读者也可以显式调用。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> intArray = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)<br>intArray: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>scala&gt; intArray(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span><br><br>scala&gt; intArray(<span class="hljs-number">1</span>) = <span class="hljs-number">2</span><br><br>scala&gt; intArray(<span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br><br>scala&gt; intArray<br>res0: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<h2 id="10-2-List列表-一个抽象类，类似不可写入的Array"><a href="#10-2-List列表-一个抽象类，类似不可写入的Array" class="headerlink" title="10.2 List列表(一个抽象类，类似不可写入的Array)"></a>10.2 List列表(一个抽象类，类似不可写入的Array)</h2><blockquote>
<p>​    列表是一种基于链表的数据结构，这使得<strong>列表访问头部元素很快，往头部增加新元素也是消耗定长时间，但是对尾部进行操作则需要线性化的时间，也就是列表越大时间越长</strong>。</p>
</blockquote>
<ul>
<li><strong>List列表是一个抽象类，因此不能用new来构造列表对象。</strong>但是伴生对象里有一个apply工厂方法，接收若干个参数，<strong>以数组的形式转换成列表(链表)</strong>。<strong>列表也是定长的</strong>，<strong>且每个元素的类型相同、不可再重新赋值</strong></li>
<li><p><strong>List有点像不可写入的Array</strong></p>
</li>
<li><p><strong>列表元素的访问</strong>：同Array</p>
</li>
</ul>
<p><mark>常用的构造与访问方法实例：</mark></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> intList = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-5</span>)<br>intList: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-5</span>)<br><br>scala&gt; intList(<span class="hljs-number">0</span>)<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; intList(<span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">-5</span><br><br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>列表添加新元素</strong>（不是修改旧表，列表不可变，而是构造新表）：列表定义了一个名为<code>::</code>的方法，在列表头部添加新元素。其写法如下：</li>
</ul>
<blockquote>
<p>因为列表的数据结构特性使得在头部添加元素很快，而尾部很慢，所以列表定义了一个名为“::”的方法，在列表头部添加新元素。注意，这会构造一个新的列表对象，而不是直接修改旧列表，因为列表是不可变的</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">x :: xs<br></code></pre></div></td></tr></table></figure>
<ul>
<li><ul>
<li><p>左侧的x是一个T类型的元素</p>
</li>
<li><p>右侧的xs是一个List[T]类型的列表。</p>
</li>
<li><p>这种写法符合直观表示。</p>
</li>
<li><blockquote>
<p>还记得前面说过以冒号结尾的中缀操作符，其调用对象在右侧吗？其实正是出自这里。因为x是任意类型的，如果让x成为调用对象，那么就必须在所有类型包括自定义类型里都添加方法“::”，这显然是不现实的。如果<strong>让列表xs成为调用对象</strong>，那么只需要列表类定义该方法即可。例如：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scalal">scala&gt; 1 :: List(2, 3)<br>res0: List[Int] = List(1, 2, 3)<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>拼接左、右两个列表，返回新的列表</strong>：<code>:::</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ::: <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <br></code></pre></div></td></tr></table></figure>
<ul>
<li><p><strong>空列表</strong>：</p>
<ul>
<li>L<strong>ist有一个子对象<code>Nil</code>，示空列表</strong>。<strong>Nil的类型是List[Nothing]</strong></li>
<li>因为List的类型参数是协变的(有关泛型请见后续章节)，而Nothing又是所有类的子类，所以<strong>List[Nothing]是所有列表的子类，即<code>Nil</code>兼容所有元素</strong></li>
</ul>
</li>
<li><p><strong>使用空列表构造列表：</strong>既然Nil是一个空列表对象，那么它同样能调用方法<code>::</code>，通过<code>Nil和::</code>就能构造出一个列表</p>
</li>
</ul>
<p><mark>使用空列表构造方法实例：</mark></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span> :: <span class="hljs-number">2</span> :: <span class="hljs-number">3</span> :: <span class="hljs-type">Nil</span><br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<ul>
<li><ul>
<li>用apply工厂方法构造其实是上述方式的等效形式。展开来解释就是：在空列表Nil的头部添加了一个元素3，构成了列表List(3)；随后，继续在头部添加元素2，构成列表List(2, 3)；最后，在头部添加元素1，得到最终的List(1, 2, 3)</li>
</ul>
</li>
<li><p><strong>使数组和列表包含不同类型的元素（不推荐）</strong>：<strong>数组与列表元素不仅可以是值类型，它们也可以是自定义的类，甚至是数组和列表本身，构成嵌套的数组与列表</strong>。此外，如果元素类型是Any，那么数组和列表也就可以包含不同类型的元素。当然，并不推荐这么做。例如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>))<br>res0: <span class="hljs-type">List</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">List</span>(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">Array</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>))<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, &#x27;<span class="hljs-number">1</span>&#x27;, <span class="hljs-string">&quot;1&quot;</span>)<br>res1: <span class="hljs-type">List</span>[<span class="hljs-type">Any</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<h2 id="10-3-快速添加元素、数组缓冲与列表缓冲"><a href="#10-3-快速添加元素、数组缓冲与列表缓冲" class="headerlink" title="10.3 快速添加元素、数组缓冲与列表缓冲"></a>10.3 快速添加元素、数组缓冲与列表缓冲</h2><p><strong>（1）如何快速添加元素往尾部添加元素：</strong></p>
<ul>
<li><p>一种可行方案是先往列表头部添加，再把列表整体翻转。</p>
</li>
<li><p>另一种方案是使用定义在scala.collection.mutable包里的ArrayBuffer和ListBuffer。</p>
<ul>
<li>这两者<strong>并不是真正的数组和列表，而可以认为是暂存在缓冲区的数据</strong>。在数组缓冲和列表缓冲的头部、尾部都能添加、删去元素，并且<strong>耗时是固定的</strong>，只不过<strong>数组缓冲要比数组慢一些</strong>。数组和列表能使用的成员方法，在它们的缓冲类里也有定义。</li>
</ul>
</li>
</ul>
<p><strong>（2）使用ArrayBuffer/ListBuffer添删元素的具体方法：</strong></p>
<ul>
<li><code>ArrayBuffer/ListBuffer += value</code>可以往<strong>缓冲尾部添加元素</strong></li>
<li>通过<code>value +=: ArrayBuffer/ListBuffer</code>可以往<strong>缓冲头部添加元素</strong></li>
<li>只能通过<code>ArrayBuffer/ListBuffer -= value</code>往缓冲的<strong>尾部删去第一个符合的元素</strong></li>
<li><strong>往尾部增加或删除元素时，元素数量可以不只一个</strong>。</li>
</ul>
<p><mark>常用的构造与访问方法实例：</mark></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">import</span> scala.collection.mutable.&#123;<span class="hljs-type">ArrayBuffer</span>, <span class="hljs-type">ListBuffer</span>&#125;<br><span class="hljs-keyword">import</span> scala.collection.mutable.&#123;<span class="hljs-type">ArrayBuffer</span>, <span class="hljs-type">ListBuffer</span>&#125;<br><br>scala&gt; <span class="hljs-keyword">val</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>]()<br>ab: scala.collection.mutable.<span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">ArrayBuffer</span>()<br><br>scala&gt; ab += <span class="hljs-number">10</span><br>res0: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">10</span>)<br><br>scala&gt; <span class="hljs-number">-10</span> +=: ab<br>res1: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)<br><br>scala&gt; ab -= <span class="hljs-number">-10</span><br>res2: ab.<span class="hljs-keyword">type</span> = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">10</span>)<br><br>scala&gt; <span class="hljs-keyword">val</span> lb = <span class="hljs-keyword">new</span> <span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>]()<br>lb: scala.collection.mutable.<span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">ListBuffer</span>()<br><br>scala&gt; lb += (<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;oops&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>)<br>res3: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(abc, oops, good)<br><br>scala&gt; lb -= <span class="hljs-string">&quot;abc&quot;</span><br>res4: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(oops, good)<br><br>scala&gt; <span class="hljs-string">&quot;scala&quot;</span> +=: lb<br>res5: lb.<span class="hljs-keyword">type</span> = <span class="hljs-type">ListBuffer</span>(scala, oops, good)<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）使用ArrayBuffer/ListBuffer转换数组的方法：</strong></p>
<ul>
<li>通过方法<code>toArray</code>或<code>toList</code>把缓冲的数据构造成一个数组或列表对象</li>
<li>注意，<strong>这是构造一个新的对象，原有缓冲仍然存在</strong>。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; lb.toArray<br>res6: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Array</span>(scala, oops, good)<br><br>scala&gt; lb.toList<br>res7: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(scala, oops, good)<br><br>scala&gt; lb<br>res8: scala.collection.mutable.<span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">ListBuffer</span>(scala, oops, good)<br></code></pre></div></td></tr></table></figure>
<h2 id="10-4-Tuple元组（一系列类）"><a href="#10-4-Tuple元组（一系列类）" class="headerlink" title="10.4 Tuple元组（一系列类）"></a>10.4 Tuple元组（一系列类）</h2><ul>
<li><strong>元组</strong>也是一种常用的数据结构，<strong>不是一个类是一系列类，不可变，但可以包含不同类型元素</strong></li>
<li><strong>两种元组的构造写法：</strong><ul>
<li><strong>(不常用)使用具体的元组类进行元组构造</strong>：<code>new TupleX(元组元素)</code>，见<a href="#元组并不是一个类，而是一系列类">下方介绍</a><ul>
<li><strong>元组字面量构造的写法：</strong>就是在圆括号里编写用逗号间隔的元素。<mark>常用的构造方法实例：</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tuple&quot;</span>, <span class="hljs-type">Console</span>)<br>res0: (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>, <span class="hljs-type">Console</span>.<span class="hljs-keyword">type</span>) = (<span class="hljs-number">1</span>,tuple,scala.<span class="hljs-type">Console</span>$@<span class="hljs-number">5</span>fc59e43) <br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>上述例子构造了一个三元组</strong>，包含了一个Int对象、一个String对象和控制台对象。注意查看打印的元组类型。</p>
</blockquote>
<ul>
<li><p><strong>元组最常用的地方：作为函数的返回值。</strong>由于函数只有一个返回语句，但如果想返回多个表达式或对象，就可以把它们包在一个元组里返回。</p>
</li>
<li><p><strong>元组不可遍历，无法通过下标来索引：</strong>因为元组含有不同类型的对象，所以不可遍历，也就无法通过下标来索引，<strong>只能通过“_1”、“_2”……这样来访问每个元素</strong>。<strong>注意第一个元素就是“_1”，不是“_0”（与Array和List从0开始不同）</strong>例如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> t = (<span class="hljs-string">&quot;God&quot;</span>, &#x27;<span class="hljs-type">A</span>&#x27;, <span class="hljs-number">2333</span>)<br>t: (<span class="hljs-type">String</span>, <span class="hljs-type">Char</span>, <span class="hljs-type">Int</span>) = (<span class="hljs-type">God</span>,<span class="hljs-type">A</span>,<span class="hljs-number">2333</span>)<br><br>scala&gt; t._1<br>res0: <span class="hljs-type">String</span> = <span class="hljs-type">God</span><br><br>scala&gt; t._2<br>res1: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br><br>scala&gt; t._3<br>res2: <span class="hljs-type">Int</span> = <span class="hljs-number">2333</span><br></code></pre></div></td></tr></table></figure>
<p><span id="元组并不是一个类，而是一系列类"></span></p>
<ul>
<li><p><strong>元组并不是一个类，而是一系列类</strong>：Tuple1、Tuple2、Tuple3……Tuple22</p>
<ul>
<li><p><strong>这些类都是具体的</strong>，因此除了通过字面量的写法构造元组，也可以显式地通过<code>new TupleX(元组元素)</code>来构造。其中，<strong>每个数字代表元组包含的元素数量，也就是说元组最多只能包含22个元素，除非自定义Tuple23、Tuple24……不过这没有意义</strong>，因为元组可以嵌套元组，并不妨碍元组包含任意数量的元素。</p>
</li>
<li><p>查看元组的API，会发现每个TupleX类里都有名为“_1”、“_2”……“_X”的字段。这正好呼应了前面访问元组元素所用的独特语法。</p>
<ul>
<li><strong>Tuple1（一元组）</strong>没有字面量，只能显式地通过“new Tuple1(元组元素)”来构造一元组，因为<strong>此时编译器不会把圆括号解释成元组</strong></li>
<li><strong>Tuple2（二元组）</strong>也叫“对偶”，这在<strong>映射里会用到</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>当函数的入参数量只有一个时，那么调用时传递进去的<strong>元组字面量也可以省略圆括号</strong>。例如：</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getType</span></span>(x: <span class="hljs-type">Any</span>) = x.getClass<br>getType: (x: <span class="hljs-type">Any</span>)<span class="hljs-type">Class</span>[_]<br><br>scala&gt; getType(<span class="hljs-number">1</span>)<br>res0: <span class="hljs-type">Class</span>[_] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Integer</span></span><br><br>scala&gt; getType(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>res1: <span class="hljs-type">Class</span>[_] = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">scala</span>.<span class="hljs-title">Tuple3</span></span><br></code></pre></div></td></tr></table></figure>
<h2 id="10-5-Map映射（一个特质）"><a href="#10-5-Map映射（一个特质）" class="headerlink" title="10.5 Map映射（一个特质）"></a>10.5 Map映射（一个特质）</h2><ul>
<li><p>映射是包含一系列<strong>“键-值”对的集合</strong>，可重复的键值对（可重复hash）</p>
</li>
<li><p><strong>键和值的类型可以是任意的，但是每个键-值对的类型必须一致</strong></p>
</li>
<li><p><strong>键-值对的写法是“键 -&gt; 值”</strong></p>
</li>
<li><p><strong>映射并不是一个类，而是一个特质</strong>。所以<strong>无法用new构建映射对象</strong>，只能通过伴生对象里的<strong>apply工厂方法来构造映射类型的对象</strong>，<mark>常用的构造方法实例：</mark></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>(<span class="hljs-number">1</span> -&gt; <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">2</span> -&gt; <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">3</span> -&gt; <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">4</span> -&gt; <span class="hljs-string">&quot;/&quot;</span>)<br>map: scala.collection.immutable.<span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>,<span class="hljs-type">String</span>] = <span class="hljs-type">Map</span>(<span class="hljs-number">1</span> -&gt; +, <span class="hljs-number">2</span> -&gt; -, <span class="hljs-number">3</span> -&gt; *, <span class="hljs-number">4</span> -&gt; /)<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>Map返回键对应值：</strong>对映射的apply方法通过接收一个键作为参数，返回对应的值。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; map(<span class="hljs-number">3</span>)<br>res0: <span class="hljs-type">String</span> = *<br><br>scala&gt; map(<span class="hljs-number">0</span>)<br>java.util.<span class="hljs-type">NoSuchElementException</span>: key not found: <span class="hljs-number">0</span><br>  at scala.collection.immutable.<span class="hljs-type">Map</span>$<span class="hljs-type">Map4</span>.apply(<span class="hljs-type">Map</span>.scala:<span class="hljs-number">204</span>)<br>  ... <span class="hljs-number">28</span> elided<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>实际意义（可以写成对偶形式）：表达式“object1 -&gt; object2”实际就是一个对偶(二元组)，</strong>因此<strong>键-值对也可以写成对偶的形式。</strong>例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> tupleMap = <span class="hljs-type">Map</span>((&#x27;a&#x27;, &#x27;<span class="hljs-type">A</span>&#x27;), (&#x27;b&#x27;, &#x27;<span class="hljs-type">B</span>&#x27;))<br>tupleMap: scala.collection.immutable.<span class="hljs-type">Map</span>[<span class="hljs-type">Char</span>,<span class="hljs-type">Char</span>] = <span class="hljs-type">Map</span>(a -&gt; <span class="hljs-type">A</span>, b -&gt; <span class="hljs-type">B</span>)<br><br>scala&gt; tupleMap(&#x27;a&#x27;)hex<br>res0: <span class="hljs-type">Char</span> = <span class="hljs-type">A</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>映射可变与不可变：<strong>默认情况下，使用的是scala.collection.immutable包</strong>里的不可变映射。当然，<strong>也可以导入scala.collection.mutable包里的可变映射</strong>，这样就能动态地增加、删除键-值对。可变映射的名字也叫“Map”，因此要注意使用import导入可变映射时，是否把不可变映射覆盖了。</li>
</ul>
<h2 id="10-6-Set集合（一个特质）"><a href="#10-6-Set集合（一个特质）" class="headerlink" title="10.6 Set集合（一个特质）"></a>10.6 Set集合（一个特质）</h2><ul>
<li><strong>集和映射一样，也是一个特质，也只能通过apply工厂方法构建对象</strong></li>
<li><p><strong>理解为hash哈希</strong></p>
</li>
<li><p>集只能包含<strong>字面值不相同</strong>的<strong>同类型元素</strong></p>
</li>
<li><strong>集的apply方法是测试是否包含传入的参数，返回true或false，而不是通过下标来索引元素</strong></li>
</ul>
<p><mark>常用的构造方法如下：</mark></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> set = <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">233</span>)<br>set: scala.collection.immutable.<span class="hljs-type">Set</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">233</span>)<br><br>scala&gt; set(<span class="hljs-number">100</span>)<br>res0: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span><br><br>scala&gt; set(<span class="hljs-number">233</span>)<br>res1: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>默认情况下，使用的也是不可变集，scala.collection.mutable包里也有同名的可变集</strong></li>
</ul>
<h2 id="10-7-Seq序列（一个特质）"><a href="#10-7-Seq序列（一个特质）" class="headerlink" title="10.7 Seq序列（一个特质）"></a>10.7 Seq序列（一个特质）</h2><ul>
<li><p><strong>序列Seq也是一个特质，数组和列表都混入了这个特质</strong></p>
</li>
<li><p><strong>序列可遍历、可迭代</strong>，也就是能用从0开始的下标索引，也可用于循环。</p>
</li>
<li><strong>序列也是包含一组相同类型的元素，并且不可变</strong>。</li>
<li><strong>其构造方法也是通过apply工厂方法</strong>。</li>
</ul>
<p>只是因为Chisel在某些场合会用到Seq，所以介绍这个概念，但是不必深入了解。</p>
<h2 id="10-8-针对集合的几种常用方法"><a href="#10-8-针对集合的几种常用方法" class="headerlink" title="10.8 针对集合的几种常用方法"></a>10.8 针对集合的几种常用方法</h2><p>​    上述类都定义了很多有用的成员方法，在这里介绍一二。如果想查看更多内容，建议前往官网的API网站查询</p>
<p><strong>（1）map方法</strong>（同python里面的Map）</p>
<p>​    <strong>为集合内每个元素接受参数：</strong>Map方法接收一个无副作用的函数作为入参，对调用该方法的集合的每个元素应用入参函数，并把所得结果全部打包在一个集合里返回</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">Array</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>).map(_ + <span class="hljs-string">&quot;s&quot;</span>)<br>res0: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Array</span>(apples, oranges, pears)<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(_ * <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>（2）foreach方法</strong>（同java里面的泛式）</p>
<p>​    <strong>遍历集合内每一个元素</strong>：foreach方法与map方法<strong>作用类似</strong>，不过它的入参是一个有副作用的函数。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>sum: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">234</span>).foreach(sum += _)<br><br>scala&gt; sum<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">233</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）zip方法</strong></p>
<p>​    <strong>把两个可迭代的集合一一对应，构成若干个对偶</strong>。如果其中一个集合比另一个长，则忽略多余的元素。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) zip <span class="hljs-type">Array</span>(&#x27;<span class="hljs-number">1</span>&#x27;, &#x27;<span class="hljs-number">2</span>&#x27;, &#x27;<span class="hljs-number">3</span>&#x27;)<br>res0: <span class="hljs-type">List</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Char</span>)] = <span class="hljs-type">List</span>((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<br><br>scala&gt; <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) zip <span class="hljs-type">Set</span>(<span class="hljs-string">&quot;good&quot;</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br>res1: <span class="hljs-type">List</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>)] = <span class="hljs-type">List</span>((<span class="hljs-number">1</span>,good), (<span class="hljs-number">2</span>,<span class="hljs-type">OK</span>))<br></code></pre></div></td></tr></table></figure>
<h2 id="10-9-章节总结"><a href="#10-9-章节总结" class="headerlink" title="10.9 章节总结"></a>10.9 章节总结</h2><p>​    本章介绍了Scala标准库里的常用集合，<strong>这些数据结构在Chisel里面也经常用到</strong>，读者应该熟悉掌握它们的概念和相关重点。在后一章内建控制结构中，也要用到这些集合</p>
<h1 id="11-内建控制结构"><a href="#11-内建控制结构" class="headerlink" title="11 内建控制结构"></a>11 内建控制结构</h1><h2 id="11-1-if表达式"><a href="#11-1-if表达式" class="headerlink" title="11.1 if表达式"></a>11.1 if表达式</h2><blockquote>
<p>用于判断的“if……else if……else”语法想必是所有编程语言都具备的。Scala的if表达式与大多数语言是一样的。在if和每个else if后面都将接收一个Boolean类型的表达式作为参数，如果表达式的结果为true，就执行对应的操作，否则跳过。每个分支都可以包含一个表达式作为执行体，如果有多个表达式，则应该放进花括号里。对整个if表达式而言，实际是算作一个表达式。</p>
</blockquote>
<p><strong>为什么叫if表达式？</strong></p>
<ul>
<li>Scala把“if”叫“表达式”，是因为if表达式能返回有用的值</li>
<li>但是while叫循环，是因为while循环不会返回有用的值，主要作用是不断重写某些var变量，所以while循环的类型是Unit</li>
<li>跟多内容在下一节有解释</li>
</ul>
<p>类似大多数高级语言，不过多介绍</p>
<h2 id="11-2-while循环"><a href="#11-2-while循环" class="headerlink" title="11.2 while循环"></a>11.2 while循环</h2><p>类似大多数高级语言，不过多介绍</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcdLoop</span></span>(x: <span class="hljs-type">Long</span>, y: <span class="hljs-type">Long</span>): <span class="hljs-type">Long</span> = &#123;<br>  <span class="hljs-keyword">var</span> a = x<br>  <span class="hljs-keyword">var</span> b = y<br>  <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">val</span> temp = a<br>    a = b % a<br>    b = temp<br>  &#125;<br>  b<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    从上述代码可以看出，<strong>while语法的风格是指令式的</strong>。实际上，<strong>Scala把“if”叫“表达式”</strong>，是因为if表达式能返回有用的值，而“while”叫循环，是因为<strong>while循环不会返回有用的值</strong>，主要作用是不断重写某些var变量，所以<strong>while循环的类型是Unit</strong>，<strong>在纯函数式的语言里，只有表达式，不会存在像while循环这样的语法。</strong>Scala兼容两种风格，并引入了while循环，是因为某些时候用while编写的代码可阅读性更强</p>
<p>​    <strong>函数式风格的while循环(使用递归的方式实现)</strong>：<strong>其实所有的while循环都可以通过其它函数式风格的语法来实现</strong>，常见做法就是函数的<strong>递归调用</strong>。例如，一个函数式风格的求取最大公约数的函数定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span></span>(x: <span class="hljs-type">Long</span>, y: <span class="hljs-type">Long</span>): <span class="hljs-type">Long</span> =<br>  <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) x <span class="hljs-keyword">else</span> gcd(y, x % y)<br></code></pre></div></td></tr></table></figure>
<h2 id="11-3-for表达式与for循环（推荐）"><a href="#11-3-for表达式与for循环（推荐）" class="headerlink" title="11.3 for表达式与for循环（推荐）"></a>11.3 for表达式与for循环（推荐）</h2><p><strong>（1）for循环介绍</strong></p>
<p>​    <strong>要实现循环，在Scala里推荐使用for表达式</strong>。Scala的<strong>for表达式是函数式风格的</strong>，<strong>没有引入指令式风格的“for(i = 0; i &lt; N; i++)”</strong></p>
<p>​    <strong>其他风格的for</strong>（类似传统上的for循环）循环可以参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-for-loop.html">https://www.runoob.com/scala/scala-for-loop.html</a></p>
<p><strong>（2）使用yield的循环：</strong></p>
<p>一个Scala的for表达式的一般形式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>( seq ) <span class="hljs-keyword">yield</span> expression<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>整个for表达式算一个语句</strong>。</li>
<li><strong>seq代表一个序列</strong><ul>
<li><strong>能放进for表达式里的对象，必须是一个可迭代（Iterable）的集合</strong>。比如常用的列表(List)、数组(Array)、映射(Map)、区间(Range)、迭代器(Iterator)、流(Stream)和所有的集(Set)，<strong>它们都混入了特质Iterable</strong><ul>
<li><strong>可迭代的集合对象能生成一个迭代器</strong>，用该<strong>迭代器可以逐个遍历</strong>集合中的所有元素，<strong>进而构成了for表达式所需的序列</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关键字“yield”是“产生”的意思</strong>，也就是把前面序列里符合条件的元素拿出来，<strong>逐个应用到后面的“expression”</strong>，<strong>得到的所有结果按顺序产生一个新的集合对象</strong></li>
</ul>
<p><strong>（3）完整的For循环（上述seq展开式）：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> &#123;<br>   <span class="hljs-comment">//sep包括三部分：生成器、定义、过滤器</span><br>  p &lt;- persons          <span class="hljs-comment">// 一个生成器</span><br>  n = p.name            <span class="hljs-comment">// 一个定义</span><br>  <span class="hljs-keyword">if</span>(n startsWith <span class="hljs-string">&quot;To&quot;</span>)  <span class="hljs-comment">// 一个过滤器</span><br>&#125; <span class="hljs-keyword">yield</span> n<br></code></pre></div></td></tr></table></figure>
<p>​    <strong>seq是由“生成器”、“定义”和“过滤器”三条语句组成</strong>（以分号隔开，或者放在花括号里让编译器自动推断分号）</p>
<ul>
<li>①<strong>生成器</strong><code>p &lt;- persons</code>右侧<code>persons</code>就是一个可迭代的集合对象，把它的每个元素逐一拿出来与左侧的模式<code>p</code>进行匹配(有关模式匹配请见后续章节)。<ul>
<li>如果匹配<strong>成功</strong>，那么<strong>模式里的变量</strong>就会绑定上该元素对应的部分；</li>
<li>如果匹配<strong>失败</strong>，并不会抛出匹配错误，而是简单地<strong>丢弃该元素</strong>。</li>
<li>在这个例子里，<strong>左侧的p</strong>是一个<strong>无需定义的变量名，它构成了变量模式</strong>，也就是<strong>简单地指向persons的每个元素</strong></li>
<li><strong>大多数情况下的for表达式的生成器都是这么简单</strong>。</li>
</ul>
</li>
<li>②<strong>定义就是一个赋值语句</strong>，这里的<strong>n</strong>也是一个无需定义的变量名。<strong>定义并不常用</strong>，比如这里的定义就可有可无。</li>
<li>③<strong>过滤器</strong>则是一个if语句，只有if后面的表达式为true时，生成器的元素才会继续向后传递，否则就丢弃该元素。</li>
<li><strong>这个例子中，是判断persons的元素的name字段是否以“To”为开头</strong>。<strong>最后，name以“To”为开头的persons元素会应用到yield后面的表达式，在这里仅仅是保持不变，没有任何操作。</strong>（总之，这个表达式的结果就是遍历集合persons的元素，按顺序找出所有name以“To”为开头的元素，然后把这些元素组成一个新的集合）</li>
<li>完整的sep展开的for的示例代码：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// test.scala</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span></span>)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Alice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Alice</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Tom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Tom</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Tony</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Tony</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Bob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Bob</span>&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Todd</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>(<span class="hljs-params">&quot;<span class="hljs-type">Todd</span>&quot;</span>)</span><br> <br><span class="hljs-keyword">val</span> persons = <span class="hljs-type">List</span>(<span class="hljs-type">Alice</span>, <span class="hljs-type">Tom</span>, <span class="hljs-type">Tony</span>, <span class="hljs-type">Bob</span>, <span class="hljs-type">Todd</span>)<br> <br><span class="hljs-keyword">val</span> <span class="hljs-type">To</span> = <span class="hljs-keyword">for</span> &#123;<br>  p &lt;- persons          <br>  n = p.name            <br>  <span class="hljs-keyword">if</span>(n startsWith <span class="hljs-string">&quot;To&quot;</span>) <br>&#125; <span class="hljs-keyword">yield</span> n<br> <br>println(<span class="hljs-type">To</span>)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>PS E:\Microsoft VS\Scala&gt; scala test.scala<br>List(Tom, Tony, Todd)</p>
</blockquote>
<p><strong>（4）嵌套for</strong></p>
<ul>
<li><strong>一个for表达式中有多个生成器</strong>：那么出现在后面的生成器比出现在前面的生成器变得更频繁，也就是指令式编程里的嵌套的for循环。例如计算乘法口诀表：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"> scala&gt; <span class="hljs-keyword">for</span> &#123;undefined<br>          |    i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">9</span><br>          |    j &lt;- i to <span class="hljs-number">9</span><br>          |  &#125; <span class="hljs-keyword">yield</span> i * j<br>res0: scala.collection.immutable.<span class="hljs-type">IndexedSeq</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">28</span>, <span class="hljs-number">32</span>, <span class="hljs-number">36</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>, <span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">36</span>, <span class="hljs-number">42</span>, <span class="hljs-number">48</span>, <span class="hljs-number">54</span>, <span class="hljs-number">49</span>, <span class="hljs-number">56</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">81</span>)<br><br></code></pre></div></td></tr></table></figure>
<p><strong>（5）普通遍历的for、定义的重新计算</strong>    </p>
<p>​    <strong>每当生成器生成一个匹配的元素，后面的定义就会重新求值。</strong></p>
<p>​    这个求值是有必要的，因为定义很可能需要随生成器的值变化而变化。为了不浪费这个操作，定义应尽量用到相关生成器绑定的变量，否则就没必要使用定义。例如： </p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">1000</span>; y = 一条计算x的函数) <span class="hljs-keyword">yield</span> x * y<br></code></pre></div></td></tr></table></figure>
<p>​    不如写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> y =  一条计算x的函数 <br><br><span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">1000</span>) <span class="hljs-keyword">yield</span> x * y<br></code></pre></div></td></tr></table></figure>
<p><strong>（6）for求和、省略yield</strong></p>
<p>​    如果只想把每个元素应用到一个Unit类型的表达式，那么就是一个“for循环”，而不再是一个“for表达式”。关键字“yield”也可以省略。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>sum: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>scala&gt; <span class="hljs-keyword">for</span>(x &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">100</span>) sum += x<br><br>scala&gt; sum<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">5050</span><br></code></pre></div></td></tr></table></figure>
<h2 id="11-4-用try表达式处理异常"><a href="#11-4-用try表达式处理异常" class="headerlink" title="11.4 用try表达式处理异常"></a>11.4 用try表达式处理异常</h2><p><strong>（1）抛出一个异常</strong></p>
<p>​    如果操作非法，那么<strong>JVM会自动抛出异常</strong>。</p>
<p>​    <strong>也可以手动抛出异常，</strong>只需要用new构造一个异常对象，并用关键字“throw”抛出即可，<strong>语法与Java一样。</strong></p>
<p>​    <strong>try表达式的完整形式是“try-catch-finally”</strong></p>
<p><strong>（2）try-catch</strong></p>
<blockquote>
<p>​    try后面可以用花括号包含任意条代码，当这些代码产生异常时，JVM并不会立即抛出，而是被catch捕获。catch捕获异常后，按其后面的定义进行相应的处理。处理的方式一般借助偏函数，在详细了解模式匹配前，只需要了解这些语法即可。例如处理除零异常：</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intDivision</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = &#123;undefined<br>         |     <span class="hljs-keyword">try</span> &#123;undefined<br>         |       x / y<br>         |     &#125; <span class="hljs-keyword">catch</span> &#123;undefined<br>         |       <span class="hljs-keyword">case</span> ex: <span class="hljs-type">ArithmeticException</span> =&gt; println(<span class="hljs-string">&quot;The divisor is Zero!&quot;</span>)<br>         |     &#125;<br>         |  &#125;<br>intDivision: (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)<span class="hljs-type">AnyVal</span><br><br>scala&gt; intDivision(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-type">The</span> divisor is <span class="hljs-type">Zero</span>!<br>res0: <span class="hljs-type">AnyVal</span> = ()<br><br>scala&gt; intDivision(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>res1: <span class="hljs-type">AnyVal</span> = <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）finally</strong></p>
<p>​    try表达式的完整形式是“try-catch-finally”。<strong>不管有没有异常产生，finally里的代码一定会执行。通常finally语句块都是执行一些清理工作，比如关闭文件。尽管try表达式可以返回有用值，但是最好不要在finally语句块里这么做。</strong>因为Java在显式声明“return”时，会用finally的返回值覆盖前面真正需要的返回值。为了以防万一，最好不要这样做。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span></span>(): <span class="hljs-type">Int</span> = <span class="hljs-keyword">try</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">finally</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>a: ()<span class="hljs-type">Int</span><br><br>scala&gt; a<br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><br>scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span></span>(): <span class="hljs-type">Int</span> = <span class="hljs-keyword">try</span> <span class="hljs-number">1</span> <span class="hljs-keyword">finally</span> <span class="hljs-number">2</span><br>b: ()<span class="hljs-type">Int</span><br><br>scala&gt; b<br>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<h2 id="10-5-match表达式"><a href="#10-5-match表达式" class="headerlink" title="10.5 match表达式"></a>10.5 match表达式</h2><p>​    match表达式的作用相当于“switch”，也就是把作用对象与定义的模式逐个比较，按匹配的模式执行相应的操作。在详细了解模式匹配之前，先看一个简单的例子粗浅地了解一番：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">something</span></span>(x: <span class="hljs-type">String</span>) = x <span class="hljs-keyword">match</span> &#123;undefined<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Apple&quot;</span> =&gt; println(<span class="hljs-string">&quot;Fruit!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Tomato&quot;</span> =&gt; println(<span class="hljs-string">&quot;Vegetable!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Cola&quot;</span> =&gt; println(<span class="hljs-string">&quot;Beverage!&quot;</span>)<br>         |     <span class="hljs-keyword">case</span> _ =&gt; println(<span class="hljs-string">&quot;Huh?&quot;</span>)<br>         |  &#125;<br>something: (x: <span class="hljs-type">String</span>)<span class="hljs-type">Unit</span><br><br>scala&gt; something(<span class="hljs-string">&quot;Cola&quot;</span>)<br><span class="hljs-type">Beverage</span>!<br><br>scala&gt; something(<span class="hljs-string">&quot;Toy&quot;</span>)<br><span class="hljs-type">Huh</span>?<br></code></pre></div></td></tr></table></figure>
<h2 id="10-6-关于continue和break"><a href="#10-6-关于continue和break" class="headerlink" title="10.6 关于continue和break"></a>10.6 关于continue和break</h2><p><strong>（1）传统循环中的continue和break</strong></p>
<p>​    对于指令式编程而言，循环里经常用到关键字“continue”和“break”，例如下面的Java程序：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Java</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">boolean</span> foundIt = <span class="hljs-keyword">false</span>;<br> <br><span class="hljs-keyword">while</span> (i &lt; args.length) &#123;<br>  <span class="hljs-keyword">if</span> (args[i].startsWith(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>    i = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (args[i].endsWith(<span class="hljs-string">&quot;.scala&quot;</span>)) &#123;<br>    foundIt = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  i = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    实际上，这两个关键字对循环而言并不是必须的。例如可以改写成如下Scala代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// bad Scala</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> foundIt = <span class="hljs-literal">false</span><br> <br><span class="hljs-keyword">while</span> (i &lt; args.length &amp;&amp; !foundIt) &#123;<br>  <span class="hljs-keyword">if</span> (!args(i).startsWith(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (args(i).endsWith(<span class="hljs-string">&quot;.scala&quot;</span>))<br>      foundIt = <span class="hljs-literal">true</span><br>  &#125;<br>  i = i + <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（2）Scala中的break和continue</strong></p>
<blockquote>
<p>​    又因为这两个关键字过于偏向指令式风格，就像“return”，所以<strong>Scala并没有引入它们</strong>。</p>
</blockquote>
<p>​    <strong>Scala不提供原生的break和continue，也不推荐用for循环，而是通过递归调用实现：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// good Scala</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchFrom</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> =<br>  <span class="hljs-keyword">if</span> (i &gt;= args.length) <span class="hljs-number">-1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args(i).startsWith(<span class="hljs-string">&quot;-&quot;</span>)) searchFrom(i + <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args(i).endsWith(<span class="hljs-string">&quot;.scala&quot;</span>)) i<br>  <span class="hljs-keyword">else</span> searchFrom(i + <span class="hljs-number">1</span>)<br> <br><span class="hljs-keyword">val</span> i = searchFrom(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>
<p>​    <strong>Scala标准库中提供了Break类从而实现break</strong></p>
<p>​    通过<code>import scala.util.control.Breaks._”</code>可以导入Breaks类，该类定义了一个名为“break”的方法。那么，在写下break的地方，就会被编译器标记为可中断。</p>
<h2 id="11-7-变量的作用域"><a href="#11-7-变量的作用域" class="headerlink" title="11.7 变量的作用域"></a>11.7 变量的作用域</h2><p>​    在使用控制结构的时候，尤其是有嵌套时，必然要搞清楚变量的作用范围。Scala变量作用范围很明确，边界就是花括号。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printMultiTable</span></span>() = &#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 只有i在作用域内</span><br>  <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// i和j都在作用域内</span><br>    <span class="hljs-keyword">while</span> (j &lt;= <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">val</span> prod = (i * j).toString<br>      <span class="hljs-comment">// i、j和prod都在作用域内</span><br>      <span class="hljs-keyword">var</span> k = prod.length<br>      <span class="hljs-comment">// i、j、prod和k都在作用域内</span><br>      <span class="hljs-keyword">while</span> (k &lt; <span class="hljs-number">4</span>) &#123;<br>        print(<span class="hljs-string">&quot; &quot;</span>)<br>        k += <span class="hljs-number">1</span><br>      &#125;<br>      print(prod)<br>      j += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// i和j仍在作用域内；prod和k已经超出作用域</span><br>    println()<br>    i += <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-comment">// i仍在作用域内；j、prod和k已经超出作用域</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    如果内、外作用域有同名的变量，那么内部作用域以内部变量为准，超出内部的范围以外部变量为准。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>() = &#123;undefined<br>         |     <span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span><br>         |     do &#123;undefined<br>         |         <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>         |         println(a)<br>         |     &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">false</span>)<br>         |     println(a)<br>         |  &#125;<br>f: ()<span class="hljs-type">Unit</span><br><br>scala&gt; f<br><span class="hljs-number">10</span><br><span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<h2 id="11-8-章节总结"><a href="#11-8-章节总结" class="headerlink" title="11.8 章节总结"></a>11.8 章节总结</h2><p>​    本章介绍了Scala的内建控制结构，尤其是for表达式，在Chisel里面也是经常用到。<strong>对于重复逻辑、连线等，使用for表达式就很方便。尽管Verilog也有for语法，但是使用较为麻烦，而且不能像Chisel一样支持泛型。</strong></p>
<p>​    除此之外，Chisel也有自定义的控制结构，这些内容会在后续章节讲解。</p>
<hr>
<p><img src="https://markdownpic-1301418409.cos.ap-nanjing.myqcloud.com/img/markdown_1/96247202_p0.jpg" srcset="/img/loading.gif" lazyload alt="pixivid：96247202"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                      <a class="hover-with-bg" href="/categories/CS/Scala/">Scala</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                      <a class="hover-with-bg" href="/tags/CS/">CS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202202281650/CS/Scalaessay/cs/scala/Scala2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Scala学习材料</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202202110126/IC/uvm%E5%AD%A6%E4%B9%A0essay/ic/sv%E5%AD%A6%E4%B9%A0/UVM%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B69%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88_%E9%9B%86%E6%88%90/">
                        <span class="hidden-mobile">UVM入门进阶9：寄存器模型概览_集成.md</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  
  <div id="aplayer" style="width:300px"></div>
  <link defer rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
  <script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js"></script>
  <script defer src="/js/aplayer.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"left","width":250,"height":500,"vOffset":-18},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
