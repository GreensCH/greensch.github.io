

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/con1.png">
  <link rel="icon" href="/img/con1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="“无论最终结果将人类历史导向何处，我们决定选择希望”">
  <meta name="author" content="友人律 | Guilin Chang">
  <meta name="keywords" content="三差学生、不学无术">
  <meta name="description" content="静态时序分析 讲义下载：https:&#x2F;&#x2F;customizablecomputinglab.gitee.io&#x2F;2020&#x2F;08&#x2F;07&#x2F;class-STA&#x2F; 课程网站：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1if4y1p7Dq  参考阅读  建立时间和保持时间关系详解   0 目录  1 静态时序分析课程概述 1.1 数字芯片与FPGA设计流程 1）数字芯片设计流程 2）FP">
<meta property="og:type" content="article">
<meta property="og:title" content="静态时序分析">
<meta property="og:url" content="http://yoursite.com/202203181046/IC/%E7%90%86%E8%AE%BA/STAessay/ic/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="友人律的博客">
<meta property="og:description" content="静态时序分析 讲义下载：https:&#x2F;&#x2F;customizablecomputinglab.gitee.io&#x2F;2020&#x2F;08&#x2F;07&#x2F;class-STA&#x2F; 课程网站：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1if4y1p7Dq  参考阅读  建立时间和保持时间关系详解   0 目录  1 静态时序分析课程概述 1.1 数字芯片与FPGA设计流程 1）数字芯片设计流程 2）FP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905804.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905807.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905808.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905809.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905814.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905816.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905817.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905818.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905819.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905821.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905825.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905826.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905827.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905828.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905829.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905830.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905831.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905833.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905835.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905836.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905837.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905838.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905840.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905842.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905843.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905846.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905847.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905848.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905850.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905851.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905852.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905853.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905855.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905857.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905858.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905859.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905860.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905861.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905862.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905863.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905864.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905865.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905866.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905867.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905868.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905869.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905870.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905871.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905872.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905873.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905874.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905875.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905876.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905878.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905879.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905881.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905882.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905883.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905884.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905885.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905886.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905887.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905888.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905889.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905890.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905891.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905892.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905893.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905894.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905895.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905896.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905897.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905898.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905899.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905900.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905901.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905903.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905905.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905908.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905909.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905910.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905911.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905914.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905915.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905916.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905917.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905918.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905920.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905921.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905923.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905925.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905926.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905928.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905931.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905932.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905933.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905934.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905935.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905936.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905937.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905939.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905940.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905942.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905944.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905945.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905949.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905950.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905953.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905954.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905959.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905960.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905961.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905962.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905963.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905964.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905966.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905967.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905968.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905969.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/cs/202205012027202.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905970.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905971.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905972.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905973.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905974.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905975.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905976.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905977.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905978.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905979.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905980.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905981.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905983.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905984.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905985.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905986.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905987.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905988.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905989.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905990.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905991.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905992.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905993.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905994.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905995.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905996.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905997.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905998.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905999.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905001.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905002.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905003.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905004.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905005.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905006.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905008.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905010.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905011.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905012.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905017.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905018.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905020.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905023.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905025.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905027.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905028.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905029.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905030.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905031.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905032.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905034.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905036.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905038.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905042.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905044.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905047.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905048.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905049.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905050.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905051.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905057.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905060.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905061.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905062.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905063.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905064.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905065.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905067.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905068.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905069.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905070.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905071.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905072.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905073.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905074.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905075.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905076.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905078.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905079.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905080.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/cs/202205012028181.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905082.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905083.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905084.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905085.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905086.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905087.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905088.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905089.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905090.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905091.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905092.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905093.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905094.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905095.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905096.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905097.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905098.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905099.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905100.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905102.png">
<meta property="article:published_time" content="2022-03-18T02:46:00.000Z">
<meta property="article:modified_time" content="2022-05-01T14:05:13.798Z">
<meta property="article:author" content="友人律 | Guilin Chang">
<meta property="article:tag" content="IC">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="STA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905802.png">
  
  <title>静态时序分析 - 友人律的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/stackoverflow-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"eca4a4d34dadf0d4e282cc6ef2dc3de6","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start -->
<link defer rel="stylesheet" href="/css/article_para.css" />
<div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友人律的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%80%9A%E7%9F%A5/">
                <i class="iconfont icon-link-fill"></i>
                通知
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                <i class="iconfont icon-link-fill"></i>
                项目与设计
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
                <i class="iconfont icon-link-fill"></i>
                开发工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/CS/">
                <i class="iconfont icon-link-fill"></i>
                CS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/IC/">
                <i class="iconfont icon-link-fill"></i>
                IC
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner_img/anime/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="静态时序分析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-18 10:46" pubdate>
        2022年3月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      58k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      181 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">静态时序分析</h1>
            
            <div class="markdown-body">
              <h1><span id="静态时序分析">静态时序分析</span></h1><ul>
<li>讲义下载：<a target="_blank" rel="noopener" href="https://customizablecomputinglab.gitee.io/2020/08/07/class-STA/">https://customizablecomputinglab.gitee.io/2020/08/07/class-STA/</a></li>
<li>课程网站：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y1p7Dq">https://www.bilibili.com/video/BV1if4y1p7Dq</a></li>
</ul>
<p>参考阅读</p>
<ul>
<li><a href="/page/建立时间和保持时间关系详解 - Lilto - 博客园.html">建立时间和保持时间关系详解 </a></li>
</ul>
<h1><span id="0-目录">0 目录</span></h1><!-- toc -->
<ul>
<li><a href="#1-静态时序分析课程概述">1 静态时序分析课程概述</a><ul>
<li><a href="#11-数字芯片与fpga设计流程">1.1 数字芯片与FPGA设计流程</a><ul>
<li><a href="#1数字芯片设计流程">1）数字芯片设计流程</a></li>
<li><a href="#2fpga设计流程">2）FPGA设计流程</a></li>
</ul>
</li>
<li><a href="#12-静态时序分析概述">1.2 静态时序分析概述</a><ul>
<li><a href="#1核心两点">1）核心两点</a></li>
<li><a href="#2静态时序分析所在阶段">2）静态时序分析所在阶段</a></li>
<li><a href="#3功能验证与sta的大体区别">3）功能验证与STA的大体区别</a></li>
</ul>
</li>
<li><a href="#13-课程主要内容">1.3 课程主要内容</a></li>
</ul>
</li>
<li><a href="#2-tcl">2 TCL</a><ul>
<li><a href="#21-概述">2.1 概述</a><ul>
<li><a href="#1tcl">1）TCL</a></li>
<li><a href="#2如何使用tcl">2）如何使用tcl</a></li>
</ul>
</li>
<li><a href="#22-置换机制">2.2 置换机制</a><ul>
<li><a href="#1变量置换">1）变量置换</a></li>
<li><a href="#2命令置换">2）命令置换</a></li>
<li><a href="#3反斜杠置换">3）反斜杠置换</a></li>
<li><a href="#4其他符号">4）其他符号</a></li>
</ul>
</li>
<li><a href="#23-变量-数组-列表">2.3 变量、数组、列表</a><ul>
<li><a href="#1变量">1）变量</a></li>
<li><a href="#2数组">2）数组</a></li>
<li><a href="#3列表重要的数据结构">3）列表（重要的数据结构）</a></li>
</ul>
</li>
<li><a href="#24-运算">2.4 运算</a><ul>
<li><a href="#1数学运算指令-expr">1）数学运算指令-expr</a></li>
</ul>
</li>
<li><a href="#25-控制流">2.5 控制流</a><ul>
<li><a href="#1控制流-if">1）控制流-if</a></li>
<li><a href="#2循环指令-foreach">2）循环指令-foreach</a></li>
<li><a href="#3循环控制指令-break">3）循环控制指令-break</a></li>
<li><a href="#4循环控制指令-continue">4）循环控制指令-continue</a></li>
<li><a href="#5循环控制指令-while">5）循环控制指令-while</a></li>
<li><a href="#6循环控制指令-for">6）循环控制指令-for</a></li>
</ul>
</li>
<li><a href="#26-过程函数">2.6 过程函数</a><ul>
<li><a href="#1过程函数-proc">1）过程函数-proc</a></li>
<li><a href="#2全局变量与局部变量">2）全局变量与局部变量</a></li>
</ul>
</li>
<li><a href="#26-正则匹配">2.6 正则匹配</a><ul>
<li><a href="#1正则匹配">1）正则匹配</a></li>
<li><a href="#2正则匹配-量词">2）正则匹配-量词</a></li>
<li><a href="#3正则匹配-锚位">3）正则匹配-锚位</a></li>
<li><a href="#4正则匹配-其他字符">4）正则匹配-其他字符</a></li>
<li><a href="#5正则匹配指令-regexp">5）正则匹配指令-regexp</a></li>
<li><a href="#6捕获变量">6）捕获变量</a></li>
</ul>
</li>
<li><a href="#27-文本处理">2.7 文本处理</a></li>
<li><a href="#28-参考书">2.8 参考书</a></li>
</ul>
</li>
<li><a href="#3-synopsys-tcl语言入门">3 Synopsys TCL语言入门</a><ul>
<li><a href="#31-tcl的应用">3.1 TCL的应用</a><ul>
<li><a href="#1overview">1）Overview</a></li>
<li><a href="#2why-synopysy-tcl">2）Why Synopysy TCL</a></li>
</ul>
</li>
<li><a href="#32-tcl在eda工具中的扩展与应用">3.2 TCL在EDA工具中的扩展与应用</a><ul>
<li><a href="#1tcl的应用design-object">1）TCL的应用：Design Object</a></li>
<li><a href="#2综合软件当中tcl的常见指令synopsystcl扩展的指令">2）综合软件当中TCL的常见指令（SynopsysTCL扩展的指令）</a><ul>
<li><a href="#1获取对象">（1）获取对象</a></li>
<li><a href="#2数据类型-object-对象-与其属性">（2）“数据类型： object （对象） ”与其“属性”</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#33-使用tcl控制eda工具流程">3.3 使用TCL控制EDA工具流程</a><ul>
<li><a href="#1使用tcl语言设计dc的自动化flow">1）使用TCL语言设计DC的自动化Flow</a></li>
<li><a href="#2重要模块分析">2）重要模块分析</a></li>
</ul>
</li>
<li><a href="#34-参考书">3.4 参考书</a></li>
</ul>
</li>
<li><a href="#4-sta基本概念">4 STA基本概念</a><ul>
<li><a href="#41-primertime">4.1 PrimerTime</a></li>
<li><a href="#42-sta-concepts">4.2 STA Concepts</a><ul>
<li><a href="#1timng-arc时序图">1）Timng Arc时序图</a></li>
<li><a href="#2cell-delay">2）Cell delay</a></li>
<li><a href="#3setup-time-and-hold-time">3）Setup time and hold time</a></li>
<li><a href="#4timg-path时序路径">4）Timg path时序路径</a></li>
<li><a href="#5clock-domains时钟域">5）Clock Domains时钟域</a></li>
<li><a href="#6operating-condition操作条件">6）Operating Condition操作条件</a></li>
</ul>
</li>
<li><a href="#43-参考书">4.3 参考书</a></li>
</ul>
</li>
<li><a href="#5-标准单元库">5 标准单元库</a><ul>
<li><a href="#51-timing-lib时序库">5.1 Timing lib时序库</a><ul>
<li><a href="#库的基本概念">库的基本概念</a></li>
</ul>
</li>
<li><a href="#52-non-linear-delay-model非线性的延迟模型">5.2 Non-Linear Delay Model非线性的延迟模型</a><ul>
<li><a href="#1反相器实例分析">1）<strong>反相器实例分析：</strong></a></li>
<li><a href="#2一种通用的线性延迟模型公式">2）一种通用的线性延迟模型公式：</a></li>
<li><a href="#3nldm非线性延迟模型">3）NLDM非线性延迟模型</a></li>
</ul>
</li>
<li><a href="#53-threshold-specifications-and-slew-derating使用缩放确定查找表的表项">5.3 Threshold Specifications and Slew Derating（使用缩放确定查找表的表项）</a></li>
<li><a href="#54-timing-model时序模型">5.4 Timing Model时序模型</a><ul>
<li><a href="#1两输入与门示例">1）两输入与门示例</a></li>
<li><a href="#2时序的cell示例">2）时序的Cell示例</a></li>
</ul>
</li>
<li><a href="#55-线延迟模型">5.5 线延迟模型</a></li>
</ul>
</li>
<li><a href="#6-sta环境配置重要">6 STA环境配置（重要）</a><ul>
<li><a href="#61-sta-env">6.1 STA Env</a></li>
<li><a href="#62-specifying-clocks时钟约束重要">6.2 Specifying Clocks时钟约束（重要）</a><ul>
<li><a href="#1specifying-clocks-时钟约束的形状">1）Specifying Clocks | 时钟约束的形状</a></li>
<li><a href="#2specifying-clocks-clock-uncertainty">2）Specifying Clocks-Clock Uncertainty</a></li>
<li><a href="#3时钟延迟">3）时钟延迟</a></li>
</ul>
</li>
<li><a href="#63-generated-clock-生成时钟">6.3 Generated Clock 生成时钟</a></li>
<li><a href="#64-constraining-input-paths-output-path">6.4 Constraining Input Paths &amp; Output Path</a><ul>
<li><a href="#1示意图">1）示意图</a></li>
<li><a href="#四种时钟约束路径总结">四种时钟约束路径总结</a></li>
<li><a href="#timing-path-groups路径组">Timing Path Groups路径组</a></li>
<li><a href="#额外属性在指定端口时的额外属性">额外属性（在指定端口时的额外属性）</a><ul>
<li><a href="#input">input</a></li>
<li><a href="#output">output</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#65-drcdesign-rule-checks">6.5 DRC(Design Rule Checks)</a></li>
<li><a href="#66-virtual-clock-虚拟时钟">6.6 Virtual Clock 虚拟时钟</a></li>
<li><a href="#67-refining-the-timing-analysis">6.7 Refining the Timing Analysis</a><ul>
<li><a href="#1set_case_analysis">1）set_case_analysis</a></li>
<li><a href="#2set_disable_timing">2）set_disable_timing</a></li>
<li><a href="#3set_false_path-伪路径">3）set_false_path 伪路径</a></li>
<li><a href="#4set_multicycle_path-多周期">4）set_multicycle_path 多周期</a></li>
</ul>
</li>
<li><a href="#68-补充">6.8 补充</a></li>
</ul>
</li>
<li><a href="#7-timing-verification一-时序检查">7 Timing Verification(一) 时序检查</a><ul>
<li><a href="#71-建立时间的检查">7.1 建立时间的检查</a><ul>
<li><a href="#1如何分析setup-time是否满足要求">1）如何分析setup time是否满足要求</a></li>
<li><a href="#2timing-report讲解1reg2regff2ff">2）timing report讲解①（reg2reg/ff2ff）</a></li>
<li><a href="#3timing-report讲解2input-port-to-register">3）timing report讲解②（input port to register）</a></li>
<li><a href="#4timing-report讲解3register-to-output-port">4）timing report讲解③（register to output port）</a></li>
<li><a href="#5timing-report讲解4input-to-output-path">5）timing report讲解④（input to output path）</a></li>
</ul>
</li>
<li><a href="#72-保持时间的检查">7.2 保持时间的检查</a><ul>
<li><a href="#1如何分析holdup-time是否满足要求">1）如何分析holdup time是否满足要求</a></li>
<li><a href="#2timing-report讲解1reg2regff2ff-1">2）timing report讲解①（reg2reg/ff2ff）</a></li>
<li><a href="#3timing-report讲解2input-port-to-register-1">3）timing report讲解②（input port to register）</a></li>
<li><a href="#4timing-report讲解3register-to-output-port-1">4）timing report讲解③（register to output port）</a></li>
<li><a href="#5timing-report讲解4input-to-output-path-1">5）timing report讲解④（input to output path）</a></li>
</ul>
</li>
<li><a href="#73-总结">7.3 总结</a></li>
</ul>
</li>
<li><a href="#8-timing-verification二-多周期半周期伪路径检查">8 Timing Verification(二) 多周期半周期伪路径检查</a><ul>
<li><a href="#81-multicycle-paths-多周期路径">8.1 Multicycle Paths 多周期路径</a></li>
<li><a href="#82-half-cycle-paths半周期">8.2 Half-Cycle Paths半周期</a></li>
<li><a href="#83-false-paths伪路径">8.3 False Paths伪路径</a></li>
</ul>
</li>
<li><a href="#9-timing-verification三-多时钟域多时钟分析">9 Timing Verification(三) 多时钟域，多时钟分析</a><ul>
<li><a href="#91-timing-across-clock-domains多时钟域分析">9.1 Timing across Clock Domains多时钟域分析</a><ul>
<li><a href="#1slow-to-fast-clock-domains">1）slow to fast clock domains</a></li>
<li><a href="#2fast-to-low-clock-domains">2）fast to low clock domains</a></li>
<li><a href="#3总结">3）总结</a></li>
</ul>
</li>
<li><a href="#92-multiple-clocks多时钟">9.2 Multiple Clocks多时钟</a><ul>
<li><a href="#1整数倍时钟">1）整数倍时钟</a></li>
<li><a href="#2非整数倍时钟">2）非整数倍时钟</a></li>
<li><a href="#3phase-shifted-相位移动频率相同">3）Phase Shifted 相位移动（频率相同）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-robust-verification鲁棒性检查">10 Robust Verification鲁棒性检查</a><ul>
<li><a href="#101-on-chip-variations">10.1 On-Chip Variations</a></li>
<li><a href="#102-ocv设置setup">10.2 OCV设置(setup)</a></li>
<li><a href="#103-cppcommon-path-pessimism问题">10.3 <strong>CPP(Common Path Pessimism)问题</strong></a></li>
<li><a href="#104-更严谨的设置倍数提高ocv时的速度">10.4 更严谨的设置倍数，提高OCV时的速度</a></li>
<li><a href="#105-ocv设置hold">10.5 OCV设置(hold)</a><ul>
<li><a href="#1ocv">1）OCV</a></li>
<li><a href="#2更严谨的设置倍数">2）更严谨的设置倍数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-time-borrowingcycle-stealing">11 Time Borrowing/Cycle Stealing</a><ul>
<li><a href="#111-回顾">11.1 回顾</a></li>
<li><a href="#112-time-borrowing">11.2 Time Borrowing</a><ul>
<li><a href="#1概念">1）概念</a></li>
<li><a href="#2示例分析">2）示例分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-data-to-data-checks">12 Data to Data Checks</a><ul>
<li><a href="#121-概述">12.1 概述</a></li>
<li><a href="#122-如何实现data-to-data-checks">12.2 如何实现data to data checks</a></li>
<li><a href="#123-data-to-data-hold-check">12.3 data to data hold check</a></li>
<li><a href="#124-交换2pins">12.4 交换2pins</a></li>
<li><a href="#125-对无变化数据的检查">12.5 对无变化数据的检查</a></li>
</ul>
</li>
<li><a href="#13-习题讲解">13 习题讲解</a></li>
</ul>
<!-- tocstop -->
<h1><span id="1-静态时序分析课程概述">1 静态时序分析课程概述</span></h1><ul>
<li>数字芯片与FPGA设计流程</li>
<li>静态时序分析概述</li>
<li>课程内容规划</li>
</ul>
<h2><span id="11-数字芯片与fpga设计流程">1.1 数字芯片与FPGA设计流程</span></h2><h3><span id="1数字芯片设计流程">1）数字芯片设计流程</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905802.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>数字前端</strong><ul>
<li><strong>功能验证</strong>（前仿真）：逻辑功能的仿真</li>
<li>1~4步（功能验证）和实际的工艺库没有强依赖关系</li>
<li>逻辑综合、优化：加入工艺库</li>
<li>一致性验证：netlist和rtl design进行比较</li>
</ul>
</li>
<li><strong>数字后端</strong><ul>
<li>DRC/LVS：生成版图</li>
<li><strong>功能验证</strong>（后仿真）：时序仿真</li>
</ul>
</li>
</ul>
<h3><span id="2fpga设计流程">2）FPGA设计流程</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905803.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>综合</strong><ul>
<li>综合后得到netlist，此netlist未在fpga上规划坐标</li>
</ul>
</li>
<li><strong>实现</strong><ul>
<li>布局</li>
<li>布线</li>
</ul>
</li>
</ul>
<p><strong>fpga设计也要求加入约束完成静态时序分析</strong></p>
<h2><span id="12-静态时序分析概述">1.2 静态时序分析概述</span></h2><h3><span id="1核心两点">1）核心两点</span></h3><p><strong>Setup Time</strong> ：<strong>采样的D触发器的时钟上升沿之前</strong>，数据稳定下来的时间（保证采样稳定）</p>
<blockquote>
<p>Setup Time 建立时间 -The length of time that data must stabilize before the clock transition.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905804.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Hold Time</strong>：<strong>采样的D触发器的时钟上升沿之后</strong>，数据依然保持稳定的时间（如果不稳定，造成数据传输错误）</p>
<blockquote>
<p>Hold Time保持时间：The length of time that data must remain stable at the input pin after the active clock transition.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905805.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong><mark>静态时序分析的内容：</mark></strong></p>
<p>​    <strong>静态时序分析最核心的两点就是检查setup和hold，来确认每一个触发器的工作是否能正确采集数据</strong></p>
<ul>
<li>对于同步电路需满足每一个触发器的setup和hold<ul>
<li>补充：大部分EDA</li>
</ul>
</li>
<li>对于异步电路不一样，其指标不同<ul>
<li>补充：异步电路单独拿出来处理，通常需要单独重点处理</li>
</ul>
</li>
<li>实际上当下soc复杂，可以看作<strong>全局异步局部同步</strong>的电路<ul>
<li>局部模块中使用STA的方法分析setup\hold</li>
<li>整体时考虑每个时钟域下，数据传递的样态、怎么降低样态出现的概率</li>
</ul>
</li>
</ul>
<h3><span id="2静态时序分析所在阶段">2）静态时序分析所在阶段</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905806.png" srcset="/img/loading.gif" lazyload alt></p>
<p>Synthesis、Scan、Place、ClockTree、Route，每一个区域中的STA模型略有区别</p>
<h3><span id="3功能验证与sta的大体区别">3）功能验证与STA的大体区别</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905807.png" srcset="/img/loading.gif" lazyload alt></p>
<p>保持功能正常的两种手段：simulation、sta</p>
<ul>
<li><p><strong>simulation：</strong>不同的生成各种测试向量确保功能覆盖率</p>
<ul>
<li>仿真太慢，很多公司使用<strong>emulator</strong>来加速</li>
</ul>
</li>
<li><p><strong>sta：</strong>确认每一个触发器的setup,hold是否能正确地采样，不关心功能，不需要设计测试向量</p>
<ul>
<li><strong>优点：</strong>相对简单，不需要穷举性的测试向量；耗时短，快速</li>
<li><strong>可能的场景：</strong>当没有把握测试到所有功能，可以使用sta进行补充</li>
</ul>
</li>
</ul>
<h2><span id="13-课程主要内容">1.3 课程主要内容</span></h2><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905808.png" srcset="/img/loading.gif" lazyload alt></p>
<p>STA工具用的最多的：synopsys的Pertime（PT），每个EDA公司都有自己的静态时序分析工具，每个功能处(数字综合、DFT、布局布线）其实也都嵌入了PT引擎</p>
<p><strong>参考图书：</strong></p>
<p>①《Static Timing Analysis for Nanometer Designs:A Practical Approach》J.4Bhasker，Rakesh Chadha.Springer Science Business Media，LLC 2009.</p>
<ul>
<li>非常经典，课程教材，希望精读，专讲静态时序机理</li>
</ul>
<p>②《综合与时序分析的设计约束：Synopsys设计约束（SDC）实用指南》[美]斯里达尔·甘加达兰（Sridhar Gangadharan），[印度]桑杰·丘里瓦拉（Sanjay，Chur著，韩德强张丽艳王宗侠等译译.出版社：机械工业出版社出版时间：2016-06-01.</p>
<ul>
<li>感兴趣可以看</li>
</ul>
<p>③《集成电路静态时序分析与建模》.刘峰，机械工业出版社.出版时间：2016-07-01.</p>
<ul>
<li>国内写的，tcl脚本讲的好，可以补充12本的知识</li>
</ul>
<p>④《Using Tcl with Synopsys Tools.Version B-2008.09》March 2011.Synopsys.</p>
<ul>
<li>Synopsys的tcl手册</li>
</ul>
<h1><span id="2-tcl">2 TCL</span></h1><ul>
<li>概述</li>
<li>变量、数组、列表</li>
<li>控制流</li>
<li>过程函数</li>
<li>正则匹配（重要）</li>
<li>文本处理</li>
</ul>
<h2><span id="21-概述">2.1 概述</span></h2><h3><span id="1tcl">1）TCL</span></h3><p>TCL在EDA工具中非常重要</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905809.png" srcset="/img/loading.gif" lazyload alt></p>
<p>不同语言的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905814.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>shell原生兼容性较好</li>
<li>tcl整个eda工具的标准语言</li>
<li>per更像转接头，eda工具无法原生支持，使用tcl操作eda工具，外层使用perl处理文本控制字符串</li>
<li>python近些年用的多一些</li>
</ul>
<h3><span id="2如何使用tcl">2）如何使用tcl</span></h3><p>Linux系统下</p>
<ul>
<li>输入<code>tclsh</code></li>
<li>在文本第一行<code>#！/user/bin/tclsh</code>（TCL的安装路径）</li>
</ul>
<p>Windows系统下</p>
<ul>
<li>安装active tcl并双击wish.exe</li>
</ul>
<h2><span id="22-置换机制">2.2 置换机制</span></h2><p><strong>TCL解释器运用规则把命令分成一个个独立的单词，同时进行必要的置换</strong></p>
<p>TCL置换分为以下三类：</p>
<ul>
<li>变量置换$</li>
<li>命令置换[]</li>
<li>反斜杠置换\<ul>
<li>C语言常用</li>
</ul>
</li>
</ul>
<h3><span id="1变量置换">1）变量置换</span></h3><p>用<strong>$</strong>表示变量置换</p>
<ul>
<li>TCL解释器会将认为<strong>$</strong>后面为变量名，将变量置换成它的值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905815.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2命令置换">2）命令置换</span></h3><p>用<strong>[]</strong>表示命令置换</p>
<ul>
<li><strong>[]</strong>内是<strong>一个独立的TCL语句</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905816.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3反斜杠置换">3）反斜杠置换</span></h3><p>用<strong>\</strong>表示反斜杠置换</p>
<ul>
<li>换行符、空格、[、$等被TCL解释器当作特殊符号对待的字符，加上反斜杠后变成普通字符</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905817.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="4其他符号">4）其他符号</span></h3><ul>
<li><p><strong>双引号””</strong> TCL解释器对双引号中$和[]符号会<strong>进行变量置换和命令置换</strong></p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905818.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li><p><strong>花括号{}</strong> 花括号中所有特殊字符都将成为<strong>普通字符</strong>，TCL解释器不会对其作特殊处理。</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905819.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li><p><strong>#</strong>表示注释</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905820.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="23-变量-数组-列表">2.3 变量、数组、列表</span></h2><h3><span id="1变量">1）变量</span></h3><ul>
<li><p>定义：set 变量名 变量值 </p>
</li>
<li><p>取值：$变量名</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905821.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>例题：假设我们想打印变量varible，后面跟一个”_1”，会发生什么呢？  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905822.png" srcset="/img/loading.gif" lazyload alt></p>
<blockquote>
<p>直接写a_1会造成引用</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905823.png" srcset="/img/loading.gif" lazyload alt></p>
<blockquote>
<p>使用{}置换做限定</p>
</blockquote>
<h3><span id="2数组">2）数组</span></h3><ul>
<li><p>数组： TCL中数组可以存储很多值，通过元素名来进行检索。类似于某件事物（数组名）几种不同属性（元素名），每一种属性有其独立的值</p>
</li>
<li><p>定义： set 数组名（元素名） 值  </p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905824.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>取值： $数组名（元素名）  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905825.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用array指令获取数组信息  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905826.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3列表重要的数据结构">3）列表（重要的数据结构）</span></h3><ul>
<li>列表是标量的有序集合。</li>
<li>定义 set 列表名 {元素1 元素2 元素3……}</li>
<li>取值 $列表名  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905827.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>TCL中有一系列十分方便的列表操作命令</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905828.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><p>列表指令-concat</p>
<ul>
<li>语法格式 ： concat 列表1 列表2</li>
<li>功能： 将列表1和列表2合并 （设计中很常用，比如合并两个时钟组放在一起）</li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905829.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li><p>列表指令-llength</p>
<ul>
<li><p>语法格式 ： llength 列表  </p>
</li>
<li><p>功能：返回列表中的元素个数  </p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905830.png" srcset="/img/loading.gif" lazyload alt></li>
<li>例题： list1为{bufx1 bufx2 bufx4}，那么 llength [concat $list1 $list1] 会得到多少呢？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905831.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>列表指令-lindex<ul>
<li>语法格式 ： lindex 列表 n  </li>
<li>返回列表中第n个元素（从0开始计数）  </li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905832.png" srcset="/img/loading.gif" lazyload alt></li>
<li>如何得到列表list1 {a b c d e f}的最后一个元素？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905833.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
<li><p>列表指令-lappend  </p>
<ul>
<li>语法格式 ： lappend 列表 新元素</li>
<li>功能： 列表末尾加入新元素  </li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905834.png" srcset="/img/loading.gif" lazyload alt></li>
<li>例题：如果我们lappend一个列表会怎么样？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905835.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li>如果我们想得到4 用什么样的命令？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905836.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
<li><p>列表指令-lsort  </p>
<ul>
<li>语法格式 ： lsort 开关 列表</li>
<li>功能： 将列表按照一定规则排序</li>
<li>开关： 缺省时默认按照ASCII码进行排序。<ul>
<li>–real 按照浮点数值大小排序</li>
<li>-unique唯一化，删除重复元素  </li>
</ul>
</li>
<li>按照ASICC码排序  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905837.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li>按照数字大小排序  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905838.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li>唯一化<ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905839.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li>例题：如何得到列表list1 {0 1.2 -4 3 5}中的最小值？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905840.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="24-运算">2.4 运算</span></h2><p>数学运算：<code>+,-,*,/</code></p>
<p>逻辑运算：<code>&lt;=,&gt;=,==,!=</code></p>
<h3><span id="1数学运算指令-expr">1）数学运算指令-expr</span></h3><ul>
<li>语法格式 ： expr 运算表达式</li>
<li>功能： 将运算表达式求值  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905841.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>例题：我们在TCL中经常会遇到下面的现象  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905842.png" srcset="/img/loading.gif" lazyload alt></li>
<li>其原因是表达式5/2中5和2都是整数型参数， 默认运算结果也是整数型。如果想要进行浮点运算， 只要将其中任意一个数值， 写成浮点形式（有小数点） 即可  </li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905843.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
<h2><span id="25-控制流">2.5 控制流</span></h2><h3><span id="1控制流-if">1）控制流-if</span></h3><ul>
<li>语法格式：<strong>注意括号一定要在一行里面，不能在下一行</strong></li>
<li>注意，下例中脚本语句的’{‘一定要写在上一行，因为如果不这样， TCL 解释<br>器会认为if命令在换行符处已结束，下一行会被当成新的命令，从而导致错误  </li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span> &#123;判断条件&#125; &#123; #括号只能在这行<br>脚本语句<br>&#125; elseif &#123;判断条件&#125; &#123; <br>脚本语句<br>&#125; else &#123;<br>脚本语句<br>&#125;<br><br><span class="hljs-keyword">if</span> &#123;判断条件&#125; <br>&#123; #括号在这里是错误的<br>脚本语句<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905844.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>例题：我们如何判断一个列表{0 1 2 3 4}的长度是大于3，还是等3，还是小于3？  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905845.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2循环指令-foreach">2）循环指令-foreach</span></h3><ul>
<li><p>语法格式 ： foreach 变量 列表 循环主体</p>
<ul>
<li>与C语言for不一样，在tcl里面很强大</li>
</ul>
</li>
<li><p>功能：从第0个元素开始， 每次按顺序取得列表的一个元素， 将其赋值给变量， 然后执行循环主体一次， 直到列表最后一个元素  </p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905846.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905847.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3循环控制指令-break">3）循环控制指令-break</span></h3><ul>
<li>语法格式 ： break</li>
<li>功能: 结束整个循环过程，并从循环中跳出 </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905848.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="4循环控制指令-continue">4）循环控制指令-continue</span></h3><ul>
<li>语法格式 ： continue</li>
<li>功能: 仅结束本次循环  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905849.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="5循环控制指令-while">5）循环控制指令-while</span></h3><ul>
<li>语法格式 ： while 判断语句 循环主体</li>
<li>功能: 如果判断语句成立（返回值非0），就运行脚本，直到不满足判断条件停止循环，此时while命令中断并返回一个空字符串。 </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905850.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="6循环控制指令-for">6）循环控制指令-for</span></h3><ul>
<li><p>语法格式 ：<br>for 参数初始化 判断语句 重新初始化参数 循环主体</p>
</li>
<li><p>功能: 如果判断语句返回值非0就进入循环，执行循环主体后，再重新初始化参数。然后再次进行判断，直到判断语句返回值为0，循环结束。  </p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905851.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="26-过程函数">2.6 过程函数</span></h2><h3><span id="1过程函数-proc">1）过程函数-proc</span></h3><ul>
<li>语法格式 ： proc 函数名 参数列表 函数主体</li>
<li>功能: 类似于C语言中的函数。即用户自定义的功能，方便多次调用。  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905852.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2全局变量与局部变量">2）全局变量与局部变量</span></h3><ul>
<li>全局变量：在所有过程之外定义的变量。</li>
<li>局部变量：对于在过程中定义的变量，因为它们只能在过程中被访问，并且当过程退出时会被自动删除。</li>
<li><strong>指令global</strong>，可以在过程内部引用全部变量  </li>
</ul>
<p>使用global引用</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905853.png" srcset="/img/loading.gif" lazyload alt></p>
<p>不使用gloabl引用，导致出错</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905854.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="26-正则匹配">2.6 正则匹配</span></h2><h3><span id="1正则匹配">1）正则匹配</span></h3><ul>
<li><p>定义：正则表达式是一种特殊的字符串模式，<strong>用来去匹配符合规则的字符串</strong>。  </p>
</li>
<li><p>正则表达式的\w，用来匹配一个字母、数字、下划线</p>
</li>
<li><p>正则表达式的\d ,用来匹配一个数字  </p>
</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">字符串 abc123<br>正则表达式 \w\w\w\d\d\d 正确<br>正则表达式 \d\w\w\d\d\d 错误<br></code></pre></div></td></tr></table></figure>
<h3><span id="2正则匹配-量词">2）正则匹配-量词</span></h3><ul>
<li>\w\w\w\d\d\d这种写法过于繁琐，我们可以用代替重复的量词进行表示 ，在TCL中常用一下三种量词</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905855.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">字符串 abc123<br>正则表达式 \w+\d+ 或者 \w*\d*<br></code></pre></div></td></tr></table></figure>
<ul>
<li><em>和+的区别： </em>可以是零次， +一个至少是一次  </li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">字符串 abc123<br>正则表达式 \d*\w*\d* 正确<br>正则表达式 \d+\w+\d+ 错误<br></code></pre></div></td></tr></table></figure>
<ul>
<li>?表示零次或者一次匹配</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">正则表达式 \w?\w?\d\d\w\w\d\d<br>字符串 <span class="hljs-number">12</span>ab34<br>字符串 ab12ab34<br></code></pre></div></td></tr></table></figure>
<h3><span id="3正则匹配-锚位">3）正则匹配-锚位</span></h3><p>锚位，用来指示字符串当中的开头和结尾的位置，使我们能够匹配到正确的字符  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905856.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905857.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="4正则匹配-其他字符">4）正则匹配-其他字符</span></h3><ul>
<li>常用的其他字符还有<mark>\s</mark>和<mark>.</mark></li>
<li>\s表示空格 <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905858.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
<li>. 表示任意一个字符  <ul>
<li>我们不确定具体是什么字符是就可以用.表示。例如已知知字符串为”xxx空格xxx空格xxx”(x为未知字符)。用.+\s.+\s.+就可以匹配  </li>
</ul>
</li>
</ul>
<h3><span id="5正则匹配指令-regexp">5）正则匹配指令-regexp</span></h3><ul>
<li><p>语法格式 ： regexp? switches? exp string? matchVar? ?subMatchVar subMatchVar …?</p>
</li>
<li><p>功能: 在字符串中使用正则表达式匹配</p>
<ul>
<li>switches：<ul>
<li>-nocase将字符串中的大写都当成小写看待。</li>
</ul>
</li>
<li>exp 正则表达式</li>
<li>string 用来进行匹配的字符串</li>
<li>matchstring表示用正则表示式匹配的所有字符串</li>
<li>sub1表示正则表达式中的第一个子表达式匹配的字符串</li>
<li>sub2表示正则表达式中的第二个子表达式匹配的字符串  </li>
</ul>
</li>
<li><p>例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905859.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
</ul>
<h3><span id="6捕获变量">6）捕获变量</span></h3><ul>
<li>通过()可以捕获字符串<ul>
<li>例如如何将字符串“Snow is 30 years old”中<strong>30</strong>捕获出来？<ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905860.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
<li>一次捕获多个字符串(多加几个变量)<ul>
<li>例如如何将字符串“Snow is 30 years old”中<strong>Snow 和30一次捕获</strong>？  <ul>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905861.png" srcset="/img/loading.gif" lazyload alt></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="27-文本处理">2.7 文本处理</span></h2><p>用TCL处理文本在工作中十分常用，主要掌握以下三个指令：</p>
<ul>
<li>get</li>
<li>gets</li>
<li>close</li>
</ul>
<p>gets</p>
<ul>
<li>语法格式 gets fileId 变量名</li>
<li>功能 gets读fileId标识的文件的下一行，并把该行赋给变量，并返回该行的字符数（文件尾返回-1）</li>
</ul>
<p>open</p>
<ul>
<li>语法格式 open 文件 打开方式（打开方式 r表示读模式， w表示写模式。）</li>
<li>功能 打开文件</li>
</ul>
<p>close</p>
<ul>
<li>语法格式 close fileid</li>
<li>功能 关闭文件  </li>
</ul>
<p>例题： 整个读入文件过程 ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905862.png" srcset="/img/loading.gif" lazyload alt></p>
<p>例题：一个完整写入文件过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905863.png" srcset="/img/loading.gif" lazyload alt></p>
<p>例题：现有文本file.txt其内容如下。请写一TCL脚本求出所有Slack值之和</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905864.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用正则匹配Slack = -</li>
</ul>
<h2><span id="28-参考书">2.8 参考书</span></h2><ul>
<li>《Using Tcl with Synopsys Tools》. Version B-2008.09, March 2011. Synopsys.</li>
<li>《集成电路静态时序分析与建模》. 刘峰, 机械工业出版社.出版时间： 2016-07-01  </li>
</ul>
<h1><span id="3-synopsys-tcl语言入门">3 Synopsys TCL语言入门</span></h1><ul>
<li>TCL在EDA工具中的扩展与应用</li>
<li>使用TCL控制EDA工具流程</li>
</ul>
<h2><span id="31-tcl的应用">3.1 TCL的应用</span></h2><h3><span id="1overview">1）Overview</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905865.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><p>内建命令</p>
</li>
<li><p>应用命令</p>
</li>
<li><p>用户自定义命令</p>
</li>
</ul>
<h3><span id="2why-synopysy-tcl">2）Why Synopysy TCL</span></h3><p>数时钟</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905866.png" srcset="/img/loading.gif" lazyload alt></p>
<p>使用TCL更简单</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905867.png" srcset="/img/loading.gif" lazyload alt></p>
<p>SynopsysTCL扩展命令参考资料：</p>
<ul>
<li>Using Tcl with SynopsysTools</li>
<li>PrimeTime User Guide: Fundamentals:</li>
<li>PrimeTime User Guide: Advanced Timing Analysis </li>
</ul>
<h2><span id="32-tcl在eda工具中的扩展与应用">3.2 TCL在EDA工具中的扩展与应用</span></h2><h3><span id="1tcl的应用design-object">1）TCL的应用：Design Object</span></h3><p>通过对Design Object的分析，我们来了解和学习DC获取电路并进行解析的方法</p>
<ul>
<li>指令都在DC环境中输入，可以在GUI界面下方窗口，也可以在DC命令行</li>
<li>DC里面net是一种collection</li>
<li>ref与inst<ul>
<li>reference是module</li>
<li>inst是实例化的module</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905868.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2综合软件当中tcl的常见指令synopsystcl扩展的指令">2）综合软件当中TCL的常见指令（SynopsysTCL扩展的指令）</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905869.png" srcset="/img/loading.gif" lazyload alt="结构示例图"></p>
<h4><span id="1获取对象">（1）获取对象</span></h4><p><strong>获取port object</strong></p>
<ul>
<li>语法格式： get_ports portsName</li>
<li>指令功能：返回design中对应的ports object  </li>
<li><p>例-1：如何查看design当中有没有一个port叫做CLK？  </p>
<ul>
<li>Shell&gt; get_ports CLK<br>{CLK}</li>
</ul>
</li>
<li><p>例-2：我们想查看design当中有没有一个port叫做SPI？</p>
<ul>
<li>Shell&gt; get_ports SPI<br>No object Found!  </li>
</ul>
</li>
<li><p>例-3：我们想查看design当中所有的port （*可以通配任何字符）  </p>
<ul>
<li>Shell&gt; get_ports *<br>{A B C D CLK OUT[0] OUT[1]}</li>
</ul>
</li>
<li>例-4：假设我们有port名字叫 {CLKA CLKB OUTA OUTB INA INB}<br>如果我们想得到所有C开头的port 怎么做？<ul>
<li>Shell&gt; get_ports C*<br>{CLKA CLKB}</li>
</ul>
</li>
</ul>
<p><strong>获取cell object</strong></p>
<ul>
<li>语法格式： get_cells cellsName</li>
<li>指令功能：返回design中对应的cell的instance name object  </li>
<li>举例-1：我们想查看design当中有没有一个cell叫做U4？<ul>
<li>Shell&gt; get_cells U4<br>{U4}</li>
</ul>
</li>
<li>举例-2：我们想查看design当中所有的cell<ul>
<li>Shell&gt; get_cells *<br>{U1 U2 U3 U4}</li>
</ul>
</li>
<li>举例-3：我们想查看design当中以3为结尾的cells<ul>
<li>Shell&gt; get_cells *3<br>{U3}  </li>
</ul>
</li>
</ul>
<p><strong>获取net object</strong></p>
<ul>
<li>语法格式： get_nets netsName</li>
<li>指令功能：返回design中net的object</li>
<li>举例-1：查看design当中有没有一个net以INV开头？<ul>
<li>Shell&gt; get_nets INV*<br>{INV0 INV1}  </li>
</ul>
</li>
<li>举例-2：我们想查看design当中所有的nets<ul>
<li>Shell&gt; get_nets *<br>{A B C D CLK BUS0 BUS1 INV0 INV1 OUT[0] OUT[1]</li>
</ul>
</li>
<li>举例-3：我们想查看design当中有多少个net？<ul>
<li>方法1，<strong>TCL基本语法</strong>的写法：<br>Shell&gt; llength [get_object_name [get_nets *]]<br>11</li>
<li>方法2，使用<strong>DC命令</strong>sizeof_collection获取：<br>Shell&gt; sizeof_collection [get_nets *]<br>11</li>
<li>注意两条指令的区别噢！  </li>
</ul>
</li>
</ul>
<p><strong>获取pin object（引脚）</strong></p>
<ul>
<li>语法格式： get_pins pinsName</li>
<li>指令功能：返回design中pin的object  </li>
<li>举例-1：查看design当中有哪些pin的名字叫做Z?<ul>
<li>Shell&gt; get_pins */Z<br>{INV0/Z INV1/Z}</li>
</ul>
</li>
<li>举例-2：查看design当中有哪些pin的名字以Q开头?<ul>
<li>Shell&gt; get_pins */Q*<br>{ENCODER/Q0 ENCODER/Q1 REGFILE/Q[1] REGFILE/Q[0]}  </li>
</ul>
</li>
</ul>
<h4><span id="2数据类型-object-对象-与其属性">（2）“数据类型： object （对象） ”与其“属性”</span></h4><p><strong>object说明：</strong></p>
<ul>
<li>object是对于tcl脚本一个重要的扩展；</li>
<li>常见的对象有四种 cell, net, port, pin；</li>
<li>每种object有它的属性。</li>
<li>get_object_name </li>
</ul>
<p><strong>下面将介绍一些常见属性：</strong></p>
<ul>
<li>任何一个属性都可以用<strong>get_attribute</strong>得到，</li>
<li><strong>list_attribute –class * 可以得到所有object 的属性，</strong></li>
<li>部分属性可以用<strong>set_attribute来设置</strong>  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905870.png" srcset="/img/loading.gif" lazyload alt="示例结构图"></p>
<p><strong>Cell object</strong></p>
<ul>
<li>属性 <strong>ref_name</strong> : 用来保存其map到的reference cell名称</li>
<li>例题：后端中常用于获取cell的ref<ul>
<li>Shell&gt; get_attribute [get_cells –h U3] ref_name<br>{INV} </li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905871.png" srcset="/img/loading.gif" lazyload alt="指令作用对象示意图"></li>
</ul>
</li>
</ul>
<p><strong>Pin object</strong></p>
<ul>
<li>属性 <strong>owner_net</strong> : 用来保存<strong>与之相连的net的名称</strong><ul>
<li>Shell&gt; get_attribute [get_pins U2/A] owner_net<br>{BUS0}  </li>
<li><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905872.png" srcset="/img/loading.gif" lazyload alt="指令作用对象示意图"></li>
</ul>
</li>
</ul>
<p><strong>Port object</strong></p>
<ul>
<li><p>属性 <strong>direction</strong> : 用来保存port 的方向</p>
<ul>
<li><p>方法1<br>Shell&gt; get_attribute [get_ports A] direction<br>{in}</p>
</li>
<li><p>方法2，<strong>get_port OUT[i]</strong></p>
<p>Shell&gt; get_attribute [get_ports OUT[1]] direction<br>{out}</p>
</li>
</ul>
</li>
</ul>
<p><strong>Net object:</strong></p>
<ul>
<li>属性 <strong>full_name</strong> : 用来保存net的名称<ul>
<li>Shell&gt; get_attribute [get_nets INV0] full_name<br>{INV0}</li>
<li>Shell&gt; get_object_name [get_nets INV0]<br>{INV0}</li>
<li>一定需要通过[get_nets INV0]把net取出来<br>*Shell&gt; get_attribute INV0 full_name<br>Error: No attribute found</li>
</ul>
</li>
</ul>
<p><strong>扩展get_* -f：</strong></p>
<ul>
<li><strong>过滤属性</strong></li>
<li>get_<em> -f :<br>-f 这个option可以用来<em>*过滤</em></em>属性，以得到我们想要的object</li>
<li>例子-1：想得到所有方向是input的port<ul>
<li>Shell&gt; get_ports * –f “direction==in”<br>{A B C D CLK}</li>
</ul>
</li>
<li>例子-2：想得到所有方向是output的pin<ul>
<li>Shell&gt;get_pins * -f “direction ==out”<br>{U1/Q0 U1/Q1 U2/Z U3/Z REGFILE/Q[0] REGFILE/Q[1]}</li>
</ul>
</li>
<li>例子-3：想得到所有ref_name 是INV的 cell<ul>
<li>Shell&gt;get_cells * -f “ref_name == INV”<br>{U2 U3}  </li>
</ul>
</li>
</ul>
<p><strong>扩展最关键的option  -of：</strong></p>
<ul>
<li><strong>获取连接的对象</strong></li>
<li>get_<em> [object]-of:<br>-of 这个option可以用来得到与你指定<em>*object相连接的object</em></em></li>
<li>object的连接关系：<ul>
<li>—port object &lt;-&gt; net object<br>>get_nets –of [get_port A]<br>A</li>
<li>—net object &lt;-&gt; port object / pin object<br>> get_net –of [get_pin U2/A]<br>BUS0</li>
<li>—pin object &lt;-&gt; net object<br>> get_pin -of [get_net INV1]<br>U3/Z</li>
<li>—cell object &lt;-&gt; pin object<br>>get_pins –of [get_cell U4]<br>{U4/D0 U4/D1 REGFILE/Q1 REGFILE/Q2}  </li>
</ul>
</li>
</ul>
<p><strong>自定义扩展TCL指令练习</strong></p>
<ul>
<li>得到电路中的所有inverter</li>
<li>解答：<ul>
<li>（1） 直接使用Synopsys TCL指令： get_buffers -inverter</li>
<li>（2） 人工扩展TCL指令： get_inverters </li>
</ul>
</li>
</ul>
<p><strong>人工扩展TCL指令： get_inverters</strong> </p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">解题思路：<br>（<span class="hljs-number">1</span>）使用get_lib_cells 得到所有引脚总数为<span class="hljs-number">2</span>的cell<br><span class="hljs-keyword">set</span> lcells [filter_collection [get_lib_cells -quiet [get_attr <span class="hljs-variable">$lib</span> extended_name]/*] <span class="hljs-string">&quot;number_of_pins==2 &amp;&amp;</span><br><span class="hljs-string">base_name=~$&#123;pattern&#125;&quot;</span>]<br>（<span class="hljs-number">2</span>）使用foreach_in_collection，循环检测每一个cell。<br>（<span class="hljs-number">3</span>）对于每一个cell，使用-filter 得到输入引脚、输出引脚的全名，以及功能名称。<br><span class="hljs-keyword">set</span> opin [get_lib_pins -quiet -of_object <span class="hljs-variable">$&#123;lcell&#125;</span> -filter <span class="hljs-string">&quot;pin_direction==out&quot;</span>]<br><span class="hljs-keyword">set</span> ipin [get_lib_pins -quiet -of_object <span class="hljs-variable">$&#123;lcell&#125;</span> -filter <span class="hljs-string">&quot;pin_direction==in&quot;</span>]<br><span class="hljs-keyword">set</span> opin_name [get_attribute -quiet <span class="hljs-variable">$&#123;opin&#125;</span> base_name]<br><span class="hljs-keyword">set</span> ipin_name [get_attribute -quiet <span class="hljs-variable">$&#123;ipin&#125;</span> base_name]<br><span class="hljs-keyword">set</span> cell_func [get_attribute -quiet <span class="hljs-variable">$&#123;opin&#125;</span> function]<br>（<span class="hljs-number">4</span>）输入引脚和输出引脚数量都为<span class="hljs-number">1</span>，且功能为反相器，则就是我们想要的cell<br>（<span class="hljs-number">5</span>）循环执行第（<span class="hljs-number">1</span>）执行的步骤，最终可获得所有的反相器<br></code></pre></div></td></tr></table></figure>
<h2><span id="33-使用tcl控制eda工具流程">3.3 使用TCL控制EDA工具流程</span></h2><h3><span id="1使用tcl语言设计dc的自动化flow">1）使用TCL语言设计DC的自动化Flow</span></h3><p><strong>内容：</strong>讲述一个简单的、入门级的Synopsys DesignComplier自动化方案，供初学者参考，感兴趣的同学对该方案进行优化和升级  </p>
<p><strong>特点：</strong></p>
<ul>
<li>该过程无需人为操作，用户只需要输入一条shell启动指令就能完全自动化的完成整个综合过程。</li>
<li>具备普适性和可重用性。在综合不同的设计时，只需要修改参数配置文件中的环境变量，不需要修<br>改脚本  </li>
</ul>
<p><strong>思路：</strong>自动化电路综合平台只需用户将待综合的设计和库文件放入一个文件夹，修改与待综合设计对象有关的环境变量参数，在命令窗口唤醒DC的指令，即自动化地完成综合过程，并得到综合后的网表文件和所需的报告。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905873.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>运行流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905874.png" srcset="/img/loading.gif" lazyload alt></p>
<p>① 运行run.csh脚本，启动DC </p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment">#!/bin/csh -f</span><br>\rm -rf *.log *.svf alib* reports log work #清除之前的文档<br>mkdir reports work #新建文件夹<br>dc_shell-xg-t <span class="hljs-number">-32</span>bit -f ./top.tcl #启动Design Compiler并运行top.tcl<br></code></pre></div></td></tr></table></figure>
<ul>
<li>top.tcl就是我们之后要写的自动化运行的TCL脚本，负责进行345所有的工作</li>
</ul>
<p>② 建立reports与work两个文件夹。 </p>
<ul>
<li>reports文件夹用于存放生成的报告， </li>
<li>work文件夹用于存放该平台运行过程中生成的文档、脚本。</li>
</ul>
<p>③ 启动顶层脚本top.tcl文件；<br>④ top.tcl按先后顺序启动各个子脚本，最终生成script.tcl；</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905875.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>运行script.tcl之前全部都是DC自动的，主要目的是生成约束脚本script.tcl，最终DC读取script.tcl通过它完成综合，并根据script.tcl生成报告</li>
</ul>
<p>⑤ <strong>DC读取script.tcl中的约束，最终完成综合，并将所有报告写入reports文件夹中</strong>。  </p>
<p><strong>top.tcl脚本运行机制：生成DC所需要的约束文件.tcl，同意放进script.tcl来供DC去读取，所有流程自动</strong></p>
<ul>
<li>set_library.tcl：生成设定库文件和search path的约束</li>
<li>read_design.tcl：生成读入设计文件的约束<ul>
<li>主要对所有verilog生成readverilog约束，写道script.tcl里面</li>
</ul>
</li>
<li>create_clock.tcl：生成时钟源相关的约束<ul>
<li>这些约束也要生成到script.tcl里面</li>
</ul>
</li>
<li>set_rst.tcl：生成复位端口约束的约束</li>
<li>set_io.tcl：生成输入输出端口的约束</li>
<li>set_cons.tcl：生成保存门级网表、各种reprot文件的约束</li>
</ul>
<p><strong><mark>注意：</mark></strong></p>
<ul>
<li><strong>以上所有约束都自动生成，无需人为干预；</strong></li>
<li><strong>库文件、代码、时钟、复位、输入输出等均根据代码自动进行匹配，并生成相应的约束；</strong></li>
<li><strong>最终所有的约束都被写入script.tcl中，供DC读取，完成最终的逻辑综合过程。</strong>  </li>
<li>我们要做的就直接run就完事了，约束自动生成了，然后DC在跑</li>
</ul>
<h3><span id="2重要模块分析">2）重要模块分析</span></h3><p><strong>（1）重要的脚本子模块——代码读入约束生成</strong> </p>
<ul>
<li><strong>工作流程：</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905876.png" srcset="/img/loading.gif" lazyload alt="脚本运行流程"></p>
<p>① 设计文件通常使用verilog语言，所以扩展名通常为v，所以先将变量extension设为v；</p>
<p>② 调用filelist.tcl脚本， filelist.tcl脚本会将所有扩展名为v的文件的<strong>文件路径</strong>输出到一个名为v_list的文档</p>
<p>③ 打开v_list文档，根据文件的内容将读入设计文件的指令输出到script.tcl脚本。</p>
<ul>
<li><strong>源码：</strong></li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> extension v #设置扩展为.v，只要是.v都读取<br><span class="hljs-keyword">source</span> [<span class="hljs-keyword">file</span> <span class="hljs-keyword">join</span> <span class="hljs-variable">$::script_path</span> test/filelist.tcl] #调用filelist.tcl脚本<br><span class="hljs-keyword">set</span> des [<span class="hljs-keyword">open</span> [<span class="hljs-keyword">file</span> <span class="hljs-keyword">join</span> <span class="hljs-variable">$::script_path</span> test/work/v_list] r] #读取文件<br><span class="hljs-keyword">set</span> design [<span class="hljs-keyword">gets</span> <span class="hljs-variable">$des</span>] #打开v_list文档<br><span class="hljs-comment">#写约束</span><br><span class="hljs-keyword">for</span> &#123;&#125; &#123;<span class="hljs-variable">$design</span>!=<span class="hljs-string">&quot;&quot;</span>&#125; &#123;<span class="hljs-keyword">set</span> design [<span class="hljs-keyword">gets</span> <span class="hljs-variable">$des</span>]&#125; &#123;<br><span class="hljs-comment">#输出读入设计文件指令</span><br><span class="hljs-keyword">puts</span> <span class="hljs-variable">$script</span> [<span class="hljs-keyword">format</span> <span class="hljs-string">&quot;read_file -format verilog %s&quot;</span> <span class="hljs-variable">$design</span>] # DC中读verilog的指令<span class="hljs-string">&quot;read_file -format verilog</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">puts $script [format &quot;</span>current_design %s<span class="hljs-string">&quot; $top] #输出设置顶层设计指令</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）重要的脚本子模块——代码filelist生成模块filelist.tcl</strong> </p>
<ul>
<li><p><strong>功能：</strong><br>本模块用filelist.tcl脚本实现，遍历目标文件下的所有文件，并将扩展名（.v）符合要求的文件完整路径输出到指定的文档，最终形成DC读取verilog代码的约束，写入script.tcl中。  </p>
</li>
<li><p><strong>工作流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905877.png" srcset="/img/loading.gif" lazyload alt="脚本运行流程"></p>
</li>
</ul>
<p>① 将工作路径切换到指定的工作路径</p>
<p>② 判断当前目录下的文件扩展名是否与设置的变量extension一致，如果一致，就将该文件路径输出到指定的文件</p>
<p>③ 如果有文件夹，则递归调用本程序，直至结束。  </p>
<ul>
<li>源码</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">proc</span><span class="hljs-title"> FindFile</span> &#123; myDir result &#125; &#123;<br>    <span class="hljs-keyword">if</span> &#123;[<span class="hljs-keyword">catch</span> &#123;<span class="hljs-keyword">cd</span> <span class="hljs-variable">$myDir</span>&#125; err]&#125; &#123;<br>        <span class="hljs-keyword">puts</span> <span class="hljs-variable">$result</span> <span class="hljs-variable">$err</span><br>        <span class="hljs-keyword">return</span>&#125;<br>	<span class="hljs-keyword">foreach</span> myfile [<span class="hljs-keyword">glob</span> -nocomplain *] &#123;<br>    	<span class="hljs-keyword">cd</span> <span class="hljs-variable">$myDir</span> #切换到对应路径<br>    	<span class="hljs-keyword">if</span> &#123;[<span class="hljs-keyword">string</span> equal <span class="hljs-variable">$myfile</span> <span class="hljs-string">&quot;&quot;</span>]&#125; &#123;<br>    		<span class="hljs-keyword">return</span> &#125; #如果是空文件夹就返回<br>		<span class="hljs-keyword">set</span> fullfile [<span class="hljs-keyword">file</span> <span class="hljs-keyword">join</span> <span class="hljs-variable">$myDir</span> <span class="hljs-variable">$myfile</span>]<br>		<span class="hljs-keyword">if</span> &#123;[<span class="hljs-keyword">file</span> isdirectory <span class="hljs-variable">$myfile</span>]&#125; &#123;<br>			FindFile <span class="hljs-variable">$fullfile</span> <span class="hljs-variable">$result</span> #如果有下一级路径则递归调用本函数<br>		&#125; elseif &#123;[<span class="hljs-keyword">string</span> equal [<span class="hljs-keyword">file</span> extension <span class="hljs-variable">$fullfile</span>] [<span class="hljs-keyword">format</span> <span class="hljs-string">&quot;.%s&quot;</span> <span class="hljs-variable">$::extension</span>]]&#125; &#123; #判断扩展名是否与要求一致<br>		<span class="hljs-keyword">puts</span> <span class="hljs-variable">$result</span> <span class="hljs-variable">$fullfile</span>&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）重要的脚本子模块——时钟约束生成子模块</strong>  </p>
<ul>
<li>功能和流程：</li>
</ul>
<p>① 首先调用parameter.tcl脚本， 读取其中用户对时钟源指定的参数， 如时钟周期等；</p>
<p>② 调用find_clk.tcl脚本， 该脚本会将搜索顶层设计中的所有的clk端口， 并将所有搜索结果输出到一个名为clk_list的文档；</p>
<p>③ 打开clk_list文档， 将对时钟端口施加约束的指令输出到script.tcl脚本</p>
<p> <img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905878.png" srcset="/img/loading.gif" lazyload alt="3，4的结构"></p>
<p><strong>（4）重要的脚本子模块——匹配时钟端口子模块find_clk.tcl  </strong></p>
<ul>
<li><p>功能：<br>搜索代码中的所有的时钟端口，将结果到work文件夹下的clk_list文档  </p>
</li>
<li><p>工作流程：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905879.png" srcset="/img/loading.gif" lazyload alt="脚本运行流程"></p>
<p>① 打开v_list文档，在其中找到顶层设计的路径，并打开改设计文件；</p>
<p>② 利用正则表达式匹配其中的clk端口；</p>
<p>③ 并将匹配到的时钟端口的端口名输出到work文件夹下的clk_list文档</p>
<p><strong>（5）其余脚本工作机制</strong></p>
<ul>
<li>其余脚本工作机制类似。</li>
<li>最终，所有的约束都被写入了script.tcl中。script.tcl脚本完全由自动化电路综合平台生成并非人工编写；</li>
<li>在自动化电路综合平台运行后，由顶层脚本调用各子模块脚本生成该脚本。生成该脚本后，由顶层脚本调用该脚本，由此实现对设计的综合</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905880.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="34-参考书">3.4 参考书</span></h2><ul>
<li>《Using Tcl with Synopsys Tools》. Version B-2008.09, March 2011. Synopsys.</li>
<li>《集成电路静态时序分析与建模》. 刘峰, 机械工业出版社.出版时间： 2016-07-01  </li>
</ul>
<h1><span id="4-sta基本概念">4 STA基本概念</span></h1><ul>
<li>PrimeTime</li>
<li>STA Conceptse</li>
</ul>
<h2><span id="41-primertime">4.1 PrimerTime</span></h2><p>PT是synopsys提出的全芯片过程中做STA的一个工具，在逻辑综合和PR的整个流程都很重要的存在</p>
<ul>
<li>PrimeTime is a full-chip, gate-level static timing analysis tool that is an essential part of<br>the design and analysis flow for today’s large chip designs.</li>
<li>PrimeTime exhaustively validates the timing performance of a design by checking all<br>possible paths for timing violations, without using logic simulation or test vectors.</li>
<li>PrimeTime fits ideally into the Synopsys physical synthesis flow because it uses many of the same libraries, databases, and commands as other Synopsys tools such as Design Compiler. It can also operate as a standalone static timing analyzer in other design flows  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905881.png" srcset="/img/loading.gif" lazyload alt="PT关联的文件及其内容，各种阶段流程"></p>
<ul>
<li><p>PT基于门级</p>
</li>
<li><p>PT在逻辑综合阶段和PR(Place &amp; Route)阶段不一样，两种阶段的模型延迟精度不同，越往后时序分析模型越准确</p>
</li>
<li><p>静态时序中的库文件：</p>
<ul>
<li><p>Technology library：库文件</p>
</li>
<li><p>Timing models：时序模型</p>
</li>
</ul>
</li>
</ul>
<p>2）两种运行模式</p>
<ul>
<li><p>pt_shell  </p>
</li>
<li><p>the graphical user interface (GUI).  GUI中的命令行</p>
</li>
</ul>
<h2><span id="42-sta-concepts">4.2 STA Concepts</span></h2><h3><span id="1timng-arc时序图">1）Timng Arc时序图</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905882.png" srcset="/img/loading.gif" lazyload alt></p>
<p>STA中的Timng Arc描述两个节点延迟信息的数据</p>
<p>Timing Arc分为：</p>
<ul>
<li><p>连线延迟：单元输出端口和扇出网络负载之间的延迟信息</p>
</li>
<li><p>Cell delay单元延迟：单元输入端口和输出网络负载之间的延迟信息</p>
</li>
<li>完整的时序路径信息：连线延时+单元延时</li>
</ul>
<h3><span id="2cell-delay">2）Cell delay</span></h3><p>（1）Transition delay：信号翻转延迟</p>
<ul>
<li>分为两种：0—&gt;1或者1—&gt;0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905883.png" srcset="/img/loading.gif" lazyload alt></p>
<p>（2）Logic gate delay：Cell由输入端口到输出端口的延迟</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905884.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3setup-time-and-hold-time">3）Setup time and hold time</span></h3><p><strong>Setup time：</strong></p>
<ul>
<li>Setup time：A setup constraint specifies how much time is necessary for data to be available at the input of a sequential device <strong>before</strong> the clock edge that captures the data in the device  </li>
<li>This constraint enforces a <strong>maximum</strong> delay on the data path relative to the clock path. （通过建立时间限制整个电路的<strong>最大延迟值</strong>）</li>
<li>两种Path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905885.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Hold time：</strong></p>
<ul>
<li><p>A hold constraint specifies how much time is necessary for data to be stable at the input of a sequential device after the clock edge that captures the data in the device.</p>
</li>
<li><p>This constraint enforces a <strong>minimum</strong> delay on the data path relative to the clock path.（最小延迟）</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905886.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="4timg-path时序路径">4）Timg path时序路径</span></h3><ul>
<li>STA把电路划分为不同的时序路径，然后分析每一条路径上的st和ht是否符合要求的约束</li>
<li>每一条Time path包括起点和终点，一定要分清pin和port</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905887.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Time path startpoint有两种：</strong></p>
<ul>
<li>a <strong>clock pin</strong> of a sequential element, or possibly an <strong>input port</strong> of the design (because the input data can be launched from some external source).  </li>
<li>startpoint in below design：D_clk_pin , A_input_port</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905888.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Time path endpoint有两种：</strong></p>
<ul>
<li>a data <strong>input pin</strong> of a sequential element, or possibly <strong>an output port</strong> of the design (because the output data can be captured by some external sink).  </li>
<li>endpoint in below design：D_clk_pin , Z_output_port</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905889.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>上述Path1~4的分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905890.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>这种定义(time path , start ,begin)覆盖了每一条门级路径</li>
<li>任何路径都会被划分为4种（两种起点*两种重点=4种path），一定要分清pin和port：<ul>
<li>clk pin  -&gt; D</li>
<li>clk pin  -&gt; output port</li>
<li>input -&gt; D</li>
<li>input -&gt; output port</li>
</ul>
</li>
<li>diff between pin &amp; port：<ul>
<li>pin for cell</li>
<li>port for core</li>
</ul>
</li>
</ul>
<h3><span id="5clock-domains时钟域">5）Clock Domains时钟域</span></h3><p>如今大部分芯片都是全局异步、局部同步，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905891.png" srcset="/img/loading.gif" lazyload alt></p>
<p>DC/PT处理同步电路，对异步电路无能为力的。因此我们在做整体分析时：</p>
<ul>
<li>首先根据时钟域区分哪些是同步电路，哪些是异步电路</li>
<li>对局部的同步电路使用PT/DC综合和分析</li>
<li>对跨时钟域电路进行一些时钟约束（定义一些时序的路径），让PT知道这部分我们无法做STA</li>
</ul>
<h3><span id="6operating-condition操作条件">6）Operating Condition操作条件</span></h3><p><strong>Operating Condition操作条件：</strong></p>
<ul>
<li><p>Static timing analysis is typically performed at a specific operating condition.</p>
<blockquote>
<p>STA时需要指定条件，才能对该特定条件cell或线进行检查，是否满足setup、hold</p>
</blockquote>
</li>
<li><p>An operating condition is defined as a combination of PVT： Process（工艺制成）, Voltage（电压） and Temperature （温度）</p>
<blockquote>
<p>operation condition条件指的是PVT</p>
</blockquote>
</li>
<li><p>Cell delays and interconnect delays are computed based upon the specified operating<br>condition.  </p>
<blockquote>
<p>cell和互连线的delay必须是基于特定的PVT，才能进行精准分析</p>
</blockquote>
</li>
<li><p>There are three kinds of manufacturing process models that are provided by the<br>semiconductor foundry for digital designs: slow process models, typical process models,and fast process models.</p>
<blockquote>
<p>PVT分为三种：slow，typical，fast</p>
</blockquote>
</li>
<li><p>The slow and fast process models represent the extreme corners of the manufacturing process of a foundry.</p>
<blockquote>
<p>slow，fast通常是极限条件进行测试</p>
</blockquote>
</li>
<li><p>For robust design, the design is validated at the extreme corners of the manufacturing process as well as environment extremes for temperature and power supply. </p>
</li>
</ul>
<p><strong>PVT与delay的关系：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905892.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>高温+低电压：确保延迟最差/慢，ss-&gt;max-&gt;check setup</li>
<li>低温+高电压：确保延迟最小，ff-&gt;min-&gt;check hold</li>
<li>典型值没有ff和ss有代表性</li>
</ul>
<p><strong>PVT的数值表现在库中：</strong></p>
<p>The choice of what operating condition to use for STA is also governed by the operating conditions under which <strong>cell libraries are available</strong>. Three standard operating conditions are:  </p>
<blockquote>
<p>一下是我们假设的等级的通常要求</p>
</blockquote>
<ul>
<li><strong>WCS</strong> (Worst-Case Slow): <ul>
<li>Process is slow, temperature is highest (say 125C) and voltage is lowest (say nominal 1.2V minus 10%)  </li>
</ul>
</li>
<li><strong>BCF</strong> (Best-Case Fast): <ul>
<li>Process is fast, temperature is lowest (say -40C) and voltage is highest (say nominal 1.2V plus 10%).  </li>
</ul>
</li>
<li><strong>TYP</strong> (Typical): <ul>
<li>Process is typical, temperature is nominal (say 25C) and voltage is nominal (say 1.2V).  </li>
</ul>
</li>
</ul>
<p><strong>SynopsysTCL指定操作条件：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_operating_conditions “WCCOM” -library mychip<br><span class="hljs-comment"># Use the operating condition called WCCOM defined in the cell library mychip</span><br></code></pre></div></td></tr></table></figure>
<h2><span id="43-参考书">4.3 参考书</span></h2><ul>
<li>Static Timing Analysis for Nanometer Designs: A Practical Approach. J.Bhasker, Rakesh Chadha. Springer Science Business Media, LLC 2009.Chaper 2.</li>
<li>集成电路静态时序分析与建模. 刘峰, 机械工业出版社.出版时间： 2016-07-01.第二章.</li>
<li>PrimeTime ® Fundamentals User Guide. Synopsys. Version F-2011.12,December 2011 </li>
</ul>
<h1><span id="5-标准单元库">5 标准单元库</span></h1><ul>
<li>Overview of Synopsys Timing lib（时序库）</li>
<li>Non-Linear Delay Model</li>
<li>Threshold Specifications and Slew Derating</li>
<li>Timing Models</li>
<li>Wire Delay Models</li>
</ul>
<h2><span id="51-timing-lib时序库">5.1 Timing lib时序库</span></h2><h3><span id="库的基本概念">库的基本概念</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905893.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>两种格式不同内容相同的库：</strong></p>
<ul>
<li><p>.db格式的库打不开</p>
</li>
<li><p>.lib格式的库可以打开看，如下图：</p>
</li>
</ul>
<p><strong>一个标准单元的工艺库(cell lib)：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905894.png" srcset="/img/loading.gif" lazyload alt="一个lib时序库的文件头信息"></p>
<ul>
<li>delay_model：lookuptable<ul>
<li>由查找表来实现延迟模型</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905895.png" srcset="/img/loading.gif" lazyload alt="cell的定义"></p>
<ul>
<li>Value对应的查找表</li>
</ul>
<h2><span id="52-non-linear-delay-model非线性的延迟模型">5.2 Non-Linear Delay Model非线性的延迟模型</span></h2><h3><span id="1反相器实例分析">1）<strong>反相器实例分析：</strong></span></h3><p>Let us first consider timing arcs for a simple inverter logic. Since it is an inverter, a rising (falling) transition at the input causes a falling (rising) transition at the output.<br>    The two kinds of delay characterized for the cell are<strong>（两种延迟特征/延迟值）:</strong>  </p>
<ul>
<li>Tr：Output rise delay（输入下降输出上升延迟）</li>
<li>Tf：Output fall delay（输入上升输出下降延迟）</li>
</ul>
<p>Notice that the delays are measured based upon the threshold points defined in a cell ibrary, which is typically 50% Vdd.  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905896.png" srcset="/img/loading.gif" lazyload alt="反向器与时序模型"></p>
<p><strong>STA中的时序模型Time Arc取决于两个因素：</strong></p>
<ul>
<li>输出的负载（输出引脚的电容负载）</li>
<li>输入的transition time转化时间<ul>
<li>大多数情况下延迟会随着输入transition增加而增加</li>
</ul>
</li>
</ul>
<p>确定输入的转化时间和输出电容后，标准单元可以跟时序的模型来计算或查询延迟信息，通常来说<strong>标准单元的延迟模型有两种：</strong></p>
<ul>
<li>线性的</li>
<li><p>非线性的</p>
<h3><span id="2一种通用的线性延迟模型公式">2）一种通用的线性延迟模型公式：</span></h3></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">D</span> = D<span class="hljs-number">0</span> + D<span class="hljs-number">1</span>*S + D<span class="hljs-number">2</span>*C<br><span class="hljs-attribute">D0</span>，D<span class="hljs-number">1</span>，D<span class="hljs-number">2</span>常量<br><span class="hljs-attribute">S</span>是input transction time<br><span class="hljs-attribute">C</span>是output 电容<br></code></pre></div></td></tr></table></figure>
<ul>
<li>通过上述模型可以计算当前的延迟信息有多少</li>
<li><strong>随着半导体工艺发展，这种线性模型越来越不准确率，实际应用较少</strong></li>
</ul>
<h3><span id="3nldm非线性延迟模型">3）NLDM非线性延迟模型</span></h3><p><strong>NLDM非线性延迟模型计算方法：</strong></p>
<ul>
<li>在cell lib标准库文件中通过一个二维的查找表构成延迟模型</li>
</ul>
<p>Here is an example of such a table for a typical inverter cell:  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905897.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>模型方向：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905898.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>传输时间和电容对应不上时：</strong></p>
<ul>
<li>通过插值计算/高斯消元法</li>
<li>实例分析</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905899.png" srcset="/img/loading.gif" lazyload alt="XY在中间，没有对应数"></p>
<p><strong>高斯消元法计算过程：</strong></p>
<ul>
<li><strong>思想：</strong>一个点用周围四个点计算</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905900.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>高斯消元法<strong>固定公式：</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905901.png" srcset="/img/loading.gif" lazyload alt="高斯消元法固定公式"></p>
<ul>
<li>步骤1：周围四个点带入公式求解ABCD</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905902.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>步骤2：计算Z</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905903.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="53-threshold-specifications-and-slew-derating使用缩放确定查找表的表项">5.3 Threshold Specifications and Slew Derating（使用缩放确定查找表的表项）</span></h2><p><strong>我们的库中一般是10%~90%的电压测量的延迟</strong></p>
<blockquote>
<p>​    The slew 1 values are based upon the measurement thresholds specified in the library. Most of the previous generation libraries (0.25?m or older) used 10% and 90% as measurement thresholds for slew or transition time.  </p>
</blockquote>
<p><strong>实际工艺中更多的是30%~70%，而库里面早期是10%~90%</strong></p>
<blockquote>
<p>​    The slew thresholds are chosen to correspond to the linear portion of the waveform. As technology becomes finer, the portion where the actual waveform is most linear is typically between 30% and 70% points.<br>​    <strong>Thus, most of the newer generation timing libraries specify slew measurement points as 30% and 70% of Vdd</strong>  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905904.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Slew：从10~90缩小到30~79</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905905.png" srcset="/img/loading.gif" lazyload alt></p>
<blockquote>
<p>​    However, because the transition times were previously measured between 10% and 90%, the transition times measured between 30% and 70% are usually doubled for populating the library. This is specified by the slew derate factor which is typically specified as 0.5.<br>​    The slew thresholds of 30% and 70% with slew derate as 0.5 results in equivalent measurement points of 10% and 90%. An example settings of threshold is illustrated below.  </p>
</blockquote>
<p><strong>对应实际库：</strong></p>
<p>​    During characterization, the transition is measured at 30-70 and the transition data in the library corresponds to extrapolation of measured values to 10% to 90% ((70 - 30)/(90 - 10) = 0.5)  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905906.png" srcset="/img/loading.gif" lazyload alt></p>
<blockquote>
<p>​    The above settings specify that the transition times in the library tables have to be multiplied by 0.5 to obtain the transition times which correspond to the slew threshold (30-70) settings.<br>​    This means that the values in the transition tables (as well as corresponding index values) are effectively 10-90 values.  </p>
</blockquote>
<p><strong>也可以不指定</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905907.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>也可指定其他值</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905908.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>应用场景：</strong></p>
<ul>
<li>自己建库</li>
<li>K库<ul>
<li>设计低功耗芯片时，需要从新建一套，需要缩小电压值，在已有的库上做扩展：<ul>
<li>此时表项、延迟都不一样了，需要在已有库上做抽取，从而形成新的查找表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905909.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="54-timing-model时序模型">5.4 Timing Model时序模型</span></h2><h3><span id="1两输入与门示例">1）两输入与门示例</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905910.png" srcset="/img/loading.gif" lazyload alt></p>
<p>库内信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905911.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2时序的cell示例">2）时序的Cell示例</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905912.png" srcset="/img/loading.gif" lazyload alt></p>
<p>库内信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905913.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905914.png" srcset="/img/loading.gif" lazyload alt="hold时序查找表"></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905915.png" srcset="/img/loading.gif" lazyload alt="内部ck到Q的时序"></p>
<h2><span id="55-线延迟模型">5.5 线延迟模型</span></h2><p>用分布式RC树来抽象互连线，主要两种模型：（参考数字集成电路书）</p>
<ul>
<li>T模型</li>
<li>Pi模型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905916.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>线模型示例库内信息</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905917.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>area面积</li>
<li>slope斜率</li>
<li>_length线长</li>
</ul>
<p><strong>超出线长时的计算方法：使用斜率计算</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905918.png" srcset="/img/loading.gif" lazyload alt></p>
<h1><span id="6-sta环境配置重要">6 STA环境配置（重要）</span></h1><ul>
<li>What is the STA Environment?</li>
<li>Specifying Clocks</li>
<li>Generated Clocks </li>
<li>Constraining Input Paths and Output Path </li>
<li>Design Rule Checks </li>
<li>Virtual Clocks </li>
<li>Refining the Timing Analysis</li>
</ul>
<p>本次课主要求如何撰写、指导、分析整个sta中的sdc约束</p>
<p><strong>PrimeTime：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905919.png" srcset="/img/loading.gif" lazyload alt></p>
<p>使用约束可以在synthesis、PR、sign-off进行静态时序分析</p>
<h2><span id="61-sta-env">6.1 STA Env</span></h2><ul>
<li>我来给STA指定一个约束，</li>
<li>约束严谨、精确才能指导STA对整个电路做一个全面且正确的检查</li>
<li>才能确定setup、hold是真正满足需求，否则给一个错误的约束可能STA错误</li>
<li>ENV包括：时钟、IO、指定时序路径的特殊约束</li>
</ul>
<p>STA针对同步电路，对异步电路无能为力:</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905920.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="62-specifying-clocks时钟约束重要">6.2 Specifying Clocks时钟约束（重要）</span></h2><h3><span id="1specifying-clocks-时钟约束的形状">1）Specifying Clocks | 时钟约束的形状</span></h3><p><strong>To define a clock, we need to provide the following information:</strong>  </p>
<ul>
<li>Clock source时钟源: it can be a port of the design, or be a pin of a cell inside the design (typically that is part of a clock generation logic).</li>
<li>Period周期: the time period of the clock.</li>
<li>Duty cycle占空比: the high duration (positive phase) and the low duration (negative phase).</li>
<li>Edge times边缘翻转时间: the times for the rising edge and the falling edge. </li>
</ul>
<p><strong>clock的sdc约束条件代码示例：</strong></p>
<ul>
<li>所有sdc的约束都是按照TCL/Synopsys TCL的语法来写的</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name SYSCLK -period <span class="hljs-number">20</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">5</span>&#125; [get_ports <span class="hljs-number">2</span> SCLK]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905921.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>其他的定义示例：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905922.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -period <span class="hljs-number">5</span> [get_ports SCAN_CLK]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905923.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name BDYCLK -period <span class="hljs-number">15</span> -waveform &#123;<span class="hljs-number">5</span> <span class="hljs-number">12</span>&#125; [get_ports GBLCLK<br></code></pre></div></td></tr></table></figure>
<h3><span id="2specifying-clocks-clock-uncertainty">2）Specifying Clocks-Clock Uncertainty</span></h3><p>前面我们描述了时钟的形状，但时钟存在误差（时钟偏斜、clock jitter等等），我们通过<code>set_clock_uncertainty</code>来对时钟误差进行估计或更严格的指定</p>
<ul>
<li>更严格可以认为是有效时钟周期的减小</li>
<li>通过比较悲观的设计使得设计变得稳健</li>
<li>也可对虚拟时钟进行指定</li>
</ul>
<p><strong>uncertainty定义示例1：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_clock_uncertainty -setup <span class="hljs-number">0.2</span> [get_clocks CLK_CONFIG]<br>set_clock_uncertainty -hold <span class="hljs-number">0.05</span> [get_clocks CLK_CONFIG]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905924.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>uncertainty定义示例2——针对两个时钟的指定：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_clock_uncertainty -from VIRTUAL_SYS_CLK -to SYS_CLK -hold <span class="hljs-number">0.05</span><br>set_clock_uncertainty -from VIRTUAL_SYS_CLK -to SYS_CLK -setup <span class="hljs-number">0.3</span><br>set_clock_uncertainty -from SYS_CLK -to CFG_CLK -hold <span class="hljs-number">0.05</span><br>set_clock_uncertainty -from SYS_CLK -to CFG_CLK -setup <span class="hljs-number">0.1</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905925.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>进一步解释uncertainty作用方法——实现时钟偏差</strong></p>
<ul>
<li>Clock Skew时钟偏差</li>
<li>Clock Jitter时钟抖动</li>
<li>Clock Delay时钟延迟</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905926.png" srcset="/img/loading.gif" lazyload alt="①时钟偏差，②时钟延迟时钟抖动"></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905927.png" srcset="/img/loading.gif" lazyload alt="时钟到两个触发器之间有距离（可能正可能负）"></p>
<ul>
<li>我们做时钟树的时候要求尽可能的减小偏差，而uncertainty产生时钟偏差从而构造一种更严格的环境</li>
</ul>
<h3><span id="3时钟延迟">3）时钟延迟</span></h3><p>两种latency，都需要计算：</p>
<ul>
<li><strong>Network latency</strong> is the delay from the clock definition point (create_clock) to the clock pin of a flip-flop  <ul>
<li>定义的时钟节点到触发器</li>
</ul>
</li>
<li><strong>Source latency</strong>, also called insertion delay, is the delay from the clock source to the clock definition point<ul>
<li>时钟源到定义节点</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905928.png" srcset="/img/loading.gif" lazyload alt="source latency &amp; network latency"></p>
<p><strong>如何通过TCL脚本指定latency：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># Specify a network latency (no -source option) of 0.8ns for rise, fall, max and min:</span><br>set_clock_latency <span class="hljs-number">0.8</span> [get_clocks CLK_CONFIG]<br><span class="hljs-comment"># Specify a source latency:</span><br>set_clock_latency <span class="hljs-number">1.9</span> -<span class="hljs-keyword">source</span> [get_clocks SYS_CLK]<br><span class="hljs-comment"># Specify a min source latency:</span><br>set_clock_latency <span class="hljs-number">0.851</span> -<span class="hljs-keyword">source</span> -min [get_clocks CFG_CLK]<br><span class="hljs-comment"># Specify a max source latency:</span><br>set_clock_latency <span class="hljs-number">1.322</span> -<span class="hljs-keyword">source</span> -max [get_clocks CFG_CLK]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905929.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>latency 总结：</strong></p>
<ul>
<li>One important distinction to observe between source and network latency is that once a clock tree is built for a design, the network latency can be ignored (assuming set_propagated_clock command is specified).<ul>
<li>latency的区别：<ul>
<li>如果时钟树已经建立好，你的得到的latency则是非常精确的</li>
<li>如果在PR之前，在DC的时候，你的时钟树综合之前，latency是个估计的</li>
</ul>
</li>
</ul>
</li>
<li>However, the source latency remains even after the clock tree is built.</li>
<li>The network latency is an estimate of the delay of the clock tree prior to clock tree synthesis.</li>
<li>After clock tree synthesis, the total clock latency from clock source to a clock pin of a flip-flop is<br>the source latency plus the actual delay of the clock tree from the clock definition point to the<br>flip-flop.  </li>
</ul>
<h2><span id="63-generated-clock-生成时钟">6.3 Generated Clock 生成时钟</span></h2><p><strong>Generated Clock &amp; Master Clock：</strong></p>
<ul>
<li>A generated clock is a clock derived from a master clock. A master clock is a clock defined using the create_clock specification.</li>
<li>When a new clock is generated in a design that is based on a master clock, the new clock can be defined as a generated clock.  </li>
</ul>
<p><strong>Generated Clock定义的作用：</strong>This definition is needed as STA does not know that the clock period has changed at the output of the divide-by logic, and more importantly what the new clock period is </p>
<p><strong>Generated Clock如何定义：</strong></p>
<ul>
<li><code>create_clock</code></li>
<li><code>create_generated_clock -source(required) -divide_by &lt;num&gt;(num option，下图中指的是2分频)</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905930.png" srcset="/img/loading.gif" lazyload alt></p>
<p>可以把generated clock定义为master clock，因此不要定义为master时钟，这样静态时序会乱，特殊情况下可以定义</p>
<p>generated clock定义成新的时钟带来的问题：</p>
<ul>
<li><strong>（问题一）</strong>两个clock之间失去了联系，作为时序分析时STA认为互为异步时钟而不是同步时钟</li>
</ul>
<blockquote>
<p>Can a new clock, that is, a master clock, be defined at the output of the flipflop instead of a generated clock? The answer is yes, that it is indeed possible. However, there are some disadvantages. Defining a master clock instead of a generated clock creates a new clock domain.  </p>
<p>Defining the new clock as a generated clock does not create a new clock domain, and the generated clock is considered to be in phase with its master clock. The generated clock does not require additional constraints to be developed. Thus, one must attempt to define a new internally generated clock as a generated clock instead of deciding to declare it as another master clock.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905931.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>（问题二）</strong>成为新的时钟的源点，与原来的mclk没有寄生关系了：</li>
</ul>
<blockquote>
<p>Another important difference between a master clock and a generated clock is the notion of clock origin. In a master clock, the origin of the clock is at the point of definition of the master clock. In a generated clock, the clock origin is that of the master clock and not that of the generated clock.4</p>
<p>This implies that in a clock path report, the start point of a clock path is always the master clock definition point. This is a big advantage of a generated clock over defining a new master clock as the source latency is not automatically included for the case of a new master clock.  </p>
</blockquote>
<ul>
<li>mclk&amp;gclk</li>
</ul>
<blockquote>
<p>Clock latencies can be specified for generated clocks as well. </p>
<p>A source latency specified on a generated clock specifies the latency from the definition of the master clock to the definition of the generated clock.  </p>
<p>The total clock latency to a clock pin of a flop-flop being driven by a generated clock is thus the sum of the source latency of the master clock, the source latency of the generated clock and the network latency of the generated clock  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905932.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>（特例）</strong>什么时候可以定义为master<ul>
<li>下图是两个clk的与生成的新时钟</li>
<li>同时推荐写gclk约束之前画一下时钟树，清楚时钟区域</li>
</ul>
</li>
</ul>
<blockquote>
<p>If the input to the and cell are both clocks, then it is safe to define a new main clock at the output of the and cell, since it is highly unlikely that the output of the cell has any phase relationship with either of the input clocks  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905933.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>上述两与门clk的约束写法：</li>
</ul>
<blockquote>
<p>If the input to the and cell are both clocks, then it is safe to define a new main clock at the output of the and cell, since it is highly unlikely that the output of the cell has any phase relationship with either of the input clocks.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905934.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Generated Clock使用情况很多：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905935.png" srcset="/img/loading.gif" lazyload alt="一种带PLL时钟的分析"></p>
<h2><span id="64-constraining-input-paths-amp-output-path">6.4 Constraining Input Paths &amp; Output Path</span></h2><h3><span id="1示意图">1）示意图</span></h3><p>我们讨论时序路径主要是分析从reg到reg</p>
<p>时序路径：INP1-&gt;UFF1.D</p>
<ul>
<li>这种路径不存在时钟，需要对INP1增加input delay</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905936.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>约束指令示例：set_input_delay</strong></p>
<ul>
<li>set_input_delay：<ul>
<li>CLKA（时钟域/时钟引脚）</li>
<li>约束值（一个区间/比例）</li>
</ul>
</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> Tclk2q <span class="hljs-number">0.9</span><br><span class="hljs-keyword">set</span> Tc1 <span class="hljs-number">0.6</span><br>set_input_delay -<span class="hljs-keyword">clock</span> CLKA -max [<span class="hljs-keyword">expr</span> Tclk2q + Tc1] [get_ports INP1]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905937.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>input——setup,hold time,max,min分别设置</strong></p>
<ul>
<li>注意max和min</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -period <span class="hljs-number">15</span> -waveform &#123;<span class="hljs-number">5</span> <span class="hljs-number">12</span>&#125;<br>[get_ports CLKP]<br>set_input_delay -<span class="hljs-keyword">clock</span> CLKP -max <span class="hljs-number">6.7</span><br>[get_ports INPA]<br>set_input_delay -<span class="hljs-keyword">clock</span> CLKP -min <span class="hljs-number">3.0</span><br>[get_ports INPA]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905938.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>output约束类似</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> Tc2 <span class="hljs-number">3.9</span><br><span class="hljs-keyword">set</span> Tsetup <span class="hljs-number">1.1</span><br>set_output_delay -<span class="hljs-keyword">clock</span> CLKQ -max [<span class="hljs-keyword">expr</span> Tc2 + Tsetup] [get_ports OUTB]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905939.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>output——setup,hold time,max,min分别设置</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -period <span class="hljs-number">100</span> -waveform &#123;<span class="hljs-number">5</span> <span class="hljs-number">55</span>&#125; [get_ports MCLK]<br>set_input_delay <span class="hljs-number">25</span> -max -<span class="hljs-keyword">clock</span> MCLK [get_ports DATAIN]<br>set_input_delay <span class="hljs-number">5</span> -min -<span class="hljs-keyword">clock</span> MCLK [get_ports DATAIN]<br>set_output_delay <span class="hljs-number">20</span> -max -<span class="hljs-keyword">clock</span> MCLK [get_ports DATAOUT]<br>set_output_delay <span class="hljs-number">-5</span> -min -<span class="hljs-keyword">clock</span> MCLK [get_ports DATAOUT]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905940.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="四种时钟约束路径总结">四种时钟约束路径总结</span></h3><p>至此我们学过了全部四种的时钟路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905941.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="timing-path-groups路径组">Timing Path Groups路径组</span></h3><p>电路内部时序复杂，有很多时钟，如何判断始于哪个时钟域/时钟组：</p>
<ul>
<li>查看endpoint终点，终点属于哪个时钟，就属于哪一时钟的path group</li>
</ul>
<blockquote>
<p>Timing paths are sorted into path groups by the clock associated with the <strong>endpoint</strong> of the path. Thus, each clock has a set of paths associated with it.</p>
<p>There is also a default path group that includes all non-clocked (asynchronous) paths.  </p>
</blockquote>
<h3><span id="额外属性在指定端口时的额外属性">额外属性（在指定端口时的额外属性）</span></h3><blockquote>
<p>While create_clock, set_input_delay and set_output_delay are enough to constrain all paths in a design for performing timing analysis, these are not enough to obtain accurate timing for the IO pins of the block.</p>
<p>The following attributes are also required to accurately model the environment of a design.  </p>
</blockquote>
<p>对input来讲：</p>
<ul>
<li>set_driver<ul>
<li>设置驱动强度，值越小越大，0为无限大(理想状态)，但还是需要都设置一下不要都设为理想</li>
</ul>
</li>
<li>set_driving_cell</li>
<li>set_input_transition</li>
</ul>
<p>对output</p>
<blockquote>
<p>For outputs, one needs to specify the capacitive load seen by the output pin. This is specified by using the following specification:  </p>
</blockquote>
<ul>
<li>set_load</li>
</ul>
<h4><span id="input">input</span></h4><p><strong>具体设置情况</strong></p>
<blockquote>
<p>The set_drive explicitly specifies a value for the drive resistance at the input pin of the DUA. The smaller the drive value, the higher the drive strength.</p>
<p>A resistance value of 0 implies an infinite drive strength.  </p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_drive <span class="hljs-number">100</span> UCLK # Specifies a drive resistance of <span class="hljs-number">100</span> on input UCLK<br><br><span class="hljs-comment"># Rise drive is different from fall drive:</span><br>set_drive -rise <span class="hljs-number">3</span> [all_inputs]<br>set_drive -fall <span class="hljs-number">2</span> [all_inputs]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905942.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>根据驱动能力，如何计算第一个门的延迟能力</li>
</ul>
<blockquote>
<p>The drive of an input port is used to calculate the transition time at the first cell. The drive value specified is also used to compute the delay from the input port to the first cell in the presence of any<br>RC interconnect.  </p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">Delay_to_first_gate = (drive * load_on_net) + interconnect_delay<br></code></pre></div></td></tr></table></figure>
<p><strong>从库里面设置driver(简单)：</strong></p>
<ul>
<li><p><strong>关于port补充内容，多翻一下synopsys手册以及刘老师的静态时序分析、建模：</strong></p>
<ul>
<li><p><code>get_ports &lt;PIN&gt;</code></p>
</li>
<li><p><code>all_inputs</code></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905943.png" srcset="/img/loading.gif" lazyload alt="set_driving_cell"></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_driving_cell -lib_cell INV3 -library slow [get_ports INPB]<br><span class="hljs-comment"># The input INPB is driven by an INV3 cell from library slow.</span><br>set_driving_cell -lib_cell INV2 -library tech13g [all_inputs]<br><span class="hljs-comment"># Specifies that the cell INV2 from a library tech13g is the driving cell for all</span><br>set_driving_cell -lib_cell BUFFD4 -library tech90gwc [get_ports &#123;testmod<br><span class="hljs-comment"># The input testmode[3] is driven by a BUFFD4 cell from library tech90gwc</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905944.png" srcset="/img/loading.gif" lazyload alt="set_input_transition"></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_input_transition <span class="hljs-number">0.85</span> [get_ports INPC]<br><span class="hljs-comment"># Specifies an input transition of 850ps on port INPC.</span><br>set_input_transition <span class="hljs-number">0.6</span> [all_inputs]<br><span class="hljs-comment"># Specifies a transition of 600ps on all input ports.</span><br>set_input_transition <span class="hljs-number">0.25</span> [get_ports SD_DIN*]<br><span class="hljs-comment"># Specifies a transition of 250ps on all ports with pattern SD_DIN*.</span><br><span class="hljs-comment"># Min and max values can optionally be specified using the -min and -max options</span><br></code></pre></div></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>缺省状态下的驱动能力为理想状态（0）与实际不符</li>
</ul>
<blockquote>
<p>In summary, a slew value at an input is needed to determine the delay of the first cell in the input<br>path.<br>In the absence of this specification, an ideal transition value of 0 is assumed, which may not be<br>realistic.  </p>
</blockquote>
<h4><span id="output">output</span></h4><p>对于output我们关心capacitive load（电容负载），默认为0，我们需要把load改为不为理想值</p>
<blockquote>
<p>The set_load specification places a capacitive load on output ports to model the external load being<br>driven by the output port.</p>
<p>By default, the capacitive load on ports is 0. The load can be specified as an explicit capacitance value<br>or as an input pin capacitance of a cell  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905945.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>具体设置情况</strong></p>
<ul>
<li>port</li>
<li>all_output</li>
<li>过滤</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_load <span class="hljs-number">5</span> [get_ports OUTX]<br><span class="hljs-comment"># Places a 5pF load on output port OUTX.</span><br>set_load <span class="hljs-number">25</span> [all_outputs]<br><span class="hljs-comment"># Sets 25pF load capacitance on all outputs.</span><br>set_load -pin_load <span class="hljs-number">0.007</span> [get_ports &#123;shift_write[<span class="hljs-number">31</span>]&#125;]<br><span class="hljs-comment"># Place 7fF pin load on the specified output port.</span><br><span class="hljs-comment"># A load on the net connected to the port can be specified using the -wire_load option.</span><br><span class="hljs-comment"># If neither -pin_load nor -wire_load option is used, # the default is the -pin_load option</span><br></code></pre></div></td></tr></table></figure>
<p>It is important to specify the load on outputs since this value impacts the delay of the cell driving the output. In the absence of such a specification, a load of 0 is assumed which may not be realistic </p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_load [get_attribute [get_lib_pins tech_lib/NAND2/A] pin_capacitance] [all_outputs]<br></code></pre></div></td></tr></table></figure>
<h2><span id="65-drcdesign-rule-checks">6.5 DRC(Design Rule Checks)</span></h2><p>STA中用到最多的：max transition and max capacitance  </p>
<p>DRC主要检查所有的port和pin是否满足the specified limits for transition time 1 and capacitance  </p>
<p><strong>通常来讲TCL指定方式为：</strong></p>
<ul>
<li>set_max_transition</li>
<li>set_max_capacitance </li>
</ul>
<p><strong>使用不是特别多的指令（在时序中使用不是特别直接），通常更关心上面两个</strong></p>
<ul>
<li>set_max_fanout (specifies a fanout limit on all pins in design)</li>
<li>set_max_area (for a design);  </li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_max_transition <span class="hljs-number">0.6</span> IOBANK<br><span class="hljs-comment"># Sets a limit of 600ps on IOBANK.</span><br>set_max_capacitance <span class="hljs-number">0.5</span> [current_design]<br><span class="hljs-comment"># Max capacitance is set to 0.5pf on all nets in current desi</span><br></code></pre></div></td></tr></table></figure>
<h2><span id="66-virtual-clock-虚拟时钟">6.6 Virtual Clock 虚拟时钟</span></h2><p>虚拟时钟与design中的pin无关，主要在STA中做参考，来指定input port或output port的相关时钟</p>
<p><strong>由于虚拟时钟在电路中没有引脚，因此不需要get_ports</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905946.png" srcset="/img/loading.gif" lazyload alt="示意图"></p>
<p><strong>具体定义示例</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name VIRTUAL_CLK_SAD -period <span class="hljs-number">10</span> -waveform &#123;<span class="hljs-number">2</span> <span class="hljs-number">8</span>&#125;<br>create_clock -name VIRTUAL_CLK_CFG -period <span class="hljs-number">8</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">4</span>&#125;<br>create_clock -period <span class="hljs-number">10</span> [get_ports CLK_CORE]<br>set_input_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLK_SAD -max <span class="hljs-number">2.7</span> [get_ports ROW_IN]<br>set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLK_CFG -max <span class="hljs-number">4.5</span> [get_ports STATE_O]<br></code></pre></div></td></tr></table></figure>
<ul>
<li>通过虚拟时钟可以更好的约束时序路径</li>
</ul>
<h2><span id="67-refining-the-timing-analysis">6.7 Refining the Timing Analysis</span></h2><p>四条精细化的STA分析路径，如果这个乱设容易让时序复杂了，因此需要对时序需求timepass属性进行分析：</p>
<ul>
<li><strong>set_case_analysis:</strong> Specifies constant value on a pin of a cell, or on an input port.</li>
<li><strong>set_disable_timing:</strong> Breaks a timing arc of a cell.</li>
<li><strong>set_false_path:</strong> Specifies paths that are not real which implies that these paths are not checked in STA.</li>
<li><strong>set_multicycle_path:</strong> Specifies paths that can take longer than one clock cycle </li>
</ul>
<h3><span id="1set_case_analysis">1）set_case_analysis</span></h3><p>芯片正常工作时DFT(test)是不要求工作的，因此需要关闭DFT(test)模式。</p>
<blockquote>
<p>In a design, certain signals have a constant value in a specific mode of the chip.</p>
<p>For example, if a chip has DFT logic in it, then the TEST pin of the chip should be at 0 in normal functional mode. It is often useful to specify such constant values to STA  </p>
</blockquote>
<ul>
<li>test和normal两种模式的时钟选择：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905947.png" srcset="/img/loading.gif" lazyload alt>、</p>
<ul>
<li>具体约束写法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905948.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>引脚不固定时，按情况具体约束</strong></p>
<blockquote>
<p>Another common application of case analysis is when the design can run on multiple clocks, and the selection of the appropriate clock is controlled by multiplexers. To make STA analysis easier and reduce CPU run time, it is beneficial to do STA for each clock selection separately.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905949.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_case_analysis <span class="hljs-number">1</span> UCORE/UMUX0/CLK_SEL[<span class="hljs-number">0</span>]<br>set_case_analysis <span class="hljs-number">1</span> UCORE/UMUX1/CLK_SEL[<span class="hljs-number">1</span>]<br>set_case_analysis <span class="hljs-number">0</span> UCORE/UMUX2/CLK_SEL[<span class="hljs-number">2</span>]<br></code></pre></div></td></tr></table></figure>
<h3><span id="2set_disable_timing">2）set_disable_timing</span></h3><p>意思：这不是一条时序路径，节点之间没有time pass，不进行STA分析，减少PT时间</p>
<blockquote>
<p>In some situations, it is possible that a certain path through a cell cannot occur.<br>Such a timing arc can be broken by using the <strong>set_disable_timing</strong> SDC command  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905950.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_disable_timing -from S -to Z [get_cells UMUX0]<br></code></pre></div></td></tr></table></figure>
<h3><span id="3set_false_path-伪路径">3）set_false_path  伪路径</span></h3><p>与disable区别：</p>
<ul>
<li>disable没有timing arc</li>
<li>false根本不是一条时序路径</li>
</ul>
<p>使用场景：</p>
<ul>
<li>两个异步电路之间，由A时钟域-&gt;B时钟域中所有的路径不进行分析</li>
<li>有很多路径做逻辑简化时发现，有些时序路径永远不会出现时</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905951.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_false_path -from [get_clocks USBCLK] -to [get_clocks MEMCLK]<br></code></pre></div></td></tr></table></figure>
<h3><span id="4set_multicycle_path-多周期">4）set_multicycle_path 多周期</span></h3><p>使用场景：</p>
<ul>
<li>​    在一个高延迟的路径下，提示PT这里要多个周期，别每个周期都检查</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905952.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name CLKM -period <span class="hljs-number">10</span> [get_ports CLKM]<br>set_multicycle_path <span class="hljs-number">3</span> -setup -from [get_pins UFF0/Q] -to [get_pins UFF1/D]<br></code></pre></div></td></tr></table></figure>
<h2><span id="68-补充">6.8 补充</span></h2><p>以上所有内容会以SDC脚本的形式出现，因此需要掌握SDC脚本的书写方法</p>
<p>一定要参考《DC命令手册》《PT命令手册》</p>
<h1><span id="7-timing-verification一-时序检查">7 Timing Verification(一) 时序检查</span></h1><ul>
<li>setup time check 建立时间的检查</li>
<li>holdup time check 保持时间的检查</li>
</ul>
<h2><span id="71-建立时间的检查">7.1 建立时间的检查</span></h2><p>常见路径举例（有两条）：  </p>
<ul>
<li>最常见路径上面的路径（Tlaunch+Tck2q+Tdp）：UFF0.CK——UFF1.D</li>
<li>capture路径下面的路径（CLKM的延迟）：CLKM——UFF1.CK</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905953.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="1如何分析setup-time是否满足要求">1）如何分析setup time是否满足要求</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905954.png" srcset="/img/loading.gif" lazyload alt="电路示意图与对应时刻"></p>
<ul>
<li>launch路径</li>
<li>capture路径</li>
</ul>
<p><strong>setup检查的公式表达：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905955.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>第一条launch路径的延迟小于第二条capture路径</li>
</ul>
<h3><span id="2timing-report讲解1reg2regff2ff">2）timing report讲解①（reg2reg/ff2ff）</span></h3><p><strong>timing report产生来源</strong>：DC/PT（后端的工具）</p>
<p><strong>Flip-flop to Flip-flop Path</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905956.png" srcset="/img/loading.gif" lazyload alt="fftoff时序报告示例——launch路径"></p>
<ul>
<li>起点UFF0，被CLKM上升沿触发</li>
<li>重点UFF1，被CLKM上升沿触发</li>
<li>时钟组：根据终点是哪个CLK划分</li>
<li>极限max：Tlaunch时间最长时，依然小于Tcaputer建立时间</li>
<li>Point：时序经过的每一个点<ul>
<li>Incr每个点自己的延迟</li>
<li>Path从起点开始累计延迟值</li>
<li>r/f：上升/翻转</li>
<li>data arrival time：数据到达时间（最终时间）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905957.png" srcset="/img/loading.gif" lazyload alt="capture路径"></p>
<ul>
<li><p>Ponit</p>
<ul>
<li><p>clock uncertainty：时钟误差，增加了表明更加严苛</p>
</li>
<li><p>data required time：数据要求到达时间</p>
</li>
<li><p>data required time - data arrival time &gt;= 0 则满足setup公式满足要求</p>
</li>
</ul>
</li>
</ul>
<h3><span id="3timing-report讲解2input-port-to-register">3）timing report讲解②（input port to register）</span></h3><p><strong>timing report产生来源</strong>：DC/PT（后端的工具）</p>
<p><strong>Input to Flip-flop Path</strong></p>
<ul>
<li>上面提到过，增加Input Delay，两种Delay<ul>
<li>min delay</li>
<li>max delay</li>
</ul>
</li>
</ul>
<p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905958.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Constrain：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">creat_clock –name VIRTUAL_CLKM –period <span class="hljs-number">10</span> –waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">5</span>&#125; #定义虚拟时钟<br>set_input_delay –<span class="hljs-keyword">clock</span> VIRTUAL_CLKM –max <span class="hljs-number">2.55</span> [get_ports INA] #定义虚拟时钟的delay<br></code></pre></div></td></tr></table></figure>
<p><strong>timing report：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905959.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<ul>
<li>launch path<ul>
<li>clock CLKP（虚拟时钟，延时为0）</li>
<li>click network delay（虚拟时钟，延时为0）</li>
<li>input external delay：自己加的，input port的延迟开始时额外延迟</li>
<li>CIN：路径开始</li>
<li>UFFD：路径终点</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905960.png" srcset="/img/loading.gif" lazyload alt="caputre路径"></p>
<ul>
<li>capture path</li>
</ul>
<p>结果&gt;=0则就满足</p>
<h3><span id="4timing-report讲解3register-to-output-port">4）timing report讲解③（register to output port）</span></h3><p><strong>Flip-flop to Output Pat  </strong></p>
<ul>
<li>与Input port to ff类似，区别在于除了约束output delay后还需约束load(set_load)，这样才能确定最后一个cell的延迟值</li>
</ul>
<p><strong>Contrainst Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKP -max <span class="hljs-number">5.1</span> [get_ports ROUT]<br>set_load <span class="hljs-number">0.02</span> [get_ports ROUT]<br></code></pre></div></td></tr></table></figure>
<p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905961.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905962.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905963.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>capture path<ul>
<li>output external delay：增加的output delay（input port 的timing report加在了launch路径中）</li>
</ul>
</li>
</ul>
<p><strong>sta、output delay位置示意</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905964.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>CK-&gt;Q不关系</li>
<li>output-&gt;虚拟时钟-&gt;D：output delay</li>
<li>Q-&gt;output：sta部分</li>
</ul>
<h3><span id="5timing-report讲解4input-to-output-path">5）timing report讲解④（input to output path）</span></h3><p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905965.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>sta 位置示意</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905966.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>TCL Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_input_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKP -max <span class="hljs-number">3.6</span> [get_ports INB]<br>set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKP -max <span class="hljs-number">5.8</span> [get_ports POUT]<br></code></pre></div></td></tr></table></figure>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905967.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905968.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905969.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>注意这里小于0，需要考虑如何修改</li>
</ul>
<h2><span id="72-保持时间的检查">7.2 保持时间的检查</span></h2><h3><span id="1如何分析holdup-time是否满足要求">1）如何分析holdup time是否满足要求</span></h3><p>同setup</p>
<blockquote>
<p>Just like the setup check, a hold timing check is between the launch flipflop - the flip-flop that launches the data, and the capture flip-flop - the flip-flop that captures the data and whose hold time must be satisfied.<br>The clocks to these two flip-flops can be the same or can be different.  </p>
</blockquote>
<p><strong>与setup区别</strong></p>
<ul>
<li><p>check在同一边缘</p>
<ul>
<li><blockquote>
<p>The hold check is from one active edge of the clock in the launch flip-flop to the same clock edge at the capture flip-flop  </p>
</blockquote>
</li>
<li><p>回忆一下触发器基础概念就懂了，而setup的capture与launch差了一个周期</p>
</li>
</ul>
</li>
<li><p>hold check独立时钟，与时钟区域没有关系</p>
<ul>
<li><blockquote>
<p>a hold check is independent of the clock period  </p>
</blockquote>
</li>
<li><blockquote>
<p>The hold check is carried out on each active edge of the clock of the capture flip-flop  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>2 Paths：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/cs/202205012027202.png" srcset="/img/loading.gif" lazyload alt><br><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905970.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch路径</li>
<li>capture路径</li>
</ul>
<p><strong>公式表达</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905971.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>极限情况：左边（launch time）的最小值&gt;右边（capture time）的最大值</li>
<li>区别于setup：<ul>
<li>setup查看launch time的最大值</li>
<li>hold查看launch time的最小值</li>
</ul>
</li>
</ul>
<h3><span id="2timing-report讲解1reg2regff2ff">2）timing report讲解①（reg2reg/ff2ff）</span></h3><p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905972.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905973.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>要点</strong></p>
<ul>
<li>Path Type：min，对应上一节提到的查看最小值</li>
<li>clock uncertainty：是正值，要往前（在setup时是负值）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905974.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>data required time 0.19：</li>
<li>required time比arrival time小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905975.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>slack：EDA为了保持与setup体验一致性，此处位置为arrival time - required time<ul>
<li>区别于setup中required time-arrival time</li>
</ul>
</li>
</ul>
<h3><span id="3timing-report讲解2input-port-to-register">3）timing report讲解②（input port to register）</span></h3><p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905976.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>TCL Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_input_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKM -min <span class="hljs-number">1.1</span> [get_ports INA]<br></code></pre></div></td></tr></table></figure>
<p><strong>Report</strong>(圈出的是设置的值)</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905977.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905978.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>capture path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905979.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>结果</li>
</ul>
<h3><span id="4timing-report讲解3register-to-output-port">4）timing report讲解③（register to output port）</span></h3><p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905980.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>TCL Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKM -min <span class="hljs-number">2.5</span> [get_ports ROUT]<br></code></pre></div></td></tr></table></figure>
<p><strong>Report</strong>(圈出的是设置的值)</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905981.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905982.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>capture path</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905983.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>结果</li>
</ul>
<h3><span id="5timing-report讲解4input-to-output-path">5）timing report讲解④（input to output path）</span></h3><p><strong>Path</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905984.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>TCL Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_load -pin_load <span class="hljs-number">0.15</span> [get_ports POUT]<br>set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKM -min <span class="hljs-number">3.2</span> [get_ports POUT]<br>set_output_delay -<span class="hljs-keyword">clock</span> VIRTUAL_CLKM -min <span class="hljs-number">1.8</span> [get_ports INB]<br>set_input_transition <span class="hljs-number">0.8</span> [get_ports INBz]<br></code></pre></div></td></tr></table></figure>
<p><strong>Report</strong>(圈出的是设置的值)</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905985.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch路径<ul>
<li>input delay</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905986.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>capture路径<ul>
<li>output delay</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905987.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>结果</li>
</ul>
<h2><span id="73-总结">7.3 总结</span></h2><p><strong>setup：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905988.png" srcset="/img/loading.gif" lazyload alt></p>
<p>Launch路径&lt;=Capture路径</p>
<p>Factors：</p>
<ul>
<li>Tlaunch：launch的时钟网络延迟</li>
<li>Tck2q：ck到q的延迟</li>
<li>Tdp：logic延迟</li>
<li>Tcapture：capture的时钟网络</li>
<li>Tcycle：一个时钟周期</li>
<li>Tsetup：一个setup</li>
</ul>
<p>Analysis：</p>
<ul>
<li>Tdp：<strong>combinational一般是我们自己写的</strong>，因此STA不满足的时候也只能对此进行修改，<strong>需要保证次值最大时公式成立</strong></li>
<li>时钟网络之间的延迟一般都很小</li>
<li>Tcycle：给定的</li>
<li>Tsetup：工艺库中</li>
</ul>
<p><strong>holdup time：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905989.png" srcset="/img/loading.gif" lazyload alt></p>
<h1><span id="8-timing-verification二-多周期半周期伪路径检查">8 Timing Verification(二) 多周期半周期伪路径检查</span></h1><ul>
<li>Multicycle Paths 多周期路径</li>
<li>Half-Cycle Paths 半周期路径</li>
<li>False Paths 伪周期路径</li>
</ul>
<h2><span id="81-multicycle-paths-多周期路径">8.1 Multicycle Paths 多周期路径</span></h2><p><strong>概述：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905990.png" srcset="/img/loading.gif" lazyload alt></p>
<p>Up to 3-cycle delay时传统的STA无法满足要求</p>
<blockquote>
<p>In some cases, the combinational data path between two flip-flops can take more than one clock cycle to propagate through the logic. In such cases, the combinational path is declared as a multicycle path. Even though the data is being captured by the capture flip-flop on every clock edge, we direct STA that the relevant capture edge occurs after the specified number of clock cycles  </p>
</blockquote>
<p><strong>约束代码</strong></p>
<blockquote>
<p>Since the data path can take up to three clock cycles, a setup multicycle check of three cycles should be specified.<br>The multicycle setup constraints specified to achieve this are given below：  </p>
</blockquote>
<ul>
<li>针对setup的一个<strong>3周期</strong>时钟路径约束设置</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name CLKM -period <span class="hljs-number">10</span> [get_ports CLKM]<br>set_multicycle_path <span class="hljs-number">3</span> -setup -from [get_pins UFF0/Q] -to p[get_pins UFF1/D]<br></code></pre></div></td></tr></table></figure>
<p><strong>单周期的setup，hold检查</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905991.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>setup检查如图所示</li>
<li>hold检查要往前推一个周期</li>
</ul>
<p><strong>三周期的setup检查：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905992.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>setup检查</li>
</ul>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905993.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Launch</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905994.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Capture<ul>
<li>clock CLKM是三个周期，所以是30</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905995.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>结果</li>
</ul>
<p><strong>三周期hold检查：</strong></p>
<ul>
<li>N周期setup需要被一个N-1周期的hold获取</li>
</ul>
<blockquote>
<p>In most designs, a multicycle setup specified as N (cycles) should be accompanied by a<br>multicycle hold constraint specified as N-1 (cycles)  </p>
</blockquote>
<p><strong>约束代码：</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_mutlticycle_path <span class="hljs-number">2</span> -hold -from [get_pins UFF0/Q] -to [get_pins UFF1/D]<br></code></pre></div></td></tr></table></figure>
<p><strong>默认，提前的hold时序路径</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905996.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用指令后hold check从default提前了两个周期</li>
</ul>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905997.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Launch<ul>
<li>min：hold check</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905998.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Capture<ul>
<li>clock CLKP往前移动了两个周期到了0</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905999.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>结果</li>
</ul>
<p><strong>对比一下默认没加约束的3周期hold检查</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905000.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905001.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><p>capture&amp;结果</p>
<ul>
<li>clock CLKM是两个周期的</li>
<li>hold time非常大</li>
<li>slack远远不满足要求</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>多周期一定要设置</p>
<ul>
<li>setup具体第N个时钟</li>
<li>hold为N-1提前</li>
</ul>
<h2><span id="82-half-cycle-paths半周期">8.2 Half-Cycle Paths半周期</span></h2><p>触发器的出发边缘不一样（有的是下降沿有的是上升沿，会造成半周期的情况）</p>
<blockquote>
<p>If a design has both negative-edge triggered flip-flops (active clock edge isfalling edge) and positive-edge triggered flip-flops (active clock edge is rising edge), it is likely that half-cycle paths exist in the design.  </p>
</blockquote>
<p><strong>Setup Graph</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905002.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>UFF5时钟上升沿</li>
<li>UFF3时钟下降沿</li>
<li>两个触发器之间只剩下半个周期，给逻辑的时间也只剩下半个周期</li>
</ul>
<p><strong>Setup Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905003.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>attribution<ul>
<li>Startpoint：下降沿</li>
<li>Endpot：上升沿</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905004.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Launch<ul>
<li>clock CLKP是从下降沿6ns开始的（周期是12ns）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905005.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Capture<ul>
<li>clock CLKP是12ns</li>
</ul>
</li>
<li>结果</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905006.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Hold Timing Graph &amp; Report</strong></p>
<blockquote>
<p>While the data path gets only half-cycle for setup check, an extra half-cycle is available for the hold timing check. Here is the hold timing path  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905007.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905008.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Launch</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905009.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Capture</li>
<li>结果<ul>
<li>一开始就是6</li>
<li>slack很轻松的就满足了</li>
</ul>
</li>
<li>半周期特性<ul>
<li>半周期使用场景：A-&gt;B传输数据的时候用半周期更稳妥</li>
<li>特点：<ul>
<li>setup非常紧（只剩T/2）<ul>
<li>数字电路的特点：setup违例了非常好修，hold违例了不容易修，因此半周期使得处理STA不容易特别棘手</li>
</ul>
</li>
<li>hold非常松</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="83-false-paths伪路径">8.3 False Paths伪路径</span></h2><blockquote>
<p>It is possible that certain timing paths are not real (or not possible) in the actual functional operation of the design.</p>
<p>Such paths can be turned off during STA by setting these as false paths.</p>
<p><strong>A false path is ignored by the STA for analysis</strong>  </p>
</blockquote>
<p>伪路径：</p>
<ul>
<li>电路中不可能存在/发生的。我们需要告诉EDA工具这种路径不会发生，从而提高STA准确性，降低STA计算使得跑的更快</li>
</ul>
<p>伪路径通常发生在：</p>
<ul>
<li>异步跨时钟域</li>
<li>一个常量路径（如一个很复杂的逻辑电路，推导下来却是常量）</li>
</ul>
<p>STA中如何处理伪路径</p>
<ul>
<li>直接指定某一路径</li>
</ul>
<blockquote>
<p>When a false path is specified through a pin of a cell, all paths that go through that pin are ignored for timing analysis.<br>The advantage of identifying the false paths is that the analysis space is reduced, thereby allowing the analysis to focus only on the real paths.<br>This helps cut down the analysis time as well.<br><strong>However, too many false paths using the through specification can slow down the analysis(太多的约束有时候不一定会减小STA时间，而会增大)</strong>  </p>
</blockquote>
<p><strong>Code</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs TCL">set_false_path -from [get_clocks SCAN_CLK] -to [get_clocks CORE_CLK]<br><span class="hljs-comment"># Any path starting from the SCAN_CLK domain to</span><br><span class="hljs-comment"># the CORE_CLK doain is a false path.</span><br><br>set_false_path -through [get_pins UMUX0/S]<br><span class="hljs-comment"># Any path going through this pin is false.</span><br><br><span class="hljs-comment">## A false path is set using the set_false_path specification. Here are some examples.</span><br>set_false_path -through [ get pins SAD CORE/RSTN]<br><span class="hljs-comment"># The false path specifications can also be specified to,</span><br><span class="hljs-comment"># through, or from a module pin instance. </span><br>set_false_path -to [ get_ports TEST_REG*]<br><span class="hljs-comment">#A11 paths that end in port named TEST REG* are false paths. </span><br><span class="hljs-keyword">set</span> false path -through UINV/Z-through UAND0/Z<br><span class="hljs-comment">#Any path that goes through both of these pins#</span><br><span class="hljs-comment"># in this order is false.</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>SCAN和CORE是什么？</li>
</ul>
<p>大部分电路会有两个时钟：SCAN(DFT时)、CORE(正常模式)，所以我们会对从SCAN,CORE时钟出来的路径进行伪路径忽略</p>
<ul>
<li>UMUX0/S</li>
</ul>
<p>任何一个满足情况的时钟都是startpoint</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905010.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>定义伪路径应尽可能精确</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905011.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>-though参数不推荐</strong></p>
<p>​    尽可能少使用-though参数，除非特别有必要的时候</p>
<blockquote>
<p>Another recommendation is to minimize the usage of through options, as it adds unnecessary runtime complexity.</p>
<p>The -through option should only be used where it is absolutely necessary and there is no<br>alternate way to specify the false path.  </p>
</blockquote>
<p><strong>别把多周期路径给设成伪路径</strong></p>
<ul>
<li>一定要把真的虚假路径设为虚假路径，不要随意设</li>
</ul>
<blockquote>
<p>From an optimization perspective, another guideline is to not use a false path when a multicycle path is the real intent.</p>
<p>If a signal is sampled at a known or predictable time, no matter how far out, a multicycle path specification should be used so that the path has some constraint and gets optimized to meet the multicycle constraint.</p>
<p>If a false path is used on a path that is sampled many clock cycles later, optimization of the remaining logic may invariably slow this path even beyond what may be necessary.  </p>
</blockquote>
<p><strong>Report</strong></p>
<ul>
<li>Launch</li>
<li>Capture</li>
<li>结果</li>
</ul>
<h1><span id="9-timing-verification三-多时钟域多时钟分析">9 Timing Verification(三) 多时钟域，多时钟分析</span></h1><p><strong>（注意）本节提到的都是同步时钟，异步时钟不是这种表现形式</strong></p>
<ul>
<li>Timing across Clock Domains</li>
<li>Multiple Clocks</li>
</ul>
<h2><span id="91-timing-across-clock-domains多时钟域分析">9.1 Timing across Clock Domains多时钟域分析</span></h2><h3><span id="1slow-to-fast-clock-domains">1）slow to fast clock domains</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905012.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Div 4 freq四分频</li>
</ul>
<p><strong>对上述电路进行静态时序分析</strong></p>
<p><strong>Graph &amp; Code</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905013.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>分别把时钟定义为20和5周期</li>
</ul>
<p><strong>Wave</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905014.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>我们在最严格的情况下进行分析</li>
</ul>
<blockquote>
<p>By default, the most constraining setup edge relationship is used, which in this case is the very next capture edge. Here is a setup path report that shows this.  </p>
</blockquote>
<ul>
<li>CLKM发送数据，CLKP接收数据</li>
<li>从慢时钟到块时钟</li>
</ul>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905015.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Launch</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905016.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Capture</li>
</ul>
<p><strong>Hold Check</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905017.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>使用多周期约束对setup进行检查（合理）</strong></p>
<ul>
<li>使用多周期约束对不是特别严苛，但对hold check来说不太合理</li>
</ul>
<blockquote>
<p>In the above example, we can see that the launch data is available every fourth cycle of the capture clock. Let us assume that the intention is not to capture data on the very next active edge of CLKP, but to capture on every 4th capture edge. This assumption gives the combinational logic between the flip-flops four periods of CLKP to propagate, which is 20ns. We can do this by setting the following multicycle specification:  </p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs TCL">set_multicycle_path <span class="hljs-number">4</span> -setup -from [get_clocks CLKM] -to [get_clocks CLKP] -end<br></code></pre></div></td></tr></table></figure>
<ul>
<li>一定要注意加到end上，<strong>也就是要有-end参数</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905018.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><p>这样的话可以把时间拉长到四个周期，中间是组合逻辑，相对合理</p>
</li>
<li><p><strong>Report</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905019.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905020.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>上述情况的hold检查(不合理)</strong></p>
<blockquote>
<p>Figure 8-24 shows the hold check - note that the hold check is derived from the setup check and defaults to one cycle preceding the intended capture edge.<br>Here is the hold timing report. Notice that the hold capture edge is at 15ns, one cycle prior to the setup capture edge.  </p>
</blockquote>
<ul>
<li><strong>Report</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905021.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905022.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>使用多周期约束对hold进行检查（合理）</strong></p>
<blockquote>
<p>In most designs, this is not the intended check, and the hold check should be moved all the way back to where the launch edge is.We do this by setting a hold multicycle specification of 3.  </p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_multicycle_path <span class="hljs-number">3</span> -hold -from [get_clocks CLKM] -to [get_clocks CLKP] -end<br></code></pre></div></td></tr></table></figure>
<ul>
<li>往回退三个周期，保证check点在0ns</li>
</ul>
<blockquote>
<p><strong>The cycle of 3 moves the hold checking edge back three cycles, that is, to time 0ns.</strong><br>The distinction with a setup multicycle is that in setup, the setup capture edge moves forward by the specified number of cycles from the default setup capture edge; in a hold multicycle, the hold check edge moves backward from the default hold check edge (one cycle before setup edge)  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905023.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>总结</strong></p>
<p><strong>In summary, if a setup multicycle of N cycles is specified, then most likely a hold multicycle of N-1 cycles should also be specified</strong>  </p>
<ul>
<li>给setupN，给holdN-1</li>
</ul>
<h3><span id="2fast-to-low-clock-domains">2）fast to low clock domains</span></h3><blockquote>
<p>In this subsection, we consider examples where the data path goes from a fast clock domain to a slow clock domain. The default setup and hold checks are as shown in Figure 8-26 when the following clock definitions are used.  </p>
</blockquote>
<p> <strong>时钟定义</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905024.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Graph</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905025.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>正常的时序逻辑检查（不太合理）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905026.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905027.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905028.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>正常情况的hold检查（不合理暴漏了出来）</strong></p>
<p><strong>不合理的原因</strong></p>
<blockquote>
<p>Similar to the setup checks, there are four hold checks possible.<br>Figure 8-26 shows the most restrictive hold check which ensures that the capture edge at 0ns does not capture the data being launched at 0ns.<br>Here is the timing report for this hold check.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905029.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905030.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>使用多周期约束进行合理设置</strong></p>
<blockquote>
<p>In general, a designer may specify the data path from the fast clock to the slow clock to be a multicycle path. If the setup check is relaxed to provide two cycles of the faster clock for the data path, the following is included for this multicycle specification:  </p>
</blockquote>
<ul>
<li>起点是快的，因此需要换成start</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905031.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>check点移动以后</strong></p>
<blockquote>
<p>In this case, Figure 8-27 shows the clock edges used for the setup and hold checks. The -start option specifies that the unit for the number of cycles (2 in this case) is that of the launch clock (CLKP in this case). The setup multicycle of 2 moves the launch edge one edge prior to the default launch edge, that is, at 10ns instead of the default 15ns. The hold multicycle ensures that the capture of the earlier data can reliably occur at 0ns due to the launch edge also at 0ns.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905032.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>launch 往后</li>
<li>hold往前，还是0</li>
</ul>
<p><strong>Report</strong></p>
<ul>
<li>setup</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905033.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905034.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>hold<ul>
<li>launch,capture都是从0开始</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905035.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905036.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3总结">3）总结</span></h3><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905037.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>start和end选项</strong></p>
<blockquote>
<p>Unlike the case of paths from slow to fast clock domains, a good rule of thumb for multi-frequency multicycle path specification in the case of paths from fast to slow clock domains is to use the -start option. The setup and hold checks are then adjusted based upon the fast clock  </p>
</blockquote>
<h2><span id="92-multiple-clocks多时钟">9.2 Multiple Clocks多时钟</span></h2><ul>
<li>多时钟之间是整数倍关系</li>
<li>多时种之间是非整数的关系</li>
<li>相位移动情况</li>
</ul>
<h3><span id="1整数倍时钟">1）整数倍时钟</span></h3><p><strong>我们使用公共时钟进行STA</strong></p>
<blockquote>
<p>Often there are multiple clocks defined in a design with frequencies that are simple (or integer) multiples of each other.<br>In such cases, <strong>STA</strong> is performed by computing <strong>a common base period(公共周期)</strong> among all related clocks (two clocks are related if they have a data path between their domains).<br>The common base period is established so that all clocks are synchronized.</p>
</blockquote>
<p><strong>时钟定义</strong></p>
<ul>
<li>定义了三个不同频率的时钟<ul>
<li>20（公共周期）,10,5</li>
</ul>
</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name CLKM -period <span class="hljs-number">20</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">10</span>&#125;[get_ports CLKM]<br>create_clock -name CLKQ -period <span class="hljs-number">10</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">5</span>&#125;<br>create_clock -name CLKP -period <span class="hljs-number">5</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">2.5</span>&#125;[get_ports CLKP]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905038.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>从最快时钟(CLKP)到最慢时钟(CLKM)的分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905039.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905040.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>最严苛的情况：CLKP(15ns)——&gt;CLKM(20ns)</li>
</ul>
<p><strong>hold check</strong>：都是从0开始</p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905041.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905042.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="2非整数倍时钟">2）非整数倍时钟</span></h3><p>倍频不是整数倍</p>
<p><strong>时钟5/8</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905043.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>三个时钟的约束的定义</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name CLKM -period <span class="hljs-number">8</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">4</span>&#125; [get_ports CLKM]<br>create_clock -name CLKQ -period <span class="hljs-number">10</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">5</span>&#125;<br>create_clock -name CLKP -period <span class="hljs-number">5</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">2.5</span>&#125; [get_ports CLKP]<br></code></pre></div></td></tr></table></figure>
<p><strong>公共时钟选取</strong></p>
<ul>
<li>取存在数据交互的时钟的最小公倍数对STA进行处理<ul>
<li>可以方便的查看哪个沿发送、哪个沿接收</li>
</ul>
</li>
</ul>
<blockquote>
<p>The timing analysis process computes a common period for the related clocks, and the clocks are then expanded to this base period.</p>
<p>Note that the common period is found only for related clocks (that is, clocks that have timing paths between them).  </p>
</blockquote>
<p><strong>Graph（从CLKM到CLKP时）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905044.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>找到最严苛的setup路径</strong>（最短的时候）</li>
<li><strong>找到最严苛的hold路径</strong>（最长的时候）</li>
</ul>
<p><strong>Report</strong></p>
<ul>
<li>建立时间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905045.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905046.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>保持时间检查</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905047.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905048.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Graph（从CLKP到CLKM时）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905049.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>找到最严苛的setup路径</strong>（最短的时候）</li>
<li><strong>找到最严苛的hold路径</strong>（最长的时候）</li>
</ul>
<p><strong>Report</strong></p>
<ul>
<li>setup</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905050.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905051.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>hold</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905052.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905053.png" srcset="/img/loading.gif" lazyload alt></p>
<h3><span id="3phase-shifted-相位移动频率相同">3）Phase Shifted 相位移动（频率相同）</span></h3><p><strong>一个两时钟相位偏移90°的例子</strong></p>
<ul>
<li>类似半周期的例子</li>
<li>对hold友好，对setup不友好</li>
</ul>
<p><strong>两时钟约束定义</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -period <span class="hljs-number">2.0</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">1.0</span>&#125;[get_ports CKM]<br>create_clock -period <span class="hljs-number">2.0</span> -waveform &#123;<span class="hljs-number">0.5</span> <span class="hljs-number">1.5</span>&#125;[get_ports CKM90]<br></code></pre></div></td></tr></table></figure>
<p><strong>Graph &amp; Wave</strong></p>
<ul>
<li>默认check point</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905054.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>为了方便查看check points都往迁移一个周期</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905055.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Report</strong></p>
<ul>
<li>setup<ul>
<li>比较难满足</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905056.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905057.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>hold</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905058.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905059.png" srcset="/img/loading.gif" lazyload alt></p>
<h1><span id="10-robust-verification鲁棒性检查">10 Robust Verification鲁棒性检查</span></h1><ul>
<li><p>On-Chip Variations</p>
<ul>
<li><p>Setup time check</p>
</li>
<li><p>Hold time check</p>
</li>
</ul>
</li>
</ul>
<h2><span id="101-on-chip-variations">10.1 On-Chip Variations</span></h2><p>由于工艺的不同，片上不同区域延迟可能不同</p>
<blockquote>
<p>In general, the process and environmental parameters may not be uniform across different portions of the die.<br>Due to process variations, identical MOS transistors in different portions of the die may not have similar characteristics. These differences are due to process variations within the die.  </p>
</blockquote>
<p>通常是这五个因素产生：</p>
<ul>
<li>IR drop variation along the die area affecting the local power supply.</li>
<li>Voltage threshold variation of the PMOS or the NMOS device.</li>
<li>Channel length variation of the PMOS or the NMOS device.</li>
<li>Temperature variations due to local hot spots.</li>
<li>Interconnect metal etch or thickness variations impacting the interconnect resistance or capacitance.  </li>
</ul>
<p>上述PVT因素通常被称为OCV(On-Chip Variations,片上偏差)，通常来说这些偏差对wire和cell延迟都有影响</p>
<blockquote>
<p>The PVT variations described above are referred to as On-Chip Variations (OCV) and these variations can affect the wire delays and cell delays in different portions of the chip.  </p>
</blockquote>
<p><strong>我们需要在STA中加入这些因素的影响效果，通常来说是对一些路径进行放大或缩小的形式（加入delay的形式）</strong></p>
<blockquote>
<p>Since the clock and data paths can be affected differently by the OCV, the timing verification can model the OCV effect by making the PVT conditions for the launch and capture paths to be slightly different.</p>
<p>The STA can include the OCV effect by derating the delays of specific paths, that is, by making those paths faster or slower and then validating the behavior of the design with these variations.<br>The cell delays or wire delays or both can be derated to model the effect of OCV.  </p>
</blockquote>
<h2><span id="102-ocv设置setup">10.2 OCV设置(setup)</span></h2><p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905060.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>由于OCV的存在使得实际中三个路径延迟都不一样</li>
<li>最严苛的情况：最长的路径特别慢，最短的路径特别快；导致数据到达特别慢，采样时钟特别快，如下图所示</li>
<li>我们需要把OCV的最严苛情况提现到STA中，具体把某一部分放大或缩小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905061.png" srcset="/img/loading.gif" lazyload alt><strong>公式回顾</strong></p>
<ul>
<li><p>整体公式： LaunchClockPath + MaxDataPath &lt;= ClockPeriod +CaptureClockPath - Tsetup_UFF1  </p>
</li>
<li><p>单独看时钟周期：This implies that the minimum clock period = LaunchClockPath + MaxDataPath - CaptureClockPath + Tsetup_UFF1  </p>
</li>
</ul>
<p><strong>理想情况下的时序分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905062.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>考虑OCV的情况</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_timing_derate -cell_delay|net_delay -early|late (number)<br><span class="hljs-comment">#for example</span><br>set_timing_derate -early <span class="hljs-number">0.8</span>#快的更早<br>set_timing_derate -late <span class="hljs-number">1.1</span>#慢的更晚<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>The derating factors apply uniformly to all net delays and cell delays.</p>
<p>If an application scenario warrants different derating factors for cells and nets, the -cell_delay and the -net_delay options can be used in the set_timing_derate specification.  </p>
</blockquote>
<p><strong>setup hold具体怎么做</strong></p>
<ul>
<li>setup<ul>
<li>对于long path(如data path/launch clock)使其更大，乘以1.n</li>
<li>对于shor path(如capture clock)使其更小，乘以0.n</li>
</ul>
</li>
<li>hold<ul>
<li>对于long path(如data path/launch clock)使其更小，乘以0.n，让数据比较短</li>
<li>对于shor path(如capture clock)使其更大，乘以1.n，让时钟网络更靠后</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905063.png" srcset="/img/loading.gif" lazyload alt></p>
<blockquote>
<p>Long path delays (for example, data paths and launch clock path for setup checks or capture clock paths for hold checks) are multiplied by the derate value specified using the -late option.</p>
<p>Short path delays (for example, capture clock paths for setup checks or data paths and launch clock paths for hold checks) are multiplied by the derate values specified using the -early option.  </p>
<p><strong>If no derating factors are specified, a value of 1.0 is assumed</strong>  </p>
</blockquote>
<p><strong>示例约束后</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905064.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905065.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>频率变低，对组合电路更严格，需要减小组合逻辑延迟，需要对组合逻辑优化</li>
</ul>
<h2><span id="103-cppcommon-path-pessimism问题">10.3 <strong>CPP(Common Path Pessimism)问题</strong></span></h2><ul>
<li><strong>背景：我们对launch和capture的公共路径同时放大缩小了</strong><ul>
<li>带来了悲观设置</li>
</ul>
</li>
</ul>
<blockquote>
<p>Applying different derating for the launch and capture clock is overly<br>pessimistic as in reality this part of the clock tree will really be at only one PVT condition, either as a maximum path or as a minimum path (or anything in between) but never both at the same time.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905066.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>CPP与CPPR<ul>
<li>CPP(Common Path Pessimism)</li>
<li>CPPR(Common Path Pessimism Removal)/CRPR(Clock Reconvergence Pessimism Remova)，移除CPP的方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>The pessimism caused by different derating factors applied on the common part of the clock tree is called Common Path Pessimism (CPP) which should be removed during the analysis.</p>
<p>CPPR, which stands for Common Path Pessimism Removal, is often listed as a separate item in a path report. It is also labeled as Clock Reconvergence Pessimism Removal (CRPR).  </p>
</blockquote>
<p><strong>CPPR具体实现</strong></p>
<p>CPP = LatestArrivalTime@CommonPoint - EarliestArrivalTime@CommonPoint  </p>
<ul>
<li>找公共路径上插值最大的两个值(period原始*(max_rate-min_rate))</li>
</ul>
<blockquote>
<p>CPPR is the removal of artificially induced pessimism between the launch clock path and the capture clock path in timing analysis.<br>If the same clock drives both the capture and the launch flip-flops, then the clock tree will likely share a common portion before branching.  </p>
<p>The common point is defined as the output pin of the last cell in the common portion of the clock tree.  </p>
</blockquote>
<p><strong>CPPR示例</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905067.png" srcset="/img/loading.gif" lazyload alt></p>
<p>总结</p>
<blockquote>
<p>Applying the OCV derating has increased the minimum clock period from 5.49ns to 6.811ns for this example design.<br>This illustrates that the OCV variations modeled by these derating factors can reduce the maximum frequency of operation of the design.  </p>
</blockquote>
<h2><span id="104-更严谨的设置倍数提高ocv时的速度">10.4 更严谨的设置倍数，提高OCV时的速度</span></h2><p>OCV时已经时不合理了，因此我们需要加快检查速度</p>
<blockquote>
<p>If the setup timing check is being performed at the worst-case PVT condition, no derating is necessary on the late paths as they are already the worst possible<br>However, derating can be applied to the early paths by making those paths faster by using a specific derating, for example, speeding up the early paths by 10%.  </p>
</blockquote>
<p><strong>定义约束</strong></p>
<p>A derate specification at the worst-case slow corner may be something like:</p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_timing_derate -early <span class="hljs-number">0.9</span><br>set_timing_derate -late <span class="hljs-number">1.0</span><br><span class="hljs-comment"># Don&#x27;t derate the late paths as they are already the slowest,</span><br><span class="hljs-comment"># but derate the early paths to make these faster by 10%.</span><br></code></pre></div></td></tr></table></figure>
<p>这样做可以：使得STA更合理一点</p>
<ul>
<li>比较差的路径，延迟不进行放大</li>
<li>比较好的路径(capture)，延迟缩小变得更快</li>
</ul>
<blockquote>
<p>The above derate settings are for max path (or setup) checks at the worstcase slow corner; thus the late path OCV derate setting is kept at 1.0 so as not to slow it beyond the worst-case slow corner.  </p>
<p>Here is the setup timing check path report performed at the worst-case slow corner. The derating used by the late paths are reported as Max Data Paths Derating Factor and as Max Clock Paths Derating Factor.</p>
<p>The derating used for the early paths is reported as Min Clock Paths Derating Factor.  </p>
</blockquote>
<p><strong>Report</strong></p>
<ul>
<li>更严谨的设置倍数、CPPR设置</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905068.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905069.png" srcset="/img/loading.gif" lazyload alt><strong>总结</strong></p>
<blockquote>
<p>The cell UCKBUF0 is on the common clock path, that is, on both the capture clock path and the launch clock path.</p>
<p>Since the common clock path cannot have a different derating, the difference in timing for this common path, 56ps - 45ps = 11ps, is corrected separately.  </p>
</blockquote>
<h2><span id="105-ocv设置hold">10.5 OCV设置(hold)</span></h2><h3><span id="1ocv">1）OCV</span></h3><p>hold timing我们也要判断路径的快慢，通常来说：</p>
<ul>
<li>launch clock path and the data path,smallest delays</li>
<li>capture clock path,largest delays</li>
</ul>
<p>所以我们悲观角度来看，缩小launch，增大capture，使得数据往后移</p>
<blockquote>
<p>If the PVT conditions are different along the chip, the worst condition for hold check occurs：<br>when the launch clock path and the data path have OCV conditions which result in the smallest delays, that is, when we have the earliest launch clock, and the capture clock path has the OCV conditions which result in the largest delays, that is, has the latest capture clock  </p>
</blockquote>
<p><strong>公式回顾</strong></p>
<p>LaunchClockPath + MinDataPath - CaptureClockPath - Thold_UFF1 &gt;= 0  </p>
<p><strong>示例约束</strong></p>
<ul>
<li>正常计算</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905070.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用约束</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_timing_derate -early <span class="hljs-number">0.9</span> <br>set_timing_derate -late <span class="hljs-number">1.2</span><br>set_timing_derate -early <span class="hljs-number">0.95</span> -cell_check #hold <span class="hljs-keyword">time</span>加了<span class="hljs-number">0.95</span>的delrate，使得更小<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905071.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用约束后的时序更差了，更不满足了</li>
</ul>
<h3><span id="2更严谨的设置倍数">2）更严谨的设置倍数</span></h3><p>hold time check快路径已经很快乐，我们需要将慢路径再慢一点</p>
<blockquote>
<p>In general, the hold timing check is performed at the best-case fast PVT corner.</p>
<p>In such a scenario, no derating is necessary on the early paths, as those paths are already the earliest possible.</p>
<p>However, derating can be applied on the late paths by making these slower by a specific derating factor, for example, slowing the late paths by 20.  </p>
</blockquote>
<p><strong>修改后的约束</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_timing_derate -early <span class="hljs-number">1.0</span> <br>set_timing_derate -late <span class="hljs-number">1.2</span><br><span class="hljs-comment"># Don&#x27;t derate the early paths as they are already the</span><br><span class="hljs-comment"># fastest, but derate the late paths slower by 20%.</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905072.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905073.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905074.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>总结</strong></p>
<blockquote>
<p>Notice that the late paths are derated by +20% while the early paths are not derated. See cell UCKBUF0.</p>
<p>Its delay on the launch path is 56ps while the delay on the capture path is 67ps - derated by +20%.</p>
<p>UCKBUF0 is the cell on the common clock tree and thus the pessimism introduced due to different derating on this common clock tree is, 67ps - 56ps = 11ps, which is accounted for separately on the line clock reconvergence pessimism.  </p>
</blockquote>
<h1><span id="11-time-borrowingcycle-stealing">11 Time Borrowing/Cycle Stealing</span></h1><h2><span id="111-回顾">11.1 回顾</span></h2><p><strong>Latch与DFF</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905075.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Latch<ul>
<li>有效电平内是透明的，无效电平时保存</li>
</ul>
</li>
</ul>
<p>我们之前分析的都是DFF，接下来分析Latch，time borrowing技术是对latch分析时使用到的特殊技术</p>
<h2><span id="112-time-borrowing">11.2 Time Borrowing</span></h2><h3><span id="1概念">1）概念</span></h3><p><strong>opening edge &amp; closing edge</strong></p>
<p>The time borrowing technique, which is also called cycle stealing, occurs at a latch.</p>
<ul>
<li>边缘跳变后时有效电平（In a latch, one edge of the clock makes the latch transparent, that is, it opens the latch so that output of the latch is the same as the data input; this clock edge is called the <strong>opening edge.</strong>）</li>
<li>边缘跳变后时无效电平（The second edge of the clock closes the latch, that is, any change on the data input is no longer available at the output of the latch; this clock edge is called the <strong>closing edge.</strong> ）</li>
</ul>
<p>通过opening edge &amp; closing edge可以分析约束是什么样子</p>
<p><strong>what is time borrowing（Latch的setup和hold）</strong></p>
<blockquote>
<p>Typically, the data should <strong>be ready at a latch input before the active edge of the clock.</strong></p>
<p>However, since a latch is transparent when the clock is active, the data <strong>can arrive later than the active clock edge</strong>, that is, it can borrow time from the next cycle.If such time is borrowed, the time available for the following stage (latch to another sequential cell) is reduced  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905076.png" srcset="/img/loading.gif" lazyload alt="ready边沿示例"></p>
<p><strong>Graph &amp; Wave</strong></p>
<blockquote>
<p>Here is an example of time borrowing using an active rising edge.</p>
<p>If data DIN is ready at time A prior to the latch opening on the rising edge of CLK at 10ns, the data flows to the output of the latch<br>as it opens. </p>
<p>If data arrives at time B as shown for DIN (delayed), it borrows time Tb. However, this reduces the time available from the latch to the next flip-flop UFF2 - instead of a complete clock cycle, only time Ta is available.  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905077.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>情况1：数据来的早，采样边沿前已经就绪</li>
<li>情况2：数据来的晚，采样边沿后还未就绪</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905078.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>positive slack, zero slack, and negative slack</strong></p>
<ul>
<li>有效点落在Ps，Zs，Ns</li>
<li>最多借半个周期</li>
</ul>
<p>The timing regions for data arrival for positive slack, zero slack, and negative slack (that is, when a violation occurs)  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905079.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Positive slave</li>
<li>Zero slave</li>
<li>Negative slave在Closing edge 后，时序违例，不正确（A data signal that arrives after the closing edge at the latch is a timing violation.  ）</li>
</ul>
<h3><span id="2示例分析">2）示例分析</span></h3><blockquote>
<p>This is the use of a latch with a half-cycle path to the next stage flip-flop.<br>We next describe three sets of timing reports for the latch example of it to illustrate the differen amounts of time borrowed from the next stage  </p>
</blockquote>
<p><strong>一种clock gating门控时钟的电路示意图</strong></p>
<blockquote>
<p>This is the use of a latch with a half-cycle path to the next stage flip-flop.<br>We next describe three sets of timing reports for the latch example of it to illustrate the different amounts of time borrowed from the next stage  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905080.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Latch前接了个反相器，时钟端低电平有效<ul>
<li>这种设计对于门控时钟可以消除毛刺</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905081.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Positive slack</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/cs/202205012028181.png" srcset="/img/loading.gif" lazyload alt><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905082.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Zero slack</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905083.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905084.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905085.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905086.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Zero slark后的时序路径分析</strong></p>
<ul>
<li>与前面zero slark相反</li>
<li>与半周期分析时类似</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905087.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905088.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905089.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>虽然前面借了0.81ns，总体看还是满足的</li>
</ul>
<p><strong>Negative slark</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905090.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>最多借半个周期</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905091.png" srcset="/img/loading.gif" lazyload alt></p>
<h1><span id="12-data-to-data-checks">12 Data to Data Checks</span></h1><h2><span id="121-概述">12.1 概述</span></h2><p><strong>两个pins</strong></p>
<p>检查两个Pin之间的数据，且这两个Pin之间没有clock，这种时候我们通常把这两个Pin分为：</p>
<ul>
<li>Constrained pin：One pin is the constrained pin, which acts like a data pin of a flip-flop<ul>
<li>看作D触发器的数据引脚</li>
</ul>
</li>
<li>Related pin：The second pin is the related pin, which acts like a clock pin of a flip-flop.  <ul>
<li>看作D触发器的时钟引脚</li>
</ul>
</li>
<li>通过定义这两个pin来检查相对的时序约束</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905092.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>与ffcheck的不同</strong></p>
<ul>
<li>The data to data setup check is performed on the same edge as the launch edge<ul>
<li>setup check的launch和capture在同一边沿（launch边沿）</li>
</ul>
</li>
<li>Unlike a normal setup check of a flip-flop, where the capture clock edge is normally one cycle away from the launch clock edge  <ul>
<li>setup check的launch和capture在同一边沿，所以中间没有时钟，因此data to data checks也叫zero-cycle checks或same-cycle checks</li>
</ul>
</li>
</ul>
<h2><span id="122-如何实现data-to-data-checks">12.2 如何实现data to data checks</span></h2><p><strong>基本模型</strong></p>
<p>​    <strong>约束代码</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_data_check -from SDA -to SCTRL -setup <span class="hljs-number">2.1</span><br>set_data_check -from SDA -to SCTRL -setup <span class="hljs-number">1.5</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905093.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>The <strong>setup data check</strong> implies that SCTRL should arrive at least 2.1ns prior to the edge of the related pin SDA. Otherwise it is a data to data setup check violation.  </li>
<li><p>The <strong>hold data check</strong> specifies that SCTRL should arrive at least 1.5ns after SDA. If the constraine signal arrives earlier than this specification, then it is a data to data hold check violation  </p>
</li>
<li><p>This check is useful in a custom-designed block where it may be necessary to provide specific arrival times of one signal with respect to another.</p>
</li>
<li>One such common situation is that of a data signal gated by an enable signal and it is required to<br>ensure that the enable signal is stable when the data signal arrives.  </li>
</ul>
<p><strong>典型与门例子</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905094.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><p>对于与门来说，数据必须非常稳定，否则会产生毛刺</p>
</li>
<li><blockquote>
<p>Consider the and cell shown in Figure 2. The requirement is to ensure that PNA arrives 1.8ns before the rising edge of PREAD and that it should not change for 1.0ns after the rising edge of PREAD. In this example, PNA is the constrained pin and PREAD is the related pin.  </p>
</blockquote>
</li>
</ul>
<p>​    <strong>约束代码</strong></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_data_check -from UAND0/A1 -to UAND0/A2 -setup <span class="hljs-number">1.8</span><br>set_data_check -from UAND0/A1 -to UAND0/A2 -setup <span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure>
<p>​    <strong>Report</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905095.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>这个report不满足要求，因此需要对电路进行优化</li>
<li>另外一个重要的点：One important aspect of a data to data setup check is that the clock edges that launch both the constrained pin and the related pin are from the same clock cycle (also referred to as same-cycle checks). Thus notice in the report that the starting time for the capture edge (UDFF0/CK) is at 0ns, not one cycle later as one would typically see in a setup report.  </li>
</ul>
<h2><span id="123-data-to-data-hold-check">12.3 data to data hold check</span></h2><p><strong>默认的hold check往前一个周期</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905096.png" srcset="/img/loading.gif" lazyload alt></p>
<p>The zero-cycle setup check causes the hold timing check to be different from other hold check reports - the hold check is no longer on the same clock edge.</p>
<p>Here is the clock specification for CLKPLL which is utilized for the hold path report below</p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">create_clock -name CLKPLL -period <span class="hljs-number">10</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">5</span>&#125; [get_ports CLKPLL]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905097.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>hold在同一周期的设置</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905098.png" srcset="/img/loading.gif" lazyload alt></p>
<p>In some scenarios, a designer may require the data to data hold check to be performed on the same clock cycle.  </p>
<p>The same cycle hold requirement implies that the clock edge used for the related pin be moved back to where the clock edge for the constrained pin is.  </p>
<p>This can be achieved by specifying a multicycle of -1： </p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_multicycle_path <span class="hljs-number">-1</span> -hold -to UAND0/A2  <br></code></pre></div></td></tr></table></figure>
<p> <img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905099.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>这里时序不满足（笑）</li>
</ul>
<h2><span id="124-交换2pins">12.4 交换2pins</span></h2><p>An alternate way of having the data to data hold check performed in the same cycle is to specify this as a data to data setup check between the pins in the reverse direction  </p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_data_check -from UAND0/A2 -to UAND0/A1 -setup <span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905100.png" srcset="/img/loading.gif" lazyload alt></p>
<h2><span id="125-对无变化数据的检查">12.5 对无变化数据的检查</span></h2><p>The data to data check is also useful in defining a no-change data check.</p>
<p>This is done by specifying a setup check on the rising edge and a hold check on the falling edge, such that a no-change window gets effectively defined  </p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905101.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/greensch/blog-drawbed/img/202205011905102.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">set_data_check -rise from D2 -to D1 -setup <span class="hljs-number">1.1</span><br>set_data_check -fall from D2 -to D1 -hold <span class="hljs-number">0.8</span><br></code></pre></div></td></tr></table></figure>
<h1><span id="13-习题讲解">13 习题讲解</span></h1><p><a target="_blank" rel="noopener" href="https://customizablecomputinglab.gitee.io/2020/08/07/class-STA/slides/14-CLock_Gating_Checks.pdf">习题PDF</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/categories/IC/%E7%90%86%E8%AE%BA/">理论</a>
                    
                      <a class="hover-with-bg" href="/categories/IC/%E7%90%86%E8%AE%BA/STA/">STA</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/IC/">IC</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                      <a class="hover-with-bg" href="/tags/STA/">STA</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/202203191912/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/hexoessay/tools/hexo%E9%AD%94%E6%94%B9%E6%B1%87%E6%80%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">hexo魔改汇总</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/202203162201/%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%AE%BE%E8%AE%A1start/%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%90%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%84%91%E5%9B%BE/">
                        <span class="hidden-mobile">关于之后学习的脑图</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'GreensCH/commitutterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span> | </span> <a href="https://weibo.com/u/7453939976" target="_blank" rel="nofollow noopener"> Green Weibo</a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?eca4a4d34dadf0d4e282cc6ef2dc3de6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  
  <div id="aplayer" style="width:300px"></div>
  <link defer rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
  <script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js"></script>
  <script defer src="/js/aplayer.js"></script><script src="/js/githubcalendar.js"></script> 
  <script data-pjax src="/js/githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?greensch";
            var git_color =['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'];
            var git_user ="greensch";
            var parent_div_git = document.getElementById('board');
            var git_div_html = '<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px;box-shadow:none;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('board')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:200px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>#github_container > .position-relative > .border{border:0!important}#github-calendar{position: relative;margin-top: -2rem;background-color: var(--board-bg-color);transition: background-color 0.2s ease-in-out;border-radius: 0.5rem;z-index: 3;-webkit-box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);}</style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":1,"position":"left","width":150,"height":400,"vOffset":-18},"mobile":{"show":true,"scale":0.1},"dialog":{"enable":false,"hitokoto":true,"width":10,"height":10,"vOffset":-100},"log":false});</script></body>
</html>
